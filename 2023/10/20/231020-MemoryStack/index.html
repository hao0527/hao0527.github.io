<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/heng32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/heng16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Memory Stack 开发总结前言截止目前，已经完成了 FlashDriver、Fls、Fee、MemIf、NvM 的开发。开发的 Memory Stack 只是借鉴了 AUTOSAR Memory Stack 架构，并非完全相同，为了兼容旧版软件，也有部分不符合 AUTOSAR 规范的地方。为了解决一些特殊需求，也有一些创新之处。 参考资料 AUTOSAR 官方资料 https:&#x2F;&#x2F;www.">
<meta property="og:type" content="article">
<meta property="og:title" content="Memory Stack 开发总结">
<meta property="og:url" content="http://example.com/2023/10/20/231020-MemoryStack/index.html">
<meta property="og:site_name" content="永恆博客网">
<meta property="og:description" content="Memory Stack 开发总结前言截止目前，已经完成了 FlashDriver、Fls、Fee、MemIf、NvM 的开发。开发的 Memory Stack 只是借鉴了 AUTOSAR Memory Stack 架构，并非完全相同，为了兼容旧版软件，也有部分不符合 AUTOSAR 规范的地方。为了解决一些特殊需求，也有一些创新之处。 参考资料 AUTOSAR 官方资料 https:&#x2F;&#x2F;www.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hao0527.gitee.io/231020-MemoryStack/231020-MemoryStack-3.png">
<meta property="og:image" content="https://hao0527.gitee.io/231020-MemoryStack/231020-MemoryStack-2.png">
<meta property="og:image" content="https://hao0527.gitee.io/231020-MemoryStack/231020-MemoryStack-1.png">
<meta property="article:published_time" content="2023-10-20T08:00:00.000Z">
<meta property="article:modified_time" content="2023-10-21T16:12:42.295Z">
<meta property="article:author" content="Hao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hao0527.gitee.io/231020-MemoryStack/231020-MemoryStack-3.png">

<link rel="canonical" href="http://example.com/2023/10/20/231020-MemoryStack/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Memory Stack 开发总结 | 永恆博客网</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">永恆博客网</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/20/231020-MemoryStack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Memory Stack 开发总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-20 16:00:00" itemprop="dateCreated datePublished" datetime="2023-10-20T16:00:00+08:00">2023-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-22 00:12:42" itemprop="dateModified" datetime="2023-10-22T00:12:42+08:00">2023-10-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AUTOSAR/" itemprop="url" rel="index"><span itemprop="name">AUTOSAR</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Memory-Stack-开发总结"><a href="#Memory-Stack-开发总结" class="headerlink" title="Memory Stack 开发总结"></a>Memory Stack 开发总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>截止目前，已经完成了 FlashDriver、Fls、Fee、MemIf、NvM 的开发。开发的 Memory Stack 只是借鉴了 AUTOSAR Memory Stack 架构，并非完全相同，为了兼容旧版软件，也有部分不符合 AUTOSAR 规范的地方。为了解决一些特殊需求，也有一些创新之处。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>AUTOSAR 官方资料</li>
<li><a target="_blank" rel="noopener" href="https://www.embeddedtutor.com/search/label/Autosar">https://www.embeddedtutor.com/search/label/Autosar</a></li>
</ol>
<h3 id="设计方式"><a href="#设计方式" class="headerlink" title="设计方式"></a>设计方式</h3><h4 id="FlashDriver"><a href="#FlashDriver" class="headerlink" title="FlashDriver"></a>FlashDriver</h4><p>Flash驱动层，这一层AUTOSAR中是没有的，我的理解是，AUTOSAR的Fls是Fee代码组件是由芯片厂家提供，那么mcu厂家提供的代码不会兼容其他厂家的外部Flash。代码我只看了云途配置工具生成的Fls代码和NXP官网上的一些芯片的BSW库，并没有见到过有外部Flash厂家提供的Fls代码。为了解决这个问题，我对Fls做了抽象，将不同Flash相关的代码和Fls分开，故有FlashDriver层。不同Flash有共性同时也有特性，为保留特性，借鉴了Linux中对各种外设共有属性和私有属性的思想，这个我是在看《嵌入式C语言自我修养——从芯片、编译器到操作系统》里学的。</p>
<p>Flash驱动层对上层Fls通过一个成员全是函数指针的结构体提供接口，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*Flash_Init)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr);</span><br><span class="line">	MemIf_JobResultType (*Flash_Erase)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType TargetAddress);</span><br><span class="line">	MemIf_JobResultType (*Flash_Write)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType TargetAddress, <span class="type">const</span> uint8 *SourceAddressPtr, Fls_LengthType Length);</span><br><span class="line">	MemIf_JobResultType (*Flash_Read)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType SourceAddress, uint8 *TargetAddressPtr, Fls_LengthType Length);</span><br><span class="line">	MemIf_JobResultType (*Flash_Compare)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType SourceAddress, <span class="type">const</span> uint8 *TargetAddressPtr, Fls_LengthType Length);</span><br><span class="line">	MemIf_JobResultType (*Flash_GetStatus)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr);</span><br><span class="line">&#125; Fls_DriverFunType;</span><br></pre></td></tr></table></figure>
<p>此结构体在每个FlashDriver中有定义，并且是对外的全局变量。用户在配置Fls时，可以配置此结构体指针，这样Fls就可以使用不同的Flash驱动了。</p>
<h5 id="保留特性"><a href="#保留特性" class="headerlink" title="保留特性"></a>保留特性</h5><p>每种Flash驱动对应一份FlashDriver代码，目前已完成两种FlashDriver开发，一个是mcu内部Flash，另一个是spi通信的外部Flash。每个Flash共有的属性有起始地址、扇区大小（最小擦除量）、扇区个数、页大小（最大写入量），特性有不同的通信方式。如外部Flash SPI通信，需要配置其SPI ID，这是在有MCAL（mcu硬件抽象层）的基础上，如果没有MCAL FlashDriver这一层需要把SPI配置都用用户配置的方式实现，方便封库。</p>
<p>为保留特性，FlashDriver每个接口都由上层传递了<code>FlsPrivateConfigPtr</code>，接口定义里这是个void指针，在每个FlashDriver的接口实现里将其转成了自己特性配置的结构体指针类型。特性配置结构体类型声明在每个FlashDriver的头文件中，由用户在Fls用户代码中定义配置，再配置进Fls层，上层Fls只是做了传递这个配置给FlashDriver，Fls无法解析这个配置。</p>
<p>像mcu内部Flash好像并不需要什么特性配置，读写方式都是定死的。不需要<code>FlsPrivateConfigPtr</code>可以在配置Fls时将这个指针配成NULL。</p>
<h5 id="阻塞在哪"><a href="#阻塞在哪" class="headerlink" title="阻塞在哪"></a>阻塞在哪</h5><p>阻塞在哪里也是个问题，在开发Fls时才想到，一开始我都是阻塞在FlashDriver，因为实现方便，写入和擦除操作可以直接查Flash状态阻塞到完成。后来Fls想做同时支持同步也支持异步的方式，还有需求是Fls超时结束任务，这就需要有Fls去控制是否还要继续阻塞。故FlashDriver中就不阻塞，新增一个读状态接口<code>Flash_GetStatus</code>，阻塞在Fls层。</p>
<p>但阻塞在FlashDriver这个配置也保留了，可以通过宏选择是否阻塞在驱动。为什么留？写入、擦除出现问题时，改这个成阻塞也不管超时，可以判断下是不是异步导致的问题，调试也能更好的定位问题（阻塞在有问题的地方，可以分析函数调用栈）。 目前Flash底层驱动可以提供阻塞或非阻塞的接口让Fls调用，甚至可以通过私有配置实现部分地址使用阻塞，部分地址使用非阻塞的方式。</p>
<h5 id="其余问题"><a href="#其余问题" class="headerlink" title="其余问题"></a>其余问题</h5><p>其余问题是云途这个Flash驱动的问题，如果不严格按例程操作寄存器写，只按手册命令方式写的话坑比较多，可能开发的时候能用，测试也没问题，但集成到整个项目工程里时有玄学问题。</p>
<h4 id="Fls"><a href="#Fls" class="headerlink" title="Fls"></a>Fls</h4><p>按AUTOSAR手册，Fls主要是Flash驱动的功能，对上层提供各种异步读写擦的功能，支持查询任务状态、运行结果。Fls可以将不同地址统一成一个从零开始的线性地址，这个有什么用？假如我想使用两个不连续的Flash扇区，Fls做个地址映射到这两个扇区，对上层来说地址是连续的，上层无需管Flash物理地址，操作的都是逻辑地址，方便上层的使用。</p>
<p>Fls把FlashDriver抽象出来，增加一种flash需编写一份Flash底层驱动，无需修改Fls代码，可在Flash底层驱动里实现不同Flash的私有配置。Fls会传递正确的物理地址和长度等参数给FlashDriver，因此FlashDriver可不用重复检查参数。Fls可以配置多个实例，支持多个实例用同一份FlashDriver，也支持同时有多种不同的Fls实例，他们共用一份Fls代码（增加复用性）。</p>
<h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><p>为什么使用异步？同步阻塞时间过大，影响其他任务运行，异步可以将一个大任务打散成多个小任务多次执行。Fls要实现异步方式调用，任务会在Fls_main里执行，用户可配每次Fls_main执行任务最大的读写量，防止一次main阻塞时间过长。</p>
<p>异步除了在实现的时候会比同步复杂些，用户在调用的时候也会比同步复杂，有os支持下还好，当任务异步调用Fls后可以挂起，定时查询状态或回调的方式，当Fls任务结束后继续执行原任务，假如没有os支持的话，没有挂起接口，用户每次异步调完Fls后需要记录下当前运行的位置，周期调度下次继续执行。异步能让io(flash)操作阻塞时mcu去干别的事，更好的利用处理器性能，但也增加了查询、任务切换等开销。Fls异步写入时，将写入任务拆成一个个异步的页写入任务，执行后内部挂起，等下次执行查状态。像云途的Flash页大小就8字节，岂不是写256字节要分成30多次子任务，这进出函数的开销和利用阻塞的时间，异步到底有没有优化性能呢？</p>
<p>擦除任务异步挺有意义的每次阻塞的时间长，也不用把任务打的很散增大函数出入的开销。GD的外部Flash页有256字节，每次写入阻塞时间较长，这种也适用异步写，车规芯片的SPI速度较低最大4M，需要SPI中断或DMA的支持。</p>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>为何保留同步？通过一个参数来决定是同步执行还是异步执行，同步的好处使用户方便使用。</p>
<p>同步如何实现？其实异步实现了，同步自然就实现了。同步就是一直调用Fls内部的main直到任务执行完毕。</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>Fls需要配置哪些参数？凡是在Fls配置的都是Flash的共有属性，配置较多：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Fls_JobType FlsJobDoing;              <span class="comment">// 正在执行的任务</span></span><br><span class="line">	MemIf_StatusType FlsJobStatus;        <span class="comment">// 任务状态</span></span><br><span class="line">	MemIf_JobResultType FlsJobResult;     <span class="comment">// 任务返回值</span></span><br><span class="line">	Fls_AddressType FlsJobAddr;           <span class="comment">// 任务目前执行到的地址</span></span><br><span class="line">	Fls_LengthType FlsJobLength;          <span class="comment">// 任务目前执行剩余长度</span></span><br><span class="line">	<span class="type">const</span> uint8 *FlsJobDataSrcPtr;        <span class="comment">// 用于传递Write、Compare地址指针参数</span></span><br><span class="line">	uint8 *FlsJobDataDestPtr;             <span class="comment">// 用于传递Read地址指针参数</span></span><br><span class="line">	MemIf_ModeType FlsJobMode;            <span class="comment">// 快速模式或者慢速模式对应的每周期操作的字节数不同</span></span><br><span class="line">	Fls_LengthType FlsPendingEraseLen;    <span class="comment">// 挂起的擦除字节长度（异步擦除用）</span></span><br><span class="line">	Fls_LengthType FlsTotalSize;          <span class="comment">// 此Fls实例的空间总大小</span></span><br><span class="line">&#125; Fls_JobInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	uint16 FlsNumberOfSectors;                <span class="comment">// 扇区个数</span></span><br><span class="line">	uint16 FlsWriteAlignSize;                 <span class="comment">// 写入对齐大小</span></span><br><span class="line">	uint16 FlsReadAlignSize;                  <span class="comment">// 读取对齐大小</span></span><br><span class="line">	Fls_LengthType FlsSectorSize;             <span class="comment">// 单个扇区字节数</span></span><br><span class="line">	Fls_LengthType FlsPageSize;               <span class="comment">// 单个页字节数</span></span><br><span class="line">	Fls_AddressType FlsSectorStartaddress;    <span class="comment">// 第一个扇区起始地址</span></span><br><span class="line">&#125; Fls_SectorType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> Fls_DriverFunType *FlsDriverFunPtr;    <span class="comment">// 驱动函数指针结构体地址</span></span><br><span class="line">	<span class="type">const</span> Fls_SectorType *FlsSectorListPtr;      <span class="comment">// 扇区列表地址</span></span><br><span class="line">	uint8 FlsSectorListNum;                      <span class="comment">// Flash（扇区列表）个数</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr;             <span class="comment">// 不同种类Flash私有属性配置地址</span></span><br><span class="line">	uint32 FlsMaxBlockingTime;                   <span class="comment">// Fls最大阻塞时间（ms），0表示不开启阻塞超时监测</span></span><br><span class="line">	uint8 FlsEnableNonBlockingErase;             <span class="comment">// 开启Fls非阻塞擦除的功能</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		Fls_LengthType FlsMaxReadFastMode;       <span class="comment">// 在快速模式下，一个周期内Read、Compare的最大字节数</span></span><br><span class="line">		Fls_LengthType FlsMaxReadNormalMode;     <span class="comment">// 在正常模式下，一个周期内Read、Compare的最大字节数</span></span><br><span class="line">		Fls_LengthType FlsMaxWriteFastMode;      <span class="comment">// 在快速模式下，一个周期内Write的最大字节数</span></span><br><span class="line">		Fls_LengthType FlsMaxWriteNormalMode;    <span class="comment">// 在正常模式下，一个周期内Write的最大字节数</span></span><br><span class="line">		MemIf_ModeType FlsDefaultJobMode;        <span class="comment">// 初始化后的JobMode</span></span><br><span class="line">	&#125; FlsModeConfig;                             <span class="comment">// 配置不同模式参数</span></span><br><span class="line">&#125; Fls_InstanceConfigType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*FlsBlockingCallbackPtr)(<span class="type">void</span>);                      <span class="comment">// 阻塞回调函数</span></span><br><span class="line">	Fls_JobInfoType *FlsJobInfoListPtr;                        <span class="comment">// 任务管理空间地址</span></span><br><span class="line">	<span class="type">const</span> Fls_InstanceConfigType *FlsInstanceConfigListPtr;    <span class="comment">// Fls实例配置指针</span></span><br><span class="line">	uint8 FlsInstanceNum;                                      <span class="comment">// 总实例数量</span></span><br><span class="line">&#125; Fls_ConfigType;</span><br></pre></td></tr></table></figure>

<p>由于要封模块，并且要做成可重入，所以需要由用户在配置代码中定义每个实例的管理ram，并配置到config常量中。</p>
<h5 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h5><p>从零开始的线性地址如何实现？看了上面的<code>Fls_SectorType</code>配置可以想到，Flash的地址映射关系就是映射到的“扇区列表配置”中。当时有个问题，假如有多个Flash，是不是映射成一个从零开始的地址？这样的话上层调用无需体现实例号的，因为根据地址映射关系就能找到要操作的Flash。后来想想还是不行，需要每个Flash的地址都分开从零开始，因为不同Flash的扇区大小等不同，上层不好只通过地址分辨是哪个Flash然后操作。</p>
<p><img src="https://hao0527.gitee.io/231020-MemoryStack/231020-MemoryStack-3.png" alt="img"></p>
<h5 id="多实例同时运行"><a href="#多实例同时运行" class="headerlink" title="多实例同时运行"></a>多实例同时运行</h5><p>这个特性也是需要支持的，不能让一个Flash阻塞的时候另一个Flash无法使用。如何实现这个特性呢？为每个Fls实例开一个<code>Fls_JobInfoType</code>管理实例的运行状态，每次Fls_main都把不同实例都执行一遍。这里有个可改善点，每次Fls_main只执行一个实例，让Fls_main的周期短一些，可以把多个Fls实例执行的阻塞时间打散一些，整个系统的最大阻塞时间会缩短。</p>
<h5 id="对外接口"><a href="#对外接口" class="headerlink" title="对外接口"></a>对外接口</h5><p>对外接口大致遵循AUTOSAR规范，增加了实例号和是否同步的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Fls_Init</span><span class="params">(<span class="type">const</span> Fls_ConfigType *ConfigPtr, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Erase</span><span class="params">(Fls_AddressType TargetAddress, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Write</span><span class="params">(Fls_AddressType TargetAddress, <span class="type">const</span> uint8 *SourceAddressPtr, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Read</span><span class="params">(Fls_AddressType SourceAddress, uint8 *TargetAddressPtr, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Compare</span><span class="params">(Fls_AddressType SourceAddress, <span class="type">const</span> uint8 *TargetAddressPtr, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_BlankCheck</span><span class="params">(Fls_AddressType TargetAddress, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line"></span><br><span class="line">MemIf_StatusType <span class="title function_">Fls_GetStatus</span><span class="params">(uint8 FlsInstanceId)</span>;</span><br><span class="line">MemIf_JobResultType <span class="title function_">Fls_GetJobResult</span><span class="params">(uint8 FlsInstanceId)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fls_SetMode</span><span class="params">(MemIf_ModeType Mode, uint8 FlsInstanceId)</span>;</span><br><span class="line">uint64 <span class="title function_">Fls_GetErrorCode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fls_MainFunction</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Fee"><a href="#Fee" class="headerlink" title="Fee"></a>Fee</h4><p>AUTOSAR NvM中的Fee(Flash EEPROM Emulation)主要做Flash模拟EEPROM的功能。使用EEPROM，软件可以在任意字节读写，也无需管擦除的事情。使用Flash需要考虑每次写入是否对齐、擦除一整个扇区的时候会不会有其他的数据被擦除，总不能每次写就擦除一整个扇区，一个扇区里就放一点点要存的内容吧。不管是Flash还是EEP通常都有磨损均衡的算法，提高Flash的寿命与利用率。Fee就是干这个事情的，并且要留出和Ea(EEPROM Abstraction Layer)一样的接口供上层MemIf(Memory Abstraction Interface)调用，在NvM操作MemIf，无需关心是Fee还是Ea。这也体现了AUTOSAR Memory Stack的高扇入低扇出思想，对外统一接口，内部可以操作不同的非易失存储器。</p>
<p>Fee是我在实现AUTOSAR Memory Stack中，最复杂的一个模块，先介绍一个基础概念：在内存协议栈中，每个要读写的数据为一个Block数据块，NvM会调用MemIf读写Block，MemIf会调用相应的子设备如Fee。</p>
<h5 id="均衡算法与Cluster概念"><a href="#均衡算法与Cluster概念" class="headerlink" title="均衡算法与Cluster概念"></a>均衡算法与Cluster概念</h5><p>均衡算法参考了AUTOSAR的多Cluster与多Cluster Group，也加入了自己的均衡磨损管理算法，最终可以实现安全可靠的Block存储。</p>
<p>在Fee中，一个Flash被划分成1个或多个Cluster Group，每个Cluster Group中可以管理不同的Block；一个Cluster Group中有2个或多个Cluster，用来均衡磨损，每次写入Block都会在所属的Cluster Group中的一个活跃的Cluster上写入，当所有Cluster被写满时，最老的一个Cluster会被擦除，然后此Cluster待写入。</p>
<p>每个Cluster Group都可以由用户配置，并且都有自己运行时的一份变量空间，一下是Cluster Group的配置与变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Fls_AddressType ClusterFreeSpaceAddr;    <span class="comment">// 指向当前Cluster的空闲空间地址，又表示当前cluster已使用的空间大小</span></span><br><span class="line">	uint16 ActiveClusterId;                  <span class="comment">// 当前ACTIVE的Cluster Id</span></span><br><span class="line">	uint16 ScanStartClusterId;               <span class="comment">// scanBlock从哪块Cluster开始，0xffff为不执行scanBlock</span></span><br><span class="line">	uint32 CycleTimes;                       <span class="comment">// Cluster擦除的周期计数</span></span><br><span class="line">	boolean NeedSwap;                        <span class="comment">// 此clusterGroup是否需要swap</span></span><br><span class="line">&#125; Fee_ClusterGroupInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	uint32 CycleTimes;               <span class="comment">// Cluster擦写次数</span></span><br><span class="line">	Fee_ClusterStatusType Status;    <span class="comment">// Cluster状态</span></span><br><span class="line">	uint8 ClrInfoVerify;             <span class="comment">// ClrId ClrGroup ClusterSize信息 1:正确 0:不正确</span></span><br><span class="line">&#125; Fee_ClusterInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Fls_AddressType ClrStartAddr;          <span class="comment">// Cluster Group起始的Fls地址</span></span><br><span class="line">	Fls_LengthType ClrSize;                <span class="comment">// 每个Cluster的字节数</span></span><br><span class="line">	uint8 ClrGroup;                        <span class="comment">// Cluster Group ID</span></span><br><span class="line">	uint16 NumberOfClr;                    <span class="comment">// Cluster Group中的Cluster数量</span></span><br><span class="line">	Fee_ClusterInfoType *FeeClrInfoPtr;    <span class="comment">// 簇信息管理空间地址（用户需要提供数组大小要与NumberOfClr一致）</span></span><br><span class="line">&#125; Fee_ClusterGroupConfigType;</span><br></pre></td></tr></table></figure>

<p>每个Cluster有它的管理数据结构，Cluster Header中包含了所属哪个Cluster Group、Cluster Id、Cluster Size、擦除次数、状态等信息。初始化会检查这些Cluster头，避免Flash中的Cluster配置与代码不一致造成的数据问题，还可以通过擦除次数看Flash的使用次数，评估其寿命，异常时做云平台上报。</p>
<h5 id="查找最新的Block"><a href="#查找最新的Block" class="headerlink" title="查找最新的Block"></a>查找最新的Block</h5><p>每次上电初始化要做的事就是从Flash中读取Block，那存在Cluster中的哪个Block是最新的呢？首先要知道一个Cluster Group中哪个Cluster是最新的。Cluster Header中会有Cluster的状态，一般情况下最新的Cluster有个活跃的状态，便可知最老的那个Cluster，从最老的Cluster上遍历查找每个Block，记录每个Block最新地址，这么一轮遍历结束就可以知道各个Block最新的数据存在哪个位置啦。</p>
<p>内部接口：<code>static Std_ReturnType Fee_ScanBlock(uint8 FeeInstanceId, uint8 ClusterGroup, uint16 ScanStartClusterId)</code></p>
<p>索引是从指定Cluster搜索有效的block，取最新的block信息保存至FeeBlockInfo。考虑Cluster中会有损坏的Block和之前写Block中断电的情况，Scan需要能跳过坏Block，按以下流程scan每个有效的Cluster：</p>
<ol>
<li>每个Cluster开始索引的地址为ClusterHeader后开始存放Block的地址。</li>
<li>开始检查对应地址的Block状态。</li>
<li><ol>
<li>为空，跳出此Cluster的索引。</li>
</ol>
</li>
<li><ol start="2">
<li>DataValid有效，Block正常，将Block地址存储在BlockInfo（hash表）中，根据此Block长度跳地址，继续索引（步骤2）。</li>
</ol>
</li>
<li><ol start="3">
<li>NumLenValid（BlockInfo）有效，Block数据段无效，数据段无法保证全为空, 跳过BlockHeader+BlockLen长度继续索引。</li>
</ol>
</li>
<li><ol start="4">
<li>NumLen和Data都无效，BlockHeader不为空正常情况下数据区还没被写，跳过一个BlockHeader长度继续索引。</li>
</ol>
</li>
</ol>
<p>每个Block在Fee中都有其对应的配置与RAM空间，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Fls_AddressType BlockAddr;     <span class="comment">// Block头所在的Fls地址</span></span><br><span class="line">	uint16 ClusterId;              <span class="comment">// Block所在的Cluster Id</span></span><br><span class="line">	uint16 BlockNumber;            <span class="comment">// Block Number</span></span><br><span class="line">	uint16 BlockLen;               <span class="comment">// Block Len</span></span><br><span class="line">	Fee_BlockStatusType Status;    <span class="comment">// Block头的状态</span></span><br><span class="line">&#125; Fee_BlockInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	uint16 BlockNumber;    <span class="comment">// 配置Block Number</span></span><br><span class="line">	uint16 BlockLen;       <span class="comment">// 配置Block Len</span></span><br><span class="line">	uint8 ClusterGroup;    <span class="comment">// 配置Block属于那个BlockGroup</span></span><br><span class="line">&#125; Fee_BlockConfigType;</span><br></pre></td></tr></table></figure>

<p>每个Block也像Cluster一样有Header，在Block Header中记录BlockId、BlockSize、各种标志位信息。可以通过这些标志位，判断当时存的时候有没有异常下电，Block数据是否完整可信，在Fee中不是通过CRC的方式判断数据是否可信，因为在初始化遍历读取Block的时候，给每个Block做CRC如果Flash很大那需要很长一段时间。</p>
<h5 id="交换Cluster"><a href="#交换Cluster" class="headerlink" title="交换Cluster"></a>交换Cluster</h5><p>内部接口：<code>static Std_ReturnType Fee_SwapCluster(uint8 FeeInstanceId, uint8 ClusterGroup, uint16 FromClusterId, uint16 ToClusterId)</code></p>
<p>将旧Cluster上的有效Block搬到新Cluster。</p>
<ol>
<li>遍历所有的BlockInfo，如果Block的ClusterGroup匹配，且有效数据在老的Cluster上，就将整个Block读取到函数栈空间，然后写入新Cluster的地址，在SWAPPING的时候无需考虑写BlockHeader标志位的顺序，因为SWAPPING时掉电，下次初始化时会擦除此Cluster重新SWAP。</li>
</ol>
<p>详细描述：当Cluster总数-1的Cluster被写完的情况下就需要触发Cluster交换任务了，目的是将最老Cluster上有效的Block（没有更新的数据）转移到那块空白的Cluster上，我称这个操作叫换页。换页时会给Cluster写上换页的标志位，换页过程中异常下电下次能识别到触发重新换页任务。上面说过每个Block都有ram空间，管理这其最新Block的地址（在哪个Cluster上和偏移地址），因此很容易知道最老的Cluster有哪些有效Block和其地址，可以简单的使用memcpy将其复制到最新的Cluster上，因为Block Header不用发生更改，并且写入Block时无需防止异常下电。换页结束后需改变Cluster的状态，将原先最新的那个从活跃设置为满状态，将新的那个Cluster从空设为活跃状态。</p>
<h5 id="维护任务"><a href="#维护任务" class="headerlink" title="维护任务"></a>维护任务</h5><p>内部接口：<code>static Std_ReturnType Fee_MaintainJob(uint8 FeeInstanceId)</code></p>
<p>维护任务，需要检查是否需要执行交换和擦除任务。考虑减少运行时阻塞，正常情况维护中擦除Cluster采用异步非阻塞的方式。正常情况维护操作流程如下：（非正常情况处理较复杂不写）</p>
<ol>
<li>当前操作的Cluster状态为ACTIVE，检查下个Cluster状态是否为VERIFIED，若不是，异步擦除下个Cluster。</li>
<li>当前操作的Cluster状态为ACTIVE，下个Cluster状态为VERIFIED，检查当前Cluster空闲空间是否充足，若不足，将当前Cluster写FULL标志位，2个Cluster和2个以上Cluster写入标志位顺序有差异。</li>
<li>当前操作的Cluster状态为FULL，执行SWAP任务，将最老的Cluster上有效的Block搬到新的Cluster上，SWAP成功后将当前操作的Cluster改为新的Cluster，新Cluster状态设为ACTIVE。</li>
</ol>
<p><strong>Cluster 状态转移图如下</strong>：</p>
<p><img src="https://hao0527.gitee.io/231020-MemoryStack/231020-MemoryStack-2.png" alt="img"></p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>对外接口：<code>void Fee_Init(const Fee_ConfigType* ConfigPtr, boolean IsSync)</code><br>内部初始化Job接口：<code>static Std_ReturnType Fee_InitJob(uint8 FeeInstanceId)</code></p>
<p>初始化Job中需要处理各种不同的Cluster状态，查找ACTIVE状态的Cluster和最老的Cluster，从最老的Cluster开始索引Block。</p>
<p>考虑在换页时断电和Cluster损坏的可能性，初始化处理Cluster状态有如下几种情况：（每种情况处理方式不描述了）</p>
<ol>
<li>只有1个ACTIVE状态的cluster。</li>
<li>没有ACTIVE状态的cluster，只有1个SWAPPING状态的cluster。</li>
<li>总共只有2个Cluster，没有cluster状态为ACTIVE和SWAPPING，只有1个cluster状态为FULL。</li>
<li>没有ACTIVE和SWAPPING状态的Cluster，只有FULL状态的Cluster。</li>
<li>其他。<br>原则上，大于2个Cluster只要有1个ACTIVE或1个SWAPPING状态的Cluster都能被成功初始化，如果存储在Flash中的数据受干扰异常导致无法识别ACTIVE和SWAPPING状态的Cluster，会导致初始化失败，会重新初始化Cluster，历史数据丢失。</li>
</ol>
<h5 id="写入Block"><a href="#写入Block" class="headerlink" title="写入Block"></a>写入Block</h5><p>对外接口：<code>Std_ReturnType Fee_Write(uint8 FeeInstanceId, uint16 BlockNumber, const uint8 *DataBufferPtr, boolean IsSync)</code><br>内部接口：<code>MemIf_JobResultType Fee_WriteJob(uint16 BlockIndex, const uint8* DataBufferPtr, uint8 FeeInstanceId)</code></p>
<p>上层调用Fee写入Block数据，支持异步。</p>
<p>在Fee_WriteJob()需考虑写入时Flash空间不为空的情况，若不为空应该找到空白区域，使下次可正常写入，具体写入流程如下：</p>
<ol>
<li>每次写入前都会检查要写入BlockHeader的地址空间是否为空白，如果不空白，解析BlockHeader。</li>
<li><ol>
<li>为空，跳出检查。</li>
</ol>
</li>
<li><ol start="2">
<li>DataValid或NumLenValid有效，根据此Block长度跳地址，继续检查下个地址空间是否空白（步骤1）。</li>
</ol>
</li>
<li><ol start="3">
<li>NumLen和Data都无效，跳过一个BlockHeader长度继续检查（步骤1）。</li>
</ol>
</li>
<li>写入BlockHeader中的INFO（BlockNumber、BlockLen），写入BlockHeader中的NUMLEN有效标志位。</li>
<li>检查要写入数据的区域是否为空，不为空则退出。</li>
<li>写入BlockData，写入Data有效标志位。</li>
<li>数据写入Flash成功，更新BlockInfo，指向最新的Block地址。</li>
</ol>
<h5 id="读取Block"><a href="#读取Block" class="headerlink" title="读取Block"></a>读取Block</h5><p>对外接口：<code>Std_ReturnType Fee_Read(uint8 FeeInstanceId, uint16 BlockNumber, uint16 BlockOffset, uint8 *DataBufferPtr, uint16 Length, boolean IsSync)</code><br>内部接口：<code>MemIf_JobResultType Fee_ReadJob(uint16 BlockIndex, uint16 BlockOffset, uint8* DataBufferPtr, uint16 Length, uint8 FeeInstanceId)</code></p>
<p>上层调用Fee读取数据，支持异步，读取通过偏移和长度参数，读取Block中的部分数据内容。</p>
<p>Block读取较为简单，判断参数正确未越界即可直接读取Flash中的数据到内存，如果Flash中未保存此数据返回MEMIF_BLOCK_INVALID。</p>
<h5 id="同异步、多实例"><a href="#同异步、多实例" class="headerlink" title="同异步、多实例"></a>同异步、多实例</h5><p>Fee和Fls都支持同步和异步的调用方式，为了实现异步调用，需要有一个管理任务的内存空间，Fee和Fls都使用JobInfo结构体来管理。每个实例都有独立的ram空间，所以多实例问题也很好解决。</p>
<p>Fee对外接口中，读Block、写Block、失效Block三个接口支持异步的方式，Fls对外接口中，读Flash、写、擦、比较、空校验这些接口支持异步方式调用。</p>
<ul>
<li>异步调用Fee对外接口，接口函数会检测参数正确性，无误后将任务参数写入JobInfo，Fee状态变为Busy，然后接口return，在Fee_main中执行Job。</li>
<li>同步调用Fee读写接口和异步方式相同，写入JobInfo后会在对外接口函数内调用执行Job函数，直到状态变为IDLE。</li>
</ul>
<h4 id="MemIf"><a href="#MemIf" class="headerlink" title="MemIf"></a>MemIf</h4><p>内存抽象接口（MemIf）模块提供对底层Fee或Ea模块的抽象，由NvM调用传入形参实例号（DeviceIndex），MemIf根据实例号区分该调用Fee或是Ea模块。</p>
<p>MemIf也做成了可配置的形式，可通过配置将需要用的子模块链接到程序中，不用的模块不链接，实现整套协议栈功能可裁剪。</p>
<h4 id="NvM"><a href="#NvM" class="headerlink" title="NvM"></a>NvM</h4><p>NvM模块包含：下电写入、周期写入、事件触发写入、Block标定、Block清除（恢复默认值）、Block读取写入、Block结构体变更处理、Block校验失败处理、Block数据和RTE同步功能。</p>
<p>NvM是基于原本EPara模块重构的，使用MemIf的接口，对上提供原EPara有的那些服务接口，如标定、同步这些AUTOSAR中没有的功能。其余读写Block，接口改的与AUTOSAR一致，一些AUTOSAR中有的但用不到的接口部分也没有实现。</p>
<p>初始化接口：<code>void NvM_Init( const NvM_ConfigType* ConfigPtr )</code><br>流程：校验config参数，读取所有Block，创建NvM周期任务。</p>
<p>读取Block任务接口：<code>static void NvM_ReadBlock(uint16 BlockId)</code><br>流程：读取NvM Block Header，根据头中的Block Len读取相应长度的数据段，做CRC16校验。CRC校验失败恢复默认值，版本不一致恢复默认值。原数据长度小于配置的Block长度，继承原先长度的Block数据，超过原先长度的部分从默认值获取。原数据长度大于等于配置的Block长度，保留Block所配置长度的数据段。</p>
<p>写入Block任务接口：<code>static void NvM_WriteBlockJob(uint16 BlockId)</code><br>流程：读取Block，比较不一致再写入，写入成功或比较一致清除Block写入标志位。</p>
<p>写入Block接口：<code>void NvM_WriteAll(boolean IsSync)</code> <code>void NvM_WriteBlock(uint16 BlockId, boolean IsSync)</code><br>流程：这两个写入Block接口会将Block写入标志位置写入标志位，如果IsSync = TRUE，会在函数内部调用<code>NvM_ExecuteJob()</code>，执行写入任务。</p>
<p>周期写入接口：<code>static void NvM_CycleWrite(void)</code><br>流程：写入周期到，会对所有配置了周期写入的Block置写入标志位。</p>
<p>下电写入接口：<code>static void NvM_PoweroffWrite(void)</code><br>流程：检测到预下电RTE信号上升沿，会对所有配置了周期写入的Block置写入标志位。</p>
<p>事件触发写入接口：<code>static void NvM_EventWrite(void)</code><br>流程：检测到对应Block事件触发信号上升沿，会对此Block置写入标志位。</p>
<p>执行任务接口：<code>static void NvM_ExecuteJob(void)</code><br>流程：执行写入任务，调用一次ExecuteJob，最多只会写入1个Block。</p>
<h5 id="NvM存储各层数据结构"><a href="#NvM存储各层数据结构" class="headerlink" title="NvM存储各层数据结构"></a>NvM存储各层数据结构</h5><p><img src="https://hao0527.gitee.io/231020-MemoryStack/231020-MemoryStack-1.png" alt="img"></p>
<h3 id="待改进点"><a href="#待改进点" class="headerlink" title="待改进点"></a>待改进点</h3><ol>
<li>Fls写入使用异步非阻塞，每写入一个页挂起，需要os支持。</li>
<li>Fee异常时的擦除也可以挂起，减少阻塞时处理器性能浪费。</li>
<li>MemIf下可以挂除Fee和Ea外的设备，支持S32K的EEP，因为S32EEP不需要均衡磨损，本身就是用Flash模拟的，所以不适合挂在Ea和Fee。为什么不直接用Flash，然后挂Fee上？因为想让用S32Eep的老项目支持这套内存协议栈。</li>
<li>NvM作为协议栈的上层，可以实现更多的功能。</li>
</ol>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>整套协议栈自己实现相比直接用AUTOSAR的组件有很多的优点，有哪些自己特殊的需求加到协议栈里比较方便。比如使用之前的均衡磨损算法、NvM支持数据不同版本继承、Fee对数据继承的支持、有同步接口的需求、外部Flash也想使用Fee等等。</p>
<p>调试的过程中云途的mcu擦flash也有坑，这么多个模块开发下来，其中感觉最为复杂的是Fee，完成一个能经得住随机下电，下次上电能自恢复的Fee是很有成就感的。这里要感谢我领导对我的支持与帮助，给我时间让我自我发挥，遇到我解决问题可以一同调试。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/23/230923-ble/" rel="prev" title="蓝牙BLE调试记录">
      <i class="fa fa-chevron-left"></i> 蓝牙BLE调试记录
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/10/31/231031-wdg/" rel="next" title="AUTOSAR Wdg Stack 架构">
      AUTOSAR Wdg Stack 架构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory-Stack-%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text">Memory Stack 开发总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">1.2.</span> <span class="nav-text">参考资料</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">设计方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FlashDriver"><span class="nav-number">1.3.1.</span> <span class="nav-text">FlashDriver</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%9D%E7%95%99%E7%89%B9%E6%80%A7"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">保留特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%9C%A8%E5%93%AA"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">阻塞在哪</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E4%BD%99%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">其余问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fls"><span class="nav-number">1.3.2.</span> <span class="nav-text">Fls</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">异步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">线性地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E5%AE%9E%E4%BE%8B%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">多实例同时运行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E5%A4%96%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">对外接口</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Fee"><span class="nav-number">1.3.3.</span> <span class="nav-text">Fee</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E4%B8%8ECluster%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">均衡算法与Cluster概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%9C%80%E6%96%B0%E7%9A%84Block"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">查找最新的Block</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%A4%E6%8D%A2Cluster"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">交换Cluster</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E4%BB%BB%E5%8A%A1"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">维护任务</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%99%E5%85%A5Block"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">写入Block</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96Block"><span class="nav-number">1.3.3.7.</span> <span class="nav-text">读取Block</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E5%BC%82%E6%AD%A5%E3%80%81%E5%A4%9A%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.3.3.8.</span> <span class="nav-text">同异步、多实例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MemIf"><span class="nav-number">1.3.4.</span> <span class="nav-text">MemIf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NvM"><span class="nav-number">1.3.5.</span> <span class="nav-text">NvM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#NvM%E5%AD%98%E5%82%A8%E5%90%84%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">NvM存储各层数据结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%85%E6%94%B9%E8%BF%9B%E7%82%B9"><span class="nav-number">1.4.</span> <span class="nav-text">待改进点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%80%83"><span class="nav-number">1.5.</span> <span class="nav-text">思考</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao</p>
  <div class="site-description" itemprop="description">保持热爱，奔赴山海。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
