<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/heng32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/heng16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Chinese translated version of Documentation&#x2F;process&#x2F;coding-style.rst If you have any comment or update to the content, please post to LKML directly. However, if you have problem communicating in Engli">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux 内核代码风格">
<meta property="og:url" content="http://example.com/2023/06/25/230625-Linux%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/index.html">
<meta property="og:site_name" content="永恆博客网">
<meta property="og:description" content="Chinese translated version of Documentation&#x2F;process&#x2F;coding-style.rst If you have any comment or update to the content, please post to LKML directly. However, if you have problem communicating in Engli">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-06-25T08:00:00.000Z">
<meta property="article:modified_time" content="2023-07-04T01:28:41.162Z">
<meta property="article:author" content="Hao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2023/06/25/230625-Linux%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux 内核代码风格 | 永恆博客网</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">永恆博客网</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/25/230625-Linux%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux 内核代码风格
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-25 16:00:00" itemprop="dateCreated datePublished" datetime="2023-06-25T16:00:00+08:00">2023-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-04 09:28:41" itemprop="dateModified" datetime="2023-07-04T09:28:41+08:00">2023-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Chinese translated version of Documentation/process/coding-style.rst</p>
<p>If you have any comment or update to the content, please post to LKML directly. However, if you have problem communicating in English you can also ask the Chinese maintainer for help. Contact the Chinese maintainer, if this translation is outdated or there is problem with translation.</p>
<p>Chinese maintainer: Zhang Le &lt;<a href="mailto:r0bertz@gentoo.org">r0bertz@gentoo.org</a>&gt;</p>
<hr>
<p>Documentation/process/coding-style.rst 的中文翻译</p>
<p>如果想评论或更新本文的内容，请直接发信到LKML。如果你使用英文交流有困难的话， 也可以向中文版维护者求助。如果本翻译更新不及时或者翻译存在问题，请联系中文版 维护者:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">中文版维护者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</span><br><span class="line">中文版翻译者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</span><br><span class="line">中文版校译者： 王聪 Wang Cong &lt;xiyou.wangcong@gmail.com&gt;</span><br><span class="line">               wheelz &lt;kernel.zeng@gmail.com&gt;</span><br><span class="line">               管旭东 Xudong Guan &lt;xudong.guan@gmail.com&gt;</span><br><span class="line">               Li Zefan &lt;lizf@cn.fujitsu.com&gt;</span><br><span class="line">               Wang Chen &lt;wangchen@cn.fujitsu.com&gt;</span><br></pre></td></tr></table></figure>

<p>以下为正文</p>
<hr>
<h1 id="Linux-内核代码风格"><a href="#Linux-内核代码风格" class="headerlink" title="Linux 内核代码风格"></a>Linux 内核代码风格</h1><p>这是一个简短的文档，描述了 linux 内核的首选代码风格。代码风格是因人而异的， 而且我不愿意把自己的观点强加给任何人，但这就像我去做任何事情都必须遵循的原则 那样，我也希望在绝大多数事上保持这种的态度。请 (在写代码时) 至少考虑一下这里 的代码风格。</p>
<p>首先，我建议你打印一份 GNU 代码规范，然后不要读。烧了它，这是一个具有重大象征性意义的动作。</p>
<p>不管怎样，现在我们开始：</p>
<h2 id="1-缩进"><a href="#1-缩进" class="headerlink" title="1) 缩进"></a>1) 缩进</h2><p>制表符是 8 个字符，所以缩进也是 8 个字符。有些异端运动试图将缩进变为 4 (甚至 2！) 字符深，这几乎相当于尝试将圆周率的值定义为 3。</p>
<p>理由：缩进的全部意义就在于清楚的定义一个控制块起止于何处。尤其是当你盯着你的 屏幕连续看了 20 小时之后，你将会发现大一点的缩进会使你更容易分辨缩进。</p>
<p>现在，有些人会抱怨 8 个字符的缩进会使代码向右边移动的太远，在 80 个字符的终端屏幕上就很难读这样的代码。这个问题的答案是，如果你需要 3 级以上的缩进，不管用 何种方式你的代码已经有问题了，应该修正你的程序。</p>
<p>简而言之，<u>8 个字符的缩进可以让代码更容易阅读，还有一个好处是当你的函数嵌套太深的时候可以给你警告。留心这个警告</u>。</p>
<p>在 switch 语句中消除多级缩进的首选的方式是让 <code>switch</code> 和从属于它的 <code>case</code> 标签对齐于同一列，而不要 <code>两次缩进</code> <code>case</code> 标签。比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (suffix) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">        mem &lt;&lt;= <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">        mem &lt;&lt;= <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:</span><br><span class="line">        mem &lt;&lt;= <span class="number">10</span>;</span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要把多个语句放在一行里，除非你有什么东西要隐藏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) do_this;</span><br><span class="line">  do_something_everytime;</span><br></pre></td></tr></table></figure>

<p>也不要在一行里放多个赋值语句。内核代码风格超级简单。就是避免可能导致别人误读 的表达式。</p>
<p>除了注释、文档和 Kconfig 之外，不要使用空格来缩进，前面的例子是例外，是有意为 之。</p>
<p>选用一个好的编辑器，不要在行尾留空格。</p>
<h2 id="2-把长的行和字符串打散"><a href="#2-把长的行和字符串打散" class="headerlink" title="2) 把长的行和字符串打散"></a>2) 把长的行和字符串打散</h2><p>代码风格的意义就在于使用平常使用的工具来维持代码的可读性和可维护性。</p>
<p>每一行的长度的限制是 80 列，我们强烈建议您遵守这个惯例。</p>
<p>长于 80 列的语句要打散成有意义的片段。除非超过 80 列能显著增加可读性，并且不 会隐藏信息。子片段要明显短于母片段，并明显靠右。这同样适用于有着很长参数列表 的函数头。然而，绝对不要打散对用户可见的字符串，例如 printk 信息，因为这样就 很难对它们 grep。</p>
<h2 id="3-大括号和空格的放置"><a href="#3-大括号和空格的放置" class="headerlink" title="3) 大括号和空格的放置"></a>3) 大括号和空格的放置</h2><p>C 语言风格中另外一个常见问题是大括号的放置。和缩进大小不同，选择或弃用某种放置策略并没有多少技术上的原因，不过首选的方式，就像 Kernighan 和 Ritchie 展示 给我们的，是把起始大括号放在行尾，而把结束大括号放在行首，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (x is true) &#123;</span><br><span class="line">        we do y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这适用于所有的非函数语句块 (if, switch, for, while, do)。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (action) &#123;</span><br><span class="line">case KOBJ_ADD:</span><br><span class="line">        return &quot;add&quot;;</span><br><span class="line">case KOBJ_REMOVE:</span><br><span class="line">        return &quot;remove&quot;;</span><br><span class="line">case KOBJ_CHANGE:</span><br><span class="line">        return &quot;change&quot;;</span><br><span class="line">default:</span><br><span class="line">        return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，有一个例外，那就是函数：函数的起始大括号放置于下一行的开头，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int function(int x)</span><br><span class="line">&#123;</span><br><span class="line">        body of function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全世界的异端可能会抱怨这个不一致性是… 呃… 不一致的，不过所有思维健全的人 都知道 (a) K&amp;R 是 <strong>正确的</strong> 并且 (b) K&amp;R 是正确的。此外，不管怎样函数都是特 殊的 (C 函数是不能嵌套的)。</p>
<p>注意结束大括号独自占据一行，除非它后面跟着同一个语句的剩余部分，也就是 do 语 句中的 “while” 或者 if 语句中的 “else”，像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">        body of do-loop</span><br><span class="line">&#125; while (condition);</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (x == y) &#123;</span><br><span class="line">        ..</span><br><span class="line">&#125; else if (x &gt; y) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理由：K&amp;R。</p>
<p>也请注意这种大括号的放置方式也能使空 (或者差不多空的) 行的数量最小化，同时不失可读性。因此，由于你的屏幕上的新行是不可再生资源 (想想 25 行的终端屏幕)，你 将会有更多的空行来放置注释。</p>
<p>当只有一个单独的语句的时候，不用加不必要的大括号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">        action();</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">        do_this();</span><br><span class="line">else</span><br><span class="line">        do_that();</span><br></pre></td></tr></table></figure>

<p>这并不适用于只有一个条件分支是单语句的情况；这时所有分支都要使用大括号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">        do_this();</span><br><span class="line">        do_that();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        otherwise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-空格"><a href="#3-1-空格" class="headerlink" title="3.1) 空格"></a>3.1) 空格</h3><p>Linux 内核的空格使用方式 (主要) 取决于它是用于函数还是关键字。(大多数) 关键字后要加一个空格。值得注意的例外是 sizeof, typeof, alignof 和 __attribute__，这 些关键字某些程度上看起来更像函数 (它们在 Linux 里也常常伴随小括号而使用，尽管 在 C 里这样的小括号不是必需的，就像 <code>struct fileinfo info;</code> 声明过后的 <code>sizeof info</code>)。</p>
<p>所以在这些关键字之后放一个空格:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if, switch, case, for, do, while</span><br></pre></td></tr></table></figure>

<p>但是不要在 sizeof, typeof, alignof 或者 <strong>attribute</strong> 这些关键字之后放空格。 例如，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = sizeof(struct file);</span><br></pre></td></tr></table></figure>

<p>不要在小括号里的表达式两侧加空格。这是一个 <strong>反例</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = sizeof( struct file );</span><br></pre></td></tr></table></figure>

<p><u>当声明指针类型或者返回指针类型的函数时， <code>*</code> 的首选使用方式是使之靠近变量名或者函数名，而不是靠近类型名</u>。例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *linux_banner;</span><br><span class="line">unsigned long long memparse(char *ptr, char **retptr);</span><br><span class="line">char *match_strdup(substring_t *s);</span><br></pre></td></tr></table></figure>

<p><u>在大多数二元和三元操作符两侧使用一个空格</u>，例如下面所有这些操作符:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=  +  -  &lt;  &gt;  *  /  %  |  &amp;  ^  &lt;=  &gt;=  ==  !=  ?  :</span><br></pre></td></tr></table></figure>

<p><u>但是一元操作符后不要加空格</u>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined</span><br></pre></td></tr></table></figure>

<p>后缀自加和自减一元操作符前不加空格:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++  --</span><br></pre></td></tr></table></figure>

<p>前缀自加和自减一元操作符后不加空格:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++  --</span><br></pre></td></tr></table></figure>

<p><code>.</code> 和 <code>-&gt;</code> 结构体成员操作符前后不加空格。</p>
<p>不要在行尾留空白。有些可以自动缩进的编辑器会在新行的行首加入适量的空白，然后 你就可以直接在那一行输入代码。不过假如你最后没有在那一行输入代码，有些编辑器 就不会移除已经加入的空白，就像你故意留下一个只有空白的行。包含行尾空白的行就 这样产生了。</p>
<p>当 git 发现补丁包含了行尾空白的时候会警告你，并且可以应你的要求去掉行尾空白； 不过如果你是正在打一系列补丁，这样做会导致后面的补丁失败，因为你改变了补丁的上下文。</p>
<h2 id="4-命名"><a href="#4-命名" class="headerlink" title="4) 命名"></a>4) 命名</h2><p>C 是一个简朴的语言，你的命名也应该这样。和 Modula-2 和 Pascal 程序员不同， C 程序员不使用类似 ThisVariableIsATemporaryCounter 这样华丽的名字。C 程序员会 称那个变量为 <code>tmp</code> ，这样写起来会更容易，而且至少不会令其难于理解。</p>
<p>不过，虽然混用大小写的名字是不提倡使用的，但是全局变量还是需要一个具描述性的名字。称一个全局函数为 <code>foo</code> 是一个难以饶恕的错误。</p>
<p>全局变量 (只有当你 <strong>真正</strong> 需要它们的时候再用它) 需要有一个具描述性的名字，就像全局函数。如果你有一个可以计算活动用户数量的函数，你应该叫它 <code>count_active_users()</code> 或者类似的名字，你不应该叫它 <code>cntuser()</code> 。</p>
<p>在函数名中包含函数类型 (所谓的匈牙利命名法) 是脑子出了问题——编译器知道那些类 型而且能够检查那些类型，这样做只能把程序员弄糊涂了。难怪微软总是制造出有问题的程序。</p>
<p>本地变量名应该简短，而且能够表达相关的含义。如果你有一些随机的整数型的循环计数器，它应该被称为 <code>i</code> 。叫它 <code>loop_counter</code> 并无益处，如果它没有被误解的可能的话。类似的， <code>tmp</code> 可以用来称呼任意类型的临时变量。</p>
<p>如果你怕混淆了你的本地变量名，你就遇到另一个问题了，叫做函数增长荷尔蒙失衡综合症。请看第六章 (函数)。</p>
<h2 id="5-Typedef"><a href="#5-Typedef" class="headerlink" title="5) Typedef"></a>5) Typedef</h2><p>不要使用类似 <code>vps_t</code> 之类的东西。</p>
<p>对结构体和指针使用 typedef 是一个 <strong>错误</strong> 。当你在代码里看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vps_t a;</span><br></pre></td></tr></table></figure>

<p>这代表什么意思呢？</p>
<p>相反，如果是这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct virtual_container *a;</span><br></pre></td></tr></table></figure>

<p>你就知道 <code>a</code> 是什么了。</p>
<p>很多人认为 typedef <code>能提高可读性</code> 。实际不是这样的。它们只在下列情况下有用：</p>
<blockquote>
<ol>
<li><p>完全不透明的对象 (这种情况下要主动使用 typedef 来 <strong>隐藏</strong> 这个对象实际上是什么)。</p>
<p>例如： <code>pte_t</code> 等不透明对象，你只能用合适的访问函数来访问它们。</p>
<p>Note：不透明性和 “访问函数” 本身是不好的。我们使用 pte_t 等类型的原因在于真的是完全没有任何共用的可访问信息。</p>
</li>
<li><p>清楚的整数类型，如此，这层抽象就可以 <strong>帮助</strong> 消除到底是 <code>int</code> 还是 <code>long</code> 的混淆。</p>
<p>u8/u16/u32 是完全没有问题的 typedef，不过它们更符合类别 (d) 而不是这里。</p>
<p>Note：要这样做，必须事出有因。如果某个变量是 <code>unsigned long</code> ，那么没有必要 typedef unsigned long myflags_t;</p>
<p>不过如果有一个明确的原因，比如它在某种情况下可能会是一个 <code>unsigned int</code> 而在其他情况下可能为 <code>unsigned long</code> ，那么就不要犹豫，请务必使用 typedef。</p>
</li>
<li><p>当你使用 sparse 按字面的创建一个 <strong>新</strong> 类型来做类型检查的时候。</p>
</li>
<li><p>和标准 C99 类型相同的类型，在某些例外的情况下。</p>
<p>虽然让眼睛和脑筋来适应新的标准类型比如 <code>uint32_t</code> 不需要花很多时间，可是有些人仍然拒绝使用它们。</p>
<p>因此，Linux 特有的等同于标准类型的 <code>u8/u16/u32/u64</code> 类型和它们的有符号类型是被允许的——尽管在你自己的新代码中，它们不是强制要求要使用的。</p>
<p>当编辑已经使用了某个类型集的已有代码时，你应该遵循那些代码中已经做出的选择。</p>
</li>
<li><p>可以在用户空间安全使用的类型。</p>
<p>在某些用户空间可见的结构体里，我们不能要求 C99 类型而且不能用上面提到的 <code>u32</code> 类型。因此，我们在与用户空间共享的所有结构体中使用 __u32 和类似 的类型。</p>
</li>
</ol>
</blockquote>
<p>可能还有其他的情况，不过基本的规则是 <strong>永远不要</strong> 使用 typedef，除非你可以明确的应用上述某个规则中的一个。</p>
<p>总的来说，如果一个指针或者一个结构体里的元素可以合理的被直接访问到，那么它们就不应该是一个 typedef。</p>
<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6) 函数"></a>6) 函数</h2><p><u>函数应该简短而漂亮，并且只完成一件事情</u>。函数应该可以一屏或者两屏显示完 (我们 都知道 ISO/ANSI 屏幕大小是 80x24)，只做一件事情，而且把它做好。</p>
<p>一个函数的最大长度是和该函数的复杂度和缩进级数成反比的。所以，如果你有一个理论上很简单的只有一个很长 (但是简单) 的 case 语句的函数，而且你需要在每个 case 里做很多很小的事情，这样的函数尽管很长，但也是可以的。</p>
<p>不过，如果你有一个复杂的函数，而且你怀疑一个天分不是很高的高中一年级学生可能甚至搞不清楚这个函数的目的，你应该严格遵守前面提到的长度限制。使用辅助函数， 并为之取个具描述性的名字 (如果你觉得它们的性能很重要的话，可以让编译器内联它们，这样的效果往往会比你写一个复杂函数的效果要好。)</p>
<p>函数的另外一个衡量标准是本地变量的数量。此数量不应超过 5－10 个，否则你的函数 就有问题了。重新考虑一下你的函数，把它分拆成更小的函数。人的大脑一般可以轻松的同时跟踪 7 个不同的事物，如果再增多的话，就会糊涂了。即便你聪颖过人，你也可能会记不清你 2 个星期前做过的事情。</p>
<p>在源文件里，使用空行隔开不同的函数。如果该函数需要被导出，它的 <strong>EXPORT</strong> 宏 应该紧贴在它的结束大括号之下。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int system_is_up(void)</span><br><span class="line">&#123;</span><br><span class="line">        return system_state == SYSTEM_RUNNING;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(system_is_up);</span><br></pre></td></tr></table></figure>

<p>在函数原型中，包含函数名和它们的数据类型。虽然 C 语言里没有这样的要求，在 Linux 里这是提倡的做法，因为这样可以很简单的给读者提供更多的有价值的信息。</p>
<h2 id="7-集中的函数退出途径"><a href="#7-集中的函数退出途径" class="headerlink" title="7) 集中的函数退出途径"></a>7) 集中的函数退出途径</h2><p>虽然被某些人声称已经过时，但是 goto 语句的等价物还是经常被编译器所使用，具体形式是无条件跳转指令。</p>
<p>当一个函数从多个位置退出，并且需要做一些类似清理的常见操作时，goto 语句就很方便了。如果并不需要清理操作，那么直接 return 即可。</p>
<p>选择一个能够说明 goto 行为或它为何存在的标签名。如果 goto 要释放 <code>buffer</code>, 一个不错的名字可以是 <code>out_free_buffer:</code> 。别去使用像 <code>err1:</code> 和 <code>err2:</code> 这样的GW_BASIC 名称，因为一旦你添加或删除了 (函数的) 退出路径，你就必须对它们重新编号，这样会难以去检验正确性。</p>
<p>使用 goto 的理由是：</p>
<ul>
<li>无条件语句容易理解和跟踪</li>
<li>嵌套程度减小</li>
<li>可以避免由于修改时忘记更新个别的退出点而导致错误</li>
<li>让编译器省去删除冗余代码的工作 ;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int fun(int a)</span><br><span class="line">&#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        char *buffer;</span><br><span class="line"></span><br><span class="line">        buffer = kmalloc(SIZE, GFP_KERNEL);</span><br><span class="line">        if (!buffer)</span><br><span class="line">                return -ENOMEM;</span><br><span class="line"></span><br><span class="line">        if (condition1) &#123;</span><br><span class="line">                while (loop1) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                &#125;</span><br><span class="line">                result = 1;</span><br><span class="line">                goto out_free_buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">out_free_buffer:</span><br><span class="line">        kfree(buffer);</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个需要注意的常见错误是 <code>一个 err 错误</code> ，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err:</span><br><span class="line">        kfree(foo-&gt;bar);</span><br><span class="line">        kfree(foo);</span><br><span class="line">        return ret;</span><br></pre></td></tr></table></figure>

<p>这段代码的错误是，在某些退出路径上 <code>foo</code> 是 NULL。通常情况下，通过把它分离 成两个错误标签 <code>err_free_bar:</code> 和 <code>err_free_foo:</code> 来修复这个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err_free_bar:</span><br><span class="line">       kfree(foo-&gt;bar);</span><br><span class="line">err_free_foo:</span><br><span class="line">       kfree(foo);</span><br><span class="line">       return ret;</span><br></pre></td></tr></table></figure>

<p>理想情况下，你应该模拟错误来测试所有退出路径。</p>
<h2 id="8-注释"><a href="#8-注释" class="headerlink" title="8) 注释"></a>8) 注释</h2><p>注释是好的，不过有过度注释的危险。永远不要在注释里解释你的代码是如何运作的： 更好的做法是让别人一看你的代码就可以明白，<u>解释写的很差的代码是浪费时间</u>。</p>
<p>一般的，你想要你的注释告诉别人你的代码做了什么，而不是怎么做的。也请你不要把注释放在一个函数体内部：如果函数复杂到你需要独立的注释其中的一部分，你很可能需要回到第六章看一看。你可以做一些小注释来注明或警告某些很聪明 (或者槽糕) 的做法，但不要加太多。你应该做的，是把注释放在函数的头部，告诉人们它做了什么， 也可以加上它做这些事情的原因。</p>
<p>当注释内核 API 函数时，请使用 kernel-doc 格式。请看 Documentation/doc-guide/ 和 scripts/kernel-doc 以获得详细信息。</p>
<p>长 (多行) 注释的首选风格是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This is the preferred style for multi-line</span><br><span class="line"> * comments in the Linux kernel source code.</span><br><span class="line"> * Please use it consistently.</span><br><span class="line"> *</span><br><span class="line"> * Description:  A column of asterisks on the left side,</span><br><span class="line"> * with beginning and ending almost-blank lines.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>对于在 net/ 和 drivers/net/ 的文件，首选的长 (多行) 注释风格有些不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* The preferred comment style for files in net/ and drivers/net</span><br><span class="line"> * looks like this.</span><br><span class="line"> *</span><br><span class="line"> * It is nearly the same as the generally preferred comment style,</span><br><span class="line"> * but there is no initial almost-blank line.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>注释数据也是很重要的，不管是基本类型还是衍生类型。为了方便实现这一点，每一行 应只声明一个数据 (不要使用逗号来一次声明多个数据)。这样你就有空间来为每个数据 写一段小注释来解释它们的用途了。</p>
<h2 id="9-你已经把事情弄糟了"><a href="#9-你已经把事情弄糟了" class="headerlink" title="9) 你已经把事情弄糟了"></a>9) 你已经把事情弄糟了</h2><p>这没什么，我们都是这样。可能你的使用了很长时间 Unix 的朋友已经告诉你 <code>GNU emacs</code> 能自动帮你格式化 C 源代码，而且你也注意到了，确实是这样，不过它 所使用的默认值和我们想要的相去甚远 (实际上，甚至比随机打的还要差——无数个猴子 在 GNU emacs 里打字永远不会创造出一个好程序) (译注：Infinite Monkey Theorem)</p>
<p>所以你要么放弃 GNU emacs，要么改变它让它使用更合理的设定。要采用后一个方案， 你可以把下面这段粘贴到你的 .emacs 文件里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(defun c-lineup-arglist-tabs-only (ignored)</span><br><span class="line">  &quot;Line up argument lists by tabs, not spaces&quot;</span><br><span class="line">  (let* ((anchor (c-langelem-pos c-syntactic-element))</span><br><span class="line">         (column (c-langelem-2nd-pos c-syntactic-element))</span><br><span class="line">         (offset (- (1+ column) anchor))</span><br><span class="line">         (steps (floor offset c-basic-offset)))</span><br><span class="line">    (* (max steps 1)</span><br><span class="line">       c-basic-offset)))</span><br><span class="line"></span><br><span class="line">(add-hook &#x27;c-mode-common-hook</span><br><span class="line">          (lambda ()</span><br><span class="line">            ;; Add kernel style</span><br><span class="line">            (c-add-style</span><br><span class="line">             &quot;linux-tabs-only&quot;</span><br><span class="line">             &#x27;(&quot;linux&quot; (c-offsets-alist</span><br><span class="line">                        (arglist-cont-nonempty</span><br><span class="line">                         c-lineup-gcc-asm-reg</span><br><span class="line">                         c-lineup-arglist-tabs-only))))))</span><br><span class="line"></span><br><span class="line">(add-hook &#x27;c-mode-hook</span><br><span class="line">          (lambda ()</span><br><span class="line">            (let ((filename (buffer-file-name)))</span><br><span class="line">              ;; Enable kernel mode for the appropriate files</span><br><span class="line">              (when (and filename</span><br><span class="line">                         (string-match (expand-file-name &quot;~/src/linux-trees&quot;)</span><br><span class="line">                                       filename))</span><br><span class="line">                (setq indent-tabs-mode t)</span><br><span class="line">                (setq show-trailing-whitespace t)</span><br><span class="line">                (c-set-style &quot;linux-tabs-only&quot;)))))</span><br></pre></td></tr></table></figure>

<p>这会让 emacs 在 <code>~/src/linux-trees</code> 下的 C 源文件获得更好的内核代码风格。</p>
<p>不过就算你尝试让 emacs 正确的格式化代码失败了，也并不意味着你失去了一切：还可以用 <code>indent</code> 。</p>
<p>不过，GNU indent 也有和 GNU emacs 一样有问题的设定，所以你需要给它一些命令选项。不过，这还不算太糟糕，因为就算是 GNU indent 的作者也认同 K&amp;R 的权威性 (GNU 的人并不是坏人，他们只是在这个问题上被严重的误导了)，所以你只要给 indent 指定选项 <code>-kr -i8</code> (代表 <code>K&amp;R，8 字符缩进</code>)，或使用 <code>scripts/Lindent</code> 这样就可以以最时髦的方式缩进源代码。</p>
<p><code>indent</code> 有很多选项，特别是重新格式化注释的时候，你可能需要看一下它的手册。 不过记住： <code>indent</code> 不能修正坏的编程习惯。</p>
<h2 id="10-Kconfig-配置文件"><a href="#10-Kconfig-配置文件" class="headerlink" title="10) Kconfig 配置文件"></a>10) Kconfig 配置文件</h2><p>对于遍布源码树的所有 Kconfig* 配置文件来说，它们缩进方式有所不同。紧挨着 <code>config</code> 定义的行，用一个制表符缩进，然而 help 信息的缩进则额外增加 2 个空格。举个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config AUDIT</span><br><span class="line">      bool &quot;Auditing support&quot;</span><br><span class="line">      depends on NET</span><br><span class="line">      help</span><br><span class="line">        Enable auditing infrastructure that can be used with another</span><br><span class="line">        kernel subsystem, such as SELinux (which requires this for</span><br><span class="line">        logging of avc messages output).  Does not do system-call</span><br><span class="line">        auditing without CONFIG_AUDITSYSCALL.</span><br></pre></td></tr></table></figure>

<p>而那些危险的功能 (比如某些文件系统的写支持) 应该在它们的提示字符串里显著的声 明这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config ADFS_FS_RW</span><br><span class="line">      bool &quot;ADFS write support (DANGEROUS)&quot;</span><br><span class="line">      depends on ADFS_FS</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>要查看配置文件的完整文档，请看 Documentation/kbuild/kconfig-language.txt。</p>
<h2 id="11-数据结构"><a href="#11-数据结构" class="headerlink" title="11) 数据结构"></a>11) 数据结构</h2><p>如果一个数据结构，在创建和销毁它的单线执行环境之外可见，那么它必须要有一个引用计数器。内核里没有垃圾收集 (并且内核之外的垃圾收集慢且效率低下)，这意味着你绝对需要记录你对这种数据结构的使用情况。</p>
<p>引用计数意味着你能够避免上锁，并且允许多个用户并行访问这个数据结构——而不需要担心这个数据结构仅仅因为暂时不被使用就消失了，那些用户可能不过是沉睡了一阵或者做了一些其他事情而已。</p>
<p>注意上锁 <strong>不能</strong> 取代引用计数。上锁是为了保持数据结构的一致性，而引用计数是一个内存管理技巧。通常二者都需要，不要把两个搞混了。</p>
<p>很多数据结构实际上有 2 级引用计数，它们通常有不同 <code>类</code> 的用户。子类计数器统计子类用户的数量，每当子类计数器减至零时，全局计数器减一。</p>
<p>这种 <code>多级引用计数</code> 的例子可以在内存管理 (<code>struct mm_struct</code>: mm_users 和 mm_count)，和文件系统 (<code>struct super_block</code>: s_count 和 s_active) 中找到。</p>
<p>记住：如果另一个执行线索可以找到你的数据结构，但这个数据结构没有引用计数器， 这里几乎肯定是一个 bug。</p>
<h2 id="12-宏，枚举和RTL"><a href="#12-宏，枚举和RTL" class="headerlink" title="12) 宏，枚举和RTL"></a>12) 宏，枚举和RTL</h2><p>用于定义常量的宏的名字及枚举里的标签需要大写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define CONSTANT 0x12345</span><br></pre></td></tr></table></figure>

<p>在定义几个相关的常量时，最好用枚举。</p>
<p>宏的名字请用大写字母，不过形如函数的宏的名字可以用小写字母。</p>
<p>一般的，如果能写成内联函数就不要写成像函数的宏。</p>
<p>含有多个语句的宏应该被包含在一个 do-while 代码块里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define macrofun(a, b, c)                       \</span><br><span class="line">        do &#123;                                    \</span><br><span class="line">                if (a == 5)                     \</span><br><span class="line">                        do_this(b, c);          \</span><br><span class="line">        &#125; while (0)</span><br></pre></td></tr></table></figure>

<p>使用宏的时候应避免的事情：</p>
<ol>
<li>影响控制流程的宏：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define FOO(x)                                  \</span><br><span class="line">        do &#123;                                    \</span><br><span class="line">                if (blah(x) &lt; 0)                \</span><br><span class="line">                        return -EBUGGERED;      \</span><br><span class="line">        &#125; while (0)</span><br></pre></td></tr></table></figure>

<p><strong>非常</strong> 不好。它看起来像一个函数，不过却能导致 <code>调用</code> 它的函数退出；不要打 乱读者大脑里的语法分析器。</p>
<ol>
<li>依赖于一个固定名字的本地变量的宏：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define FOO(val) bar(index, val)</span><br></pre></td></tr></table></figure>

<p>可能看起来像是个不错的东西，不过它非常容易把读代码的人搞糊涂，而且容易导致看起来不相关的改动带来错误。</p>
<ol>
<li>作为左值的带参数的宏： FOO(x) = y；如果有人把 FOO 变成一个内联函数的话，这 种用法就会出错了。</li>
<li>忘记了优先级：使用表达式定义常量的宏必须将表达式置于一对小括号之内。带参数 的宏也要注意此类问题。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define CONSTANT 0x4000</span><br><span class="line">#define CONSTEXP (CONSTANT | 3)</span><br></pre></td></tr></table></figure>

<ol>
<li>在宏里定义类似函数的本地变量时命名冲突：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define FOO(x)                          \</span><br><span class="line">(&#123;                                      \</span><br><span class="line">        typeof(x) ret;                  \</span><br><span class="line">        ret = calc_ret(x);              \</span><br><span class="line">        (ret);                          \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><u>ret 是本地变量的通用名字 - __foo_ret 更不容易与一个已存在的变量冲突。</u></p>
<p>cpp 手册对宏的讲解很详细。gcc internals 手册也详细讲解了 RTL，内核里的汇编语言经常用到它。</p>
<h2 id="13-打印内核消息"><a href="#13-打印内核消息" class="headerlink" title="13) 打印内核消息"></a>13) 打印内核消息</h2><p>内核开发者应该是受过良好教育的。请一定注意内核信息的拼写，以给人以好的印象。 不要用不规范的单词比如 <code>dont</code>，而要用 <code>do not</code> 或者 <code>don&#39;t</code> 。保证这些信息简单明了，无歧义。</p>
<p>内核信息不必以英文句号结束。</p>
<p>在小括号里打印数字 (%d) 没有任何价值，应该避免这样做。</p>
<p>&lt;linux/device.h&gt; 里有一些驱动模型诊断宏，你应该使用它们，以确保信息对应于正确的设备和驱动，并且被标记了正确的消息级别。这些宏有：dev_err(), dev_warn(), dev_info() 等等。对于那些不和某个特定设备相关连的信息，&lt;linux/printk.h&gt; 定义了 pr_notice(), pr_info(), pr_warn(), pr_err() 和其他。</p>
<p>写出好的调试信息可以是一个很大的挑战；一旦你写出后，这些信息在远程出错时能提供极大的帮助。然而打印调试信息的处理方式同打印非调试信息不同。其他 pr_XXX() 函数能无条件地打印，pr_debug() 却不；默认情况下它不会被编译，除非定义了 DEBUG 或设定了 CONFIG_DYNAMIC_DEBUG。实际这同样是为了 dev_dbg()，一个相关约定是在一个已经开启了 DEBUG 时，使用 VERBOSE_DEBUG 来添加 dev_vdbg()。</p>
<p>许多子系统拥有 Kconfig 调试选项来开启 -DDEBUG 在对应的 Makefile 里面；在其他情况下，特殊文件使用 #define DEBUG。当一条调试信息需要被无条件打印时，例如，如果已经包含一个调试相关的 #ifdef 条件，printk(KERN_DEBUG …) 就可被使用。</p>
<h2 id="14-分配内存"><a href="#14-分配内存" class="headerlink" title="14) 分配内存"></a>14) 分配内存</h2><p>内核提供了下面的一般用途的内存分配函数： kmalloc(), kzalloc(), kmalloc_array(), kcalloc(), vmalloc() 和 vzalloc()。 请参考 API 文档以获取有关它们的详细信息。</p>
<p>传递结构体大小的首选形式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = kmalloc(sizeof(*p), ...);</span><br></pre></td></tr></table></figure>

<p>另外一种传递方式中，sizeof 的操作数是结构体的名字，这样会降低可读性，并且可能会引入 bug。有可能指针变量类型被改变时，而对应的传递给内存分配函数的 sizeof 的结果不变。</p>
<p>强制转换一个 void 指针返回值是多余的。C 语言本身保证了从 void 指针到其他任何指针类型的转换是没有问题的。</p>
<p>分配一个数组的首选形式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = kmalloc_array(n, sizeof(...), ...);</span><br></pre></td></tr></table></figure>

<p>分配一个零长数组的首选形式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = kcalloc(n, sizeof(...), ...);</span><br></pre></td></tr></table></figure>

<p>两种形式检查分配大小 n * sizeof(…) 的溢出，如果溢出返回 NULL。</p>
<h2 id="15-内联弊病"><a href="#15-内联弊病" class="headerlink" title="15) 内联弊病"></a>15) 内联弊病</h2><p>有一个常见的误解是 <code>内联</code> 是 gcc 提供的可以让代码运行更快的一个选项。虽然使 用内联函数有时候是恰当的 (比如作为一种替代宏的方式，请看第十二章)，不过很多情况下不是这样。inline 的过度使用会使内核变大，从而使整个系统运行速度变慢。 <u>因为体积大内核会占用更多的指令高速缓存</u>，而且会导致 pagecache 的可用内存减少。 想象一下，一次 pagecache 未命中就会导致一次磁盘寻址，将耗时 5 毫秒。5 毫秒的 时间内 CPU 能执行很多很多指令。</p>
<p><u>一个基本的原则是如果一个函数有 3 行以上，就不要把它变成内联函数</u>。这个原则的一个例外是，如果你知道某个参数是一个编译时常量，而且因为这个常量你确定编译器在编译时能优化掉你的函数的大部分代码，那仍然可以给它加上 inline 关键字。 kmalloc() 内联函数就是一个很好的例子。</p>
<p>人们经常主张给 static 的而且只用了一次的函数加上 inline，如此不会有任何损失， 因为没有什么好权衡的。虽然从技术上说这是正确的，但是实际上这种情况下即使不加 inline gcc 也可以自动使其内联。而且其他用户可能会要求移除 inline，由此而来的争论会抵消 inline 自身的潜在价值，得不偿失。</p>
<h2 id="16-函数返回值及命名"><a href="#16-函数返回值及命名" class="headerlink" title="16) 函数返回值及命名"></a>16) 函数返回值及命名</h2><p>函数可以返回多种不同类型的值，最常见的一种是表明函数执行成功或者失败的值。这样 的一个值可以表示为一个错误代码整数 (-Exxx＝失败，0＝成功) 或者一个 <code>成功</code> 布尔值 (0＝失败，非0＝成功)。</p>
<p>混合使用这两种表达方式是难于发现的 bug 的来源。如果 C 语言本身严格区分整形和布尔型变量，那么编译器就能够帮我们发现这些错误… 不过 C 语言不区分。为了避免 产生这种 bug，请遵循下面的惯例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果函数的名字是一个动作或者强制性的命令，那么这个函数应该返回错误代</span><br><span class="line">码整数。如果是一个判断，那么函数应该返回一个 &quot;成功&quot; 布尔值。</span><br></pre></td></tr></table></figure>

<p>比如， <code>add work</code> 是一个命令，所以 add_work() 在成功时返回 0，在失败时返回 -EBUSY。类似的，因为 <code>PCI device present</code> 是一个判断，所以 pci_dev_present() 在成功找到一个匹配的设备时应该返回 1，如果找不到时应该返回 0。</p>
<p>所有 EXPORTed 函数都必须遵守这个惯例，所有的公共函数也都应该如此。私有 (static) 函数不需要如此，但是我们也推荐这样做。</p>
<p>返回值是实际计算结果而不是计算是否成功的标志的函数不受此惯例的限制。一般的， 他们通过返回一些正常值范围之外的结果来表示出错。典型的例子是返回指针的函数， 他们使用 NULL 或者 ERR_PTR 机制来报告错误。</p>
<h2 id="17-不要重新发明内核宏"><a href="#17-不要重新发明内核宏" class="headerlink" title="17) 不要重新发明内核宏"></a>17) 不要重新发明内核宏</h2><p>头文件 include/linux/kernel.h 包含了一些宏，你应该使用它们，而不要自己写一些它们的变种。比如，如果你需要计算一个数组的长度，使用这个宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))</span><br></pre></td></tr></table></figure>

<p>类似的，如果你要计算某结构体成员的大小，使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)-&gt;f))</span><br></pre></td></tr></table></figure>

<p>还有可以做严格的类型检查的 min() 和 max() 宏，如果你需要可以使用它们。你可以自己看看那个头文件里还定义了什么你可以拿来用的东西，如果有定义的话，你就不应在你的代码里自己重新定义。</p>
<h2 id="18-编辑器模式行和其他需要罗嗦的事情"><a href="#18-编辑器模式行和其他需要罗嗦的事情" class="headerlink" title="18) 编辑器模式行和其他需要罗嗦的事情"></a>18) 编辑器模式行和其他需要罗嗦的事情</h2><p>有一些编辑器可以解释嵌入在源文件里的由一些特殊标记标明的配置信息。比如，emacs 能够解释被标记成这样的行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-*- mode: c -*-</span><br></pre></td></tr></table></figure>

<p>或者这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Local Variables:</span><br><span class="line">compile-command: &quot;gcc -DMAGIC_DEBUG_FLAG foo.c&quot;</span><br><span class="line">End:</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>Vim 能够解释这样的标记：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* vim:set sw=8 noet */</span><br></pre></td></tr></table></figure>

<p>不要在源代码中包含任何这样的内容。每个人都有他自己的编辑器配置，你的源文件不应该覆盖别人的配置。这包括有关缩进和模式配置的标记。人们可以使用他们自己定制的模式，或者使用其他可以产生正确的缩进的巧妙方法。</p>
<h2 id="19-内联汇编"><a href="#19-内联汇编" class="headerlink" title="19) 内联汇编"></a>19) 内联汇编</h2><p>在特定架构的代码中，你可能需要内联汇编与 CPU 和平台相关功能连接。需要这么做时就不要犹豫。然而，当 C 可以完成工作时，不要平白无故地使用内联汇编。在可能的情况下，你可以并且应该用 C 和硬件沟通。</p>
<p>请考虑去写捆绑通用位元 (wrap common bits) 的内联汇编的简单辅助函数，别去重复地写下只有细微差异内联汇编。记住内联汇编可以使用 C 参数。</p>
<p>大型，有一定复杂度的汇编函数应该放在 .S 文件内，用相应的 C 原型定义在 C 头文 件中。汇编函数的 C 原型应该使用 <code>asmlinkage</code> 。</p>
<p>你可能需要把汇编语句标记为 volatile，用来阻止 GCC 在没发现任何副作用后就把它 移除了。你不必总是这样做，尽管，这不必要的举动会限制优化。</p>
<p>在写一个包含多条指令的单个内联汇编语句时，把每条指令用引号分割而且各占一行， 除了最后一条指令外，在每个指令结尾加上 nt，让汇编输出时可以正确地缩进下一条 指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asm (&quot;magic %reg1, #42\n\t&quot;</span><br><span class="line">     &quot;more_magic %reg2, %reg3&quot;</span><br><span class="line">     : /* outputs */ : /* inputs */ : /* clobbers */);</span><br></pre></td></tr></table></figure>

<h2 id="20-条件编译"><a href="#20-条件编译" class="headerlink" title="20) 条件编译"></a>20) 条件编译</h2><p>只要可能，就不要在 .c 文件里面使用预处理条件 (#if, #ifdef)；这样做让代码更难阅读并且更难去跟踪逻辑。替代方案是，<u>在头文件中用预处理条件提供给那些 .c 文件使用，再给 #else 提供一个空桩 (no-op stub) 版本</u>，然后在 .c 文件内无条件地调用 那些 (定义在头文件内的) 函数。这样做，编译器会避免为桩函数 (stub) 的调用生成任何代码，产生的结果是相同的，但逻辑将更加清晰。</p>
<p>最好倾向于编译整个函数，而不是函数的一部分或表达式的一部分。与其放一个 ifdef 在表达式内，不如分解出部分或全部表达式，放进一个单独的辅助函数，并应用预处理 条件到这个辅助函数内。</p>
<p>如果你有一个在特定配置中，可能变成未使用的函数或变量，编译器会警告它定义了但未使用，把它标记为 __maybe_unused 而不是将它包含在一个预处理条件中。(然而，如果一个函数或变量总是未使用，就直接删除它。)</p>
<p>在代码中，尽可能地使用 IS_ENABLED 宏来转化某个 Kconfig 标记为 C 的布尔 表达式，并在一般的 C 条件中使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (IS_ENABLED(CONFIG_SOMETHING)) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会做常量折叠，然后就像使用 #ifdef 那样去包含或排除代码块，所以这不会带来任何运行时开销。然而，这种方法依旧允许 C 编译器查看块内的代码，并检查它的正确性 (语法，类型，符号引用，等等)。因此，如果条件不满足，代码块内的引用符号就不存在时，你还是必须去用 #ifdef。</p>
<p>在任何有意义的 #if 或 #ifdef 块的末尾 (超过几行的)，在 #endif 同一行的后面写下注解，注释这个条件表达式。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_SOMETHING</span><br><span class="line">...</span><br><span class="line">#endif /* CONFIG_SOMETHING */</span><br></pre></td></tr></table></figure>

<h2 id="附录-I-参考"><a href="#附录-I-参考" class="headerlink" title="附录 I) 参考"></a>附录 I) 参考</h2><p>The C Programming Language, 第二版 作者：Brian W. Kernighan 和 Denni M. Ritchie. Prentice Hall, Inc., 1988. ISBN 0-13-110362-8 (软皮), 0-13-110370-9 (硬皮).</p>
<p>The Practice of Programming 作者：Brian W. Kernighan 和 Rob Pike. Addison-Wesley, Inc., 1999. ISBN 0-201-61586-X.</p>
<p>GNU 手册 - 遵循 K&amp;R 标准和此文本 - cpp, gcc, gcc internals and indent, 都可以从 <a target="_blank" rel="noopener" href="http://www.gnu.org/manual/">http://www.gnu.org/manual/</a> 找到</p>
<p>WG14 是 C 语言的国际标准化工作组，URL: <a target="_blank" rel="noopener" href="http://www.open-std.org/JTC1/SC22/WG14/">http://www.open-std.org/JTC1/SC22/WG14/</a></p>
<p>Kernel process/coding-style.rst，作者 <a href="mailto:greg@kroah.com">greg@kroah.com</a> 发表于 OLS 2002： <a target="_blank" rel="noopener" href="http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/">http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/05/15/230515-gitSubTree/" rel="prev" title="如何从Git仓库中将模块分离成独立仓库并保留其提交历史？">
      <i class="fa fa-chevron-left"></i> 如何从Git仓库中将模块分离成独立仓库并保留其提交历史？
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/08/22/230822-sourceProtect/" rel="next" title="C语言源码保护技术">
      C语言源码保护技术 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="nav-number">1.</span> <span class="nav-text">Linux 内核代码风格</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%BC%A9%E8%BF%9B"><span class="nav-number">1.1.</span> <span class="nav-text">1) 缩进</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%8A%8A%E9%95%BF%E7%9A%84%E8%A1%8C%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%93%E6%95%A3"><span class="nav-number">1.2.</span> <span class="nav-text">2) 把长的行和字符串打散</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%A4%A7%E6%8B%AC%E5%8F%B7%E5%92%8C%E7%A9%BA%E6%A0%BC%E7%9A%84%E6%94%BE%E7%BD%AE"><span class="nav-number">1.3.</span> <span class="nav-text">3) 大括号和空格的放置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E7%A9%BA%E6%A0%BC"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1) 空格</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%91%BD%E5%90%8D"><span class="nav-number">1.4.</span> <span class="nav-text">4) 命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Typedef"><span class="nav-number">1.5.</span> <span class="nav-text">5) Typedef</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.</span> <span class="nav-text">6) 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E9%9B%86%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E9%80%80%E5%87%BA%E9%80%94%E5%BE%84"><span class="nav-number">1.7.</span> <span class="nav-text">7) 集中的函数退出途径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%B3%A8%E9%87%8A"><span class="nav-number">1.8.</span> <span class="nav-text">8) 注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%8A%8A%E4%BA%8B%E6%83%85%E5%BC%84%E7%B3%9F%E4%BA%86"><span class="nav-number">1.9.</span> <span class="nav-text">9) 你已经把事情弄糟了</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-Kconfig-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">1.10.</span> <span class="nav-text">10) Kconfig 配置文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.11.</span> <span class="nav-text">11) 数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%AE%8F%EF%BC%8C%E6%9E%9A%E4%B8%BE%E5%92%8CRTL"><span class="nav-number">1.12.</span> <span class="nav-text">12) 宏，枚举和RTL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E6%89%93%E5%8D%B0%E5%86%85%E6%A0%B8%E6%B6%88%E6%81%AF"><span class="nav-number">1.13.</span> <span class="nav-text">13) 打印内核消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">1.14.</span> <span class="nav-text">14) 分配内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E5%86%85%E8%81%94%E5%BC%8A%E7%97%85"><span class="nav-number">1.15.</span> <span class="nav-text">15) 内联弊病</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%8F%8A%E5%91%BD%E5%90%8D"><span class="nav-number">1.16.</span> <span class="nav-text">16) 函数返回值及命名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%E4%B8%8D%E8%A6%81%E9%87%8D%E6%96%B0%E5%8F%91%E6%98%8E%E5%86%85%E6%A0%B8%E5%AE%8F"><span class="nav-number">1.17.</span> <span class="nav-text">17) 不要重新发明内核宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E7%BC%96%E8%BE%91%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%A1%8C%E5%92%8C%E5%85%B6%E4%BB%96%E9%9C%80%E8%A6%81%E7%BD%97%E5%97%A6%E7%9A%84%E4%BA%8B%E6%83%85"><span class="nav-number">1.18.</span> <span class="nav-text">18) 编辑器模式行和其他需要罗嗦的事情</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><span class="nav-number">1.19.</span> <span class="nav-text">19) 内联汇编</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="nav-number">1.20.</span> <span class="nav-text">20) 条件编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95-I-%E5%8F%82%E8%80%83"><span class="nav-number">1.21.</span> <span class="nav-text">附录 I) 参考</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao</p>
  <div class="site-description" itemprop="description">保持热爱，奔赴山海。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
