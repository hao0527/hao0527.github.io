<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/heng32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/heng16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="保持热爱，奔赴山海。">
<meta property="og:type" content="website">
<meta property="og:title" content="永恆博客网">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="永恆博客网">
<meta property="og:description" content="保持热爱，奔赴山海。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>永恆博客网</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">永恆博客网</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/31/2207031-WindowsC%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/31/2207031-WindowsC%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Windows C/C++编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-31 18:00:00" itemprop="dateCreated datePublished" datetime="2022-07-31T18:00:00+08:00">2022-07-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-01 23:47:49" itemprop="dateModified" datetime="2022-08-01T23:47:49+08:00">2022-08-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Windows串口接收代码"><a href="#Windows串口接收代码" class="headerlink" title="Windows串口接收代码"></a>Windows串口接收代码</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39100510/article/details/124292893">windows串口通信函数API</a></li>
<li><a target="_blank" rel="noopener" href="http://www.yfvb.com/help/win32sdk/webhelplefth.htm">Win32API参考手册</a></li>
<li><a target="_blank" rel="noopener" href="http://t.zoukankan.com/zhuguanhao-p-2887210.html">使用CreateFile()打开COM10及以上串口的问题</a></li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">serial_openSerial</span><span class="params">(<span class="type">void</span>* lpFileName, <span class="type">unsigned</span> <span class="type">int</span> baudRate, <span class="type">unsigned</span> <span class="type">int</span> dwInQueue, <span class="type">unsigned</span> <span class="type">int</span> dwOutQueue)</span> &#123;</span><br><span class="line">	HANDLE hComm = <span class="literal">NULL</span>;</span><br><span class="line">	DCB dcb;</span><br><span class="line">	hComm = CreateFile(lpFileName,       <span class="comment">//串口名称</span></span><br><span class="line">						GENERIC_READ | GENERIC_WRITE, <span class="comment">//允许读和写</span></span><br><span class="line">						<span class="number">0</span>,             <span class="comment">//独占方式</span></span><br><span class="line">						<span class="literal">NULL</span>,          <span class="comment">// 无安全属性，不可被子程序继承</span></span><br><span class="line">						OPEN_EXISTING, <span class="comment">//创建文件的性质，打开而不是创建</span></span><br><span class="line">						<span class="number">0</span>,             <span class="comment">// Non Overlapped I/O</span></span><br><span class="line">						<span class="literal">NULL</span>);         <span class="comment">// Null for Comm Devices</span></span><br><span class="line">	SetupComm(hComm, dwInQueue, dwOutQueue);</span><br><span class="line">	GetCommState(hComm, &amp;dcb);</span><br><span class="line">	dcb.BaudRate = baudRate;</span><br><span class="line">	SetCommState(hComm, &amp;dcb);</span><br><span class="line">	<span class="keyword">return</span> hComm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">serial_readLen</span><span class="params">(<span class="type">void</span>* hComm, <span class="type">unsigned</span> <span class="type">char</span>* pBuff, <span class="type">unsigned</span> <span class="type">int</span> len, <span class="type">unsigned</span> <span class="type">int</span>* pLenRead)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ReadFile(hComm, pBuff, len, pLenRead, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">serial_closeSerial</span><span class="params">(<span class="type">void</span>* hComm)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> CloseHandle(hComm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>Windows.h的api是<strong>正确返回非0</strong></p>
<h2 id="不同系统编译各数据类型所占内存空间大小"><a href="#不同系统编译各数据类型所占内存空间大小" class="headerlink" title="不同系统编译各数据类型所占内存空间大小"></a>不同系统编译各数据类型所占内存空间大小</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table>
<thead>
<tr>
<th>类型</th>
<th>win32</th>
<th>win64</th>
<th>linux32</th>
<th>linux64</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>8</td>
</tr>
<tr>
<td>long long</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>void*</td>
<td>4</td>
<td>8</td>
<td>4</td>
<td>8</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>指针所占空间看系统是16位、32位还是64位。</li>
<li>win64把long编成4字节，linux64把long编成8字节。</li>
<li>在32位系统中，int和long都是4字节，取值范围相同。</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/31/2207031-CubeMX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/31/2207031-CubeMX/" class="post-title-link" itemprop="url">STM32CubeMX使用上遇到的一些问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-31 14:00:00 / 修改时间：14:53:38" itemprop="dateCreated datePublished" datetime="2022-07-31T14:00:00+08:00">2022-07-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使用DMA发送串口数据问题"><a href="#使用DMA发送串口数据问题" class="headerlink" title="使用DMA发送串口数据问题"></a>使用DMA发送串口数据问题</h2><ol>
<li>CubeMX生成的代码初始化DMA和UART顺序问题，应该先初始化DMA再UART，可以在CubeMX中调整生成初始化代码的顺序。<img src="/2022/07/31/2207031-CubeMX/2207031-CubeMX-1.jpg" alt="2207031-CubeMX-1.jpg"></li>
<li>CubeMX生成的代码使用<code>HAL_UART_Transmit_DMA()</code>后需要手动将串口状态配置成空闲状态，可以在DMA传输完成中断中加<code>(&amp;huart1)-&gt;gState = HAL_UART_STATE_READY;</code></li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/24/2207024-python%E8%B4%A6%E6%9C%AC%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/24/2207024-python%E8%B4%A6%E6%9C%AC%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">用Python统计花费</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-07-24 22:00:00 / 修改时间：23:10:48" itemprop="dateCreated datePublished" datetime="2022-07-24T22:00:00+08:00">2022-07-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>不喜欢用现成的账本app记账，喜欢在手机记事本里记账，没次统计花费总额都需要按计算器，比较麻烦也不确定会不会按错，所以用Python写个脚本算算总共花费多少，额外也可以统计些自己想知道的数据。</p>
<h2 id="账本格式"><a href="#账本格式" class="headerlink" title="账本格式"></a>账本格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7.8 两餐-29 电费-57 开箱-30 充气宝-160</span><br><span class="line">7.9 一餐-10 充话费-54</span><br><span class="line">7.10 两餐-33 鼠标脚垫-11 早餐包-24</span><br><span class="line">7.11 两餐-22 出行-7 理发-13</span><br></pre></td></tr></table></figure>

<h2 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">costStruct = [  &#123;&#x27;date&#x27;: &#x27;7.1&#x27;, &#x27;item&#x27;: [&#x27;两餐&#x27;], &#x27;consume&#x27;: [33]&#125;,</span></span><br><span class="line"><span class="string">                &#123;&#x27;date&#x27;: &#x27;7.2&#x27;, &#x27;item&#x27;: [&#x27;两餐&#x27;, &#x27;遮阳布&#x27;, &#x27;出行&#x27;], &#x27;consume&#x27;: [25, 6, 13]&#125;,</span></span><br><span class="line"><span class="string">                ...</span></span><br><span class="line"><span class="string">             ]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">costStruct = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file=<span class="string">&#x27;cost.txt&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    costStrList = fp.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除空白行</span></span><br><span class="line">delNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(costStrList)):</span><br><span class="line">    j = i - delNum</span><br><span class="line">    costStrList[j] = costStrList[j].strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(costStrList[j].replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)) == <span class="number">0</span>:</span><br><span class="line">        delNum = delNum + <span class="number">1</span></span><br><span class="line">        <span class="keyword">del</span>(costStrList[j])</span><br><span class="line"><span class="comment"># print(costStrList)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(costStrList)):</span><br><span class="line">    costDic = &#123;<span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;item&#x27;</span>: [], <span class="string">&#x27;consume&#x27;</span>: []&#125;</span><br><span class="line">    strList = costStrList[i].split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    costDic[<span class="string">&#x27;date&#x27;</span>] = strList[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(strList)):</span><br><span class="line">        cost = strList[j].split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        costDic[<span class="string">&#x27;item&#x27;</span>].append(cost[<span class="number">0</span>])</span><br><span class="line">        costDic[<span class="string">&#x27;consume&#x27;</span>].append(<span class="built_in">int</span>(cost[<span class="number">1</span>]))</span><br><span class="line">    costStruct.append(costDic)</span><br><span class="line"><span class="comment"># print(costStruct)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算总共花费</span></span><br><span class="line">dayCost = []</span><br><span class="line">dateStr = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(costStruct)):</span><br><span class="line">    dayCost.append(<span class="built_in">sum</span>(costStruct[i][<span class="string">&#x27;consume&#x27;</span>]))</span><br><span class="line">    dateStr.append(costStruct[i][<span class="string">&#x27;date&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(costStruct[i][<span class="string">&#x27;date&#x27;</span>] + <span class="string">&#x27; cost ￥&#x27;</span> + <span class="built_in">str</span>(dayCost[i]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;total cost ￥&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">sum</span>(dayCost)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">3</span>+<span class="number">0.25</span>*<span class="built_in">len</span>(dayCost), <span class="number">8</span>), dpi=<span class="number">100</span>)    <span class="comment"># 自适应长度</span></span><br><span class="line">plt.bar(dateStr, dayCost)</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;total cost &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">sum</span>(dayCost)) + <span class="string">&#x27; yuan&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;consume&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>代码存放在<a target="_blank" rel="noopener" href="https://github.com/hao0527/costSummary">https://github.com/hao0527/costSummary</a>，以后有新的统计分析需求，会直接在我的Github更新。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/10/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/10/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/" class="post-title-link" itemprop="url">RC振荡器 晶体振荡器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-10 15:00:00" itemprop="dateCreated datePublished" datetime="2022-07-10T15:00:00+08:00">2022-07-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-24 11:13:56" itemprop="dateModified" datetime="2022-07-24T11:13:56+08:00">2022-07-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A1%AC%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">硬件</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="RC振荡器"><a href="#RC振荡器" class="headerlink" title="RC振荡器"></a>RC振荡器</h2><p>在振荡电路中的频率选择部分可以只用电阻和电容构成，这种只用电阻和电容构成的振荡器称为RC振荡器。RC振荡器需要起振电路，常用的正弦波荡电路有文氏桥振荡电路，要起振所以电路是正反馈，RC构成选频网络，两个二极管和R3构成稳幅电路。</p>
<p><img src="/2022/07/10/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8-1.jpg" alt="2207010-RC与晶体振荡器-1.jpg"></p>
<p>RC振荡器容易封装到芯片中，MCU内部的时钟一般就是RC振荡器。成本低、功耗小、电路板上无需外部晶振，这些都是RC振荡器的优点。</p>
<p>缺点：MCU的内部振荡电路对外界干扰很敏感，非常容易受到外界环境温度的影响。同时精度也低，下图是用F767内部和外部振荡器生成1Hz方波的区别。</p>
<p><img src="/2022/07/10/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8-2.jpg" alt="2207010-RC与晶体振荡器-2.jpg"></p>
<h2 id="晶体振荡器"><a href="#晶体振荡器" class="headerlink" title="晶体振荡器"></a>晶体振荡器</h2><p>只要在晶体板级上施加交变电压，就会是晶片产生机械变形振动，此现象即所谓逆压电效应。当外加电压频率等于晶体谐振器的固有频率时，就会发生压电谐振，从而导致机械变形的振幅突然增大。一般而言，晶振的振荡频率比较稳定。但是价格稍微高点，还有用晶体振荡器一般还要接两个15-33pF起振电容。</p>
<p>有源晶振（Oscillator，晶振）只需要供电自身就能起振，无源晶振（Crystal，晶体）最高精度为5ppm，而有源晶振的精度则可以达到0.1ppm。有源晶振的信号电平是固定，所以需要选择好合适输出电平，灵活性较差。无源晶振单片机可以配置振荡输出电压。</p>
<p><img src="/2022/07/10/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8-3.jpg" alt="有源晶振"><img src="/2022/07/10/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8-4.jpg" alt="无源晶振"></p>
<h2 id="STM32CubeMX中的时钟配置"><a href="#STM32CubeMX中的时钟配置" class="headerlink" title="STM32CubeMX中的时钟配置"></a>STM32CubeMX中的时钟配置</h2><p><img src="/2022/07/10/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8-5.jpg" alt="STM32中的时钟配置"></p>
<p>BYPASS Clock Source：使用有源晶振的话，则只需要给它加上电源，即可输出时钟到MCU的时钟输入端，绕过MCU的OSC模块，时钟直接供MCU使用。</p>
<p>Crystal/Ceramic Resonator：使用晶体的话，除了外部需要加上谐振电容（有些会加上MΩ的反馈电阻）之外，还需要<strong>MCU内部的OSC振荡电路辅助</strong>才能正常产生所需时钟。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/08/220708-XilinxFPGA%E7%82%B9%E7%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/08/220708-XilinxFPGA%E7%82%B9%E7%81%AF/" class="post-title-link" itemprop="url">Xilinx FPGA 点灯</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-08 00:01:00" itemprop="dateCreated datePublished" datetime="2022-07-08T00:01:00+08:00">2022-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-09 23:35:14" itemprop="dateModified" datetime="2022-07-09T23:35:14+08:00">2022-07-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="好久不见，甚是想念"><a href="#好久不见，甚是想念" class="headerlink" title="好久不见，甚是想念"></a>好久不见，甚是想念</h2><p>一个多月没写博客了，毕业后学习时间少了，白天忙公司的项目，偶尔晚上有空看看自己想学的资料，自己还在做个地质分析仪的项目，每周日会花一天的时间做。为自己加油，2022年我还要完成这块FPGA的学习，感谢那位支持我学这块开发板的人。</p>
<h2 id="安装Vivado"><a href="#安装Vivado" class="headerlink" title="安装Vivado"></a>安装Vivado</h2><ol>
<li>下载vivado安装包，资料链接B盘：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1eM7Sx-RmeYFE1ht_RPqxhw">https://pan.baidu.com/s/1eM7Sx-RmeYFE1ht_RPqxhw</a> 提取码：a8vu</li>
<li>解压安装包到<strong>无中文路径的目录</strong>下，否则会出现安装包无法打开的情况。打开安装包，我在安装选件的页面取消了K系列、V系列和Soc Zynq的选件，安装空间要70GB左右，因此我还买了个1T的固态。</li>
<li>激活只需要网上下载对应版本的激活licences，在激活页面load a licences即可。</li>
</ol>
<h2 id="软件操作"><a href="#软件操作" class="headerlink" title="软件操作"></a>软件操作</h2><ol>
<li>Tools -&gt; Settings -&gt; Text Editor中选择编辑器，我选择的是notepad++，需要将编辑器路径加到系统环境变量。</li>
<li>创建PLL IP核：<img src="/2022/07/08/220708-XilinxFPGA%E7%82%B9%E7%81%AF/220708-XilinxFPGA%E7%82%B9%E7%81%AF-2.jpg" alt="220708-XilinxFPGA点灯-2.jpg"></li>
<li>功能仿真，RTL分析，综合，约束输入，设计实现都在左侧的Flow Navigator中。</li>
</ol>
<h2 id="流水灯"><a href="#流水灯" class="headerlink" title="流水灯"></a>流水灯</h2><ol>
<li>New Project，芯片选择xc7a35tfgg484-2。<img src="/2022/07/08/220708-XilinxFPGA%E7%82%B9%E7%81%AF/220708-XilinxFPGA%E7%82%B9%E7%81%AF-1.jpg" alt="220708-XilinxFPGA点灯-1.jpg"></li>
<li>Add Sources -&gt; Create File，创建led_top.v文件。</li>
<li>Vivado中打开文件会调用Notepad++编辑器，编写流水灯代码：<img src="/2022/07/08/220708-XilinxFPGA%E7%82%B9%E7%81%AF/220708-XilinxFPGA%E7%82%B9%E7%81%AF-5.jpg" alt="220708-XilinxFPGA点灯-5.jpg"></li>
<li>再功能仿真（可选），再综合、约束输入。</li>
<li>最后生成bit流下载到开发板：<img src="/2022/07/08/220708-XilinxFPGA%E7%82%B9%E7%81%AF/220708-XilinxFPGA%E7%82%B9%E7%81%AF-4.jpg" alt="220708-XilinxFPGA点灯-4.jpg"></li>
<li>Xilinx的集成开发环境要比Altera的好用不少，就是编译速度较慢。</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/22/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/22/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/" class="post-title-link" itemprop="url">交叉编译工具链的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-22 00:00:00 / 修改时间：23:35:24" itemprop="dateCreated datePublished" datetime="2022-05-22T00:00:00+08:00">2022-05-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="交叉编译简介"><a href="#交叉编译简介" class="headerlink" title="交叉编译简介"></a>交叉编译简介</h2><p>交叉编译，是一个和本地编译相对应的概念，交叉编译通俗地讲就是一种平台上编译出的程序能够运行在不同体系结构的平台上，比如在PC平台（X86 CPU）上编译出能运行在ARM CPU的程序。</p>
<h2 id="使用交叉编译的原因"><a href="#使用交叉编译的原因" class="headerlink" title="使用交叉编译的原因"></a>使用交叉编译的原因</h2><p>主要原因是：嵌入式系统中的资源太少。具体的解释就是：所要运行的目标环境中，各种资源，都相对有限，所以很难进行直接的本地编译。嵌入式开发板的CPU、RAM、Falsh等硬件资源相对比较紧张，在已经运行了嵌入式Linux的前提下，没法方便的进行本地编译。因为编译，开发，都需要相对比较多的CPU，内存，硬盘等资源，而嵌入式开发上的资源，只够嵌入式（Linux）系统运行的，没太多剩余的资源，供你本地编译。</p>
<h2 id="交叉编译工具链组成"><a href="#交叉编译工具链组成" class="headerlink" title="交叉编译工具链组成"></a>交叉编译工具链组成</h2><p>常用交叉编译工具有交叉编译器、交叉连接器、交叉解释器还有交叉ELF文件工具、交叉反汇编器等工具。交叉编译工具链主要由binutils、gcc和glibc三个部分组成。有时出于减小 libc 库大小的考虑，也可以用别的 c 库来代替 glibc，例如 uClibc、dietlibc 和 newlib。</p>
<p>编译器能将我们编写的语言转成计算机可以识别的机器语言，解释器能够执行用其他计算机语言编写的程序的系统软件，它是一种翻译程序，转换一行，运行一行，再转换一行，再运行一行。<strong>解释性</strong>语言：Python，JavaScript，<strong>编译性</strong>语言：Java，c，c++。</p>
<h2 id="交叉工具链命名规则"><a href="#交叉工具链命名规则" class="headerlink" title="交叉工具链命名规则"></a>交叉工具链命名规则</h2><p>交叉编译工具链的命名规则为：arch - vendor - os - (gnu)eabi</p>
<p>arch – 体系架构，如ARM，MIPS，表示该编译器用于编译哪个目标平台的程序<br>vendor – 工具链提供商，通常是把vendor写成体系架构的值，比如cortex_a8<br>os – 运行编译产生的程序的目标操作系统，一般用linux表示有操作系统，none表示裸系统，uboot编译无os<br>eabi – 嵌入式应用二进制接口（Embedded Application Binary Interface），abi是计算机上的</p>
<h2 id="编译工具使用（持续更新）"><a href="#编译工具使用（持续更新）" class="headerlink" title="编译工具使用（持续更新）"></a>编译工具使用（持续更新）</h2><p>交叉编译工具使用方法与本地编译工具链基本一样，只是命名不同。</p>
<h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><p>Linux系统下的GCC编译器实际上是GNU编译工具链中的一款软件，可以用它来调用其他不同的工具进行诸如预处理、编译、汇编和链接这样的工作。gcc编译器从拿到一个c源文件到生成一个可执行程序，中间一共经历了四个步骤：</p>
<p><img src="/2022/05/22/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE-1.jpg" alt="220522-交叉编译工具链-1.jpg"></p>
<h3 id="ld"><a href="#ld" class="headerlink" title="ld"></a>ld</h3><p>ld是GNU操作系统上的连接器，把二进制文件连接成可执行文件。<strong>ELF文件</strong>可用于程序的链接，重定位目标文件。用于链接的ELF文件格式：</p>
<p><img src="/2022/05/22/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE-2.jpg" alt="220522-交叉编译工具链-2.jpg"></p>
<p>从编译和链接角度看ELF文件<strong>ELF头</strong>，每个ELF文件都必须存在一个ELF_Header，这里存放了很多重要的信息用来<strong>描述整个文件的组织</strong>，如：版本信息、入口信息、偏移信息等，程序执行也必须依靠其提供的信息。</p>
<p><strong>段头表</strong>，存放的是所有<strong>不同段将在内存中的位置</strong>。代码段.text section，存放已编译程序的机器代码，一般是只读的。只读数据段.rodata section，此段的数据不可修改，存放常量。数据段.data section，存放已初始化的全局变量。.bss section，未初始化全局变量，仅是占位符，不占据任何实际磁盘空间，目标文件格式区分初始化和非初始化是为了空间效率。</p>
<p>符号表.symtab section，它存放在程序中定义和引用的函数和全局变量的信息。.text节的重定位信息.rel.txt section，用于重新修改代码段的指令中的地址信息。.data节的重定位信息.rel.data section，用于对被模块使用或定义的全局变量进行重定位的信息。调试用的符号表.debug section。.strtab section，包含symtab和debug节中符号及节名。.line section，存储调试的行号信息，描述源代码和机器码之间的对应关系。</p>
<p>ELF(Executable and Linkable Format)的完整描述，可以参考这个文档 - <a target="_blank" rel="noopener" href="http://www.uclibc.org/docs/elf-64-gen.pdf">这里</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/12/220512-Git%E5%92%8CSVN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/12/220512-Git%E5%92%8CSVN/" class="post-title-link" itemprop="url">Git和SVN</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-12 21:00:00" itemprop="dateCreated datePublished" datetime="2022-05-12T21:00:00+08:00">2022-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-13 00:12:20" itemprop="dateModified" datetime="2022-05-13T00:12:20+08:00">2022-05-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Git和SVN"><a href="#Git和SVN" class="headerlink" title="Git和SVN"></a>Git和SVN</h3><p>公司里常用的两种版本控制工具：Git和SVN，两者最大的区别就是Git是分布式，SVN是集中式。<strong>集中式</strong>的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 <strong>分布式</strong>的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们在自己本地也会创建一个库，用于保存自己的修改与提交，之后再将自己库提交至服务器库进行更新。</p>
<p><strong>Subversion的特点概括起来主要由以下几条：</strong></p>
<ul>
<li>每个版本库有唯一的URL（官方地址），每个用户都从这个地址获取代码和数据；</li>
<li>获取代码的更新，也只能连接到这个唯一的版本库，同步以取得最新数据；</li>
<li>提交必须有网络连接（非本地版本库）；</li>
<li>提交需要授权，如果没有写权限，提交会失败；</li>
<li>提交并非每次都能够成功。如果有其他人先于你提交，会提示“改动基于过时的版本，先更新再提交”… 诸如此类；</li>
<li>冲突解决是一个提交速度的竞赛：手快者，先提交，平安无事；手慢者，后提交，可能遇到麻烦的冲突解决；</li>
</ul>
<p><strong>Git具有以下特点：</strong></p>
<ul>
<li>Git中每个克隆(clone)的版本库都是平等的。你可以从任何一个版本库的克隆来创建属于你自己的版本库，同时你的版本库也可以作为源提供给他人，只要你愿意；</li>
<li>Git的每一次提取操作，实际上都是一次对代码仓库的完整备份；</li>
<li>提交完全在本地完成，无须别人给你授权，你的版本库你作主，并且提交总是会成功；</li>
<li>甚至基于旧版本的改动也可以成功提交，提交会基于旧的版本创建一个新的分支；</li>
<li>Git的提交不会被打断，直到你的工作完全满意了，PUSH给他人或者他人PULL你的版本库，合并会发生在PULL和PUSH过程中，不能自动解决的冲突会提示您手工完成；</li>
<li>冲突解决不再像是SVN一样的提交竞赛，而是在需要的时候才进行合并和冲突解决；</li>
<li>Git 也可以模拟集中式的工作模式，Git版本库统一放在服务器中，Git 的集中式工作模式非常灵活；</li>
<li>可以为 Git 版本库进行授权：谁能创建版本库，谁能向版本库PUSH，谁能够读取（克隆）版本库;</li>
<li>团队的成员先将服务器的版本库克隆到本地；并经常的从服务器的版本库拉（PULL）最新的更新；</li>
<li>团队的成员将自己的改动推（PUSH）到服务器的版本库中，当其他人和版本库同步（PULL）时，会自动获取改变；</li>
<li>你完全可以在脱离Git服务器所在网络的情况下，如移动办公或出差时，照常使用代码库；</li>
<li>你只需要在能够接入Git服务器所在网络时，PULL和PUSH即可完成和服务器同步以及提交；</li>
<li>Git提供 rebase 命令，可以让你的改动看起来是基于最新的代码实现的改动；</li>
<li>Git 有更多的工作模式可以选择，远非 Subversion可比；</li>
<li>Git 分支是指针指向某次提交，而 SVN 分支是拷贝的目录，这个特性使 Git 的分支切换非常迅速，且创建成本非常低；</li>
</ul>
<h3 id="Git基本概念和常用命令"><a href="#Git基本概念和常用命令" class="headerlink" title="Git基本概念和常用命令"></a>Git基本概念和常用命令</h3><ul>
<li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li>
<li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li>
<li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库，版本库可分为远程仓库和本地仓库。<br><img src="/2022/05/12/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-1.jpg" alt="220512-Git和SVN-1.jpg"></li>
</ul>
<p>Git 常用的是以下 6 个命令：<strong>git clone</strong>、<strong>git push</strong>、<strong>git add</strong> 、<strong>git commit</strong>、<strong>git checkout</strong>、<strong>git pull</strong><br><img src="/2022/05/12/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-2.jpg" alt="220512-Git和SVN-2.jpg"></p>
<p> git 创建仓库的命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git init</code></td>
<td align="left">初始化仓库</td>
</tr>
<tr>
<td align="left"><code>git clone</code></td>
<td align="left">拷贝一份远程仓库，也就是下载一个项目。</td>
</tr>
</tbody></table>
<p>提交与修改的命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git add</code></td>
<td align="left">添加文件到暂存区</td>
</tr>
<tr>
<td align="left"><code>git status</code></td>
<td align="left">查看仓库当前的状态，显示有变更的文件。</td>
</tr>
<tr>
<td align="left"><code>git diff</code></td>
<td align="left">比较文件的不同，即暂存区和工作区的差异。</td>
</tr>
<tr>
<td align="left"><code>git commit</code></td>
<td align="left">提交暂存区到本地仓库。</td>
</tr>
<tr>
<td align="left"><code>git reset</code></td>
<td align="left">回退版本。</td>
</tr>
<tr>
<td align="left"><code>git rm</code></td>
<td align="left">删除工作区文件。</td>
</tr>
<tr>
<td align="left"><code>git mv</code></td>
<td align="left">移动或重命名工作区文件。</td>
</tr>
</tbody></table>
<p>提交日志的命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git log</code></td>
<td align="left">查看历史提交记录</td>
</tr>
<tr>
<td align="left"><code>git blame </code></td>
<td align="left">以列表形式查看指定文件的历史修改记录</td>
</tr>
</tbody></table>
<p>远程操作的命令：</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>git remote</code></td>
<td align="left">远程仓库操作</td>
</tr>
<tr>
<td align="left"><code>git fetch</code></td>
<td align="left">从远程获取代码库</td>
</tr>
<tr>
<td align="left"><code>git pull</code></td>
<td align="left">下载远程代码并合并</td>
</tr>
<tr>
<td align="left"><code>git push</code></td>
<td align="left">上传远程代码并合并</td>
</tr>
</tbody></table>
<p>Git 分支管理：<a target="_blank" rel="noopener" href="https://www.runoob.com/git/git-branch.html">https://www.runoob.com/git/git-branch.html</a><br>Git 查看提交历史：<a target="_blank" rel="noopener" href="https://www.runoob.com/git/git-commit-history.html">https://www.runoob.com/git/git-commit-history.html</a><br>Git 标签：<a target="_blank" rel="noopener" href="https://www.runoob.com/git/git-tag.html">https://www.runoob.com/git/git-tag.html</a><br>更多命令查看Git完整命令手册地址：<a target="_blank" rel="noopener" href="http://git-scm.com/docs">http://git-scm.com/docs</a></p>
<h3 id="Tortoise-SVN"><a href="#Tortoise-SVN" class="headerlink" title="Tortoise SVN"></a>Tortoise SVN</h3><p>SVN教程：<a target="_blank" rel="noopener" href="https://www.runoob.com/svn/svn-tutorial.html">https://www.runoob.com/svn/svn-tutorial.html</a></p>
<p>TortoiseSVN 是 SVN(Subversion) 版本控制系统的一个免费开源客户端，可以超越时间的管理文件和目录。TortoiseSVN 使用教程：<a target="_blank" rel="noopener" href="https://www.runoob.com/svn/tortoisesvn-intro.html">https://www.runoob.com/svn/tortoisesvn-intro.html</a></p>
<p>企业通常是使用TortoiseSVN提供的图像化界面操作，使用较简单。Windows的Git提供了GitGUI，也可以使用TortoiseGit，配置参数也有图形化界面，之前实习的一家公司就是 TortoiseGit 和 TortoiseSVN 。</p>
<h3 id="版本管控工具分支管理"><a href="#版本管控工具分支管理" class="headerlink" title="版本管控工具分支管理"></a>版本管控工具分支管理</h3><h4 id="SVN分支管理策略"><a href="#SVN分支管理策略" class="headerlink" title="SVN分支管理策略"></a>SVN分支管理策略</h4><ul>
<li>truck (主干|主线|主分支)：是用来做主方向开发的，新功能的开发应放在主线中，当模块开发完成后，需要修改，就用branch。</li>
<li>branches(分支)：分支开发和主线开发是可以同时进行的，也就是并行开发，分支通常用于修复bug时使用。</li>
<li>tags (标记)：用于标记某个可用的版本，可以标记已经上线发布的版本，也可以标记正在测试的版本，通常是只读的。</li>
</ul>
<p>branch是用来做并行开发的，这里的并行是指和trunk进行比较。比如，3.0开发完成，这个时候要做一个tag，tag_release_3_0，然后基于这个tag做release，比如安装程序等。trunk进入3.1的开发，但是3.0发现了bug，那么就需要基于tag_release_3_0做一个branch，branch_bugfix_3_0，基于这个branch进行bugfix，等到bugfix结束，做一个tag，tag_release_3_0_1，然后，根据需要决定branch_bugfix_3_0是否并入trunk。</p>
<h4 id="Git分支管理策略"><a href="#Git分支管理策略" class="headerlink" title="Git分支管理策略"></a>Git分支管理策略</h4><p><strong>Git Flow模型</strong>中定义了主分支和辅助分支两类分支。其中主分支用于组织与软件开发、部署相关的活动，辅助分支组织用于解决特定的问题而进行的各种开发活动。Git Flow开发模型从源代码管理角度对通常意义上的软件开发活动进行了约束，为软件开发提供了一个可供参考的管理模型。Git Flow开发模型让代码仓库保持整洁，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。</p>
<p>Git Flow模型的特点是只有2个主干分支，Master和Develop分支：Master分支上只有稳定的生产版本，Develop分支用于集成。其中还涉及到HotFix分支。而其他还有三类分支：Feature分支用于开发人员各自开发；Release用于代码合并和集成；HotFix用于产品版本代码的紧急修订。</p>
<p><strong>master分支</strong>通常只能从其它分支合并，不能在master分支直接修改。master分支上存放的是随时可供在生产环境中部署的代码（Production Ready state）。当开发活动到一定阶段，产生一份新的可供部署的代码时，master分支上的代码会被更新。同时，每一次更新，最好添加对应的版本号标签（TAG），所有在Master分支上的Commit应该打Tag。</p>
<p><strong>develop分支</strong>是保持当前开发最新成果的分支，一般会在此分支上进行晚间构建（Nightly Build）并执行自动化测试。develop分支产生于master分支, 并长期存在。当一个版本功能开发完毕且通过测试功能稳定时，就会合并到master分支上，并打好带有相应版本号的tag。develop分支是主开发分支，包含所有要发布到下一个Release的代码，主要合并其它分支，比如Feature分支。</p>
<p><strong>辅助分支</strong>是用于组织解决特定问题的各种软件开发活动的分支。辅助分支主要用于组织软件新功能的并行开发、简化新功能开发代码的跟踪、辅助完成版本发布工作以及对生产代码的缺陷进行紧急修复工作。辅助分支通常只会在有限的时间范围内存在。辅助分支包括用于开发新功能时所使用的feature分支，用于辅助版本发布的release分支，用于修正生产代码中的缺陷的hotfix分支。辅助分支都有固定的使用目的和分支操作限制。通过对分支的命名，定义了使用辅助分支的方法。</p>
<p><strong>feature分支</strong>可以从develop分支派生。feature分支的命名可以使用除master，develop，release-*，hotfix-*之外的任何名称。feature分支（topic分支）通常在开发一项新的软件功能的时候使用，分支上的代码变更最终合并回develop分支或者干脆被抛弃掉（例如实验性且效果不好的代码变更）。一般而言，feature分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里。Feature分支开发完成后，必须合并回Develop分支，合并完分支后一般会删feature分支，但也可以保留。</p>
<p><strong>release分支</strong>可以从develop分支派生。release分支是为发布新的产品版本而设计的。在release分支上的代码允许做测试、bug修改、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等）。通过在release分支上进行发布相关工作可以让develop分支空闲出来以接受新的feature分支上的代码提交，进入新的软件开发迭代周期。当develop分支上的代码已经包含了所有即将发布的版本中所计划包含的软件功能，并且已通过所有测试时，可以考虑准备创建release分支。而所有在当前即将发布的版本外的业务需求一定要确保不能混到release分支内（避免由此引入一些不可控的系统缺陷）。成功的派生release分支并被赋予版本号后，develop分支就可以为下一个版本服务。版本号的命名可以依据项目定义的版本号命名规则进行。发布Release分支时，合并Release到Master和Develop， 同时在Master分支上打个Tag记住Release版本号，然后就可以删除Release分支。</p>
<p><strong>hotfix分支</strong>可以从master分支派生。hotfix分支是计划外创建的，可以产生一个新的可供在生产环境部署的软件版本。当生产环境中的软件遇到异常情况或者发现了严重到必须立即修复的软件缺陷时，就需要从master分支上指定的TAG版本派生hotfix分支来组织代码的紧急修复工作。优点是不会打断正在进行的develop分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行的开展工作。hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/11/220511-C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/11/220511-C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">C语言预处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-11 23:00:00" itemprop="dateCreated datePublished" datetime="2022-05-11T23:00:00+08:00">2022-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-31 23:20:29" itemprop="dateModified" datetime="2022-05-31T23:20:29+08:00">2022-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="ANSI-C标准"><a href="#ANSI-C标准" class="headerlink" title="ANSI C标准"></a><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ANSI%20C%E6%A0%87%E5%87%86/6044290?fr=aladdin">ANSI C标准</a></h3><p>ANSI C是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E5%8D%8F%E4%BC%9A/5709537">美国国家标准协会</a>（ANSI）对<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>发布的标准。使用C的软件开发者被鼓励遵循ANSI C文档的要求，因为它鼓励使用<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B7%A8%E5%B9%B3%E5%8F%B0/8558902">跨平台</a>的代码。</p>
<p>发展过程中产生了C89、C90、C99、C11四套标准，最早的C89在1983年创立，C90是1990年创立的ANSI C标准（带有一些小改动），C99在2000年3月创立，C11在2011年12月创立。</p>
<h3 id="C预处理器"><a href="#C预处理器" class="headerlink" title="C预处理器"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-preprocessors.html">C预处理器</a></h3><table>
<thead>
<tr>
<th align="left">指令</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">#define</td>
<td align="left">定义宏</td>
</tr>
<tr>
<td align="left">#include</td>
<td align="left">包含一个源代码文件</td>
</tr>
<tr>
<td align="left">#undef</td>
<td align="left">取消已定义的宏</td>
</tr>
<tr>
<td align="left">#ifdef</td>
<td align="left">如果宏已经定义，则返回真</td>
</tr>
<tr>
<td align="left">#ifndef</td>
<td align="left">如果宏没有定义，则返回真</td>
</tr>
<tr>
<td align="left">#if</td>
<td align="left">如果给定条件为真，则编译下面代码</td>
</tr>
<tr>
<td align="left">#else</td>
<td align="left">#if 的替代方案</td>
</tr>
<tr>
<td align="left">#elif</td>
<td align="left">如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td>
</tr>
<tr>
<td align="left">#endif</td>
<td align="left">结束一个 #if……#else 条件编译块</td>
</tr>
<tr>
<td align="left">#error</td>
<td align="left">当遇到标准错误时，输出错误消息</td>
</tr>
<tr>
<td align="left">#pragma</td>
<td align="left">使用标准化方法，向编译器发布特殊的命令到编译器中</td>
</tr>
</tbody></table>
<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>ANSI C 定义了许多宏。在编程中可以使用这些宏，但是不能直接修改这些预定义的宏。</p>
<table>
<thead>
<tr>
<th align="left">宏</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__DATE__</td>
<td align="left">当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td>
</tr>
<tr>
<td align="left">__TIME__</td>
<td align="left">当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td>
</tr>
<tr>
<td align="left">__FILE__</td>
<td align="left">这会包含当前文件名，一个字符串常量。</td>
</tr>
<tr>
<td align="left">__LINE__</td>
<td align="left">这会包含当前行号，一个十进制常量。</td>
</tr>
<tr>
<td align="left">__STDC__</td>
<td align="left">当编译器以 ANSI 标准编译时，则定义为 1。</td>
</tr>
</tbody></table>
<h3 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39640298/article/details/84503428">#pragma</a></h3><p>#pragma指令的作用是：用于指定计算机或操作系统特定的编译器功能。C 和 C++ 的每个实现均支持某些对其主机或操作系统唯一的功能。 例如，某些程序必须对将数据放入的内存区域进行准确的控制或控制某些函数接收参数的方式。 在保留与 C 和 C++ 语言的总体兼容性的同时，#pragma 指令使每个编译器均能够提供特定于计算机和操作系统的功能。</p>
<p>根据定义，#pragma指令是计算机或操作系统特定的，并且通常对于每个编译器而言都有所不同。 #pragma指令可用于条件语句以提供新的预处理器功能，或为编译器提供实现所定义的信息。</p>
<p><code>#pragma pack([ show ] | [ push | pop ] [, identifier ] , n)</code>，用于内存对齐。<br><code>#pragma message(messageString)</code>，用于不中断编译的情况下，发送一个字符串文字量到标准输出。</p>
<p>编译器可识别的指令还有很多。</p>
<h3 id="和…"><a href="#和…" class="headerlink" title="##和…"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/ysds20211402/article/details/122300354">##和…</a></h3><p><code>##</code> 起连接字符串的作用，用于把参数宏中的“形参”与其它没有天然分割的内容粘连在一起。<br>例如：<code>#define def_u32_array(__name, __size)    uint32_t array_##__name[__size];</code><br><code>def_u32_array(sample_buffer, 64)</code>，宏展开后为：<code>uint32_t array_sample_buffer[64];</code></p>
<p><code>...</code> 是ANSI-C99标准引入的另外一个参数宏扩展，“可变参数宏”，其实就是将__VA_ARGS__替换为…中的值。<br>例如：<code>#define log_info(__STRING, ...)    printf(__STRING, __VA_ARGS__)</code><br><code>log_info(&quot;Count:%d&quot;, total_cycle_cnt);</code>，宏展开后：<code>printf(&quot;Count:%d&quot;, total_cycle_cnt);</code><br><code>log_info(&quot;-----------------\r\n&quot;);</code>，宏展开后：<code>printf(&quot;-----------------\r\n&quot;,);</code>，…无参数，__VA_ARGS__为空，但是宏展开后仍有逗号。</p>
<p>逗号后无内容可能会产生个warning，想解决逗号问题，可以##和…一起使用。<br>例如：<code>\#define log_info(__STRING, ...)    printf(__STRING,##__VA_ARGS__)</code><br><code>log_info(&quot;-----------------\r\n&quot;);</code>，宏展开后：<code>printf(&quot;-----------------\r\n&quot;);</code></p>
<h3 id="…初始化数组"><a href="#…初始化数组" class="headerlink" title="…初始化数组"></a>…初始化数组</h3><p><code>int a[5] = &#123;[0...2] = 1, [3...4] = 2&#125;;</code>使数组a[0]~a[2] = 1, a[3]和a[4] = 2。</p>
<p>这种写法只可以在gcc编译C的情况下使用，gcc编译c++也不行。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">基于Altera FPGA的网络摄像机设计与实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-01 13:00:00" itemprop="dateCreated datePublished" datetime="2022-05-01T13:00:00+08:00">2022-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-21 23:04:58" itemprop="dateModified" datetime="2022-05-21T23:04:58+08:00">2022-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h3><p>本文介绍了如何设计一个以Altera FPGA为核心的网络摄像机，将图像传感器和MEMS麦克风作为的主要传感器，辅以千兆以太网模块、电源模块等模块，最终完成实现一个低成本易使用的网络摄像机的功能。要求该网络摄像机能够实时传输图像和音频信息，在电脑端可以将图像实时处理显示并将音频实时播放。此外，还能够将数据流存储在设备中，便于用户对视频进行回放等操作。</p>
<h2 id="总体设计方案描述"><a href="#总体设计方案描述" class="headerlink" title="总体设计方案描述"></a>总体设计方案描述</h2><p>本设计方案是以Altera FPGA为核心，在Quartus 18.0开发平台上，实现FPGA接收图像传感器和麦克风数据，并通过千兆以太网PHY芯片，将图像和声音数据发送至电脑上位机，电脑上位机利用Python3编程语言编写，在PyCharm IDE中执行，实现音视频实时播放和音视频回放的功能。主要由Altera FPGA控制器、图像传感器模块、麦克风模块、以太网模块和电脑上位机组成，系统框图如下图所示。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-1.png" alt="220501-毕业设计-1.png"></p>
<h3 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h3><p>FPGA选用Cyclone IV EP4CE15 Starter Kit开发板。开发板板载W25Q64 SPI Flash芯片，8MB字节的存储容量，开发板给主控提供了50MHz的外部时钟源，芯片逻辑单元数为 15K LE，开发板引出了芯片的JTAG调试端口，引出了GMII千兆以太网接口，采用了RealTek的RTL8211EG芯片，引出了一个CMOS/CCD摄像头接口和40P的排座。开发板条件满足本设计的所有需求。</p>
<p>图像传感器选择经典的OV2640模组，OV2640适配开发板引出的40P的排座，提供了SCCB接口，可供配置传感器参数，可以配置最大1600*1200分辨率的图像输出，还可以配置JPEG压缩格式输出图像，模组拥有8位并口，可以高速输出图像信息，拥有帧场同步信号管脚，和电源使能管脚，方便FPGA控制和接收图像信息。</p>
<p>麦克风选择INMP441全向麦克风传感器，INMP441麦克风直接输出数字信号，采用的接口是I2S，非常适合FPGA去读取总线数据。传统驻极体麦克风输出模拟信号，选用INMP441省去了传统驻极体麦克所需的放大器、滤波器和模数转换器等硬件设计。</p>
<h3 id="FPGA设计方案"><a href="#FPGA设计方案" class="headerlink" title="FPGA设计方案"></a>FPGA设计方案</h3><p>FPGA设计采用模块化设计的方案，通过模块化设计，可以使一个大型设计分成多个模块，这样分工协作可使仿真测试更加容易，并且代码维护和代码升级也会更加方便。顶层模块不做逻辑设计，只通过例化调用子模块接口。因此，顶层模块下就由各功能模块组成，各功能模块下还可以分成多个子功能模块来实现。通过编译器对每个模块的综合仿真约束等设计，最后将所有模块连在一起，构成整个网络摄像机FPGA部分的设计。</p>
<p>本设计模块层次设计图如下所示，由时钟模块、数据交互模块、图像传感器模块、麦克风模块、千兆网络模块总共5个模块组成，各模块又由各个子模块组成，顶层模块通过例化的方式，将5个模块之间的接口互相连接起来，实现顶层模块的最终设计。该模块层次设计的各个子模块功能相对独立，各模块内部联系紧密，模块之间的连接简单，满足FPGA的模块化设计基本规则。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-2.png" alt="220501-毕业设计-2.png"></p>
<h3 id="上位机设计方案"><a href="#上位机设计方案" class="headerlink" title="上位机设计方案"></a>上位机设计方案</h3><p>上位机采用Python3编程语言设计，主要功能分为接收数据包、实时解码播放、保存回放。FPGA传来的UDP数据包包含了音频和图像，两者通过两个不同的端口传输，这样更便于应用层的分开处理。在UDP数据包中还加入了帧序列号，上位机可通过校验前后两帧的序列号是否对应，来判断是否发生掉包的现象。实时解码播放是通过数据包的传输协议将有用数据部分取出，图像数据为JPEG压缩图像，通过OpenCV对JPEG图像解码，通过图像流的方式显示在屏幕上。音频是通过PCM码流传输，通过约定好的采样频率、量化位数、声道数等信息，调用PyAudio函数库接口进行播放。回放功能是将图片流保存成avi视频格式，音频流保存成wav音频格式，然后在电脑文件系统中可以打开进行回放。通过多进程多线程将这三个功能配合起来，通过流水线操作的方式，让整个上位机程序执行更加的高效、稳定。上位机的程序流程图如下图所示。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-3.png" alt="220501-毕业设计-3.png"></p>
<h2 id="FPGA各模块功能实现"><a href="#FPGA各模块功能实现" class="headerlink" title="FPGA各模块功能实现"></a>FPGA各模块功能实现</h2><h3 id="时钟模块实现"><a href="#时钟模块实现" class="headerlink" title="时钟模块实现"></a>时钟模块实现</h3><h4 id="系统时钟输入和PLL配置"><a href="#系统时钟输入和PLL配置" class="headerlink" title="系统时钟输入和PLL配置"></a>系统时钟输入和PLL配置</h4><p>下图为FPGA开发板硬件原理图中的时钟部分，FPGA系统时钟信号由一颗50MHz有源晶振，从FPGA的T2引脚传入，由该时钟通过PLL锁相环和分频器，得到各模块所需的时钟，为整个系统提供准确的时钟信号。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-4.jpg" alt="220501-毕业设计-4.jpg"></p>
<p>锁相环（Phase Locked Loop, PLL）是一种反馈型的控制电路，可以通过PLL对输入时钟进行系统级的时钟控制，可以配置管理时钟相位、偏移，具有倍频、分频和可编程占空比等功能。由于本设计使用到的模块较多，使用单一的时钟通过软件分频无法得到精准音频采样的频率，所以满足本设计要求。故使用PLL模块来满足该设计的不同时钟频率和不同时钟相位偏移的要求。通过Quartus提供的PLL IP核，对Altera FPGA片上的可编程PLL进行控制，使其输出各种时钟信号提供给各个模块使用。</p>
<p>下图为在Quartus 18.0中通过PLL IP核配置输入50Mhz时钟，输出2.205MHz时钟提供给麦克风模块的采样频率使用，配置软件会根据输入输出时钟频率自动计算出PLL的各个参数（时钟倍频参数、时钟分频参数），提供给麦克风模块的采样频率不需要相位偏移和特殊的占空比，故设置相位偏移为0，占空比为50%。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-5.jpg" alt="220501-毕业设计-5.jpg"></p>
<h4 id="软件分频器实现"><a href="#软件分频器实现" class="headerlink" title="软件分频器实现"></a>软件分频器实现</h4><p>由于片上PLL资源数量有限，部分对时钟精准度要求不高的模块也可以采用软件分频器实现。例如I²C模块中的时钟信号采用250KHz，通过对输入的50MHz系统时钟上升沿或者下降沿计数，计数器值累加到100时，让输出信号产生翻转，即可产生250KHz的I²C驱动信号。这就是软件分频器的实现原理，占用硬件资源少，像这种整数倍分频，也可以提供较好的精度。</p>
<h3 id="数据交互模块实现"><a href="#数据交互模块实现" class="headerlink" title="数据交互模块实现"></a>数据交互模块实现</h3><p>设计FPGA各模块交互时，需要将图像和音频的数据传送给网络模块封装发送，故使用FIFO来做数据的缓冲。而网络模块的时钟信号是125MHz，与图像传感器模块24MHz和麦克风模块44100Hz有较大的区别，所以不能直接将数据通过同读写同时钟的FIFO传送给网络模块发送。FIFO模块可以配置读写相同时钟和读写不同时钟，在实际测试中，由于读取时钟为125MHz高频率信号，读写不同时钟情况下，FIFO的读写会产生严重的数据错误。因此本设计采用读写同时钟，FIFO模块输入时钟为网络模块的时钟125MHz，再手动编写跨时钟数据交互的时序逻辑，实现不同时钟域数据通过FIFO的转换。</p>
<h4 id="FIFO模块配置"><a href="#FIFO模块配置" class="headerlink" title="FIFO模块配置"></a>FIFO模块配置</h4><p>FIFO（First In First Out）模块是对数据缓冲时用到存储器，使模块可以被突发性读写。通常也被用于高速信号跨时钟域的数据交互，它可以被顺序写入，然后可以被顺序读出，先进先出的特性是FIFO不同于其他存储器的地方。</p>
<p>在Quartus 18.0中也可以通过IP核的方式来配置FIFO模块，关系FIFO容量的两个参数是FIFO的宽度和深度，宽度是指同时多少位可以被读写，深度是指可以存储多少该宽度的数据。由于FPGA中以太网是以字（4Bytes）的宽度来发送数据，并且以太网一帧默认最长大小是1500个字节，其中有用的数据为1472个字节，因此这里选择宽度为32bits，深度为512words可以满足缓冲一阵的以太网数据包。这里配置时我们采用读写相同时钟，从而使FIFO高速稳定的运行。需要打开usedw[]的功能，让网络模块读取已经使用的FIFO数量，当已经使用的数量大于等于1472字节时，可以开始发送一帧以太网数据。在输出寄存器一选项中，选择要求时间同步，Yes(best speed)，由于FIFO时钟是125MHz，不选速度优先的话也会导致FIFO读写混乱错误。同时关闭上下溢出检测以提升FIFO模块性能。下图为最后FIFO模块配置的部分参数，配置时一定要使性能最优。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-6.jpg" alt="220501-毕业设计-6.jpg"></p>
<h4 id="将数据写入FIFO模块实现"><a href="#将数据写入FIFO模块实现" class="headerlink" title="将数据写入FIFO模块实现"></a>将数据写入FIFO模块实现</h4><p>FIFO模块的时钟为125MHz，在图像FIFO存储模块中，图像传感器的时钟是24MHz，并且是8位宽度，需要手动编写跨时钟数据交互的时序逻辑，实现不同时钟域数据通过FIFO的转换。图像FIFO写模块输入有时钟、复位、图像数据、数据有效使能、垂直同步信号，输出有32位FIFO写入、FIFO写使能信号。捕获四个数据有效使能信号上升沿，将4个8位数据合并成1个32位数据，并向FIFO模块发送写使能，由于FIFO模块的时钟为125MHz，要写1个数据到FIFO模块，写使能信号高电平时间只能为8ns。为了使每幅图像不会等到下一张图像数据写入FIFO，直到FIFO满1472字节才发送，即使每幅图像都可以在该图像接收结束被发送完成，在垂直同步（一幅图像数据结束）信号产生后就向FIFO中追加写入1472个字节的0x00数据。</p>
<p>麦克风模块和网络模块也通过FIFO传递数据，麦克风模块的采样频率为44100Hz，也需要做个时钟转换和数据宽度转换，转换成FIFO模块的125MHz和32位宽才能写入FIFO，实现方法与图像数据写入FIFO模块类似。由于音频数据的采样量化位数是24位，转换成32位数据需要在首位补0x00，为了上位机方便保存成wav格式，采用小段存储方方式写入FIFO模块。</p>
<h4 id="从FIFO模块读取数据实现"><a href="#从FIFO模块读取数据实现" class="headerlink" title="从FIFO模块读取数据实现"></a>从FIFO模块读取数据实现</h4><p>网络模块在判断FIFO存储数量大于等于1472字节时会开始发送数据，发送数据时会请求读取FIFO模块数据，以太网发送数据的时钟是125MHz的，读取FIFO数据后要及时锁存，在锁存进入稳态后才可以被网络模块读取发送，否则由于FIFO发送速度过快，数据在信号线上容易未进入稳态被读取，造成读取和发送的数据出现错误。因为音频传送的数据量小，且实时性要求高，所以音频FIFO模块读取的优先级要设置比图像FIFO模块读取的优先级高。</p>
<h3 id="图像传感器模块实现"><a href="#图像传感器模块实现" class="headerlink" title="图像传感器模块实现"></a>图像传感器模块实现</h3><h4 id="I²C驱动模块实现"><a href="#I²C驱动模块实现" class="headerlink" title="I²C驱动模块实现"></a>I²C驱动模块实现</h4><p>使用OV2640传感器，需要用SCCB类I²C总线配置OV2640传感器的寄存器。I²C总线协议由飞利浦公司发明，由一根数据线和一根时钟线构成，属于半双工同步通信，较常用的时钟速率有低速模式100KHz，高速模式400KHz，超高速模式3.4MHz。I²C总线协议支持一主多从，由于I²C总线协议中设备标识符占7位空间，所以I²C总线理论可以挂载128个设备，但实际考虑I²C总线上设备的驱动能力，只可以挂载5个左右从设备。</p>
<p>I²C总线协议发送起始位后开始通信，起始位的标识是时钟线为高电平时，数据线从高电转变为低电平。通信时发送的第一个字节高7位内容为从设备的设备地址，末一位为读或写请求，低标识写标志位，反之则是读标志位。I²C通信协议中每发送一个字节后一位（第9位），对应的从机接收到就要发送应答响应，即第9位需要将数据线拉低响应，若主机读取到第9位仍为高电平，则标识无对应从机应答。发送设备地址后，若从机有应答，则主从双方继续通信，若主机写请求，就可以发送数据，向从机对应寄存器地址写入数据，从机收到数据后会返回应答信号，若主机读请求，则从机会向主机发送对应地址的数据内容，主机在接收后也需要拉低数据线响应。通信结束后主机发送停止位信号，停止位的标识是时钟线保持高电平，数据线从低电平转变为高电平的状态。</p>
<p>在FPGA中实现I²C驱动相对别的通信方式（USART、SPI等）难度较高，因为I²C驱动存在有多个工作状态，需要采用复杂的有限状态机来实现I²C驱动。下图是FPGA程序的有限状态机状态转移图，I²C驱动部分程序的代码见附录。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-7.jpg" alt="220501-毕业设计-7.jpg"></p>
<h4 id="图像传感器配置模块实现"><a href="#图像传感器配置模块实现" class="headerlink" title="图像传感器配置模块实现"></a>图像传感器配置模块实现</h4><p>OV2640图像传感器有较多的寄存器，参考数据手册配置，在图像传感器配置模块中总共配置了201个寄存器，通过case语句，用查表的形式读取相应寄存器地址和寄存器数据，发送给I²C驱动模块，配置OV2640图像传感器。</p>
<p>先对传感器软复位，后根据本设计的需要配置寄存器，例如：分辨率采用UXGA模式，对输入时钟不分频，倍频系数2，配置JPEG输出，设置图像窗口大小和图像尺寸大小等。配置的程序代码和各寄存器的配置的值见附录。在配置完成后，图像传感器配置模块会发送给图像数据读取模块OV2640初始化完成信号。</p>
<h4 id="图像数据读取模块实现"><a href="#图像数据读取模块实现" class="headerlink" title="图像数据读取模块实现"></a>图像数据读取模块实现</h4><p>图像传感器数据通讯接口采用的是DCMI接口，在OV2640中DCMI接口是8位数据并口，并且配有行同步垂直同步信号。行同步信号高电平时为图片中一行像素点有效数据，低电平为无效数据，所以每当出现行同步信号上升沿时就是该幅图像传输新的一行标识位。垂直同步信号是一张图片中有效数据的标识，当垂直同步高电平时为有效，每当出现垂直信号的下降沿时，表示该幅图像传输完成，当出现垂直信号的上升沿时，表示新的一幅图像传输开始。</p>
<p>图像数据读取模块收到配置模块发来的初始化完成信号后开始采集数据，在OV2640传感器实际应用中，图像传感器传来的前几幅图像会有显示问题，所以将开始传来的数据丢弃，根据垂直同步信号计数，第10幅图像开始开始采集图像数据发送给写FIFO模块。数据读取模块实现的代码见附录。</p>
<h3 id="麦克风模块实现"><a href="#麦克风模块实现" class="headerlink" title="麦克风模块实现"></a>麦克风模块实现</h3><h4 id="I²S总线数据读取模块实现"><a href="#I²S总线数据读取模块实现" class="headerlink" title="I²S总线数据读取模块实现"></a>I²S总线数据读取模块实现</h4><p>使用的MEMS硅麦克风采用的是I²S通信协议，当INMP441的L/R引脚为低电平时，INMP441提供单个左通道音频数据，时序图如下图所示。和I²C比较而言，I²S多了个WS接口，WS接口是串行数据声道选择，为低时左声道麦克风模块在I²S总线上发送数据，右声道是高阻态。WS为高时右声道麦克风模块在I²S总线上发送数据，而左声道是高阻态。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-8.jpg" alt="220501-毕业设计-8.jpg"></p>
<p>根据时序图可以编写FPGA的I²S驱动，可见经过WS的一周期会得到一组声音信号，WS在SCK下降沿时跳变，在WS跳变后的第二个SCK上升沿可以读取音频数据的最高位，依次24个SCK后得到完整的24位左声道音频数据。设计FPGA程序时，一周期WS会有50次SCK上升沿，因此SCK的频率会比WS高50倍，要保证采样率为44100Hz，就需要通过PLL模块给麦克风模块提供2.205MHz的SCK信号。具体的I²S驱动代码见附录。</p>
<h3 id="千兆以太网模块实现"><a href="#千兆以太网模块实现" class="headerlink" title="千兆以太网模块实现"></a>千兆以太网模块实现</h3><p>千兆以太网模块是本设计FPGA部分实现起来最复杂和困难的模块，由于千兆以太网PHY芯片采用125MHz高速时钟和8位并口数据传输，容易导致数据传输时未进入稳定态，出现时序混乱的现象。网络模块由三个部分组成，分别是网络发送模块、网络接收模块、CRC-32校验模块，三个模块之间的连接关系RTL视图如下图所示。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-9.jpg" alt="220501-毕业设计-9.jpg"></p>
<h4 id="CRC-32校验模块实现"><a href="#CRC-32校验模块实现" class="headerlink" title="CRC-32校验模块实现"></a>CRC-32校验模块实现</h4><p>以太网帧组成如下图所示，它是由前导、帧起始定界符、以太网帧头、以太网数据、帧校验序列组成，其中网络中帧校验序列使用最广泛的是采用4字节的循环冗余校验方式，即CRC-32校验。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-10.jpg" alt="220501-毕业设计-10.jpg"></p>
<p>CRC-32计算方式可以采用串行或并行计算，为了发挥FPGA并行优势，本设计采用并行的方式计算CRC-32校验码，并行CRC-32计算的表可以由工具生成。在FPGA设计中，该模块输入的值有时钟、使能、一字节数据，以太网每发送一字节数据，就要将发送的数据值发送给CRC-32校验模块，会根据上次CRC-32的结果和本次传来的数据值，同步更新CRC-32的值，最后输出为CRC-32校验的结果加在以太网帧的帧尾发送出去，如果目的主机校验CRC-32结果失败，则会在数据链路层丢弃该帧。具体的CRC-32校验模块实现代码见附录。</p>
<h4 id="千兆以太网数据发送模块实现"><a href="#千兆以太网数据发送模块实现" class="headerlink" title="千兆以太网数据发送模块实现"></a>千兆以太网数据发送模块实现</h4><p>实现以太网数据发送模块，要解决两个问题，需要发送的数据包含哪些信息，需要如何控制千兆以太网PHY芯片。</p>
<p>在CRC-32校验模块实现一节中介绍了以太网帧的组成结构，在发送目的MAC地址时使用ff-ff-ff-ff-ff-ff广播地址。以太网帧中的以太网数据段格式如下图所示，由于网络摄像机传输要满足实时性，且网络传输在局域网环境下环境不复杂，所以采用UDP协议传输数据，即在IP首部选择协议的地址中写入17表示UDP，生存时间一般为64，标识部分需要每次发送后累加，首部校验和是对IP首部内容累加保留末四位进行校验，在本设计中将源IP地址（FPGA的IP地址）设置为192.168.0.2，目的IP地址（电脑的IP地址）设置为192.168.0.3。以太网数据一般不超过1500字节，IP首部占了24字节，所以IP数据部分最大可为1476字节，其中IP数据的首四字节为用户自定义的帧序列号，用于上位机校验是否有丢包现象产生，所以实际每帧的IP数据中传输有用信息的只有1472个字节。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-11.jpg" alt="220501-毕业设计-11.jpg"></p>
<p>下图为物理层芯片RTL8211的硬件原理图，可见RTL8211与FPGA的连接主要包含8个发送引脚、8个接收引脚，还有发送和接收的时钟引脚，MDC和MDIO属于配置RTL8211芯片寄存器的接口，在本设计中采用默认寄存器值，所以未用到配置引脚。RTL8211发送和接收时钟均为125MHz，上升沿采样，发送和接收均为8位并口，可以满足1000Mbps全双工通信。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-12.jpg" alt="220501-毕业设计-12.jpg"></p>
<p>设计千兆以太网数据发送模块也是用有限状态机实现，使用了idle, start, make, send55, sendmac, sendheader, sendpicdata, sendmicdata, sendcrc共9个状态。在idle状态的时候，程序主要是初始化数据，并且检测图像FIFO和音频FIFO是否有超过1472个字节，其中先检测音频FIFO的使用量，若有超过1472个字节跳转到下个状态start。在start状态中会对IP首部进行配置，如果是图像FIFO大于1472字节，会配置端口号为8080，如果是音频FIFO大于1472字节，会配置端口号为8081，配置完成后会跳到下一个状态。make状态中会对IP首部计算校验和，并写入IP首部配置变量ip_header中，跳转至send55状态。在send55状态下，FPGA会和RTL8211通信，发送7字节前导码0x55和1字节帧起始界定符0xD5，发送完成后跳转到下个状态sendmac。在sendmac状态中会发送以太网帧头，包含目的MAC地址，源MAC地址，长度类型这些信息。下个状态sendheader，即发送start状态下存入ip_header变量中的IP首部信息，接下来进入发送数据的状态。发送数据的状态分两种一种是发送图像的状态，另一种是发送音频数据的状态，两个实现的方法一致，只是FIFO读请求所对应的FIFO不同，在发送数据状态中要先发送帧序列号，图像和音频的帧序列号是分开的，发送完帧序列号后循环请求读FIFO368次，将1472字节数据发送给RTL8211芯片，RTL8211会将从FPGA接收到的数据通过网线中的两对差分信号线发送到电脑网口。发送数据状态结束后进入最后一个sendcrc状态，该状态下会读取最后CRC-32的校验值发送给以太网PHY芯片，该状态结束后，表示一帧以太网数据传输结束，状态又跳转至空闲状态检测两个FIFO使用量。具体实现详见附录代码。</p>
<h2 id="上位机功能实现"><a href="#上位机功能实现" class="headerlink" title="上位机功能实现"></a>上位机功能实现</h2><h3 id="图像功能实现"><a href="#图像功能实现" class="headerlink" title="图像功能实现"></a>图像功能实现</h3><h4 id="接收和解析图像数据包功能实现"><a href="#接收和解析图像数据包功能实现" class="headerlink" title="接收和解析图像数据包功能实现"></a>接收和解析图像数据包功能实现</h4><p>接收UDP的数据包使用了Python中socket库，在程序开始引用该库，通过socket.socket(socket.AF_INET, socket.SOCK_DGRAM)构造函数构造一个套接字，配置使用UDP协议，并且通过server.bind(‘192.168.0.3’, 8080)绑定该套接字对应的IP地址和端口号。接收UDP数据包通过函数server.recvfrom(BUFSIZE)，其中BUFSIZE为缓冲大小，由于一帧以太网数据1472字节，这里将BUFSIZE设置为1472*1000，以实现每次接收缓冲区满足处理的速度。在每次接收UDP数据包后，首先会校验帧序列号，即数据区前四字节，帧序列号是否为上次接收的累加1，若帧序列号不连续则表示存在丢包的现象，通过打印verify error告诉用户帧序列号校验失败。处理图像数据时，传来的图像数据时JPEG编码格式，由于JPEG编码格式帧起始标识符值为0xFFD8、帧结束标识符值为0xFFD9，提取数据包中的有用数据就是通过find(0xff, index)函数找到0xff功能标识符，然后再判断的下一字节是否为0xD8，若判断为真即表示找到JPEG图像数据头，再找尾标识符0xFFD9，通过同样的方法找到数据尾标识符后，将JPEG图像数据包头到包尾数据通过fp.write(data)函数写入jpg格式的文件，就完成了一张图像的保存。</p>
<h4 id="图像流实时播放功能实现"><a href="#图像流实时播放功能实现" class="headerlink" title="图像流实时播放功能实现"></a>图像流实时播放功能实现</h4><p>要实现图像流实时播放功能，需按照拍摄图像的帧率，连续读取保存在磁盘中的图像，再在屏幕上不断刷新显示。本设计上位机程序采用OpenCV函数库实现图像的读取，解码和显示的功能。首先，在程序的开头通过import cv2引用OpenCV库。通过img = cv2.imread(img_root + str(i)+’.jpg’, cv2.IMREAD_COLOR)读取jpg格式的文件，其中img_root为图像所在文件夹的名字，imread的第一个参数就是图像路径，将读取到的数据保存在mat对象img中。调用cv2.namedWindow(“video”, cv2.WINDOW_AUTOSIZE)创建一个显示图像的窗口，窗口名为video。最后通过cv2.imshow(“video”, img)函数，该函数可以让名为video的显示窗口中显示img图像信息。cv2.waitKey(55)函数是使该窗口显示时间为55ms，这个延时时间由视频的帧数决定。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-13.jpg" alt="220501-毕业设计-13.jpg"></p>
<h4 id="图像流存储功能实现"><a href="#图像流存储功能实现" class="headerlink" title="图像流存储功能实现"></a>图像流存储功能实现</h4><p>OpenCV库中有支持导出avi视频的函数，fourcc = cv2.VideoWriter_fourcc(*’XVID’)函数，其中XVID参数是指将视频以MPEG-4编码类型保存，保存成avi格式的文件。videoWriter = cv2.VideoWriter(‘./avi/‘ + str(j) + ‘.avi’, fourcc, fps, size)函数配置了视频保存的路径，编码格式，帧率和每帧图像的分辨率，size = (1600, 1200)图像为1600 * 1200的分辨率。通过videoWriter.write(img)函数可以将img图像信息传入，让OpenCV处理生成视频。每隔150张图像发布一个10秒钟时长的avi视频，通过函数videoWriter.release()实现avi视频的发布。每次发布成功后程序会打印release告诉用户，可以在avi文件夹下查看保存的回放视频。</p>
<h3 id="音频功能实现"><a href="#音频功能实现" class="headerlink" title="音频功能实现"></a>音频功能实现</h3><h4 id="接收和解析音频数据包功能实现"><a href="#接收和解析音频数据包功能实现" class="headerlink" title="接收和解析音频数据包功能实现"></a>接收和解析音频数据包功能实现</h4><p>接收音频数据的方式与接收图像数据方式相同，通过Python的socket库。在接收音频数据后做帧序列号校验，并提取有效部分。接收到的音频数据是24位的麦克风adc原始值，由于自己电脑声卡输出只支持16位，播放24位音频会没有声音，故在上位机上做了个24位转换为16位的操作，即提取高16位数据，保存到pcm文件中。使用20ms的数据缓冲时间，分别将20ms的pcm数据保存到电脑中。</p>
<h4 id="音频流实时播放功能实现"><a href="#音频流实时播放功能实现" class="headerlink" title="音频流实时播放功能实现"></a>音频流实时播放功能实现</h4><p>上位机使用pyaudio库播放PCM音频，在程序的开始通过import pyaudio引用该库，读取已经保存在硬盘中的音频数据，通过p = pyaudio.PyAudio()初始化音频播放器，由于PCM是音频的原始数据，不包含量化位数、通道数、采样率等参数，所以，通过stream = p.open(format=p.get_format_from_width(2), channels=1, rate=44563, output=True)配置要播放音频的参数，并赋值给stream对象。通过stream.write(data)向stream播放器对象中写入音频数据，就可以完成音频的实时播放。</p>
<h4 id="音频流存储功能实现"><a href="#音频流存储功能实现" class="headerlink" title="音频流存储功能实现"></a>音频流存储功能实现</h4><p>使用wave库，将pcm音频保存成wav格式的音频文件写入磁盘，为了方便回放，每10s中保存一个wav音频。通过wavfile = wave.open(‘./wav/‘ + str(j) + ‘.wav’, ‘wb’)打开一个wav文件，通过设置函数给wavfile对象设置音频的通道数、量化位数和采样率。最后通过wavfile.writeframes(data)就可以往wav文件中追加音频内容，每10s保存成一个文件。</p>
<h3 id="通过多进程实现各个功能"><a href="#通过多进程实现各个功能" class="headerlink" title="通过多进程实现各个功能"></a>通过多进程实现各个功能</h3><h4 id="多进程并行工作实现"><a href="#多进程并行工作实现" class="headerlink" title="多进程并行工作实现"></a>多进程并行工作实现</h4><p>为了让程序高效运行，发挥CPU的多核优势，采用多进程并行的思想来实现上位机的设计。使用多进程可以实现流水线架构，例如，让解码显示图像的操作不阻塞接收UDP数据。在本上位机中共使用了四个进程，分别是图像接收数据和解析数据进程、音频接收数据和解析数据进程、图像实时显示和保存回放进程、音频实时播放和保存回放进程，四个进程互不影响，并行运行。在Python中使用multiprocessing库可实现多进程，例如创建接收和保存数据的进程p1 = multiprocessing.Process(target=receive_save_process, args=(pipe[0], ))，第一个参数是传入进程所执行的函数，第二个参数是所要执行的函数对外的参数接口。通过p1.start()就可以使进程开始运行。</p>
<h4 id="数据包进程间通信实现"><a href="#数据包进程间通信实现" class="headerlink" title="数据包进程间通信实现"></a>数据包进程间通信实现</h4><p>在Python中进程间通信的常用方式有文件IO，共享内存，管道，消息队列等。通过文件的方式内存通信比较占用IO资源，为了使视频有更好的实时性，本设计采用管道和IO流的方式进程间通信。通过fp = io.BytesIO()创建IO流让fp指向该字节流，fp可以像文件一样通过write函数被写入，通过read函数读取IO流中的数据。多进程库提供了管道这种通信方式，通过multiprocessing.Pipe()创建管道。在多进程通信中，将数据写入IO流，并通过管道传输IO流的地址，使数据可以在内存中被交互，从而达到减小传输时延，使视频更具实时性。</p>
<h2 id="系统性能测试与功能展示"><a href="#系统性能测试与功能展示" class="headerlink" title="系统性能测试与功能展示"></a>系统性能测试与功能展示</h2><h3 id="系统性能测试"><a href="#系统性能测试" class="headerlink" title="系统性能测试"></a>系统性能测试</h3><h4 id="FIFO和以太网高带宽传输测试"><a href="#FIFO和以太网高带宽传输测试" class="headerlink" title="FIFO和以太网高带宽传输测试"></a>FIFO和以太网高带宽传输测试</h4><p>FPGA编写测试模块，往FIFO模块中高速写入数据，再从FIFO中读取出进行对比，若对比不正确则亮红灯提示。测试的数据需要每次都不一致，竟可能有多个位产生变化，可以采用随机值。噪声的ADC值可以作为硬件真随机值，在本设计中通过麦克风传感器的低八位ADC值来作为测试数据，通过测试FIFO可以在125MHz频率下全速读写。</p>
<p>以太网测试也是采用比对发送和接收到的数据，由于发送和接收数据无法简单的通过其他的方式高速传输，所以要发送的数据选择有规律的数据。数据选择从0x00开始，下一字节都发送上一个数据加一后的补码，这样可以使每次发送的数据较上一次数据有更多的位会产生变化，通过此方法可以检测出更多的异常数据，若只通过单纯的数据累加测试，无法发现异常数据。经测试，以太网数据在200Mbps带宽下有较好的准确性，丢包现象不常发生，以太网在P2P模式下，全速传输千兆带宽数据时，丢包率为2%左右。</p>
<h4 id="系统稳定性测试"><a href="#系统稳定性测试" class="headerlink" title="系统稳定性测试"></a>系统稳定性测试</h4><p>对本设计经过长时间的稳定性测试，本设计不会产生图像卡顿，回放保存失败等现象，说明本设计具有良好的系统稳定性。</p>
<h3 id="作品展示"><a href="#作品展示" class="headerlink" title="作品展示"></a>作品展示</h3><p>下图为FPGA部分的图片，包含FPGA开发板、图像传感器和麦克风传感器。</p>
<p><img src="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-14.jpg" alt="220501-毕业设计-14.jpg"></p>
<h2 id="总结与不足"><a href="#总结与不足" class="headerlink" title="总结与不足"></a>总结与不足</h2><p>毕业设计是对学生四年所学知识的一次考察，也是对我们四年学习成绩的一次考验。本次毕业设计让我学习了FPGA设计和上位机开发，经过此次毕业设计，我懂得了如何将一整个设计划分成多个小功能逐个实现，在联调的过程中也学习了如何分析问题和解决问题。通过本次毕业设计，让我懂得了学习其实是长期积累的过程，越往深的学会发现自己有越多的不会，所以在今后工作是也要学会敬畏知识，学习是个长期积累的过程，就算毕业工作会我也会持续学习，努力提高自己的综合水平。</p>
<p>本次毕业设计还有几个可以改进的地方：第一，在传输UDP的时候为采用丢包重传，上位机具备发现丢包的能力，可以在丢包发生时将帧序列号发回FPGA，请求FPGA重发数据。第二，上位机软件没有图形化界面，可以使用QT对上位机的图形化界面做开发。第三，FPGA可以尝试设计个MCU，在MCU中跑操作系统和lwip协议栈，使用TCP协议传输语音数据。本设计还有更多功能待完善。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">GPIO输入输出各种模式（推挽、开漏、准双向端口）详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-26 20:00:00 / 修改时间：21:56:10" itemprop="dateCreated datePublished" datetime="2022-04-26T20:00:00+08:00">2022-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>此文章是搬运来的，<a target="_blank" rel="noopener" href="https://blog.csdn.net/techexchangeischeap/article/details/72569999">原地址点击此处</a>，写的真好，能看的非常懂，原作者有个地方可能笔误写错了，做了改正。</p>
<h2 id="输入IO"><a href="#输入IO" class="headerlink" title="输入IO"></a>输入IO</h2><p>这里所说的输入IO，指的是只作为输入，不具有输出功能。此时对于input引脚的要求就是高阻（高阻与三态是同一个概念）。基本输入电路的类型大致可以分为3类：基本输入IO电路、施密特触发输入电路以及弱上拉输入电路。</p>
<p>先从最基本的基本输入IO电路说起，其电路如图 1所示。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-1.jpg" alt="220426-GPIO输入输出各种模式-1.jpg"></p>
<p>其中的缓冲器U1是具有控制输入端，且具有高阻抗特性的三态缓冲器。通俗地说就是这个缓冲器对外来说是高阻的，相当于在控制输入端不使能的情况下，物理引脚与内部总线之间是完全隔离的，完全不会影响内部电路。而控制输入端的作用就是可以发出读Pin状态的操作指令。其过程如图 2所示。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-2.jpg" alt="220426-GPIO输入输出各种模式-2.jpg"></p>
<p>这种基本电路的一个缺点是在读取外部信号的跳变沿时会出现抖动，如下图所示。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-3.jpg" alt="220426-GPIO输入输出各种模式-3.jpg"></p>
<p>于是施密特触发输入电路就是解决了上述这种抖动的问题，其经过施密特触发器后的信号如图 4所示。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-4.jpg" alt="220426-GPIO输入输出各种模式-4.jpg"></p>
<p>对于输入电路还存在另外一个问题，就是当输入引脚悬空的时候，输入端检测到的电平是高还是低？当输入信号没有被驱动，即悬空(Floating)时，输入引脚上任何的噪声都会改变输入端检测到的电平，如图 5所示。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-5.jpg" alt="220426-GPIO输入输出各种模式-5.jpg"></p>
<p>为了解决这个问题，可以在输入引脚处加一个弱上拉电阻，如图 6所示。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-6.jpg" alt="220426-GPIO输入输出各种模式-6.jpg"></p>
<p>这样，当输入引脚悬空时，会被RP上拉到高电平，在内部总线上就有确定的状态了。</p>
<p>但是这种结构是有一定问题的。首先很明显的一点是，当输入引脚悬空时读到的是1，当输入引脚被高电平驱动时读到的也是1，只有当输入引脚被低电平驱动时读到的才是0。也就是对于读1采取的方式是”读取非零”的方式。</p>
<p>另一个问题是该电路对外呈现的不是高阻，某种意义上说也在向外输出，当外部驱动电路不同时可能出现错误的检测结果。例如外部驱动电路是如图 7所示的结构，该电路结构中通过K打到不同端可以输出高电平或者低电平。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-7.jpg" alt="220426-GPIO输入输出各种模式-7.jpg"></p>
<p>如果将如图 7所示的电路输出低电平，连接到带有弱上拉电阻的输入引脚，其结构如下所示。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-8.jpg" alt="220426-GPIO输入输出各种模式-8.jpg"></p>
<p>由欧姆定律知，测试点处的电平是4.545V，于是CPU测得的输入信号为高，而外部驱动电路希望输出的电平为低。这种错误的原因就在于这种结构的输入电路并不是真正的高阻，或者说这个输入IO其实也在输出，而且影响了外部输入电路。</p>
<p>这种情况的发生也说明了：信号前后两级传递，为什么需要输出阻抗小，输入阻抗大的原因。在这个例子中，外围驱动电路的输出阻抗很大，达到了100Kohm;而输入端的阻抗又不够大，只有10Kohm，于是就出现了问题。如果输入端的输入阻抗真正做到高阻（无穷大），如下所示，就不会出现问题。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-9.jpg" alt="220426-GPIO输入输出各种模式-9.jpg"></p>
<p>上面提到的这个带弱上拉的输入电路，也就是在后续章节会提到的准双向端口的情况。</p>
<h2 id="输出IO"><a href="#输出IO" class="headerlink" title="输出IO"></a>输出IO</h2><p>IO输出电路最主要的两种模式分别是推挽输出（Push-Pull Output）和开漏输出（Open Drain Output）。</p>
<h3 id="推挽输出（Push-Pull-Output）"><a href="#推挽输出（Push-Pull-Output）" class="headerlink" title="推挽输出（Push-Pull Output）"></a>推挽输出（Push-Pull Output）</h3><p>推挽输出的结构是由两个三极管或者MOS管受到互补信号的控制，两个管子始终保持一个处于截止，另一个处于导通的状态。如图 10所示。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-10.jpg" alt="220426-GPIO输入输出各种模式-10.jpg"></p>
<p>推挽输出的最大特点是可以真正能真正的输出高电平和低电平，在两种电平下都具有驱动能力。</p>
<p><em><strong>补充说明</strong></em>：所谓的驱动能力，就是指输出电流的能力。对于驱动大负载（即负载内阻越小，负载越大）时，例如IO输出为5V，驱动的负载内阻为10ohm，于是根据欧姆定律可以正常情况下负载上的电流为0.5A（推算出功率为2.5W）。显然一般的IO不可能有这么大的驱动能力，也就是没有办法输出这么大的电流。于是造成的结果就是输出电压会被拉下来，达不到标称的5V。</p>
<p>当然如果只是数字信号的传递，下一级的输入阻抗理论上最好是高阻，也就是只需要传电压，基本没有电流，也就没有功率，于是就不需要很大的驱动能力。</p>
<p>对于推挽输出，输出高、低电平时电流的流向如图 11所示。所以相比于后面介绍的开漏输出，输出高电平时的驱动能力强很多。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-11.jpg" alt="220426-GPIO输入输出各种模式-11.jpg"></p>
<p>但推挽输出的一个缺点是，如果当两个推挽输出结构相连在一起，一个输出高电平，即上面的MOS导通，下面的MOS闭合时；同时另一个输出低电平，即上面的MOS闭合，下面的MOS导通时。电流会从第一个引脚的VCC通过上端MOS再经过第二个引脚的下端MOS直接流向GND。整个通路上电阻很小，会发生短路，进而可能造成端口的损害。这也是为什么推挽输出不能实现” 线与”的原因。</p>
<h3 id="开漏输出（Open-Drain-Output）"><a href="#开漏输出（Open-Drain-Output）" class="headerlink" title="开漏输出（Open Drain Output）"></a>开漏输出（Open Drain Output）</h3><p>常说的与推挽输出相对的就是开漏输出，对于开漏输出和推挽输出的区别最普遍的说法就是开漏输出无法真正输出高电平，即高电平时没有驱动能力，需要借助外部上拉电阻完成对外驱动。下面就从内部结构和原理上说明为什么开漏输出输出高电平时没有驱动能力，以及进一步比较与推挽输出的区别。</p>
<p>首先需要介绍一些开漏输出和开集输出。这两种输出的原理和特性基本是类似的，区别在于一个是使用MOS管，其中的”漏”指的就是MOS管的漏极；另一个使用三极管，其中的”集”指的就是MOS三极管的集电极。这两者其实都是和推挽输出相对应的输出模式，由于使用MOS管的情况较多，很多时候就用”开漏输出”这个词代替了开漏输出和开集输出。</p>
<p>介绍就先从开集输出开始，其原理电路结如图 12所示。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-12.jpg" alt="220426-GPIO输入输出各种模式-12.jpg"></p>
<p>图 12左边的电路是开集（OC）输出最基本的电路，当输入为高电平时，NPN三极管导通，Output被拉到GND，输出为低电平；当输入为低电平时，NPN三极管闭合，Output相当于开路（输出高阻）。高电平时输出高阻（高阻、三态以及floating说的都是一个意思），此时对外没有任何的驱动能力。这就是开漏和开集输出最大的特点，如何利用该特点完成各种功能稍后介绍。这个电路虽然完成了开集输出的功能，但是会出现input为高，输出为低；input为低，输出为高的情况。</p>
<p>图 12右边的电路中多使用了一个三极管完成了”反相”。当输入为高电平时，第一个三极管导通，此时第二个三极管的输入端会被拉到GND，于是第二个三极管闭合，输出高阻；当输入为低电平时，第一个三极管闭合，此时第二个三极管的输入端会被上拉电阻拉到高电平，于是第二个三极管导通，输出被拉到GND。这样，这个电路的输入与输出是同相的了。</p>
<p>接下来介绍开漏输出的电路，如图 13所示。原理与开集输出基本相同，只是将三极管换成了MOS而已。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-13.jpg" alt="220426-GPIO输入输出各种模式-13.jpg"></p>
<p>接着说说开漏、开集输出的特点以及应用，由于两者相似，后文中若无特殊说明，则用开漏表示开漏和开集输出电路。</p>
<ol>
<li><p>开漏输出最主要的特性就是高电平没有驱动能力，需要借助外部上拉电阻才能真正输出高电平，其电路如图 14所示。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-14.jpg" alt="220426-GPIO输入输出各种模式-14.jpg"></p>
</li>
</ol>
<p>当MOS管<em><strong>断开</strong></em>时，开漏输出电路输出高电平，且连接着负载时，电流流向是从外部电源，流经上来电阻RPU，流进负载，最后进入GND。</p>
<ol>
<li>开漏输出的这一特性一个明显的优势就是可以很方便的调节输出的电平，因为输出电平完全由上拉电阻连接的电源电平决定。所以在需要进行电平转换的地方，非常适合使用开漏输出。</li>
<li>开漏输出的这一特性另一个好处在于可以实现”线与”功能，所谓的”线与”指的是多个信号线直接连接在一起，只有当所有信号全部为高电平时，合在一起的总线为高电平；只要有任意一个或者多个信号为低电平，则总线为低电平。而推挽输出就不行，如果高电平和低电平连在一起，会出现电流倒灌，损坏器件。</li>
</ol>
<h3 id="推挽与开漏输出的区别"><a href="#推挽与开漏输出的区别" class="headerlink" title="推挽与开漏输出的区别"></a>推挽与开漏输出的区别</h3><p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-15.jpg" alt="220426-GPIO输入输出各种模式-15.jpg"></p>
<h2 id="双向IO"><a href="#双向IO" class="headerlink" title="双向IO"></a>双向IO</h2><p>很多处理器的引脚可以设置为双向端口，双向端口的要求就是既可以输出信号，又可以读回外部信号输入。要同时做到这两点从原理上来说有点困难，首先从处理器的开漏输出IO口的内部结构说起，如图 16所示。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-16.jpg" alt="220426-GPIO输入输出各种模式-16.jpg"></p>
<p>该结构是在图 13的基础上，在三极管之前加入了一个FF，目的是用于控制输出信号的时间。比较常见的一个应用场合是多个IO作为一个总线时，需要总线上的各个引脚同时将数据输出。</p>
<p>对于开漏输出结构，会将FF的输出Q端连接会输入驱动缓冲器，这样的话执行读操作是读的并不是外部引脚的状态，而是自己输出的状态。</p>
<h3 id="双向开漏IO"><a href="#双向开漏IO" class="headerlink" title="双向开漏IO"></a>双向开漏IO</h3><p>但是对图 16的结构稍作修改，如图 17所示时，该结构称为双向开漏IO的结构。所做的改动是将输入驱动缓冲器连接到了PIN上。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-17.jpg" alt="220426-GPIO输入输出各种模式-17.jpg"></p>
<p>该结构输出为”1”时，T1断开，此时pin对外呈现高阻，作为输入引脚没有任何问题。但是如果该结构输出”0”时，T1导通，此时pin对外短路到地，即无论外部输入什么信号，U2读回的全部是低。所以对于这样的结构，如果需要作为输入引脚使用时，必须给U1输出”1”后才能读取外部引脚数据。</p>
<h3 id="准双向开漏IO"><a href="#准双向开漏IO" class="headerlink" title="准双向开漏IO"></a>准双向开漏IO</h3><p>很多文献中还提到了准双向端口，其实准双向端口就是图 17的结构中加了一个上拉电阻，如图 18所示。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-18.jpg" alt="220426-GPIO输入输出各种模式-18.jpg"></p>
<p>这个结构与图 17相比有以下相同与不同之处：</p>
<ol>
<li>作为输入引脚使用时，也必须先向U1中写”1”，以达到断开T1的目的。所以是否需要提前写”1”并不是双向IO与准双向IO的区别。两者做输入端口时都需要提前写”1”。</li>
<li>双向端口作为输入时是真正的高阻态，而准双向IO作为输入端口时，输入阻抗不为高阻，于是有可能出现如本文图 8所示的问题。</li>
<li>准双向端口读取输入状态，默认为高。也就是判断外部输入信号的方法是”非低则为高”。即该结构只能准确的识别外部的低电平，无法区分悬空和真正的高。于是只要读到的不是0，都认为外部为1。</li>
</ol>
<h3 id="推挽输出作为双向IO"><a href="#推挽输出作为双向IO" class="headerlink" title="推挽输出作为双向IO"></a>推挽输出作为双向IO</h3><p>如果双向端口中的输出部分采用的是推挽输出结构，那么作为输入时必须将上下两个管子全部端口才能成为高阻，作为输入。</p>
<h3 id="51单片机的P0端口"><a href="#51单片机的P0端口" class="headerlink" title="51单片机的P0端口"></a>51单片机的P0端口</h3><p>在双向端口的讨论中，比较复杂的就是51单片机的P0端口了。这里就详细讨论一下51单片机的P0端口结构和工作原理。</p>
<p>P0端口的内部结构如图 19所示。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-19.jpg" alt="220426-GPIO输入输出各种模式-19.jpg"></p>
<p>内部结构比较复杂，包括以下这些器件：</p>
<ol>
<li>U1：与门。一个输入连着控制线，另一个输入连接这地址/数据信号。由于与门的特性，当控制线为1时，与门输出与地址/数据信号的电平保持一致；如果控制线为0，则输出恒为。于是控制信号线相当于与门的使能信号。</li>
<li>U2：反相器，输出信号为地址/数据信号的反相信号。</li>
<li>U3和U6都是具有控制输入端且具有高阻抗特性的三态缓冲器，作用是对于外部呈现高阻态。当控制端使能时可以将外部信号的电平读进数据总线。</li>
<li>U4：为锁存器，目的就是控制引脚输出信号的时间。</li>
<li>U5：模拟开关，可以控制V2的输入信号是来自锁存器U4的Q非输出还是来自于反相器U2的输出。</li>
<li>V1和V2分别是两个MOS管。</li>
</ol>
<p>了解了各个独立器件之后就开始介绍工作在各个模式下的工作原理：</p>
<p><strong>P0用于地址/数据线时：</strong></p>
<p>在P0作为地址/数据线时，是地址、数据复用总线，P0需要输出地址，同时需要读回数据信号。</p>
<p>当P0需要输出地址信息时，U1的控制信号为0，模拟开关U5接到U2反相器的输出。于是当地址信号线传来的信号为1，与控制线”1”相与之后输出到V1的输入信号为”0”，V1截止。地址信号”1”经反相之后，通过模拟开关输出到V2的输入端为”1”，V2导通，于是情况如图 20所示，pin输出”0”。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-20.jpg" alt="220426-GPIO输入输出各种模式-20.jpg"></p>
<p>当地址信号线传来的信号为1，与控制线”1”相与之后输出到V1的输入信号为”1”，V1导通。地址信号”0”经反相之后，通过模拟开关输出到V2的输入端为”0”，V2截止，于是情况如图 21所示，pin输出”1”。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-21.jpg" alt="220426-GPIO输入输出各种模式-21.jpg"></p>
<p>于是在作为地址线输出时，V1、V2两个MOS管均使用了，是推挽输出。</p>
<p>当P0在输出低8位地址信息后，将变为数据总线，此时CPU的操作是控制端输出0，模拟开关打到锁存器的Q非端，且向锁存器中打入”1”。于是Q非输出为0，V2截止。同时控制线为0使得与门输出为0，V1截止。由于V1和V2都截止，所以此时pin对外完全呈现高阻，作为输入端口，外部数据通过U6进入内部总线，情况如图 22所示。（相当于将推挽输出的两个MOS管全部断开了）此时由于对外呈现高阻，所以是真正的输入引脚。这就解释了为什么说P0是真正的双线端口。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-22.jpg" alt="220426-GPIO输入输出各种模式-22.jpg"></p>
<p><strong>P0用于普通IO时：</strong></p>
<p>在P0作为普通IO并作为输出时，控制信号为0，使V1始终处于截止状态。模拟开关连接到Q非输出，当作为输出时，锁存器的输入端直接输入0或者1，Q非将反相信号输入到V2的输入端。即当输出”0”时，V2输入端为”1”，V2导通，pin输出”0”；当输出”1”时，V2输入端为”0”，V2截止，pin输出高阻的0。即当P0工作在普通IO模式下，输出为开漏输出，且内部没有上拉电阻。</p>
<p>在P0作为普通IO并作为输入时，控制信号为0，使V1始终处于截止状态。模拟开关连接到Q非输出，且CPU自动向锁存器输入端写1，则V2输入端为0，V2截止。与之前在作为地址/数据线，作为输入时一样，也是两个MOS管全部断开，pin直接连接到U6，对外呈现高阻。于是也是真正的输入引脚。</p>
<p>综上P0无论工作在哪种模式下都是真正的双端口IO。</p>
<h3 id="51单片机的P1～P3端口"><a href="#51单片机的P1～P3端口" class="headerlink" title="51单片机的P1～P3端口"></a>51单片机的P1～P3端口</h3><p>51单片机的其他三个端口的内部结构如图 23所示，与P0相比简单了很多，没有了顶部的MOS管，也没有了地址/数据信号的选项。作为输出时是带有上拉电阻的的开漏输出，作为输入时是有上拉电阻存在的，于是输入端口对外不是高阻。这就解释了为什么P1～P3只能是准双向端口。</p>
<p><img src="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-23.jpg" alt="220426-GPIO输入输出各种模式-23.jpg"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao</p>
  <div class="site-description" itemprop="description">保持热爱，奔赴山海。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">46</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
