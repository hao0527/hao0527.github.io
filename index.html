<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/heng32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/heng16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="保持热爱，奔赴山海。">
<meta property="og:type" content="website">
<meta property="og:title" content="永恆博客网">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="永恆博客网">
<meta property="og:description" content="保持热爱，奔赴山海。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>永恆博客网</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">永恆博客网</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/25/230625-Linux%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/25/230625-Linux%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/" class="post-title-link" itemprop="url">Linux 内核代码风格</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-25 16:00:00" itemprop="dateCreated datePublished" datetime="2023-06-25T16:00:00+08:00">2023-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-04 09:28:41" itemprop="dateModified" datetime="2023-07-04T09:28:41+08:00">2023-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Chinese translated version of Documentation/process/coding-style.rst</p>
<p>If you have any comment or update to the content, please post to LKML directly. However, if you have problem communicating in English you can also ask the Chinese maintainer for help. Contact the Chinese maintainer, if this translation is outdated or there is problem with translation.</p>
<p>Chinese maintainer: Zhang Le &lt;<a href="mailto:r0bertz@gentoo.org">r0bertz@gentoo.org</a>&gt;</p>
<hr>
<p>Documentation/process/coding-style.rst 的中文翻译</p>
<p>如果想评论或更新本文的内容，请直接发信到LKML。如果你使用英文交流有困难的话， 也可以向中文版维护者求助。如果本翻译更新不及时或者翻译存在问题，请联系中文版 维护者:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">中文版维护者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</span><br><span class="line">中文版翻译者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</span><br><span class="line">中文版校译者： 王聪 Wang Cong &lt;xiyou.wangcong@gmail.com&gt;</span><br><span class="line">               wheelz &lt;kernel.zeng@gmail.com&gt;</span><br><span class="line">               管旭东 Xudong Guan &lt;xudong.guan@gmail.com&gt;</span><br><span class="line">               Li Zefan &lt;lizf@cn.fujitsu.com&gt;</span><br><span class="line">               Wang Chen &lt;wangchen@cn.fujitsu.com&gt;</span><br></pre></td></tr></table></figure>

<p>以下为正文</p>
<hr>
<h1 id="Linux-内核代码风格"><a href="#Linux-内核代码风格" class="headerlink" title="Linux 内核代码风格"></a>Linux 内核代码风格</h1><p>这是一个简短的文档，描述了 linux 内核的首选代码风格。代码风格是因人而异的， 而且我不愿意把自己的观点强加给任何人，但这就像我去做任何事情都必须遵循的原则 那样，我也希望在绝大多数事上保持这种的态度。请 (在写代码时) 至少考虑一下这里 的代码风格。</p>
<p>首先，我建议你打印一份 GNU 代码规范，然后不要读。烧了它，这是一个具有重大象征性意义的动作。</p>
<p>不管怎样，现在我们开始：</p>
<h2 id="1-缩进"><a href="#1-缩进" class="headerlink" title="1) 缩进"></a>1) 缩进</h2><p>制表符是 8 个字符，所以缩进也是 8 个字符。有些异端运动试图将缩进变为 4 (甚至 2！) 字符深，这几乎相当于尝试将圆周率的值定义为 3。</p>
<p>理由：缩进的全部意义就在于清楚的定义一个控制块起止于何处。尤其是当你盯着你的 屏幕连续看了 20 小时之后，你将会发现大一点的缩进会使你更容易分辨缩进。</p>
<p>现在，有些人会抱怨 8 个字符的缩进会使代码向右边移动的太远，在 80 个字符的终端屏幕上就很难读这样的代码。这个问题的答案是，如果你需要 3 级以上的缩进，不管用 何种方式你的代码已经有问题了，应该修正你的程序。</p>
<p>简而言之，<u>8 个字符的缩进可以让代码更容易阅读，还有一个好处是当你的函数嵌套太深的时候可以给你警告。留心这个警告</u>。</p>
<p>在 switch 语句中消除多级缩进的首选的方式是让 <code>switch</code> 和从属于它的 <code>case</code> 标签对齐于同一列，而不要 <code>两次缩进</code> <code>case</code> 标签。比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (suffix) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">        mem &lt;&lt;= <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">        mem &lt;&lt;= <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:</span><br><span class="line">        mem &lt;&lt;= <span class="number">10</span>;</span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要把多个语句放在一行里，除非你有什么东西要隐藏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) do_this;</span><br><span class="line">  do_something_everytime;</span><br></pre></td></tr></table></figure>

<p>也不要在一行里放多个赋值语句。内核代码风格超级简单。就是避免可能导致别人误读 的表达式。</p>
<p>除了注释、文档和 Kconfig 之外，不要使用空格来缩进，前面的例子是例外，是有意为 之。</p>
<p>选用一个好的编辑器，不要在行尾留空格。</p>
<h2 id="2-把长的行和字符串打散"><a href="#2-把长的行和字符串打散" class="headerlink" title="2) 把长的行和字符串打散"></a>2) 把长的行和字符串打散</h2><p>代码风格的意义就在于使用平常使用的工具来维持代码的可读性和可维护性。</p>
<p>每一行的长度的限制是 80 列，我们强烈建议您遵守这个惯例。</p>
<p>长于 80 列的语句要打散成有意义的片段。除非超过 80 列能显著增加可读性，并且不 会隐藏信息。子片段要明显短于母片段，并明显靠右。这同样适用于有着很长参数列表 的函数头。然而，绝对不要打散对用户可见的字符串，例如 printk 信息，因为这样就 很难对它们 grep。</p>
<h2 id="3-大括号和空格的放置"><a href="#3-大括号和空格的放置" class="headerlink" title="3) 大括号和空格的放置"></a>3) 大括号和空格的放置</h2><p>C 语言风格中另外一个常见问题是大括号的放置。和缩进大小不同，选择或弃用某种放置策略并没有多少技术上的原因，不过首选的方式，就像 Kernighan 和 Ritchie 展示 给我们的，是把起始大括号放在行尾，而把结束大括号放在行首，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (x is true) &#123;</span><br><span class="line">        we do y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这适用于所有的非函数语句块 (if, switch, for, while, do)。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (action) &#123;</span><br><span class="line">case KOBJ_ADD:</span><br><span class="line">        return &quot;add&quot;;</span><br><span class="line">case KOBJ_REMOVE:</span><br><span class="line">        return &quot;remove&quot;;</span><br><span class="line">case KOBJ_CHANGE:</span><br><span class="line">        return &quot;change&quot;;</span><br><span class="line">default:</span><br><span class="line">        return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，有一个例外，那就是函数：函数的起始大括号放置于下一行的开头，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int function(int x)</span><br><span class="line">&#123;</span><br><span class="line">        body of function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全世界的异端可能会抱怨这个不一致性是… 呃… 不一致的，不过所有思维健全的人 都知道 (a) K&amp;R 是 <strong>正确的</strong> 并且 (b) K&amp;R 是正确的。此外，不管怎样函数都是特 殊的 (C 函数是不能嵌套的)。</p>
<p>注意结束大括号独自占据一行，除非它后面跟着同一个语句的剩余部分，也就是 do 语 句中的 “while” 或者 if 语句中的 “else”，像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">        body of do-loop</span><br><span class="line">&#125; while (condition);</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (x == y) &#123;</span><br><span class="line">        ..</span><br><span class="line">&#125; else if (x &gt; y) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理由：K&amp;R。</p>
<p>也请注意这种大括号的放置方式也能使空 (或者差不多空的) 行的数量最小化，同时不失可读性。因此，由于你的屏幕上的新行是不可再生资源 (想想 25 行的终端屏幕)，你 将会有更多的空行来放置注释。</p>
<p>当只有一个单独的语句的时候，不用加不必要的大括号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">        action();</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">        do_this();</span><br><span class="line">else</span><br><span class="line">        do_that();</span><br></pre></td></tr></table></figure>

<p>这并不适用于只有一个条件分支是单语句的情况；这时所有分支都要使用大括号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">        do_this();</span><br><span class="line">        do_that();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        otherwise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-空格"><a href="#3-1-空格" class="headerlink" title="3.1) 空格"></a>3.1) 空格</h3><p>Linux 内核的空格使用方式 (主要) 取决于它是用于函数还是关键字。(大多数) 关键字后要加一个空格。值得注意的例外是 sizeof, typeof, alignof 和 __attribute__，这 些关键字某些程度上看起来更像函数 (它们在 Linux 里也常常伴随小括号而使用，尽管 在 C 里这样的小括号不是必需的，就像 <code>struct fileinfo info;</code> 声明过后的 <code>sizeof info</code>)。</p>
<p>所以在这些关键字之后放一个空格:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if, switch, case, for, do, while</span><br></pre></td></tr></table></figure>

<p>但是不要在 sizeof, typeof, alignof 或者 <strong>attribute</strong> 这些关键字之后放空格。 例如，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = sizeof(struct file);</span><br></pre></td></tr></table></figure>

<p>不要在小括号里的表达式两侧加空格。这是一个 <strong>反例</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = sizeof( struct file );</span><br></pre></td></tr></table></figure>

<p><u>当声明指针类型或者返回指针类型的函数时， <code>*</code> 的首选使用方式是使之靠近变量名或者函数名，而不是靠近类型名</u>。例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *linux_banner;</span><br><span class="line">unsigned long long memparse(char *ptr, char **retptr);</span><br><span class="line">char *match_strdup(substring_t *s);</span><br></pre></td></tr></table></figure>

<p><u>在大多数二元和三元操作符两侧使用一个空格</u>，例如下面所有这些操作符:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=  +  -  &lt;  &gt;  *  /  %  |  &amp;  ^  &lt;=  &gt;=  ==  !=  ?  :</span><br></pre></td></tr></table></figure>

<p><u>但是一元操作符后不要加空格</u>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined</span><br></pre></td></tr></table></figure>

<p>后缀自加和自减一元操作符前不加空格:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++  --</span><br></pre></td></tr></table></figure>

<p>前缀自加和自减一元操作符后不加空格:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++  --</span><br></pre></td></tr></table></figure>

<p><code>.</code> 和 <code>-&gt;</code> 结构体成员操作符前后不加空格。</p>
<p>不要在行尾留空白。有些可以自动缩进的编辑器会在新行的行首加入适量的空白，然后 你就可以直接在那一行输入代码。不过假如你最后没有在那一行输入代码，有些编辑器 就不会移除已经加入的空白，就像你故意留下一个只有空白的行。包含行尾空白的行就 这样产生了。</p>
<p>当 git 发现补丁包含了行尾空白的时候会警告你，并且可以应你的要求去掉行尾空白； 不过如果你是正在打一系列补丁，这样做会导致后面的补丁失败，因为你改变了补丁的上下文。</p>
<h2 id="4-命名"><a href="#4-命名" class="headerlink" title="4) 命名"></a>4) 命名</h2><p>C 是一个简朴的语言，你的命名也应该这样。和 Modula-2 和 Pascal 程序员不同， C 程序员不使用类似 ThisVariableIsATemporaryCounter 这样华丽的名字。C 程序员会 称那个变量为 <code>tmp</code> ，这样写起来会更容易，而且至少不会令其难于理解。</p>
<p>不过，虽然混用大小写的名字是不提倡使用的，但是全局变量还是需要一个具描述性的名字。称一个全局函数为 <code>foo</code> 是一个难以饶恕的错误。</p>
<p>全局变量 (只有当你 <strong>真正</strong> 需要它们的时候再用它) 需要有一个具描述性的名字，就像全局函数。如果你有一个可以计算活动用户数量的函数，你应该叫它 <code>count_active_users()</code> 或者类似的名字，你不应该叫它 <code>cntuser()</code> 。</p>
<p>在函数名中包含函数类型 (所谓的匈牙利命名法) 是脑子出了问题——编译器知道那些类 型而且能够检查那些类型，这样做只能把程序员弄糊涂了。难怪微软总是制造出有问题的程序。</p>
<p>本地变量名应该简短，而且能够表达相关的含义。如果你有一些随机的整数型的循环计数器，它应该被称为 <code>i</code> 。叫它 <code>loop_counter</code> 并无益处，如果它没有被误解的可能的话。类似的， <code>tmp</code> 可以用来称呼任意类型的临时变量。</p>
<p>如果你怕混淆了你的本地变量名，你就遇到另一个问题了，叫做函数增长荷尔蒙失衡综合症。请看第六章 (函数)。</p>
<h2 id="5-Typedef"><a href="#5-Typedef" class="headerlink" title="5) Typedef"></a>5) Typedef</h2><p>不要使用类似 <code>vps_t</code> 之类的东西。</p>
<p>对结构体和指针使用 typedef 是一个 <strong>错误</strong> 。当你在代码里看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vps_t a;</span><br></pre></td></tr></table></figure>

<p>这代表什么意思呢？</p>
<p>相反，如果是这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct virtual_container *a;</span><br></pre></td></tr></table></figure>

<p>你就知道 <code>a</code> 是什么了。</p>
<p>很多人认为 typedef <code>能提高可读性</code> 。实际不是这样的。它们只在下列情况下有用：</p>
<blockquote>
<ol>
<li><p>完全不透明的对象 (这种情况下要主动使用 typedef 来 <strong>隐藏</strong> 这个对象实际上是什么)。</p>
<p>例如： <code>pte_t</code> 等不透明对象，你只能用合适的访问函数来访问它们。</p>
<p>Note：不透明性和 “访问函数” 本身是不好的。我们使用 pte_t 等类型的原因在于真的是完全没有任何共用的可访问信息。</p>
</li>
<li><p>清楚的整数类型，如此，这层抽象就可以 <strong>帮助</strong> 消除到底是 <code>int</code> 还是 <code>long</code> 的混淆。</p>
<p>u8/u16/u32 是完全没有问题的 typedef，不过它们更符合类别 (d) 而不是这里。</p>
<p>Note：要这样做，必须事出有因。如果某个变量是 <code>unsigned long</code> ，那么没有必要 typedef unsigned long myflags_t;</p>
<p>不过如果有一个明确的原因，比如它在某种情况下可能会是一个 <code>unsigned int</code> 而在其他情况下可能为 <code>unsigned long</code> ，那么就不要犹豫，请务必使用 typedef。</p>
</li>
<li><p>当你使用 sparse 按字面的创建一个 <strong>新</strong> 类型来做类型检查的时候。</p>
</li>
<li><p>和标准 C99 类型相同的类型，在某些例外的情况下。</p>
<p>虽然让眼睛和脑筋来适应新的标准类型比如 <code>uint32_t</code> 不需要花很多时间，可是有些人仍然拒绝使用它们。</p>
<p>因此，Linux 特有的等同于标准类型的 <code>u8/u16/u32/u64</code> 类型和它们的有符号类型是被允许的——尽管在你自己的新代码中，它们不是强制要求要使用的。</p>
<p>当编辑已经使用了某个类型集的已有代码时，你应该遵循那些代码中已经做出的选择。</p>
</li>
<li><p>可以在用户空间安全使用的类型。</p>
<p>在某些用户空间可见的结构体里，我们不能要求 C99 类型而且不能用上面提到的 <code>u32</code> 类型。因此，我们在与用户空间共享的所有结构体中使用 __u32 和类似 的类型。</p>
</li>
</ol>
</blockquote>
<p>可能还有其他的情况，不过基本的规则是 <strong>永远不要</strong> 使用 typedef，除非你可以明确的应用上述某个规则中的一个。</p>
<p>总的来说，如果一个指针或者一个结构体里的元素可以合理的被直接访问到，那么它们就不应该是一个 typedef。</p>
<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6) 函数"></a>6) 函数</h2><p><u>函数应该简短而漂亮，并且只完成一件事情</u>。函数应该可以一屏或者两屏显示完 (我们 都知道 ISO/ANSI 屏幕大小是 80x24)，只做一件事情，而且把它做好。</p>
<p>一个函数的最大长度是和该函数的复杂度和缩进级数成反比的。所以，如果你有一个理论上很简单的只有一个很长 (但是简单) 的 case 语句的函数，而且你需要在每个 case 里做很多很小的事情，这样的函数尽管很长，但也是可以的。</p>
<p>不过，如果你有一个复杂的函数，而且你怀疑一个天分不是很高的高中一年级学生可能甚至搞不清楚这个函数的目的，你应该严格遵守前面提到的长度限制。使用辅助函数， 并为之取个具描述性的名字 (如果你觉得它们的性能很重要的话，可以让编译器内联它们，这样的效果往往会比你写一个复杂函数的效果要好。)</p>
<p>函数的另外一个衡量标准是本地变量的数量。此数量不应超过 5－10 个，否则你的函数 就有问题了。重新考虑一下你的函数，把它分拆成更小的函数。人的大脑一般可以轻松的同时跟踪 7 个不同的事物，如果再增多的话，就会糊涂了。即便你聪颖过人，你也可能会记不清你 2 个星期前做过的事情。</p>
<p>在源文件里，使用空行隔开不同的函数。如果该函数需要被导出，它的 <strong>EXPORT</strong> 宏 应该紧贴在它的结束大括号之下。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int system_is_up(void)</span><br><span class="line">&#123;</span><br><span class="line">        return system_state == SYSTEM_RUNNING;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(system_is_up);</span><br></pre></td></tr></table></figure>

<p>在函数原型中，包含函数名和它们的数据类型。虽然 C 语言里没有这样的要求，在 Linux 里这是提倡的做法，因为这样可以很简单的给读者提供更多的有价值的信息。</p>
<h2 id="7-集中的函数退出途径"><a href="#7-集中的函数退出途径" class="headerlink" title="7) 集中的函数退出途径"></a>7) 集中的函数退出途径</h2><p>虽然被某些人声称已经过时，但是 goto 语句的等价物还是经常被编译器所使用，具体形式是无条件跳转指令。</p>
<p>当一个函数从多个位置退出，并且需要做一些类似清理的常见操作时，goto 语句就很方便了。如果并不需要清理操作，那么直接 return 即可。</p>
<p>选择一个能够说明 goto 行为或它为何存在的标签名。如果 goto 要释放 <code>buffer</code>, 一个不错的名字可以是 <code>out_free_buffer:</code> 。别去使用像 <code>err1:</code> 和 <code>err2:</code> 这样的GW_BASIC 名称，因为一旦你添加或删除了 (函数的) 退出路径，你就必须对它们重新编号，这样会难以去检验正确性。</p>
<p>使用 goto 的理由是：</p>
<ul>
<li>无条件语句容易理解和跟踪</li>
<li>嵌套程度减小</li>
<li>可以避免由于修改时忘记更新个别的退出点而导致错误</li>
<li>让编译器省去删除冗余代码的工作 ;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int fun(int a)</span><br><span class="line">&#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        char *buffer;</span><br><span class="line"></span><br><span class="line">        buffer = kmalloc(SIZE, GFP_KERNEL);</span><br><span class="line">        if (!buffer)</span><br><span class="line">                return -ENOMEM;</span><br><span class="line"></span><br><span class="line">        if (condition1) &#123;</span><br><span class="line">                while (loop1) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                &#125;</span><br><span class="line">                result = 1;</span><br><span class="line">                goto out_free_buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">out_free_buffer:</span><br><span class="line">        kfree(buffer);</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个需要注意的常见错误是 <code>一个 err 错误</code> ，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err:</span><br><span class="line">        kfree(foo-&gt;bar);</span><br><span class="line">        kfree(foo);</span><br><span class="line">        return ret;</span><br></pre></td></tr></table></figure>

<p>这段代码的错误是，在某些退出路径上 <code>foo</code> 是 NULL。通常情况下，通过把它分离 成两个错误标签 <code>err_free_bar:</code> 和 <code>err_free_foo:</code> 来修复这个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err_free_bar:</span><br><span class="line">       kfree(foo-&gt;bar);</span><br><span class="line">err_free_foo:</span><br><span class="line">       kfree(foo);</span><br><span class="line">       return ret;</span><br></pre></td></tr></table></figure>

<p>理想情况下，你应该模拟错误来测试所有退出路径。</p>
<h2 id="8-注释"><a href="#8-注释" class="headerlink" title="8) 注释"></a>8) 注释</h2><p>注释是好的，不过有过度注释的危险。永远不要在注释里解释你的代码是如何运作的： 更好的做法是让别人一看你的代码就可以明白，<u>解释写的很差的代码是浪费时间</u>。</p>
<p>一般的，你想要你的注释告诉别人你的代码做了什么，而不是怎么做的。也请你不要把注释放在一个函数体内部：如果函数复杂到你需要独立的注释其中的一部分，你很可能需要回到第六章看一看。你可以做一些小注释来注明或警告某些很聪明 (或者槽糕) 的做法，但不要加太多。你应该做的，是把注释放在函数的头部，告诉人们它做了什么， 也可以加上它做这些事情的原因。</p>
<p>当注释内核 API 函数时，请使用 kernel-doc 格式。请看 Documentation/doc-guide/ 和 scripts/kernel-doc 以获得详细信息。</p>
<p>长 (多行) 注释的首选风格是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This is the preferred style for multi-line</span><br><span class="line"> * comments in the Linux kernel source code.</span><br><span class="line"> * Please use it consistently.</span><br><span class="line"> *</span><br><span class="line"> * Description:  A column of asterisks on the left side,</span><br><span class="line"> * with beginning and ending almost-blank lines.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>对于在 net/ 和 drivers/net/ 的文件，首选的长 (多行) 注释风格有些不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* The preferred comment style for files in net/ and drivers/net</span><br><span class="line"> * looks like this.</span><br><span class="line"> *</span><br><span class="line"> * It is nearly the same as the generally preferred comment style,</span><br><span class="line"> * but there is no initial almost-blank line.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>注释数据也是很重要的，不管是基本类型还是衍生类型。为了方便实现这一点，每一行 应只声明一个数据 (不要使用逗号来一次声明多个数据)。这样你就有空间来为每个数据 写一段小注释来解释它们的用途了。</p>
<h2 id="9-你已经把事情弄糟了"><a href="#9-你已经把事情弄糟了" class="headerlink" title="9) 你已经把事情弄糟了"></a>9) 你已经把事情弄糟了</h2><p>这没什么，我们都是这样。可能你的使用了很长时间 Unix 的朋友已经告诉你 <code>GNU emacs</code> 能自动帮你格式化 C 源代码，而且你也注意到了，确实是这样，不过它 所使用的默认值和我们想要的相去甚远 (实际上，甚至比随机打的还要差——无数个猴子 在 GNU emacs 里打字永远不会创造出一个好程序) (译注：Infinite Monkey Theorem)</p>
<p>所以你要么放弃 GNU emacs，要么改变它让它使用更合理的设定。要采用后一个方案， 你可以把下面这段粘贴到你的 .emacs 文件里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(defun c-lineup-arglist-tabs-only (ignored)</span><br><span class="line">  &quot;Line up argument lists by tabs, not spaces&quot;</span><br><span class="line">  (let* ((anchor (c-langelem-pos c-syntactic-element))</span><br><span class="line">         (column (c-langelem-2nd-pos c-syntactic-element))</span><br><span class="line">         (offset (- (1+ column) anchor))</span><br><span class="line">         (steps (floor offset c-basic-offset)))</span><br><span class="line">    (* (max steps 1)</span><br><span class="line">       c-basic-offset)))</span><br><span class="line"></span><br><span class="line">(add-hook &#x27;c-mode-common-hook</span><br><span class="line">          (lambda ()</span><br><span class="line">            ;; Add kernel style</span><br><span class="line">            (c-add-style</span><br><span class="line">             &quot;linux-tabs-only&quot;</span><br><span class="line">             &#x27;(&quot;linux&quot; (c-offsets-alist</span><br><span class="line">                        (arglist-cont-nonempty</span><br><span class="line">                         c-lineup-gcc-asm-reg</span><br><span class="line">                         c-lineup-arglist-tabs-only))))))</span><br><span class="line"></span><br><span class="line">(add-hook &#x27;c-mode-hook</span><br><span class="line">          (lambda ()</span><br><span class="line">            (let ((filename (buffer-file-name)))</span><br><span class="line">              ;; Enable kernel mode for the appropriate files</span><br><span class="line">              (when (and filename</span><br><span class="line">                         (string-match (expand-file-name &quot;~/src/linux-trees&quot;)</span><br><span class="line">                                       filename))</span><br><span class="line">                (setq indent-tabs-mode t)</span><br><span class="line">                (setq show-trailing-whitespace t)</span><br><span class="line">                (c-set-style &quot;linux-tabs-only&quot;)))))</span><br></pre></td></tr></table></figure>

<p>这会让 emacs 在 <code>~/src/linux-trees</code> 下的 C 源文件获得更好的内核代码风格。</p>
<p>不过就算你尝试让 emacs 正确的格式化代码失败了，也并不意味着你失去了一切：还可以用 <code>indent</code> 。</p>
<p>不过，GNU indent 也有和 GNU emacs 一样有问题的设定，所以你需要给它一些命令选项。不过，这还不算太糟糕，因为就算是 GNU indent 的作者也认同 K&amp;R 的权威性 (GNU 的人并不是坏人，他们只是在这个问题上被严重的误导了)，所以你只要给 indent 指定选项 <code>-kr -i8</code> (代表 <code>K&amp;R，8 字符缩进</code>)，或使用 <code>scripts/Lindent</code> 这样就可以以最时髦的方式缩进源代码。</p>
<p><code>indent</code> 有很多选项，特别是重新格式化注释的时候，你可能需要看一下它的手册。 不过记住： <code>indent</code> 不能修正坏的编程习惯。</p>
<h2 id="10-Kconfig-配置文件"><a href="#10-Kconfig-配置文件" class="headerlink" title="10) Kconfig 配置文件"></a>10) Kconfig 配置文件</h2><p>对于遍布源码树的所有 Kconfig* 配置文件来说，它们缩进方式有所不同。紧挨着 <code>config</code> 定义的行，用一个制表符缩进，然而 help 信息的缩进则额外增加 2 个空格。举个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config AUDIT</span><br><span class="line">      bool &quot;Auditing support&quot;</span><br><span class="line">      depends on NET</span><br><span class="line">      help</span><br><span class="line">        Enable auditing infrastructure that can be used with another</span><br><span class="line">        kernel subsystem, such as SELinux (which requires this for</span><br><span class="line">        logging of avc messages output).  Does not do system-call</span><br><span class="line">        auditing without CONFIG_AUDITSYSCALL.</span><br></pre></td></tr></table></figure>

<p>而那些危险的功能 (比如某些文件系统的写支持) 应该在它们的提示字符串里显著的声 明这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config ADFS_FS_RW</span><br><span class="line">      bool &quot;ADFS write support (DANGEROUS)&quot;</span><br><span class="line">      depends on ADFS_FS</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>要查看配置文件的完整文档，请看 Documentation/kbuild/kconfig-language.txt。</p>
<h2 id="11-数据结构"><a href="#11-数据结构" class="headerlink" title="11) 数据结构"></a>11) 数据结构</h2><p>如果一个数据结构，在创建和销毁它的单线执行环境之外可见，那么它必须要有一个引用计数器。内核里没有垃圾收集 (并且内核之外的垃圾收集慢且效率低下)，这意味着你绝对需要记录你对这种数据结构的使用情况。</p>
<p>引用计数意味着你能够避免上锁，并且允许多个用户并行访问这个数据结构——而不需要担心这个数据结构仅仅因为暂时不被使用就消失了，那些用户可能不过是沉睡了一阵或者做了一些其他事情而已。</p>
<p>注意上锁 <strong>不能</strong> 取代引用计数。上锁是为了保持数据结构的一致性，而引用计数是一个内存管理技巧。通常二者都需要，不要把两个搞混了。</p>
<p>很多数据结构实际上有 2 级引用计数，它们通常有不同 <code>类</code> 的用户。子类计数器统计子类用户的数量，每当子类计数器减至零时，全局计数器减一。</p>
<p>这种 <code>多级引用计数</code> 的例子可以在内存管理 (<code>struct mm_struct</code>: mm_users 和 mm_count)，和文件系统 (<code>struct super_block</code>: s_count 和 s_active) 中找到。</p>
<p>记住：如果另一个执行线索可以找到你的数据结构，但这个数据结构没有引用计数器， 这里几乎肯定是一个 bug。</p>
<h2 id="12-宏，枚举和RTL"><a href="#12-宏，枚举和RTL" class="headerlink" title="12) 宏，枚举和RTL"></a>12) 宏，枚举和RTL</h2><p>用于定义常量的宏的名字及枚举里的标签需要大写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define CONSTANT 0x12345</span><br></pre></td></tr></table></figure>

<p>在定义几个相关的常量时，最好用枚举。</p>
<p>宏的名字请用大写字母，不过形如函数的宏的名字可以用小写字母。</p>
<p>一般的，如果能写成内联函数就不要写成像函数的宏。</p>
<p>含有多个语句的宏应该被包含在一个 do-while 代码块里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define macrofun(a, b, c)                       \</span><br><span class="line">        do &#123;                                    \</span><br><span class="line">                if (a == 5)                     \</span><br><span class="line">                        do_this(b, c);          \</span><br><span class="line">        &#125; while (0)</span><br></pre></td></tr></table></figure>

<p>使用宏的时候应避免的事情：</p>
<ol>
<li>影响控制流程的宏：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define FOO(x)                                  \</span><br><span class="line">        do &#123;                                    \</span><br><span class="line">                if (blah(x) &lt; 0)                \</span><br><span class="line">                        return -EBUGGERED;      \</span><br><span class="line">        &#125; while (0)</span><br></pre></td></tr></table></figure>

<p><strong>非常</strong> 不好。它看起来像一个函数，不过却能导致 <code>调用</code> 它的函数退出；不要打 乱读者大脑里的语法分析器。</p>
<ol>
<li>依赖于一个固定名字的本地变量的宏：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define FOO(val) bar(index, val)</span><br></pre></td></tr></table></figure>

<p>可能看起来像是个不错的东西，不过它非常容易把读代码的人搞糊涂，而且容易导致看起来不相关的改动带来错误。</p>
<ol>
<li>作为左值的带参数的宏： FOO(x) = y；如果有人把 FOO 变成一个内联函数的话，这 种用法就会出错了。</li>
<li>忘记了优先级：使用表达式定义常量的宏必须将表达式置于一对小括号之内。带参数 的宏也要注意此类问题。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define CONSTANT 0x4000</span><br><span class="line">#define CONSTEXP (CONSTANT | 3)</span><br></pre></td></tr></table></figure>

<ol>
<li>在宏里定义类似函数的本地变量时命名冲突：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define FOO(x)                          \</span><br><span class="line">(&#123;                                      \</span><br><span class="line">        typeof(x) ret;                  \</span><br><span class="line">        ret = calc_ret(x);              \</span><br><span class="line">        (ret);                          \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><u>ret 是本地变量的通用名字 - __foo_ret 更不容易与一个已存在的变量冲突。</u></p>
<p>cpp 手册对宏的讲解很详细。gcc internals 手册也详细讲解了 RTL，内核里的汇编语言经常用到它。</p>
<h2 id="13-打印内核消息"><a href="#13-打印内核消息" class="headerlink" title="13) 打印内核消息"></a>13) 打印内核消息</h2><p>内核开发者应该是受过良好教育的。请一定注意内核信息的拼写，以给人以好的印象。 不要用不规范的单词比如 <code>dont</code>，而要用 <code>do not</code> 或者 <code>don&#39;t</code> 。保证这些信息简单明了，无歧义。</p>
<p>内核信息不必以英文句号结束。</p>
<p>在小括号里打印数字 (%d) 没有任何价值，应该避免这样做。</p>
<p>&lt;linux/device.h&gt; 里有一些驱动模型诊断宏，你应该使用它们，以确保信息对应于正确的设备和驱动，并且被标记了正确的消息级别。这些宏有：dev_err(), dev_warn(), dev_info() 等等。对于那些不和某个特定设备相关连的信息，&lt;linux/printk.h&gt; 定义了 pr_notice(), pr_info(), pr_warn(), pr_err() 和其他。</p>
<p>写出好的调试信息可以是一个很大的挑战；一旦你写出后，这些信息在远程出错时能提供极大的帮助。然而打印调试信息的处理方式同打印非调试信息不同。其他 pr_XXX() 函数能无条件地打印，pr_debug() 却不；默认情况下它不会被编译，除非定义了 DEBUG 或设定了 CONFIG_DYNAMIC_DEBUG。实际这同样是为了 dev_dbg()，一个相关约定是在一个已经开启了 DEBUG 时，使用 VERBOSE_DEBUG 来添加 dev_vdbg()。</p>
<p>许多子系统拥有 Kconfig 调试选项来开启 -DDEBUG 在对应的 Makefile 里面；在其他情况下，特殊文件使用 #define DEBUG。当一条调试信息需要被无条件打印时，例如，如果已经包含一个调试相关的 #ifdef 条件，printk(KERN_DEBUG …) 就可被使用。</p>
<h2 id="14-分配内存"><a href="#14-分配内存" class="headerlink" title="14) 分配内存"></a>14) 分配内存</h2><p>内核提供了下面的一般用途的内存分配函数： kmalloc(), kzalloc(), kmalloc_array(), kcalloc(), vmalloc() 和 vzalloc()。 请参考 API 文档以获取有关它们的详细信息。</p>
<p>传递结构体大小的首选形式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = kmalloc(sizeof(*p), ...);</span><br></pre></td></tr></table></figure>

<p>另外一种传递方式中，sizeof 的操作数是结构体的名字，这样会降低可读性，并且可能会引入 bug。有可能指针变量类型被改变时，而对应的传递给内存分配函数的 sizeof 的结果不变。</p>
<p>强制转换一个 void 指针返回值是多余的。C 语言本身保证了从 void 指针到其他任何指针类型的转换是没有问题的。</p>
<p>分配一个数组的首选形式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = kmalloc_array(n, sizeof(...), ...);</span><br></pre></td></tr></table></figure>

<p>分配一个零长数组的首选形式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = kcalloc(n, sizeof(...), ...);</span><br></pre></td></tr></table></figure>

<p>两种形式检查分配大小 n * sizeof(…) 的溢出，如果溢出返回 NULL。</p>
<h2 id="15-内联弊病"><a href="#15-内联弊病" class="headerlink" title="15) 内联弊病"></a>15) 内联弊病</h2><p>有一个常见的误解是 <code>内联</code> 是 gcc 提供的可以让代码运行更快的一个选项。虽然使 用内联函数有时候是恰当的 (比如作为一种替代宏的方式，请看第十二章)，不过很多情况下不是这样。inline 的过度使用会使内核变大，从而使整个系统运行速度变慢。 <u>因为体积大内核会占用更多的指令高速缓存</u>，而且会导致 pagecache 的可用内存减少。 想象一下，一次 pagecache 未命中就会导致一次磁盘寻址，将耗时 5 毫秒。5 毫秒的 时间内 CPU 能执行很多很多指令。</p>
<p><u>一个基本的原则是如果一个函数有 3 行以上，就不要把它变成内联函数</u>。这个原则的一个例外是，如果你知道某个参数是一个编译时常量，而且因为这个常量你确定编译器在编译时能优化掉你的函数的大部分代码，那仍然可以给它加上 inline 关键字。 kmalloc() 内联函数就是一个很好的例子。</p>
<p>人们经常主张给 static 的而且只用了一次的函数加上 inline，如此不会有任何损失， 因为没有什么好权衡的。虽然从技术上说这是正确的，但是实际上这种情况下即使不加 inline gcc 也可以自动使其内联。而且其他用户可能会要求移除 inline，由此而来的争论会抵消 inline 自身的潜在价值，得不偿失。</p>
<h2 id="16-函数返回值及命名"><a href="#16-函数返回值及命名" class="headerlink" title="16) 函数返回值及命名"></a>16) 函数返回值及命名</h2><p>函数可以返回多种不同类型的值，最常见的一种是表明函数执行成功或者失败的值。这样 的一个值可以表示为一个错误代码整数 (-Exxx＝失败，0＝成功) 或者一个 <code>成功</code> 布尔值 (0＝失败，非0＝成功)。</p>
<p>混合使用这两种表达方式是难于发现的 bug 的来源。如果 C 语言本身严格区分整形和布尔型变量，那么编译器就能够帮我们发现这些错误… 不过 C 语言不区分。为了避免 产生这种 bug，请遵循下面的惯例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果函数的名字是一个动作或者强制性的命令，那么这个函数应该返回错误代</span><br><span class="line">码整数。如果是一个判断，那么函数应该返回一个 &quot;成功&quot; 布尔值。</span><br></pre></td></tr></table></figure>

<p>比如， <code>add work</code> 是一个命令，所以 add_work() 在成功时返回 0，在失败时返回 -EBUSY。类似的，因为 <code>PCI device present</code> 是一个判断，所以 pci_dev_present() 在成功找到一个匹配的设备时应该返回 1，如果找不到时应该返回 0。</p>
<p>所有 EXPORTed 函数都必须遵守这个惯例，所有的公共函数也都应该如此。私有 (static) 函数不需要如此，但是我们也推荐这样做。</p>
<p>返回值是实际计算结果而不是计算是否成功的标志的函数不受此惯例的限制。一般的， 他们通过返回一些正常值范围之外的结果来表示出错。典型的例子是返回指针的函数， 他们使用 NULL 或者 ERR_PTR 机制来报告错误。</p>
<h2 id="17-不要重新发明内核宏"><a href="#17-不要重新发明内核宏" class="headerlink" title="17) 不要重新发明内核宏"></a>17) 不要重新发明内核宏</h2><p>头文件 include/linux/kernel.h 包含了一些宏，你应该使用它们，而不要自己写一些它们的变种。比如，如果你需要计算一个数组的长度，使用这个宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))</span><br></pre></td></tr></table></figure>

<p>类似的，如果你要计算某结构体成员的大小，使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)-&gt;f))</span><br></pre></td></tr></table></figure>

<p>还有可以做严格的类型检查的 min() 和 max() 宏，如果你需要可以使用它们。你可以自己看看那个头文件里还定义了什么你可以拿来用的东西，如果有定义的话，你就不应在你的代码里自己重新定义。</p>
<h2 id="18-编辑器模式行和其他需要罗嗦的事情"><a href="#18-编辑器模式行和其他需要罗嗦的事情" class="headerlink" title="18) 编辑器模式行和其他需要罗嗦的事情"></a>18) 编辑器模式行和其他需要罗嗦的事情</h2><p>有一些编辑器可以解释嵌入在源文件里的由一些特殊标记标明的配置信息。比如，emacs 能够解释被标记成这样的行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-*- mode: c -*-</span><br></pre></td></tr></table></figure>

<p>或者这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Local Variables:</span><br><span class="line">compile-command: &quot;gcc -DMAGIC_DEBUG_FLAG foo.c&quot;</span><br><span class="line">End:</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>Vim 能够解释这样的标记：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* vim:set sw=8 noet */</span><br></pre></td></tr></table></figure>

<p>不要在源代码中包含任何这样的内容。每个人都有他自己的编辑器配置，你的源文件不应该覆盖别人的配置。这包括有关缩进和模式配置的标记。人们可以使用他们自己定制的模式，或者使用其他可以产生正确的缩进的巧妙方法。</p>
<h2 id="19-内联汇编"><a href="#19-内联汇编" class="headerlink" title="19) 内联汇编"></a>19) 内联汇编</h2><p>在特定架构的代码中，你可能需要内联汇编与 CPU 和平台相关功能连接。需要这么做时就不要犹豫。然而，当 C 可以完成工作时，不要平白无故地使用内联汇编。在可能的情况下，你可以并且应该用 C 和硬件沟通。</p>
<p>请考虑去写捆绑通用位元 (wrap common bits) 的内联汇编的简单辅助函数，别去重复地写下只有细微差异内联汇编。记住内联汇编可以使用 C 参数。</p>
<p>大型，有一定复杂度的汇编函数应该放在 .S 文件内，用相应的 C 原型定义在 C 头文 件中。汇编函数的 C 原型应该使用 <code>asmlinkage</code> 。</p>
<p>你可能需要把汇编语句标记为 volatile，用来阻止 GCC 在没发现任何副作用后就把它 移除了。你不必总是这样做，尽管，这不必要的举动会限制优化。</p>
<p>在写一个包含多条指令的单个内联汇编语句时，把每条指令用引号分割而且各占一行， 除了最后一条指令外，在每个指令结尾加上 nt，让汇编输出时可以正确地缩进下一条 指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asm (&quot;magic %reg1, #42\n\t&quot;</span><br><span class="line">     &quot;more_magic %reg2, %reg3&quot;</span><br><span class="line">     : /* outputs */ : /* inputs */ : /* clobbers */);</span><br></pre></td></tr></table></figure>

<h2 id="20-条件编译"><a href="#20-条件编译" class="headerlink" title="20) 条件编译"></a>20) 条件编译</h2><p>只要可能，就不要在 .c 文件里面使用预处理条件 (#if, #ifdef)；这样做让代码更难阅读并且更难去跟踪逻辑。替代方案是，<u>在头文件中用预处理条件提供给那些 .c 文件使用，再给 #else 提供一个空桩 (no-op stub) 版本</u>，然后在 .c 文件内无条件地调用 那些 (定义在头文件内的) 函数。这样做，编译器会避免为桩函数 (stub) 的调用生成任何代码，产生的结果是相同的，但逻辑将更加清晰。</p>
<p>最好倾向于编译整个函数，而不是函数的一部分或表达式的一部分。与其放一个 ifdef 在表达式内，不如分解出部分或全部表达式，放进一个单独的辅助函数，并应用预处理 条件到这个辅助函数内。</p>
<p>如果你有一个在特定配置中，可能变成未使用的函数或变量，编译器会警告它定义了但未使用，把它标记为 __maybe_unused 而不是将它包含在一个预处理条件中。(然而，如果一个函数或变量总是未使用，就直接删除它。)</p>
<p>在代码中，尽可能地使用 IS_ENABLED 宏来转化某个 Kconfig 标记为 C 的布尔 表达式，并在一般的 C 条件中使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (IS_ENABLED(CONFIG_SOMETHING)) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会做常量折叠，然后就像使用 #ifdef 那样去包含或排除代码块，所以这不会带来任何运行时开销。然而，这种方法依旧允许 C 编译器查看块内的代码，并检查它的正确性 (语法，类型，符号引用，等等)。因此，如果条件不满足，代码块内的引用符号就不存在时，你还是必须去用 #ifdef。</p>
<p>在任何有意义的 #if 或 #ifdef 块的末尾 (超过几行的)，在 #endif 同一行的后面写下注解，注释这个条件表达式。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_SOMETHING</span><br><span class="line">...</span><br><span class="line">#endif /* CONFIG_SOMETHING */</span><br></pre></td></tr></table></figure>

<h2 id="附录-I-参考"><a href="#附录-I-参考" class="headerlink" title="附录 I) 参考"></a>附录 I) 参考</h2><p>The C Programming Language, 第二版 作者：Brian W. Kernighan 和 Denni M. Ritchie. Prentice Hall, Inc., 1988. ISBN 0-13-110362-8 (软皮), 0-13-110370-9 (硬皮).</p>
<p>The Practice of Programming 作者：Brian W. Kernighan 和 Rob Pike. Addison-Wesley, Inc., 1999. ISBN 0-201-61586-X.</p>
<p>GNU 手册 - 遵循 K&amp;R 标准和此文本 - cpp, gcc, gcc internals and indent, 都可以从 <a target="_blank" rel="noopener" href="http://www.gnu.org/manual/">http://www.gnu.org/manual/</a> 找到</p>
<p>WG14 是 C 语言的国际标准化工作组，URL: <a target="_blank" rel="noopener" href="http://www.open-std.org/JTC1/SC22/WG14/">http://www.open-std.org/JTC1/SC22/WG14/</a></p>
<p>Kernel process/coding-style.rst，作者 <a href="mailto:greg@kroah.com">greg@kroah.com</a> 发表于 OLS 2002： <a target="_blank" rel="noopener" href="http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/">http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/15/230515-gitSubTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/15/230515-gitSubTree/" class="post-title-link" itemprop="url">如何从Git仓库中将模块分离成独立仓库并保留其提交历史？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-15 08:00:00" itemprop="dateCreated datePublished" datetime="2023-05-15T08:00:00+08:00">2023-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-06 09:11:57" itemprop="dateModified" datetime="2023-07-06T09:11:57+08:00">2023-07-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%88%E6%9C%AC%E7%AE%A1%E6%8E%A7/" itemprop="url" rel="index"><span itemprop="name">版本管控</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="如何从Git仓库中将模块分离成独立仓库并保留其提交历史？"><a href="#如何从Git仓库中将模块分离成独立仓库并保留其提交历史？" class="headerlink" title="如何从Git仓库中将模块分离成独立仓库并保留其提交历史？"></a>如何从Git仓库中将模块分离成独立仓库并保留其提交历史？</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><ul>
<li>部门代码管理使用的SVN，由于Git可以提交至本地，自己在本地又使用Git管理代码，使用Git管理了一整个工程，在开发不同模块时切到不同分支，一开始没把模块独立放到一个Git仓库，现在想独立模块，又想保留其提交历史，故有此文。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://shantanoo-desai.github.io/posts/technology/git_subtree/">subtrees in Git: How to split Directories into individual standalone repositories</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/25559260/assertion-failed-errors-when-trying-to-git-subtree-split">assertion failed errors when trying to git subtree split</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/74486167/git-clone-recurse-submodules-throws-error-on-macos-transmission-type-file-n">Git clone –recurse-submodules throws error on MacOs: Transmission type ‘file’ not allowed</a></li>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">Git 工具 - 子模块</a></li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol>
<li>将子目录拆分独立库：<code>git subtree split -P &lt;name-of-folder&gt; -b &lt;name-of-new-branch&gt;</code>，注意此行命令需要在Git仓库toplevel目录执行，<code>&lt;name-of-folder&gt;</code>需要避免在前面加<code>./</code>，避免使用反斜杠，否则会产生assertion failed errors，解决方案就是改掉就行，参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/25559260/assertion-failed-errors-when-trying-to-git-subtree-split">assertion failed errors when trying to git subtree split</a></li>
<li>拆分独立库后此仓库在<code>&lt;name-of-new-branch&gt;</code>分支中会保存模块代码和提交记录，然后<code>mkdir &lt;name-of-new-branch&gt; &amp;&amp; cd &lt;name-of-new-branch&gt; &amp;&amp; git</code>，我参考别人的操作使用<code>git pull &lt;/path/to/big-repo&gt; &lt;name-of-new-branch&gt;</code>拉取上级目录的指定分支到一个新的文件夹好像不太行，网上暂时没查到<code>/path/to</code>的用法。我使用的方式是将老仓库<code>&lt;name-of-new-branch&gt;</code>分支代码push，然后使用<code>git pull &lt;repo-path.git&gt; &lt;name-of-new-branch&gt;</code>拉来的代码。</li>
<li>上一步操作后就已经将代码和历史提交记录全部拉到了一个新仓库，后续就可以将新仓库Push。</li>
</ol>
<h3 id="如何在工程的Git仓库中引用模块仓库？"><a href="#如何在工程的Git仓库中引用模块仓库？" class="headerlink" title="如何在工程的Git仓库中引用模块仓库？"></a>如何在工程的Git仓库中引用模块仓库？</h3><ol>
<li><p>参考Git文档：<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">Git 工具 - 子模块</a></p>
<blockquote>
<p>我们首先将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。 你可以通过在 git submodule add 命令后面加上想要跟踪的项目的相对或绝对 URL 来添加新的子模块。 在本例中，我们将会添加一个名为 “DbConnector” 的库。<br>$ git submodule add <a target="_blank" rel="noopener" href="https://github.com/chaconinc/DbConnector">https://github.com/chaconinc/DbConnector</a><br>Cloning into ‘DbConnector’…<br>remote: Counting objects: 11, done.<br>remote: Compressing objects: 100% (10/10), done.<br>remote: Total 11 (delta 0), reused 11 (delta 0)<br>Unpacking objects: 100% (11/11), done.<br>Checking connectivity… done.<br>默认情况下，子模块会将子项目放到一个与仓库同名的目录中，本例中是 “DbConnector”。 如果你想要放到其他地方，那么可以在命令结尾添加一个不同的路径。</p>
</blockquote>
</li>
<li><p>如果一个分支有子模块，另一个分支没有，直接 checkout 后会造成子模块的文件在另一个分支未被删除，可以在 checkout 前使用<code>git submodule deinit --all</code>命令来卸载当前分支已安装的所有子模块，在 checkout 后，如果另一个分支也有子模块，可以使用<code>git submodule init</code>命令注册子模块，再使用<code>git submodule update</code>从子模块库中取出文件。</p>
</li>
<li><p>我使用的子模块库是本地的Git仓库，在拉库的时候首次会报<code>Transmission type &#39;file&#39; not allowed</code>的错误，需通过<code>git config --global protocol.file.allow always</code>配置Git，参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/74486167/git-clone-recurse-submodules-throws-error-on-macos-transmission-type-file-n">Git clone –recurse-submodules throws error on MacOs: Transmission type ‘file’ not allowed</a></p>
</li>
</ol>
<h3 id="Git子模块和子树区别"><a href="#Git子模块和子树区别" class="headerlink" title="Git子模块和子树区别"></a>Git子模块和子树区别</h3><p>Git子模块（submodule）和子树（subtree）都是Git中用于将外部仓库包含到自己的仓库中的机制。虽然它们的目的相似，但在功能和使用方式上有一些区别。</p>
<h4 id="Git子模块："><a href="#Git子模块：" class="headerlink" title="Git子模块："></a>Git子模块：</h4><ul>
<li>子模块是对外部仓库中特定提交的引用。</li>
<li>当你将一个子模块添加到你的仓库时，你在自己的仓库中包含了指向另一个仓库的链接，它作为一个子目录存在。</li>
<li>子模块维护着独立的Git历史，被视为独立的仓库。它们有自己的分支、标签和提交历史。</li>
<li>每个子模块引用指向外部仓库中的特定提交。你可以通过显式地拉取变更来更新子模块到新的提交。</li>
<li>子模块通常用于在你的仓库中包含另一个项目作为依赖项，但希望保持两个代码库的分离。</li>
</ul>
<h4 id="Git子树："><a href="#Git子树：" class="headerlink" title="Git子树："></a>Git子树：</h4><ul>
<li>子树允许你直接将外部仓库的内容嵌入到自己仓库的子目录中。</li>
<li>当你向你的仓库添加子树时，你将另一个仓库的文件导入并合并到你的仓库的子目录中。导入的文件成为你的仓库历史的一部分。</li>
<li>子树不维护独立的Git历史。相反，外部仓库的提交会合并到你的仓库的历史中。</li>
<li>子树允许你在你的仓库中直接对导入的代码进行修改。如果你有写入权限，你也可以将修改的内容推送回原始仓库。</li>
<li>子树通常用于将另一个项目的代码作为你仓库的一部分，并将其视为你代码库的一个组成部分。</li>
</ul>
<p>总结而言，子模块提供了一种将外部仓库作为独立实体包含在你的仓库中的方式，而子树允许你将外部仓库的内容合并到你的仓库历史中。选择使用子模块还是子树取决于你的具体需求和工作流程。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/10/230310-macro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/10/230310-macro/" class="post-title-link" itemprop="url">C语言 宏的高级用法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-10 16:00:00" itemprop="dateCreated datePublished" datetime="2023-03-10T16:00:00+08:00">2023-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-13 07:35:35" itemprop="dateModified" datetime="2023-03-13T07:35:35+08:00">2023-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="字符串转换符"><a href="#字符串转换符" class="headerlink" title="字符串转换符"></a>字符串转换符</h3><p>使用<code>#</code>运算符可以将宏参数替换为一个字符串，并用双引号括起来，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_STR(x) printf(<span class="string">&quot;The string is: %s\n&quot;</span>, #x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    PRINT_STR(Hello World);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例程序中，定义了一个宏PRINT_STR，它的参数x通过#运算符被转换为一个字符串，并被传递给printf函数进行输出。运行这个程序会输出：<code>The string is: Hello World</code></p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>在C语言中，宏定义可以使用##运算符进行字符串拼接，称为连接运算符（Token Pasting Operator）。<code>##</code>运算符可以将两个标记（Token）连接成一个标记，从而实现字符串拼接的功能。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONCAT(x, y) x##y</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> xy = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, CONCAT(x, y));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例程序中，定义了一个宏CONCAT，它使用<code>##</code>运算符将两个参数x和y连接成一个标记。在main函数中定义了一个变量xy，并将连接后的标记xy作为参数传递给printf函数进行输出。输出结果是：<code>10</code></p>
<h3 id="变长参数宏"><a href="#变长参数宏" class="headerlink" title="变长参数宏"></a>变长参数宏</h3><p>C语言中的变长参数宏（Variadic Macro）可以接受可变数量的参数。变长参数宏是通过使用特殊的预处理符号<code>__VA_ARGS__</code>来实现的，它表示可变参数的列表。下面是一个简单的示例，展示了如何使用变长参数宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF(...) printf(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    PRINTF(<span class="string">&quot;x = %d, str = %s\n&quot;</span>, x, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例程序中，定义了一个宏PRINTF，它使用printf函数打印可变数量的参数。使用<code>__VA_ARGS__</code>表示可变参数的列表。在main函数中，PRINTF宏被调用，传递了三个参数，包括一个整数和一个字符串。输出结果是：<code>x = 10, str = hello</code></p>
<h3 id="宏：取最大值"><a href="#宏：取最大值" class="headerlink" title="宏：取最大值"></a>宏：取最大值</h3><p>一种方式：<code>#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))</code><br>这种方式需要注意参数如果有自增运算，需要在传参的时候加括号，否则自增运算会重复两次。<br>正确调用方法如：<code>z = MAX((x++), (y++));</code></p>
<p>使用下面一种方式可以避免此类问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) (&#123; \</span></span><br><span class="line"><span class="meta">    typeof(a) _a = (a); \</span></span><br><span class="line"><span class="meta">    typeof(b) _b = (b); \</span></span><br><span class="line"><span class="meta">    (void)(&amp;_a == &amp;_b); \</span></span><br><span class="line"><span class="meta">    _a &gt; _b ? _a : _b; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p><code>typeof</code>是GNU C编译器内置的一种类型描述符，用于表示表达式的类型。在编译时，编译器会根据<code>typeof(x)</code>对象的类型生成一个类型的值，并将其插入到代码中。</p>
<p>比较难理解的是<code>(void)(&amp;_a == &amp;_b);</code>，看起来很多余，仔细分析一下，你会发现这条语句很有意思。它的作用有两个： </p>
<ol>
<li>用来给用户提示一个警告，对于不同类型的指针比较，编译器会发出一个警告， 提示两种数据的类型不同。<code>warning: comparison of distinct pointer types lacks a cast.</code></li>
<li>两个数进行比较运算，运算的结果却没有用到，有些编译器可能会给出一个warning，加一个<code>(void)</code>后，就可以消除这个警告。</li>
</ol>
<h3 id="宏：offsetof"><a href="#宏：offsetof" class="headerlink" title="宏：offsetof"></a>宏：offsetof</h3><p><code>offsetof</code>是一个宏，用于获取结构体中成员的偏移量。实现是使用指针运算来计算结构体成员的偏移量。具体实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(type, member) ((size_t) &amp;((type *)0)-&gt;member)</span></span><br></pre></td></tr></table></figure>

<p>其中，type表示结构体类型，member表示结构体成员。在宏展开时，(type *)0将一个空指针强制转换为结构体指针类型，然后通过指针运算获取成员的地址。由于空指针的地址为0，因此可以确保这个地址不会指向任何实际的内存位置，避免了访问非法内存的风险。最后，将成员的地址转换为size_t类型的偏移量，并返回。</p>
<p>需要注意的是，offsetof宏只能用于标准布局的结构体，即结构体中的成员按照其定义顺序依次存储，没有嵌套、位域、虚函数等。对于非标准布局的结构体，offsetof可能无法正确计算成员的偏移量。</p>
<h3 id="宏：container-of"><a href="#宏：container-of" class="headerlink" title="宏：container_of"></a>宏：container_of</h3><p><code>container_of</code>是一个宏，用于从结构体的成员指针计算出结构体的地址。其实现通常基于<code>offsetof</code>宏和指针运算。实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    ((type *)((char *)(ptr) - offsetof(type, member)))</span></span><br></pre></td></tr></table></figure>

<p>其中，ptr表示结构体成员的指针，type表示结构体类型，member表示结构体成员名。offsetof(type, member)用于计算结构体成员在结构体中的偏移量，(char *)(ptr)将成员指针转换为char类型指针，以便进行指针运算。通过成员指针的地址减去成员在结构体中的偏移量，可以得到结构体的地址。最后，将地址转换为type类型的指针，并返回。</p>
<p>container_of宏常用于实现Linux内核中的数据结构，如链表、哈希表等。它可以方便地从链表节点或哈希桶中获取对应的数据结构。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/09/230309-CompoundLiterals/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/09/230309-CompoundLiterals/" class="post-title-link" itemprop="url">C语言 复合字面量(Compound Literals)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-03-09 16:00:00 / 修改时间：21:15:42" itemprop="dateCreated datePublished" datetime="2023-03-09T16:00:00+08:00">2023-03-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Compound-Literals.html">https://gcc.gnu.org/onlinedocs/gcc/Compound-Literals.html</a></li>
</ul>
<h3 id="复合字面量介绍"><a href="#复合字面量介绍" class="headerlink" title="复合字面量介绍"></a>复合字面量介绍</h3><p>假设给带int类型的形参函数传递一个值，可以传递int类型的变量，也可以传递int类型常量，但是对于带数组形参的函数则不一样，可以传递数组，但是不支持传递数组常量，由此C99新增了复合字面量的用法，字面量是指除符号常量外的常量。</p>
<p>例如：10是int的类型的字面量，10.24是double类型的字面量，”abc”是字符串的字面量等，如果有数组或者结构体的字面量，这样使用起来会更方便。</p>
<h3 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h3><p>数组的复合字面量和数组初始化列表差不多，前面使用括号括起来的类型名。<br>例如，这是个数组定义：<code>int age[2] = [19, 20];</code><br>使用复合字面量创建一个匿名数组：<code>(int [2])&#123;19, 20&#125;;</code><br>可见去掉定义中的数组名，留下的int[2]就是复合字面量的类型名，整个就是数组字面量。<br>使用数组字面量时可以像定义数组一样省略数组大小，也可以应用于二维或多维数组。<br>还可构造一个字符串数组，将复合字面量强制转换为指向其第一个元素的指针，如：<code>char **foo = (char *[]) &#123; &quot;x&quot;, &quot;y&quot;, &quot;z&quot; &#125;;</code></p>
<h3 id="结构体字面量"><a href="#结构体字面量" class="headerlink" title="结构体字面量"></a>结构体字面量</h3><p>结构体的复合字面量的指定类型是一个结构体。<br>假设，struct foo 和 structure 声明如：<code>struct foo &#123;int a; char b[2];&#125; structure;</code><br>使用复合字面量构造 struct foo 的示例：<code>structure = ((struct foo) &#123;x + y, &#39;a&#39;, 0&#125;);</code><br>这等效于：<code>&#123;   struct foo temp = &#123;x + y, &#39;a&#39;, 0&#125;;   structure = temp; &#125;</code></p>
<h3 id="复合字面量生命周期"><a href="#复合字面量生命周期" class="headerlink" title="复合字面量生命周期"></a>复合字面量生命周期</h3><p>在 C 语言中，复合字面量指定具有静态或自动存储持续时间的未命名对象。在 C++ 中，复合字面量指定一个临时对象，该对象仅在其完整表达式结束之前存在。因此，采用复合字面量的子对象地址的定义良好的 C 代码在 C++ 中可以是未定义的，因此 G++ 拒绝将临时数组转换为指针。例如，如果上面的数组复合字面量示例出现在函数内部，则在 C++ 中对 foo 的任何后续使用都会产生未定义的行为，因为数组的生命周期在 foo 的声明之后结束。</p>
<p>作为一种优化，G++ 有时会为数组复合字面量提供更长的生命周期：当数组出现在函数外部或具有 const 限定类型时。如果 foo 及其初始值设定项具有 char *const 而不是 char * 类型的元素，或者如果 foo 是全局变量，则数组将具有静态存储持续时间。但是，避免在 C++ 代码中使用数组复合字面量可能是最安全的。</p>
<h3 id="复合字面量应用"><a href="#复合字面量应用" class="headerlink" title="复合字面量应用"></a>复合字面量应用</h3><ol>
<li>函数参数是结构体、数组，用复合字面量传参。</li>
<li>程序运行中想给char数组赋字符串。</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/07/230307-cAsm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/07/230307-cAsm/" class="post-title-link" itemprop="url">分析c语言函数调用时的汇编代码，进出函数时CPU做了什么？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-07 16:00:00" itemprop="dateCreated datePublished" datetime="2023-03-07T16:00:00+08:00">2023-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-08 08:20:03" itemprop="dateModified" datetime="2023-03-08T08:20:03+08:00">2023-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span><span class="type">int</span> a; <span class="type">int</span> b; <span class="type">int</span> c; <span class="type">int</span> d; <span class="type">int</span> e;&#125; g_stTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">struct</span> foo <span class="title function_">testFun2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">stTest</span>;</span></span><br><span class="line">    stTest.a = a;</span><br><span class="line">    stTest.b = b;</span><br><span class="line">    stTest.c = c;</span><br><span class="line">    stTest.d = d;</span><br><span class="line">    stTest.e = e;</span><br><span class="line">    <span class="keyword">return</span> stTest;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span> <span class="title function_">testFun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_stTest = testFun2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p>用gcc工具链编译s32k144平台的代码，通过ozone分析elf得到反汇编如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">void</span> <span class="title function_">testFun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 0002C74C   PUSH           &#123;R4-R5, R7, LR&#125;</span></span><br><span class="line"><span class="comment">// 0002C74E   SUB            SP, SP, #32</span></span><br><span class="line"><span class="comment">// 0002C750   ADD            R7, SP, #8</span></span><br><span class="line">    g_stTest = testFun2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 0002C752   LDR            R4, =g_stTest                 ; [PC, #40] [0x0002C77C] =0x20002318</span></span><br><span class="line">    <span class="comment">// 0002C754   MOV            R2, R7</span></span><br><span class="line">    <span class="comment">// 0002C756   MOVS           R3, #4</span></span><br><span class="line">    <span class="comment">// 0002C758   STR            R3, [SP, #0]</span></span><br><span class="line">    <span class="comment">// 0002C75A   MOVS           R3, #5</span></span><br><span class="line">    <span class="comment">// 0002C75C   STR            R3, [SP, #4]</span></span><br><span class="line">    <span class="comment">// 0002C75E   MOV            R0, R2</span></span><br><span class="line">    <span class="comment">// 0002C760   MOVS           R1, #1</span></span><br><span class="line">    <span class="comment">// 0002C762   MOVS           R2, #2</span></span><br><span class="line">    <span class="comment">// 0002C764   MOVS           R3, #3</span></span><br><span class="line">    <span class="comment">// 0002C766   BL             testFun2                      ; 0x0002C710</span></span><br><span class="line">    <span class="comment">// 0002C76A   MOV            R5, R4</span></span><br><span class="line">    <span class="comment">// 0002C76C   MOV            R4, R7</span></span><br><span class="line">    <span class="comment">// 0002C76E   LDM            R4!, &#123;R0-R3&#125;</span></span><br><span class="line">    <span class="comment">// 0002C770   STM            R5!, &#123;R0-R3&#125;</span></span><br><span class="line">    <span class="comment">// 0002C772   LDR            R3, [R4]</span></span><br><span class="line">    <span class="comment">// 0002C774   STR            R3, [R5]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0002C776   ADDS           R7, #24</span></span><br><span class="line"><span class="comment">// 0002C778   MOV            SP, R7</span></span><br><span class="line"><span class="comment">// 0002C77A   POP            &#123;R4-R5, R7, PC&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">struct</span> foo <span class="title function_">testFun2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 0002C710   PUSH           &#123;R4-R5, R7&#125;</span></span><br><span class="line"><span class="comment">// 0002C712   SUB            SP, SP, #44</span></span><br><span class="line"><span class="comment">// 0002C714   ADD            R7, SP, #0</span></span><br><span class="line"><span class="comment">// 0002C716   STR            R0, [R7, #12]</span></span><br><span class="line"><span class="comment">// 0002C718   STR            R1, [R7, #8]</span></span><br><span class="line"><span class="comment">// 0002C71A   STR            R2, [R7, #4]</span></span><br><span class="line"><span class="comment">// 0002C71C   STR            R3, [R7]</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">stTest</span>;</span></span><br><span class="line">    stTest.a = a;</span><br><span class="line">    <span class="comment">// 0002C71E   LDR            R3, [R7, #8]</span></span><br><span class="line">    <span class="comment">// 0002C720   STR            R3, [R7, #20]</span></span><br><span class="line">    stTest.b = b;</span><br><span class="line">    <span class="comment">// 0002C722   LDR            R3, [R7, #4]</span></span><br><span class="line">    <span class="comment">// 0002C724   STR            R3, [R7, #24]</span></span><br><span class="line">    stTest.c = c;</span><br><span class="line">    <span class="comment">// 0002C726   LDR            R3, [R7]</span></span><br><span class="line">    <span class="comment">// 0002C728   STR            R3, [R7, #28]</span></span><br><span class="line">    stTest.d = d;</span><br><span class="line">    <span class="comment">// 0002C72A   LDR            R3, [R7, #56]</span></span><br><span class="line">    <span class="comment">// 0002C72C   STR            R3, [R7, #32]</span></span><br><span class="line">    stTest.e = e;</span><br><span class="line">    <span class="comment">// 0002C72E   LDR            R3, [R7, #60]</span></span><br><span class="line">    <span class="comment">// 0002C730   STR            R3, [R7, #36]</span></span><br><span class="line">    <span class="keyword">return</span> stTest;</span><br><span class="line">    <span class="comment">// 0002C732   LDR            R3, [R7, #12]</span></span><br><span class="line">    <span class="comment">// 0002C734   MOV            R5, R3</span></span><br><span class="line">    <span class="comment">// 0002C736   ADD.W          R4, R7, #20</span></span><br><span class="line">    <span class="comment">// 0002C73A   LDM            R4!, &#123;R0-R3&#125;</span></span><br><span class="line">    <span class="comment">// 0002C73C   STM            R5!, &#123;R0-R3&#125;</span></span><br><span class="line">    <span class="comment">// 0002C73E   LDR            R3, [R4]</span></span><br><span class="line">    <span class="comment">// 0002C740   STR            R3, [R5]</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 0002C742   LDR            R0, [R7, #12]</span></span><br><span class="line"><span class="comment">// 0002C744   ADDS           R7, #44</span></span><br><span class="line"><span class="comment">// 0002C746   MOV            SP, R7</span></span><br><span class="line"><span class="comment">// 0002C748   POP            &#123;R4-R5, R7&#125;</span></span><br><span class="line"><span class="comment">// 0002C74A   BX             LR</span></span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li>在进入函数后，首先会将R4, R5, R7寄存器压栈，使用PUSH指令后SP会自动减去压栈空间的大小。</li>
<li>然后是SP减去一个直接数，是在给局部变量、形参和参数传递开辟栈区空间。</li>
<li>R7 = SP + 偏移，R7是局部变量所在栈区的地址，偏移的大小是函数内调用函数时，参数传递所需要的空间大小。</li>
<li><code>g_stTest = testFun2(1, 2, 3, 4, 5);</code>反汇编中，参数4, 5通过栈传递，参数1, 2, 3通过R1~R3寄存器传递。</li>
<li>在<code>testFun2</code>函数进入后，<code>STR R0, [R7, #12]</code>等指令，会将R0~R3寄存器传递的参数存入（局部变量）栈中，为什么传参的还有R0？</li>
<li>重新分析<code>g_stTest = testFun2(1, 2, 3, 4, 5);</code>反汇编，R0传入的是R7（局部变量地址），在<code>testFun2</code>函数<code>return stTest;</code>时，将stTest写入R0传入的地址区域。</li>
<li>在退出函数时，如果函数有return参数，会将return参数写入R0，若大于4字节会将进入函数时R0传入的地址返回。</li>
<li>在退出函数时，会将SP改回进入函数前的SP，并使用POP指令出栈（POP指令会增加SP），最后跳转出函数（还可以直接POP取出PC跳转）。</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/15/230215-git/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/15/230215-git/" class="post-title-link" itemprop="url">分享一个学习Git的网站，记录Git一些用法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-15 16:00:00" itemprop="dateCreated datePublished" datetime="2023-02-15T16:00:00+08:00">2023-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-06 08:46:48" itemprop="dateModified" datetime="2023-07-06T08:46:48+08:00">2023-07-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%88%E6%9C%AC%E7%AE%A1%E6%8E%A7/" itemprop="url" rel="index"><span itemprop="name">版本管控</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="网站：Learn-Git-Branching"><a href="#网站：Learn-Git-Branching" class="headerlink" title="网站：Learn Git Branching"></a>网站：<a target="_blank" rel="noopener" href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></h2><h3 id="分离HEAD"><a href="#分离HEAD" class="headerlink" title="分离HEAD"></a>分离HEAD</h3><p><strong>HEAD 是一个对当前检出记录的符号引用</strong>，也就是指向你正在其基础上进行工作的提交记录。HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。HEAD 通常情况下是指向分支名的。在你提交时，改变了分支的状态，这一变化通过 HEAD 变得可见。<br>如果想看 HEAD 指向，可以通过 cat .git/HEAD 查看， 如果 HEAD 指向的是一个引用，还可以用 git symbolic-ref HEAD 查看它的指向。 </p>
<h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><p>切换至上个版本<code>git checkout HEAD^</code><br>切换至上上上版本<code>git checkout HEAD~3</code></p>
<h3 id="强制修改分支位置"><a href="#强制修改分支位置" class="headerlink" title="强制修改分支位置"></a>强制修改分支位置</h3><p>我使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。例如:<code>git branch -f main HEAD~3</code>，命令会将 main 分支强制指向 HEAD 的第 3 级父提交。</p>
<h3 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h3><p><code>git reset</code> 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。<code>git reset</code> 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。<br>为了撤销更改并分享给别人，我们需要使用 <code>git revert</code>，在我们要撤销的提交记录后面居然多了一个新提交，此次提交是用来撤销上一次提交的，此次提交与上上一次提交状态相同。</p>
<h3 id="Git-Cherry-pick"><a href="#Git-Cherry-pick" class="headerlink" title="Git Cherry-pick"></a>Git Cherry-pick</h3><p>如果你想<strong>将一些提交复制到当前所在的位置（HEAD）下面</strong>的话， Cherry-pick 是最直接的方式了。命令形式为：<code>git cherry-pick &lt;提交号&gt;...</code></p>
<h3 id="交互式的-Rebase"><a href="#交互式的-Rebase" class="headerlink" title="交互式的 Rebase"></a>交互式的 Rebase</h3><p>交互式 rebase 指的是使用带参数 –interactive 的 rebase 命令, 简写为 -i。<br>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。Git会自动打开默认的文本编辑器，比如在我本地使用的是vim。在文本编辑器的开始几行会列出所有满足条件的提交记录，每个提交记录对应一行，每行开头单词代表要对这条提交记录实施的操作。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>pick</td>
<td>采用该提交（默认行为）</td>
</tr>
<tr>
<td>reword</td>
<td>采用该提交，但要求修改提交记录的备注</td>
</tr>
<tr>
<td>edit</td>
<td>采用该提交，但要求修改提交记录的信息，如：作者名称，邮箱地址等</td>
</tr>
<tr>
<td>squash</td>
<td>采用该提交，但它会被并入前一条提交</td>
</tr>
<tr>
<td>fixup</td>
<td>类似“squash”，但是会丢弃这条提交记录的日志信息</td>
</tr>
<tr>
<td>exec</td>
<td>执行指定的shell脚本或命令</td>
</tr>
<tr>
<td>drop</td>
<td>丢弃该提交</td>
</tr>
</tbody></table>
<h3 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h3><p>git describe 的​​语法是：<code>git describe &lt;ref&gt;</code><br><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）。<br>它输出的结果：<code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code><br>tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。当 ref 提交记录上有某个标签时，则只输出标签名称。</p>
<h3 id="Git-Pull"><a href="#Git-Pull" class="headerlink" title="Git Pull"></a>Git Pull</h3><p>git pull 就是 git fetch 和 git merge 的缩写！</p>
<h3 id="rebase和merge区别【阅读原文】"><a href="#rebase和merge区别【阅读原文】" class="headerlink" title="rebase和merge区别【阅读原文】"></a>rebase和merge区别【<a target="_blank" rel="noopener" href="https://joyohub.com/2020/04/06/git-rebase/">阅读原文</a>】</h3><p>使用git merge 命令将 master 分支合并到 feature分支中：<code>git merge feature master</code>，git merge 会在 feature 分支中新增一个新的 merge commit，然后将两个分支的历史联系在一起。</p>
<ul>
<li>使用 merge 是很好的方式，因为它是一种非破坏性的操作，对现有分支不会以任何方式被更改。</li>
<li>另一方面，这也意味着 feature 分支每次需要合并上游更改时，它都将产生一个额外的合并提交。</li>
<li>如果master 提交非常活跃，这可能会严重污染你的 feature 分支历史记录。不过这个问题可以使用高级选项 git log 来缓解。</li>
</ul>
<p>使用git rebase 命令将 master 分支合并到 feature分支中：<code>git rebase feature master</code></p>
<ul>
<li>rebase 会将整个 feature 分支移动到 master 分支的顶端，从而有效地整合了所有 master 分支上的提交。</li>
<li>但是，与 merge 提交方式不同，rebase 通过为原始分支中的每个提交创建全新的 commits 来重写项目历史记录,特点是仍然会在feature分支上形成线性提交。</li>
<li>rebase 的主要好处是可以获得更清晰的项目历史。首先，它消除了 git merge 所需的不必要的合并提交；其次，正如你在上图中所看到的，rebase 会产生完美线性的项目历史记录，你可以在 feature分支上没有任何分叉的情况下一直追寻到项目的初始提交。</li>
</ul>
<h3 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h3><p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:<br><code>! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</code></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/01/230201-gitee/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/01/230201-gitee/" class="post-title-link" itemprop="url">Github静态博客访问速度慢，部署图片资源到其他服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-01 16:00:00" itemprop="dateCreated datePublished" datetime="2023-02-01T16:00:00+08:00">2023-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-11 14:03:38" itemprop="dateModified" datetime="2023-02-11T14:03:38+08:00">2023-02-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Hexo/" itemprop="url" rel="index"><span itemprop="name">Hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>用Github部署静态站访问国内速度慢，主要表现有2个，一是首次请求页面打开慢，二是打开后图片加载慢。问题一原因是域名解析需要访问多个海外的DNS服务器，且Github静态站服务器也在海外，首次请求国内或本地没有缓存。问题二也是访问Github静态站服务器速度受限，图片和文本并发访问，文本比图片数据量小先加载完成显示。</p>
<p>本想将博客全部移到Gitee上，尝试部署又遇到三个问题，一是不能使用自己的域名解析，二是部署Gitee静态站服务它竟说我有文章不合规，三是每次上传Gitee后不会自动更新静态页面，每次要重新发布审核。</p>
<p>本人使用的解决办法是将图片上传到gitee，github静态博客上的图片都使用gitee的链接，<a target="_blank" rel="noopener" href="https://gitee.com/hao0527/hao0527/tree/img/">Gitee/blog仓库img分支</a>上传了本博客用到的图片。</p>
<h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><p>参考：<a target="_blank" rel="noopener" href="https://gitee.com/help/articles/4136#article-header0">Gitee Pages</a></p>
<p>在Gitee中创建仓库，开然后将博客用到的图片上传到Gitee中，开通仓库的Pages服务更新分支。审核成功后就可以通过Gitee提供的域名，加上图片在仓库中的路径访问了。例如我的静态页面网址是：<code>https://hao0527.gitee.io/</code>，要访问仓库<code>210430-at32</code>文件夹中的<code>210430-at32-1.jpg</code>，访问网址为：<code>https://hao0527.gitee.io/210430-at32/210430-at32-1.jpg</code>。</p>
<h3 id="使用域名转发"><a href="#使用域名转发" class="headerlink" title="使用域名转发"></a>使用域名转发</h3><p>加入以后我的图床地址变了，但我又不想重新修改每个文章里的图片网址怎么办？</p>
<p>使用域名转发可以解决此问题，我使用的是易名注册的域名和易名免费的域名解析服务，开启URL隐性转发，转发值为你的静态页面网址，这样就可以通过自己的域名访问了，以后想换个图床的话只需要转发地址更改下就可以了。使用易名域名解析转发到我的静态页面会审核不通过，这是因为静态页面没有内容，只需要加个index.html骗骗审核就行了，审核结束就可以删除。</p>
<p>遇到一个问题，使用域名转发通过http访问可以，通过https访问不行，暂且文章里的图片网址用http访问吧。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/21/230121-iot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/21/230121-iot/" class="post-title-link" itemprop="url">阿里云物联网平台数据解析与物模型显示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-21 21:00:00" itemprop="dateCreated datePublished" datetime="2023-01-21T21:00:00+08:00">2023-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-31 23:40:50" itemprop="dateModified" datetime="2023-01-31T23:40:50+08:00">2023-01-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章是对之前文章【<a href="2021/12/17/211217-ltecat1/">LTE Cat.1模块和阿里云物联网平台使用</a>】的一个补充。之前只介绍了阿里云物联网平台如何创建产品、添加设备、添加物模型概述，缺少对消息解析、物模型展示的使用介绍，导致我这次用阿里云物联网平台时花了将近半天的时间在做之前做过又忘记怎么做的事情。本文就来介绍下<strong>消息解析</strong>、<strong>物模型展示</strong>的功能。</p>
<p>另外阿里云免费的物联网平台公共实例的资源包将于2023年2月20日下线，我看企业版的最便宜的也要700元/月，我这种添加一个设备调试用的不能白嫖了，到时候需要的话只能包一台服务器自己搭个MQTT划算点了，或者看看其他云服务商那能不能白嫖😂。</p>
<h3 id="添加物模型"><a href="#添加物模型" class="headerlink" title="添加物模型"></a>添加物模型</h3><p>在<strong>设备管理-&gt;产品-&gt;对应产品名称-&gt;功能定义-&gt;编辑草稿</strong>中添加物模型数据，功能类型有<strong>属性、服务、事件</strong>，我目前只使用到了属性类型，编辑完成后发布上线即可，下面是我这次调试模块用到的物模型功能定义：</p>
<p><img src="https://hao0527.gitee.io/230121-iot/230121-iot-1.jpg" alt="img"></p>
<h3 id="消息解析"><a href="#消息解析" class="headerlink" title="消息解析"></a>消息解析</h3><p>在<strong>设备管理-&gt;产品-&gt;对应产品名称-&gt;消息解析-&gt;编辑草稿</strong>中编写消息解析的脚本代码，有<strong>js、Python、php</strong>三种语言可供选择，我选择的是Python。消息解析有<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/149962.html">自定义Topic消息解析</a>和<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/66640.html">物模型消息解析</a>两种，创建产品时数据格式选择<strong>透传/自定义</strong>，消息解析里才有设备上报数据和设备接收数据，数据格式选ICA 标准数据格式(Alink JSON)，消息解析里只有自定义Topic消息解析。通过看模拟输入中模拟类型有哪些，可以知道是否支持某种消息类型的数据解析。</p>
<h4 id="自定义Topic消息解析"><a href="#自定义Topic消息解析" class="headerlink" title="自定义Topic消息解析"></a>自定义Topic消息解析</h4><p>设备通过携带解析标记<code>?_sn=default</code>的自定义Topic上报自定义格式消息时，物联网平台收到消息数据后，需调用消息解析脚本将自定义格式数据转换为JSON结构体，再流转给后续业务系统。例如，设备发送到Topic <code>/$&#123;productKey&#125;/$&#123;deviceName&#125;/user/update</code>的消息需要解析为JSON格式，在开发设备端时，就需配置该Topic为：<code>/$&#123;productKey&#125;/$&#123;deviceName&#125;/user/update?_sn=default</code>。</p>
<p>在Python脚本中，自定义Topic消息解析的接口函数名为<code>transform_payload(topic, rawData)</code>，可以根据不同的topic选择不同的解析方式。</p>
<h4 id="物模型消息解析"><a href="#物模型消息解析" class="headerlink" title="物模型消息解析"></a>物模型消息解析</h4><p>数据格式为<strong>ICA标准数据格式</strong>，设备按照物联网平台定义的标准数据格式生成消息上报，标准Alink JSON数据格式说明，请参见<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/89301.htm#concept-mvc-4tw-y2b">设备属性、事件、服务</a>。</p>
<p>数据格式为<strong>透传/自定义</strong>，设备通信时，需要物联网平台调用您提交的消息解析脚本，将上行物模型消息解析为物联网平台定义的标准格式（Alink JSON），将下行物模型消息据解析为设备的自定义数据格式。</p>
<p>在Python脚本中，设备自定义数据格式转Alink JSON格式数据的函数（上行通信）为<code>raw_data_to_protocol</code>，Alink JSON格式数据转为设备自定义数据格式的函数（下行通信）为<code>protocol_to_raw_data</code>，要注意的是<code>raw_data_to_protocol</code>函数需要将rawData输入转为标准的Alink JSON，参考标准Alink JSON数据格式说明。下面是我这次用到的脚本解析代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ALINK_PROP_REPORT_METHOD = <span class="string">&#x27;thing.event.property.post&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raw_data_to_protocol</span>(<span class="params">rawData</span>):</span><br><span class="line">    uint8Array = []</span><br><span class="line">    <span class="keyword">for</span> byteValue <span class="keyword">in</span> rawData:</span><br><span class="line">        uint8Array.append(byteValue &amp; <span class="number">0xff</span>)</span><br><span class="line">    </span><br><span class="line">    jsonMap = &#123;&#125;</span><br><span class="line">    params = &#123;&#125;</span><br><span class="line">    params[<span class="string">&#x27;status&#x27;</span>] = uint8Array[<span class="number">0</span>]</span><br><span class="line">    params[<span class="string">&#x27;error&#x27;</span>] = uint8Array[<span class="number">1</span>]</span><br><span class="line">    params[<span class="string">&#x27;validIDNum&#x27;</span>] = uint8Array[<span class="number">2</span>]</span><br><span class="line">    params[<span class="string">&#x27;errorSlave&#x27;</span>] = uint8Array[<span class="number">3</span>]</span><br><span class="line">    params[<span class="string">&#x27;idallocTimes&#x27;</span>] = uint8Array[<span class="number">4</span>]</span><br><span class="line">    params[<span class="string">&#x27;costTime&#x27;</span>] = (uint8Array[<span class="number">6</span>]|(uint8Array[<span class="number">7</span>]&lt;&lt;<span class="number">8</span>))		<span class="comment"># 非单字节变量注意大小端</span></span><br><span class="line">    params[<span class="string">&#x27;successCnt&#x27;</span>] = (uint8Array[<span class="number">8</span>]|(uint8Array[<span class="number">9</span>]&lt;&lt;<span class="number">8</span>)|(uint8Array[<span class="number">10</span>]&lt;&lt;<span class="number">16</span>)|(uint8Array[<span class="number">11</span>]&lt;&lt;<span class="number">24</span>))</span><br><span class="line">    params[<span class="string">&#x27;errorCnt&#x27;</span>] = (uint8Array[<span class="number">12</span>]|(uint8Array[<span class="number">13</span>]&lt;&lt;<span class="number">8</span>)|(uint8Array[<span class="number">14</span>]&lt;&lt;<span class="number">16</span>)|(uint8Array[<span class="number">15</span>]&lt;&lt;<span class="number">24</span>))</span><br><span class="line">    jsonMap[<span class="string">&#x27;params&#x27;</span>] = params		<span class="comment"># 物模型中的属性添加到params中，再加到jsonMap</span></span><br><span class="line">    jsonMap[<span class="string">&#x27;method&#x27;</span>] = ALINK_PROP_REPORT_METHOD	<span class="comment"># 标准的Alink JSON必须要加method</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonMap</span><br></pre></td></tr></table></figure>

<h3 id="物模型显示效果"><a href="#物模型显示效果" class="headerlink" title="物模型显示效果"></a>物模型显示效果</h3><p>这次应用是有软件模块过年放假期间需要测试，我用4G Cat.1模块传到阿里云物联网平台记录数据，最终物模型显示效果如下图：</p>
<p><img src="https://hao0527.gitee.io/230121-iot/230121-iot-2.jpg" alt="img"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/20/230120-printf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/01/20/230120-printf/" class="post-title-link" itemprop="url">C语言printf变长参数如何实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-20 17:00:00" itemprop="dateCreated datePublished" datetime="2023-01-20T17:00:00+08:00">2023-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-31 23:40:51" itemprop="dateModified" datetime="2023-01-31T23:40:51+08:00">2023-01-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h3><p>函数原型：<code>int printf(const char *format, ...)</code><br>调用格式为：<code>printf(&quot;&lt;格式化字符串&gt;&quot;, &lt;参量表&gt;);</code><br>功能：发送格式化输出到标准输出 stdout</p>
<h3 id="变长参数实现思路"><a href="#变长参数实现思路" class="headerlink" title="变长参数实现思路"></a>变长参数实现思路</h3><p>C语言支持变长参数函数(Variable Argument Functions)，即参数的个数可以是不定个，在函数定义的时候用<code>...</code>表示。采用这种形式定义的变长参数函数，<strong>至少需要一个普通的形参</strong>，且<code>...</code>需要放在最后一个参数，比如printf函数中的<code>*format</code>后面的<code>...</code>是函数原型的一部分。</p>
<p>变长参数的实现得益于C语言默认的<em><strong>cdecl</strong></em>调用惯例，其参数是<strong>从右向左</strong>压入栈的，第一个参数位于栈顶。这样printf函数实现的时候，就无需关心调用他的函数会传递几个参数过来，而只要关心自己用到几个，将全部参数压入栈，函数处理时从栈中取即可。</p>
<h3 id="自己实现一个变长参数的函数"><a href="#自己实现一个变长参数的函数" class="headerlink" title="自己实现一个变长参数的函数"></a>自己实现一个变长参数的函数</h3><p>Ｃ已经有现成可用的一些东西来帮我们实现变长参数，它主要通过<code>stdarg.h</code>头文件定义的一个变量类型（va_list）和三个宏（va_start、va_arg、va_end）来实现。</p>
<p>实现一个可变长参数的sum函数，第一个参数<code>num</code>传递变长参数中有参数的数量，紧接着后面会传递<code>num</code>个整型变量，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, val = <span class="number">0</span>;</span><br><span class="line">    va_list ap;	<span class="comment">//定义一个具有va_list型的变量，这个变量是指向参数的指针</span></span><br><span class="line">    va_start(ap, num);	<span class="comment">//始化变量刚定义的va_list变量,使其指向第一个可变参数的地址,地址自动增加</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        val += va_arg(ap, <span class="type">int</span>);	<span class="comment">//va_arg返回va_list中的参数，并增加指针偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);	<span class="comment">//结束可变参数列表</span></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16+38+53=%d\n&quot;</span>, sum(<span class="number">3</span>, <span class="number">16</span>, <span class="number">38</span>, <span class="number">53</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变长参数实现原理"><a href="#变长参数实现原理" class="headerlink" title="变长参数实现原理"></a>变长参数实现原理</h3><p>上面的sum函数也可以不使用va_list等宏，通过其他方法实现。<br>当我们调用：<code>int n = sum(3, 16, 38, 53);</code><br>参数在栈上会形成如下布局：<br><img src="https://hao0527.gitee.io/230120-printf/230120-printf-1.jpg" alt="img"></p>
<p>在函数内部，函数可以使用变量<code>num</code>来访问数字3，但无法使用任何名称访问其他的几个不定参数。但此时由于栈上其他的几个参数实际恰好依序排列在参数<code>num</code>的高地址方向，因此可以很简单地通过<code>num</code>的地址计算出其他参数的地址，sum函数的另一种实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = &amp;num + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">        ret += *p++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>printf的不定参数比sum要复杂得多，因为printf的参数不仅数量不定，而且<strong>类型</strong>也不定。所以printf需要在格式字符串中注明参数的类型，例如用<code>%d</code>表明是一个整数。printf里的格式字符串如果将类型描述错误，因为不同参数的大小不同，不仅可能导致这个参数的输出错误，还有可能导致其后的一系列参数错误。[摘自《程序员的自我修养——链接、封装、库》P338]</p>
<p><code>printf(&quot;%lf\t%d\t%c\n&quot;, 1, 666, &#39;a&#39;);</code> 在这行函数里，printf的第一个输出参数是一个int(4 字节)，而我们告诉printf它是一个double(8字节)，因此printf的输出会错误，由于printf在读取double的时候实际造成了越界，因此后面几个参数的输出也会失败。该程序的实际输出为：<code>0.000000 97</code>（根据实际编译器和环境可能不同）</p>
<h3 id="va-list等宏如何实现"><a href="#va-list等宏如何实现" class="headerlink" title="va_list等宏如何实现"></a>va_list等宏如何实现</h3><p><strong>va_list</strong> 实际是一个指针，用来指向各个不定参数。由于类型不明，因此这个 va_list 以 void* 或 char*  为最佳选择。<br><strong>va_start</strong> 将 va_list 定义的指针指向函数的最后一个参数后面的位置，这个位置就是第一个不定参数。<br><strong>va_arg</strong> 获取当前不定参数的值，并根据当前不定参数的大小将指针移向下一个参数。<br><strong>va_end</strong> 将指针清 0。<br>按照以上思路，va_list等宏的一个<strong>最简单的实现</strong>就可以得到了，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_list char*</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap, arg) (ap=(va_list)&amp;arg+sizeof(arg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap, t) (*(t*)((ap+=sizeof(t))-sizeof(t)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) (ap=(va_list)0)</span></span><br></pre></td></tr></table></figure>

<p>注意：实际代码中还套了很多宏，不同编译器，不同架构都有可能使用不同的代码实现，但具体实现思想一致，有些x64条件编译时va_list会是一个结构体，里面会记录可变参数开始地址、结束地址、参数数量等信息。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/17/221217-ddr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/17/221217-ddr/" class="post-title-link" itemprop="url">DDR关键参数介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-17 17:00:00" itemprop="dateCreated datePublished" datetime="2022-12-17T17:00:00+08:00">2022-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-12-21 08:27:07" itemprop="dateModified" datetime="2022-12-21T08:27:07+08:00">2022-12-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>在学习FPGA时使用了DDR3，最近学ARM处理器也用到了DDR3的外设，在FPGA是使用 MIG(Memory Interface Generators)IP核驱动DDR3，ARM处理器是通过配置MMDC(Multi Mode DDR Controller)模块驱动DDR3，这编博客将会介绍使用DDR需配置的几个关键参数。</p>
<p>SRAM操作流程、时序图可以浏览我之前的文章，<a href="/2021/12/19/211219-fpga%E4%B9%8Bsdram/">FPGA之SDRAM学习</a>。</p>
<h3 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h3><h4 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h4><p>传输速率的单位是MT/s(Mega Transfer Per Second)，即每秒传输的百万次数，常见DDR3有800MT/s、1066MT/s、1333MT/s、1600MT/s等，这是首先需要考虑的，该参数决定了DDR的最高数据传输速率。</p>
<h4 id="tRCD-参数"><a href="#tRCD-参数" class="headerlink" title="tRCD 参数"></a>tRCD 参数</h4><p>tRCD 全称是 RAS-to-CAS Delay，也就是<strong>行寻址到列寻址之间的延迟</strong>。 DDR 的寻址流程是先指定 BANK 地址，然后在指定行地址，最后指定列地址确定最终要寻址的单元。 BANK 地址和行地址是同时发出的，这个命令叫做<strong>行激活</strong>(Row Active)。行激活以后就发送列地址和具体的操作命令(读还是写)，这两个是同时发出的，因此一般也用<strong>读/写命令</strong>表示<strong>列寻址</strong>。在行有效(行激活)到读/写命令发出的这段时间间隔叫做 tRCD。</p>
<h4 id="CL-参数"><a href="#CL-参数" class="headerlink" title="CL 参数"></a>CL 参数</h4><p>当列地址发出以后就会触发数据传输，但是从数据从存储单元到内存芯片 IO 接口上还需要一段时间，这段时间就是非常著名的 CL(CAS Latency)，也就是<strong>列地址选通潜伏期</strong>。</p>
<h4 id="AL-参数"><a href="#AL-参数" class="headerlink" title="AL 参数"></a>AL 参数</h4><p>在 DDR 的发展中，提出了一个前置 CAS 的概念，目的是为了解决 DDR 中的指令冲突，它允许 CAS 信号紧随着 RAS 发送，相当于将 DDR 中的 CAS 前置了。但是读/写操作并没有因此提前，依旧要保证足够的延迟/潜伏期，为此引入了 AL(Additive Latency)，单位也是时钟周期数。 AL+CL 组成了 RL(Read Latency)，从 DDR2 开始还引入了写潜伏期 WL(Write Latency)，WL 表示写命令发出以后到第一笔数据写入的潜伏期。</p>
<h4 id="tRAS-参数"><a href="#tRAS-参数" class="headerlink" title="tRAS 参数"></a>tRAS 参数</h4><p>RAS active time，也指Active to Precharge Delay，行有效至行预充电时间。是指从收到一个请求后到初始化RAS(行地址选通脉冲)真正开始接受数据的间隔时间，tRAS 是 ACTIVE 命令到 PRECHARGE 命令之间的最小时间，tRAS=tRCD+tWR。</p>
<h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><h4 id="tRP-参数"><a href="#tRP-参数" class="headerlink" title="tRP 参数"></a>tRP 参数</h4><p>在发出预充电命令之后，要经过一段时间才能允许发送RAS行有效命令打开新的工作行，这个间隔被称为tRP（RAS Precharge time，预充电有效时间）。</p>
<h4 id="tRC-参数"><a href="#tRC-参数" class="headerlink" title="tRC 参数"></a>tRC 参数</h4><p>tRC(Row Cycle Time)，表示“SDRAM行周期时间”，它是包括行单元预充电到激活在内的整个过程所需要的最小的时钟周期数，是两个 ACTIVE 命令或者 ACTIVE 命令到 REFRESH 命令之间的周期。tRC=tRAS+tRP。如果tRC的时间过长，会因在完成整个时钟周期后激活新的地址而等待无谓的延时，而降低性能。然而如果该值设置过小，在被激活的行单元被充分充电之前，新的周期就可以被初始化，也会导致数据丢失和损坏。</p>
<h4 id="tWR-参数"><a href="#tWR-参数" class="headerlink" title="tWR 参数"></a>tWR 参数</h4><p>由于数据信号由控制端发出，输入时芯片无需做任何调校，只需直接传到数据输入寄存器中，然后再由写入驱动器进行对存储电容的充电操作，因此数据可以与CAS同时发送，也就是说写入延迟为0。不过，数据并不是即时地写入存储电容，因为选通三极管（就如读取时一样）与电容的充电必须要有一段时间，所以数据的真正写入需要一定的周期。为了保证数据的可靠写入，都会留出足够的写入/校正时间（tWR，Write Recovery Time），这个操作也被称作写回（Write Back）。tWR至少占用一个时钟周期或再多一点（时钟频率越高，tWR占用周期越多）。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao</p>
  <div class="site-description" itemprop="description">保持热爱，奔赴山海。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">66</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
