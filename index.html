<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/heng32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/heng16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="保持热爱，奔赴山海。">
<meta property="og:type" content="website">
<meta property="og:title" content="永恆博客网">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="永恆博客网">
<meta property="og:description" content="保持热爱，奔赴山海。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>永恆博客网</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">永恆博客网</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/27/231227-argv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/27/231227-argv/" class="post-title-link" itemprop="url">C语言传递的参数还能这样解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-27 21:30:00 / 修改时间：23:17:41" itemprop="dateCreated datePublished" datetime="2023-12-27T21:30:00+08:00">2023-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前写脚本的时候用到过传参：python最简单，直接<code>import argparse</code>。shell中使用<code>$#</code>表示传递到脚本的参数个数，用<code>$*</code>表示以一个单字符串显示所有向脚本传递的参数，如”$*“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。bat脚本传参和shell类似，<code>%#</code>表示传递到脚本的参数个数，<code>%*</code>表示参数字符串，*可以是数字。在C语言中可以使用<code>getopt</code>，它是一个标准的C库函数，用于解析命令行参数。它可以帮助你处理短选项（-h）和长选项（–help）。</p>
<p>今天学习 <a target="_blank" rel="noopener" href="https://github.com/dbry/adpcm-xq">adpcm-xq</a> 看到一个C代码直接用指针操作argv，如*++*argv，能差不多看懂，现在回家再来理一下。</p>
<h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(argc, argv)</span> <span class="type">int</span> argc; <span class="type">char</span> **argv;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lookahead = <span class="number">3</span>, flags = ADPCM_FLAG_NOISE_SHAPING, blocksize_pow2 = <span class="number">0</span>, overwrite = <span class="number">0</span>, asked_help = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *infilename = <span class="literal">NULL</span>, *outfilename = <span class="literal">NULL</span>;</span><br><span class="line">    FILE *outfile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the name of the executable ends in &quot;encoder&quot; or &quot;decoder&quot;, just do that function</span></span><br><span class="line">    encode_only = argc &amp;&amp; <span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;encoder&quot;</span>) &amp;&amp; <span class="built_in">strlen</span> (<span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;encoder&quot;</span>)) == <span class="built_in">strlen</span> (<span class="string">&quot;encoder&quot;</span>);</span><br><span class="line">    decode_only = argc &amp;&amp; <span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;decoder&quot;</span>) &amp;&amp; <span class="built_in">strlen</span> (<span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;decoder&quot;</span>)) == <span class="built_in">strlen</span> (<span class="string">&quot;decoder&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop through command-line arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (_WIN32)</span></span><br><span class="line">        <span class="keyword">if</span> ((**++argv == <span class="string">&#x27;-&#x27;</span> || **argv == <span class="string">&#x27;/&#x27;</span>) &amp;&amp; (*argv)[<span class="number">1</span>])</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> ((**++argv == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (*argv)[<span class="number">1</span>])</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">while</span> (*++*argv)</span><br><span class="line">                <span class="keyword">switch</span> (**argv) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">                        lookahead = **argv - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                        blocksize_pow2 = strtol (++*argv, argv, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (blocksize_pow2 &lt; <span class="number">8</span> || blocksize_pow2 &gt; <span class="number">15</span>) &#123;</span><br><span class="line">                            <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nblock size power must be 8 to 15!\n&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        --*argv;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                        decode_only = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                        encode_only = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                        flags &amp;= ~ADPCM_FLAG_NOISE_SHAPING;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                        asked_help = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">                        verbosity = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">                        flags |= ADPCM_FLAG_RAW_OUTPUT;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                        verbosity = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">                        overwrite = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nillegal option: %c !\n&quot;</span>, **argv);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!infilename) &#123;</span><br><span class="line">            infilename = <span class="built_in">malloc</span> (<span class="built_in">strlen</span> (*argv) + <span class="number">10</span>);</span><br><span class="line">            <span class="built_in">strcpy</span> (infilename, *argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!outfilename) &#123;</span><br><span class="line">            outfilename = <span class="built_in">malloc</span> (<span class="built_in">strlen</span> (*argv) + <span class="number">10</span>);</span><br><span class="line">            <span class="built_in">strcpy</span> (outfilename, *argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nextra unknown argument: %s !\n&quot;</span>, *argv);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbosity &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;%s&quot;</span>, sign_on);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!outfilename || asked_help) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%s&quot;</span>, usage);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span> (infilename, outfilename)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;can&#x27;t overwrite input file (specify different/new output file name)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!overwrite &amp;&amp; (outfile = fopen (outfilename, <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">        fclose (outfile);</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;output file \&quot;%s\&quot; exists (use -y to overwrite)\n&quot;</span>, outfilename);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adpcm_converter (infilename, outfilename, flags, blocksize_pow2, lookahead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="argc-argv-知识"><a href="#argc-argv-知识" class="headerlink" title="argc argv 知识"></a>argc argv 知识</h2><p>C语言中的<code>argc</code>和<code>argv</code>通常用于处理命令行参数。在C程序中，<code>main</code>函数可以接受两个参数，分别是<code>argc</code>（参数计数）和<code>argv</code>（参数向量）。</p>
<ul>
<li><code>argc</code> 表示命令行参数的数量（包含命令），它是一个整数。</li>
<li><code>argv</code> 是一个指向字符指针数组的指针，每个指针指向一个字符串，这些字符串是命令行参数的实际内容。<code>argv[0]</code>通常是程序的名称，而<code>argv[1]</code>、<code>argv[2]</code>等则是传递给程序的参数。</li>
</ul>
<p>下面是一个简单的例子，展示了如何在C语言中使用<code>argc</code>和<code>argv</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of arguments: %d\n&quot;</span>, argc);</span><br><span class="line">    <span class="comment">// 输出所有命令行参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Argument %d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设你将上述代码保存在一个名为 <code>example.c</code> 的文件中，然后通过命令行编译并运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc example.c -o example</span><br><span class="line">./example arg1 arg2 arg3</span><br></pre></td></tr></table></figure>

<p>这将输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CopyNumber of arguments:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">Argument 0:</span> <span class="string">./example</span></span><br><span class="line"><span class="attr">Argument 1:</span> <span class="string">arg1</span></span><br><span class="line"><span class="attr">Argument 2:</span> <span class="string">arg2</span></span><br><span class="line"><span class="attr">Argument 3:</span> <span class="string">arg3</span></span><br></pre></td></tr></table></figure>

<p>这里，<code>argc</code>是4，因为有四个参数（包括程序的名称），而<code>argv</code>包含这四个参数的字符串。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>接下来我将对代码片段中的argc argv相关代码的逐行分析：</p>
<h3 id="片段1"><a href="#片段1" class="headerlink" title="片段1"></a>片段1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if the name of the executable ends in &quot;encoder&quot; or &quot;decoder&quot;, just do that function</span></span><br><span class="line">encode_only = argc &amp;&amp; <span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;encoder&quot;</span>) &amp;&amp; <span class="built_in">strlen</span> (<span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;encoder&quot;</span>)) == <span class="built_in">strlen</span> (<span class="string">&quot;encoder&quot;</span>);</span><br><span class="line">decode_only = argc &amp;&amp; <span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;decoder&quot;</span>) &amp;&amp; <span class="built_in">strlen</span> (<span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;decoder&quot;</span>)) == <span class="built_in">strlen</span> (<span class="string">&quot;decoder&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>argc</code>：传递给程序的命令行参数数量；<code>argv[0]</code>：可执行文件的名称（第一个命令行参数）。</p>
<p><code>char *strstr(const char *haystack, const char *needle);</code> 返回一个指向第一次出现 <code>needle</code> 的指针，如果未找到，则返回 <code>NULL</code>。</p>
<p><code>strlen</code>用于计算字符串的长度，即字符串中字符的个数，不包括字符串末尾的 null 终止符。</p>
<p>这段代码用于检查可执行文件的名称（从命令行参数 <code>argv[0]</code> 获取）是否以 “encoder” 或 “decoder” 结尾（出现字符通过<code>strstr</code>保证，结尾通过<code>strlen</code>保证）。它根据这些条件设置两个布尔变量 <code>encode_only</code> 和 <code>decode_only</code>。</p>
<h3 id="片段2"><a href="#片段2" class="headerlink" title="片段2"></a>片段2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 循环了 argc - 1 次，遍历完所有命令参数</span></span><br><span class="line">    <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (_WIN32)</span></span><br><span class="line">        <span class="comment">// argv首先自增，即指向下一个字符串，**argv是字符串的第一个字符，比较是否为&#x27;-&#x27;或&#x27;/&#x27;，</span></span><br><span class="line">        <span class="comment">// &amp;&amp; (*argv)[1]，且这个字符串存在第二个字符</span></span><br><span class="line">        <span class="keyword">if</span> ((**++argv == <span class="string">&#x27;-&#x27;</span> || **argv == <span class="string">&#x27;/&#x27;</span>) &amp;&amp; (*argv)[<span class="number">1</span>])</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">// argv首先自增，即指向下一个字符串，**argv是字符串的第一个字符，比较是否为&#x27;-&#x27;，</span></span><br><span class="line">        <span class="comment">// &amp;&amp; (*argv)[1]，且这个字符串存在第二个字符</span></span><br><span class="line">        <span class="keyword">if</span> ((**++argv == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (*argv)[<span class="number">1</span>])</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="comment">// argv是指针数组，*argv是指向的字符串，++*argv是增加偏移1字节，指向字符串下一个字符，</span></span><br><span class="line">            <span class="comment">// *++*argv就是下个字符，while (*++*argv)意思就是当下个字符不为结束符&#x27;\0&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> (*++*argv)</span><br><span class="line">                <span class="comment">// **argv是字符串中的一个字符，上一行用++让字符串*argv的指向+1，**argv就是当前指向的字符串字符</span></span><br><span class="line">                <span class="keyword">switch</span> (**argv) &#123;</span><br></pre></td></tr></table></figure>

<h3 id="片段3"><a href="#片段3" class="headerlink" title="片段3"></a>片段3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">    lookahead = **argv - <span class="string">&#x27;0&#x27;</span>;	<span class="comment">// lookahead为数值，字符串转数值</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="片段4"><a href="#片段4" class="headerlink" title="片段4"></a>片段4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">    <span class="comment">// long strtol(const char *str, char **endptr, int base);</span></span><br><span class="line">    <span class="comment">// strtol 用于将字符串转换为长整型数（long）返回，str是要转换的字符串，base 10表示十进制，</span></span><br><span class="line">    <span class="comment">// endptr 如果不是 NULL，则它存储一个指向第一个无法转换的字符的指针，或者如果字符串为空，则指向 str 的开始，</span></span><br><span class="line">    <span class="comment">// 感觉这行代码endptr把 argv 传进去有风险，如果++*argv无法转换成long，argv则会被写</span></span><br><span class="line">    blocksize_pow2 = strtol (++*argv, argv, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (blocksize_pow2 &lt; <span class="number">8</span> || blocksize_pow2 &gt; <span class="number">15</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nblock size power must be 8 to 15!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 感觉这行可有可无，都要break了，接下来就是检查下个字符串了</span></span><br><span class="line">    --*argv;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="片段5"><a href="#片段5" class="headerlink" title="片段5"></a>片段5</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!infilename) &#123;</span><br><span class="line">    <span class="comment">// 先是把非&#x27;-&#x27;开头的参数赋给输入文件名字</span></span><br><span class="line">    infilename = <span class="built_in">malloc</span> (<span class="built_in">strlen</span> (*argv) + <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span> (infilename, *argv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!outfilename) &#123;</span><br><span class="line">    <span class="comment">// 再是把非&#x27;-&#x27;开头的参数赋给输出文件名字</span></span><br><span class="line">    outfilename = <span class="built_in">malloc</span> (<span class="built_in">strlen</span> (*argv) + <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span> (outfilename, *argv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果参数有问题就输出stderr，打印出是哪个参数错误</span></span><br><span class="line">    <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nextra unknown argument: %s !\n&quot;</span>, *argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在没有用解析命令参数库的情况下，竟然可以这样实现一些常见的命令选项功能，佩服！</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/31/231031-wdg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/31/231031-wdg/" class="post-title-link" itemprop="url">AUTOSAR Wdg Stack 架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-31 10:30:00" itemprop="dateCreated datePublished" datetime="2023-10-31T10:30:00+08:00">2023-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-01 21:50:34" itemprop="dateModified" datetime="2023-11-01T21:50:34+08:00">2023-11-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AUTOSAR/" itemprop="url" rel="index"><span itemprop="name">AUTOSAR</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Wdg-功能"><a href="#Wdg-功能" class="headerlink" title="Wdg 功能"></a>Wdg 功能</h2><p>看门狗/Wdg模块是一个独立的定时器，它的作用是提供安全功能以确保软件按计划执行，并且CPU不会陷入无限循环或执行意外的代码。如果Wdg模块在一定时间内未被触发/刷新/喂狗，它将复位MCU。</p>
<p>看门狗功能对于关键安全系统是必须的，对于非关键安全系统也是很有必要的。</p>
<p>对于汽车上使用的诸多零部件，鉴于汽车环境的恶劣，各类ECU中的软件均有可能遭受如外部电磁干扰，高温等环境因素的影响，从而导致程序“跑飞”或者“死机”现象，此时如果有看门狗的存在，便可以主动触发系统复位机制保证能够再次正常使用。</p>
<h2 id="硬件看门狗"><a href="#硬件看门狗" class="headerlink" title="硬件看门狗"></a>硬件看门狗</h2><p>硬件看门狗依赖自身定时器来完成看门狗功能，俗称“硬狗”。常见的硬件看门狗比如MCU内部自带的看门狗、外部的独立看门狗。至于选用何种的硬件看门狗，取决于自身系统设计需要。</p>
<p>在使用硬件看门狗的时候需要特别考虑以下：</p>
<ul>
<li>该硬件看门狗的最大超时时间能否满足系统设计需求，如果该超时时间过小，就会导致整个系统的不稳定性，误触发看门狗。</li>
<li>该硬件看门狗是否可以进行关闭，对于关键安全系统，一般都要求看门狗一旦打开将不允许被关闭。</li>
<li>该硬件看门狗系统上电后默认处于开狗还是关狗状态，如果是默认开狗，那么对于软件而言，需考虑芯片上电后便要进行喂狗或者重置看门狗行为，同时设计一种在刷软件或者调试软件前的物理关狗动作。</li>
<li>该硬件看门狗是采用哪种方式进行喂狗，如通过GPIO，IIC或SPI等通讯方式来喂狗。</li>
</ul>
<p>UJA1078A手册：</p>
<p><img src="https://hao0527.gitee.io/231031-wdg/sbc-ds1-en.png" alt="img"></p>
<p><img src="https://hao0527.gitee.io/231031-wdg/sbc-ds1-cn.png" alt="img"></p>
<h2 id="软件看门狗"><a href="#软件看门狗" class="headerlink" title="软件看门狗"></a>软件看门狗</h2><p>属于通过软件定时器的方式来实现看门狗功能，俗称“软狗”。软件看门狗的时基本质上也需要依赖硬件定时器。</p>
<p>比如常见的用systick作时基，通过一个task运行软狗监控的定时器不断递减，其他task程序则是重置软狗定时器，如果软狗监控的某个定时器归零，那么此时可以便可以判断其他task并没有被正常的执行，此时便可以通过主动复位的方式来实现看门狗功能。</p>
<p>以上可实现软狗对<strong>多个task</strong>的监控，这是硬狗没有的功能。软狗除了实现硬狗timeout和window的两种模式，还可以实现其他模式，取决于软件，监控的花样更多。</p>
<p>一般而言，运行软狗的主任务的优先级不应设置比被监控的任务优先级低，所以软狗无法检测Hardfault中卡死的问题。<strong>软狗跟硬狗搭配在一起使用</strong>，可以解决硬狗监控模式单一、软狗执行优先级没被监控任务高的问题。</p>
<h2 id="AUTOSAR-Wdg-架构"><a href="#AUTOSAR-Wdg-架构" class="headerlink" title="AUTOSAR Wdg 架构"></a>AUTOSAR Wdg 架构</h2><h3 id="内部分层"><a href="#内部分层" class="headerlink" title="内部分层"></a>内部分层</h3><p><img src="https://hao0527.gitee.io/231031-wdg/wdg-stack.png" alt="img"></p>
<p>Watchdog Driver：用于实现针对硬件看门狗的寄存器操作与控制，可以分为MCU内部看门狗(Internal Watchdog)与外部看门狗(External Watchdog)，该外部看门狗可以通过GPIO、IIC或SPI来实现喂狗。</p>
<p>Watchdog Interface：其主要功能则是为了实现上层Watchdog Manager与底层Watchdog Driver的连接，当然其连接的底层Watchdog Driver可以存在多个。</p>
<p>Watchdog Manager：作为整个看门狗协议栈中的服务层，主体功能就是为了负责整个程序执行的正确性，并触发相应的硬件看门狗的喂狗动作，扮演了整个监控的核心角色。</p>
<h3 id="WdgM-依赖"><a href="#WdgM-依赖" class="headerlink" title="WdgM 依赖"></a>WdgM 依赖</h3><p><img src="https://hao0527.gitee.io/231031-wdg/wdgM-dep-en.png" alt="img"></p>
<p><img src="https://hao0527.gitee.io/231031-wdg/wdgM-dep-cn.png" alt="img"></p>
<h2 id="AUTOSAR-Wdg-基础知识"><a href="#AUTOSAR-Wdg-基础知识" class="headerlink" title="AUTOSAR Wdg 基础知识"></a>AUTOSAR Wdg 基础知识</h2><h3 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h3><p>在AUTOSAR架构中，针对Watchdog Driver而言，定义了看门狗控制模式存在如下三种模式：</p>
<ul>
<li>Off Mode：表示看门狗关闭状态，对于关键安全系统，一般不能将其切换至Off状态，即一旦打开，将不能被关闭。</li>
<li>Slow Mode：表示看门狗的一个长时间喂狗窗口，该模式一般用于系统启动初始化过程中。</li>
<li>Fast Mode：表示看门狗的正常喂狗模式，该模式运用在系统正常运行的过程中。</li>
</ul>
<h2 id="AUTOSAR-Wdg-各层功能"><a href="#AUTOSAR-Wdg-各层功能" class="headerlink" title="AUTOSAR Wdg 各层功能"></a>AUTOSAR Wdg 各层功能</h2><h3 id="Wdg"><a href="#Wdg" class="headerlink" title="Wdg"></a>Wdg</h3><p>Wdg通常有两种，一种是芯片内部自带的片内看门狗；还有一种是在芯片外部通过SPI这种接口连接的片外看门狗。MCAL只负责第一种片内看门狗，片内看门狗的特点是Wdg模块是直接访问相关硬件寄存器。片外看门狗属于板级设备抽象层负责，通常需要使用MCAL提供的其他模块（比如SPI等）来访问/控制外扩看门狗芯片，这种不能直接访问硬件寄存器。</p>
<p>部分flash不能在写的时候读取，所以该模块代码可以在RAM里面运行。比如在刷写Flash时，Wdg模块可能作为二进制文件里面的一部分在RAM上运行。（到底哪些部分需要放RAM？）</p>
<h4 id="Wdg-API"><a href="#Wdg-API" class="headerlink" title="Wdg API"></a>Wdg API</h4><p>Wdg 驱动层，主要接口就三个，调用方式如下图：</p>
<p><img src="https://hao0527.gitee.io/231031-wdg/wdg-1.png" alt="img"></p>
<ul>
<li>wdg初始化：通过EcuM模块调用函数Wdg_Init来完成Watchdog的初始化配置。</li>
<li>触发wdg喂狗：通过WdgM模块调用WdgIf模块提供的函数WdgIf_SetTriggerCondition来触发底层驱动进行喂狗（不是wdg真正的喂狗操作），并设置下次看门狗timeout时间。</li>
<li>改变wdg模式：通过WdgM模块调用WdgIf模块提供的函数WdgIf_SetMode来实现看门狗模式的改变。</li>
</ul>
<h4 id="喂狗"><a href="#喂狗" class="headerlink" title="喂狗"></a>喂狗</h4><p>在AUTOSAR之前的版本中，看门狗服务是<strong>由上层软件来调用</strong>，会导致一些问题：</p>
<ol>
<li>很难保证针对窗口式看门狗严格的时间约束。新版对这部分做了优化，优化的基本思想是将<strong>用于维护看门狗硬件时序的服务与逻辑控制分开</strong>，触发看门狗的时基可以通过系统时钟（systick）来提供，而控制看门狗硬件的程序可直接在硬件定时器的中断函数里面实现，这样可确保满足窗口式看门狗的喂狗时间准确。</li>
<li>很难处理了快和慢两种模式。Wdg模块3种模式其中两种是Slow，Fast模式。很多时候应用层可能并不需要那么严格的时间监控，可能秒级的周期即可。但由于喂狗周期都是固定的且比较短，应用层不断去喂狗会导致性能下降，而且需要到处穿插喂狗函数。</li>
<li>应用软件频繁修改硬狗寄存器不安全。现在AUTOSAR实现方式，应用层调用喂狗函数（Wdg_SetTriggerCondition）并不是直接去操作硬件看门狗寄存器的，而是去喂软狗。<strong>真正喂硬狗靠硬件定时器</strong>，在定时器中断回调中判断软狗没问题才去操作硬狗寄存器。</li>
</ol>
<p>看门狗驱动程序和硬狗操作之间的调用方式如下图：</p>
<p><img src="https://hao0527.gitee.io/231031-wdg/wdg-2.png" alt="img"></p>
<h3 id="WdgIf"><a href="#WdgIf" class="headerlink" title="WdgIf"></a>WdgIf</h3><p>和NvM下的MemIf功能相同，可以通过DeviceIndex区分要调用哪个Wdg Driver，可以用宏或函数实现，接口如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Std_ReturnType <span class="title function_">WdgIf_SetMode</span><span class="params">(uint8 DeviceIndex, WdgIf_ModeType WdgMode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">WdgIf_SetTriggerCondition</span><span class="params">(uint8 DeviceIndex, uint16 Timeout)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="WdgM"><a href="#WdgM" class="headerlink" title="WdgM"></a>WdgM</h3><p>Watchdog Manager可以理解为一种应用层软狗机制，该软件机制监控的对象被称为<strong>监控实体</strong>（SupervisedEntity, SE），通过在每个监控实体中打上对应的<strong>检查点</strong>（Checkpoint, CP）监控程序是否正常。</p>
<p>WdgM中可以创建一个或多个SE，每个SE都有对应的SEID。<br>每个SE可以创建一个或多个CP，每个CP都有对应的CheckpointID。<br>每个SE可以选择一个<strong>监控方式</strong>，这个取决于具体的需求，监控方式可以分为如下三种：</p>
<ol>
<li>Alive Supervision: 用于监控周期性任务是否周期性运行。</li>
<li>Deadline Supervision：用于监控事件型任务的运行时间是否超时。</li>
<li>Logical Supervision: 用于监控任务的执行逻辑/时序是否正确。</li>
</ol>
<p>每一个监控实体可以基于上述三种监控方式计算得出监控结果，被称为<strong>Local Status</strong>。<br>当每一个监控实体的状态得到确定，那么整个MCU的监控结果便可以最终确定，这个最终确定的状态被称为<strong>Global Status</strong>。</p>
<h4 id="WdgM-API"><a href="#WdgM-API" class="headerlink" title="WdgM API"></a>WdgM API</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">WdgM_Init</span><span class="params">(<span class="type">const</span> WdgM_ConfigType *ConfigPtr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WdgM_DeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (WDGM_VERSION_INFO_API == STD_ON)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WdgM_GetVersionInfo(_vi) STD_GET_VERSION_INFO(_vi,WDGM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_SetMode</span><span class="params">(WdgM_ModeType Mode)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_GetMode</span><span class="params">(WdgM_ModeType *Mode)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_CheckpointReached</span><span class="params">(WdgM_SupervisedEntityIdType SEID, WdgM_CheckpointIdType CheckpointID)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_GetLocalStatus</span><span class="params">(WdgM_SupervisedEntityIdType SEID, WdgM_LocalStatusType *Status)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_GetGlobalStatus</span><span class="params">(WdgM_GlobalStatusType *Status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WdgM_PerformReset</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_GetFirstExpiredSEID</span><span class="params">(WdgM_SupervisedEntityIdType *SEID)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WdgM_MainFunction</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h4><p>Figure 2: Local Supervision Status:</p>
<p><img src="https://hao0527.gitee.io/231031-wdg/wdgM-1.png" alt="img"></p>
<p>在从其他状态切换至WDGM_LOCAL_STATUS_EXPIRED状态时，Watchdog Manager提供一定的时间保留机制能够允许做一些特别的操作，如设置看门狗模式或者写入NvM数据，复位原因等。</p>
<p>Figure 3: Global Supervision Status:</p>
<p><img src="https://hao0527.gitee.io/231031-wdg/wdgM-2.png" alt="img"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/20/231020-MemoryStack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/20/231020-MemoryStack/" class="post-title-link" itemprop="url">Memory Stack 开发总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-20 16:00:00" itemprop="dateCreated datePublished" datetime="2023-10-20T16:00:00+08:00">2023-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-22 00:12:42" itemprop="dateModified" datetime="2023-10-22T00:12:42+08:00">2023-10-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AUTOSAR/" itemprop="url" rel="index"><span itemprop="name">AUTOSAR</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Memory-Stack-开发总结"><a href="#Memory-Stack-开发总结" class="headerlink" title="Memory Stack 开发总结"></a>Memory Stack 开发总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>截止目前，已经完成了 FlashDriver、Fls、Fee、MemIf、NvM 的开发。开发的 Memory Stack 只是借鉴了 AUTOSAR Memory Stack 架构，并非完全相同，为了兼容旧版软件，也有部分不符合 AUTOSAR 规范的地方。为了解决一些特殊需求，也有一些创新之处。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>AUTOSAR 官方资料</li>
<li><a target="_blank" rel="noopener" href="https://www.embeddedtutor.com/search/label/Autosar">https://www.embeddedtutor.com/search/label/Autosar</a></li>
</ol>
<h3 id="设计方式"><a href="#设计方式" class="headerlink" title="设计方式"></a>设计方式</h3><h4 id="FlashDriver"><a href="#FlashDriver" class="headerlink" title="FlashDriver"></a>FlashDriver</h4><p>Flash驱动层，这一层AUTOSAR中是没有的，我的理解是，AUTOSAR的Fls是Fee代码组件是由芯片厂家提供，那么mcu厂家提供的代码不会兼容其他厂家的外部Flash。代码我只看了云途配置工具生成的Fls代码和NXP官网上的一些芯片的BSW库，并没有见到过有外部Flash厂家提供的Fls代码。为了解决这个问题，我对Fls做了抽象，将不同Flash相关的代码和Fls分开，故有FlashDriver层。不同Flash有共性同时也有特性，为保留特性，借鉴了Linux中对各种外设共有属性和私有属性的思想，这个我是在看《嵌入式C语言自我修养——从芯片、编译器到操作系统》里学的。</p>
<p>Flash驱动层对上层Fls通过一个成员全是函数指针的结构体提供接口，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*Flash_Init)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr);</span><br><span class="line">	MemIf_JobResultType (*Flash_Erase)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType TargetAddress);</span><br><span class="line">	MemIf_JobResultType (*Flash_Write)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType TargetAddress, <span class="type">const</span> uint8 *SourceAddressPtr, Fls_LengthType Length);</span><br><span class="line">	MemIf_JobResultType (*Flash_Read)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType SourceAddress, uint8 *TargetAddressPtr, Fls_LengthType Length);</span><br><span class="line">	MemIf_JobResultType (*Flash_Compare)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType SourceAddress, <span class="type">const</span> uint8 *TargetAddressPtr, Fls_LengthType Length);</span><br><span class="line">	MemIf_JobResultType (*Flash_GetStatus)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr);</span><br><span class="line">&#125; Fls_DriverFunType;</span><br></pre></td></tr></table></figure>
<p>此结构体在每个FlashDriver中有定义，并且是对外的全局变量。用户在配置Fls时，可以配置此结构体指针，这样Fls就可以使用不同的Flash驱动了。</p>
<h5 id="保留特性"><a href="#保留特性" class="headerlink" title="保留特性"></a>保留特性</h5><p>每种Flash驱动对应一份FlashDriver代码，目前已完成两种FlashDriver开发，一个是mcu内部Flash，另一个是spi通信的外部Flash。每个Flash共有的属性有起始地址、扇区大小（最小擦除量）、扇区个数、页大小（最大写入量），特性有不同的通信方式。如外部Flash SPI通信，需要配置其SPI ID，这是在有MCAL（mcu硬件抽象层）的基础上，如果没有MCAL FlashDriver这一层需要把SPI配置都用用户配置的方式实现，方便封库。</p>
<p>为保留特性，FlashDriver每个接口都由上层传递了<code>FlsPrivateConfigPtr</code>，接口定义里这是个void指针，在每个FlashDriver的接口实现里将其转成了自己特性配置的结构体指针类型。特性配置结构体类型声明在每个FlashDriver的头文件中，由用户在Fls用户代码中定义配置，再配置进Fls层，上层Fls只是做了传递这个配置给FlashDriver，Fls无法解析这个配置。</p>
<p>像mcu内部Flash好像并不需要什么特性配置，读写方式都是定死的。不需要<code>FlsPrivateConfigPtr</code>可以在配置Fls时将这个指针配成NULL。</p>
<h5 id="阻塞在哪"><a href="#阻塞在哪" class="headerlink" title="阻塞在哪"></a>阻塞在哪</h5><p>阻塞在哪里也是个问题，在开发Fls时才想到，一开始我都是阻塞在FlashDriver，因为实现方便，写入和擦除操作可以直接查Flash状态阻塞到完成。后来Fls想做同时支持同步也支持异步的方式，还有需求是Fls超时结束任务，这就需要有Fls去控制是否还要继续阻塞。故FlashDriver中就不阻塞，新增一个读状态接口<code>Flash_GetStatus</code>，阻塞在Fls层。</p>
<p>但阻塞在FlashDriver这个配置也保留了，可以通过宏选择是否阻塞在驱动。为什么留？写入、擦除出现问题时，改这个成阻塞也不管超时，可以判断下是不是异步导致的问题，调试也能更好的定位问题（阻塞在有问题的地方，可以分析函数调用栈）。 目前Flash底层驱动可以提供阻塞或非阻塞的接口让Fls调用，甚至可以通过私有配置实现部分地址使用阻塞，部分地址使用非阻塞的方式。</p>
<h5 id="其余问题"><a href="#其余问题" class="headerlink" title="其余问题"></a>其余问题</h5><p>其余问题是云途这个Flash驱动的问题，如果不严格按例程操作寄存器写，只按手册命令方式写的话坑比较多，可能开发的时候能用，测试也没问题，但集成到整个项目工程里时有玄学问题。</p>
<h4 id="Fls"><a href="#Fls" class="headerlink" title="Fls"></a>Fls</h4><p>按AUTOSAR手册，Fls主要是Flash驱动的功能，对上层提供各种异步读写擦的功能，支持查询任务状态、运行结果。Fls可以将不同地址统一成一个从零开始的线性地址，这个有什么用？假如我想使用两个不连续的Flash扇区，Fls做个地址映射到这两个扇区，对上层来说地址是连续的，上层无需管Flash物理地址，操作的都是逻辑地址，方便上层的使用。</p>
<p>Fls把FlashDriver抽象出来，增加一种flash需编写一份Flash底层驱动，无需修改Fls代码，可在Flash底层驱动里实现不同Flash的私有配置。Fls会传递正确的物理地址和长度等参数给FlashDriver，因此FlashDriver可不用重复检查参数。Fls可以配置多个实例，支持多个实例用同一份FlashDriver，也支持同时有多种不同的Fls实例，他们共用一份Fls代码（增加复用性）。</p>
<h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><p>为什么使用异步？同步阻塞时间过大，影响其他任务运行，异步可以将一个大任务打散成多个小任务多次执行。Fls要实现异步方式调用，任务会在Fls_main里执行，用户可配每次Fls_main执行任务最大的读写量，防止一次main阻塞时间过长。</p>
<p>异步除了在实现的时候会比同步复杂些，用户在调用的时候也会比同步复杂，有os支持下还好，当任务异步调用Fls后可以挂起，定时查询状态或回调的方式，当Fls任务结束后继续执行原任务，假如没有os支持的话，没有挂起接口，用户每次异步调完Fls后需要记录下当前运行的位置，周期调度下次继续执行。异步能让io(flash)操作阻塞时mcu去干别的事，更好的利用处理器性能，但也增加了查询、任务切换等开销。Fls异步写入时，将写入任务拆成一个个异步的页写入任务，执行后内部挂起，等下次执行查状态。像云途的Flash页大小就8字节，岂不是写256字节要分成30多次子任务，这进出函数的开销和利用阻塞的时间，异步到底有没有优化性能呢？</p>
<p>擦除任务异步挺有意义的每次阻塞的时间长，也不用把任务打的很散增大函数出入的开销。GD的外部Flash页有256字节，每次写入阻塞时间较长，这种也适用异步写，车规芯片的SPI速度较低最大4M，需要SPI中断或DMA的支持。</p>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>为何保留同步？通过一个参数来决定是同步执行还是异步执行，同步的好处使用户方便使用。</p>
<p>同步如何实现？其实异步实现了，同步自然就实现了。同步就是一直调用Fls内部的main直到任务执行完毕。</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>Fls需要配置哪些参数？凡是在Fls配置的都是Flash的共有属性，配置较多：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Fls_JobType FlsJobDoing;              <span class="comment">// 正在执行的任务</span></span><br><span class="line">	MemIf_StatusType FlsJobStatus;        <span class="comment">// 任务状态</span></span><br><span class="line">	MemIf_JobResultType FlsJobResult;     <span class="comment">// 任务返回值</span></span><br><span class="line">	Fls_AddressType FlsJobAddr;           <span class="comment">// 任务目前执行到的地址</span></span><br><span class="line">	Fls_LengthType FlsJobLength;          <span class="comment">// 任务目前执行剩余长度</span></span><br><span class="line">	<span class="type">const</span> uint8 *FlsJobDataSrcPtr;        <span class="comment">// 用于传递Write、Compare地址指针参数</span></span><br><span class="line">	uint8 *FlsJobDataDestPtr;             <span class="comment">// 用于传递Read地址指针参数</span></span><br><span class="line">	MemIf_ModeType FlsJobMode;            <span class="comment">// 快速模式或者慢速模式对应的每周期操作的字节数不同</span></span><br><span class="line">	Fls_LengthType FlsPendingEraseLen;    <span class="comment">// 挂起的擦除字节长度（异步擦除用）</span></span><br><span class="line">	Fls_LengthType FlsTotalSize;          <span class="comment">// 此Fls实例的空间总大小</span></span><br><span class="line">&#125; Fls_JobInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	uint16 FlsNumberOfSectors;                <span class="comment">// 扇区个数</span></span><br><span class="line">	uint16 FlsWriteAlignSize;                 <span class="comment">// 写入对齐大小</span></span><br><span class="line">	uint16 FlsReadAlignSize;                  <span class="comment">// 读取对齐大小</span></span><br><span class="line">	Fls_LengthType FlsSectorSize;             <span class="comment">// 单个扇区字节数</span></span><br><span class="line">	Fls_LengthType FlsPageSize;               <span class="comment">// 单个页字节数</span></span><br><span class="line">	Fls_AddressType FlsSectorStartaddress;    <span class="comment">// 第一个扇区起始地址</span></span><br><span class="line">&#125; Fls_SectorType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> Fls_DriverFunType *FlsDriverFunPtr;    <span class="comment">// 驱动函数指针结构体地址</span></span><br><span class="line">	<span class="type">const</span> Fls_SectorType *FlsSectorListPtr;      <span class="comment">// 扇区列表地址</span></span><br><span class="line">	uint8 FlsSectorListNum;                      <span class="comment">// Flash（扇区列表）个数</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr;             <span class="comment">// 不同种类Flash私有属性配置地址</span></span><br><span class="line">	uint32 FlsMaxBlockingTime;                   <span class="comment">// Fls最大阻塞时间（ms），0表示不开启阻塞超时监测</span></span><br><span class="line">	uint8 FlsEnableNonBlockingErase;             <span class="comment">// 开启Fls非阻塞擦除的功能</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		Fls_LengthType FlsMaxReadFastMode;       <span class="comment">// 在快速模式下，一个周期内Read、Compare的最大字节数</span></span><br><span class="line">		Fls_LengthType FlsMaxReadNormalMode;     <span class="comment">// 在正常模式下，一个周期内Read、Compare的最大字节数</span></span><br><span class="line">		Fls_LengthType FlsMaxWriteFastMode;      <span class="comment">// 在快速模式下，一个周期内Write的最大字节数</span></span><br><span class="line">		Fls_LengthType FlsMaxWriteNormalMode;    <span class="comment">// 在正常模式下，一个周期内Write的最大字节数</span></span><br><span class="line">		MemIf_ModeType FlsDefaultJobMode;        <span class="comment">// 初始化后的JobMode</span></span><br><span class="line">	&#125; FlsModeConfig;                             <span class="comment">// 配置不同模式参数</span></span><br><span class="line">&#125; Fls_InstanceConfigType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*FlsBlockingCallbackPtr)(<span class="type">void</span>);                      <span class="comment">// 阻塞回调函数</span></span><br><span class="line">	Fls_JobInfoType *FlsJobInfoListPtr;                        <span class="comment">// 任务管理空间地址</span></span><br><span class="line">	<span class="type">const</span> Fls_InstanceConfigType *FlsInstanceConfigListPtr;    <span class="comment">// Fls实例配置指针</span></span><br><span class="line">	uint8 FlsInstanceNum;                                      <span class="comment">// 总实例数量</span></span><br><span class="line">&#125; Fls_ConfigType;</span><br></pre></td></tr></table></figure>

<p>由于要封模块，并且要做成可重入，所以需要由用户在配置代码中定义每个实例的管理ram，并配置到config常量中。</p>
<h5 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h5><p>从零开始的线性地址如何实现？看了上面的<code>Fls_SectorType</code>配置可以想到，Flash的地址映射关系就是映射到的“扇区列表配置”中。当时有个问题，假如有多个Flash，是不是映射成一个从零开始的地址？这样的话上层调用无需体现实例号的，因为根据地址映射关系就能找到要操作的Flash。后来想想还是不行，需要每个Flash的地址都分开从零开始，因为不同Flash的扇区大小等不同，上层不好只通过地址分辨是哪个Flash然后操作。</p>
<p><img src="https://hao0527.gitee.io/231020-MemoryStack/231020-MemoryStack-3.png" alt="img"></p>
<h5 id="多实例同时运行"><a href="#多实例同时运行" class="headerlink" title="多实例同时运行"></a>多实例同时运行</h5><p>这个特性也是需要支持的，不能让一个Flash阻塞的时候另一个Flash无法使用。如何实现这个特性呢？为每个Fls实例开一个<code>Fls_JobInfoType</code>管理实例的运行状态，每次Fls_main都把不同实例都执行一遍。这里有个可改善点，每次Fls_main只执行一个实例，让Fls_main的周期短一些，可以把多个Fls实例执行的阻塞时间打散一些，整个系统的最大阻塞时间会缩短。</p>
<h5 id="对外接口"><a href="#对外接口" class="headerlink" title="对外接口"></a>对外接口</h5><p>对外接口大致遵循AUTOSAR规范，增加了实例号和是否同步的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Fls_Init</span><span class="params">(<span class="type">const</span> Fls_ConfigType *ConfigPtr, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Erase</span><span class="params">(Fls_AddressType TargetAddress, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Write</span><span class="params">(Fls_AddressType TargetAddress, <span class="type">const</span> uint8 *SourceAddressPtr, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Read</span><span class="params">(Fls_AddressType SourceAddress, uint8 *TargetAddressPtr, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Compare</span><span class="params">(Fls_AddressType SourceAddress, <span class="type">const</span> uint8 *TargetAddressPtr, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_BlankCheck</span><span class="params">(Fls_AddressType TargetAddress, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line"></span><br><span class="line">MemIf_StatusType <span class="title function_">Fls_GetStatus</span><span class="params">(uint8 FlsInstanceId)</span>;</span><br><span class="line">MemIf_JobResultType <span class="title function_">Fls_GetJobResult</span><span class="params">(uint8 FlsInstanceId)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fls_SetMode</span><span class="params">(MemIf_ModeType Mode, uint8 FlsInstanceId)</span>;</span><br><span class="line">uint64 <span class="title function_">Fls_GetErrorCode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fls_MainFunction</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Fee"><a href="#Fee" class="headerlink" title="Fee"></a>Fee</h4><p>AUTOSAR NvM中的Fee(Flash EEPROM Emulation)主要做Flash模拟EEPROM的功能。使用EEPROM，软件可以在任意字节读写，也无需管擦除的事情。使用Flash需要考虑每次写入是否对齐、擦除一整个扇区的时候会不会有其他的数据被擦除，总不能每次写就擦除一整个扇区，一个扇区里就放一点点要存的内容吧。不管是Flash还是EEP通常都有磨损均衡的算法，提高Flash的寿命与利用率。Fee就是干这个事情的，并且要留出和Ea(EEPROM Abstraction Layer)一样的接口供上层MemIf(Memory Abstraction Interface)调用，在NvM操作MemIf，无需关心是Fee还是Ea。这也体现了AUTOSAR Memory Stack的高扇入低扇出思想，对外统一接口，内部可以操作不同的非易失存储器。</p>
<p>Fee是我在实现AUTOSAR Memory Stack中，最复杂的一个模块，先介绍一个基础概念：在内存协议栈中，每个要读写的数据为一个Block数据块，NvM会调用MemIf读写Block，MemIf会调用相应的子设备如Fee。</p>
<h5 id="均衡算法与Cluster概念"><a href="#均衡算法与Cluster概念" class="headerlink" title="均衡算法与Cluster概念"></a>均衡算法与Cluster概念</h5><p>均衡算法参考了AUTOSAR的多Cluster与多Cluster Group，也加入了自己的均衡磨损管理算法，最终可以实现安全可靠的Block存储。</p>
<p>在Fee中，一个Flash被划分成1个或多个Cluster Group，每个Cluster Group中可以管理不同的Block；一个Cluster Group中有2个或多个Cluster，用来均衡磨损，每次写入Block都会在所属的Cluster Group中的一个活跃的Cluster上写入，当所有Cluster被写满时，最老的一个Cluster会被擦除，然后此Cluster待写入。</p>
<p>每个Cluster Group都可以由用户配置，并且都有自己运行时的一份变量空间，一下是Cluster Group的配置与变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Fls_AddressType ClusterFreeSpaceAddr;    <span class="comment">// 指向当前Cluster的空闲空间地址，又表示当前cluster已使用的空间大小</span></span><br><span class="line">	uint16 ActiveClusterId;                  <span class="comment">// 当前ACTIVE的Cluster Id</span></span><br><span class="line">	uint16 ScanStartClusterId;               <span class="comment">// scanBlock从哪块Cluster开始，0xffff为不执行scanBlock</span></span><br><span class="line">	uint32 CycleTimes;                       <span class="comment">// Cluster擦除的周期计数</span></span><br><span class="line">	boolean NeedSwap;                        <span class="comment">// 此clusterGroup是否需要swap</span></span><br><span class="line">&#125; Fee_ClusterGroupInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	uint32 CycleTimes;               <span class="comment">// Cluster擦写次数</span></span><br><span class="line">	Fee_ClusterStatusType Status;    <span class="comment">// Cluster状态</span></span><br><span class="line">	uint8 ClrInfoVerify;             <span class="comment">// ClrId ClrGroup ClusterSize信息 1:正确 0:不正确</span></span><br><span class="line">&#125; Fee_ClusterInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Fls_AddressType ClrStartAddr;          <span class="comment">// Cluster Group起始的Fls地址</span></span><br><span class="line">	Fls_LengthType ClrSize;                <span class="comment">// 每个Cluster的字节数</span></span><br><span class="line">	uint8 ClrGroup;                        <span class="comment">// Cluster Group ID</span></span><br><span class="line">	uint16 NumberOfClr;                    <span class="comment">// Cluster Group中的Cluster数量</span></span><br><span class="line">	Fee_ClusterInfoType *FeeClrInfoPtr;    <span class="comment">// 簇信息管理空间地址（用户需要提供数组大小要与NumberOfClr一致）</span></span><br><span class="line">&#125; Fee_ClusterGroupConfigType;</span><br></pre></td></tr></table></figure>

<p>每个Cluster有它的管理数据结构，Cluster Header中包含了所属哪个Cluster Group、Cluster Id、Cluster Size、擦除次数、状态等信息。初始化会检查这些Cluster头，避免Flash中的Cluster配置与代码不一致造成的数据问题，还可以通过擦除次数看Flash的使用次数，评估其寿命，异常时做云平台上报。</p>
<h5 id="查找最新的Block"><a href="#查找最新的Block" class="headerlink" title="查找最新的Block"></a>查找最新的Block</h5><p>每次上电初始化要做的事就是从Flash中读取Block，那存在Cluster中的哪个Block是最新的呢？首先要知道一个Cluster Group中哪个Cluster是最新的。Cluster Header中会有Cluster的状态，一般情况下最新的Cluster有个活跃的状态，便可知最老的那个Cluster，从最老的Cluster上遍历查找每个Block，记录每个Block最新地址，这么一轮遍历结束就可以知道各个Block最新的数据存在哪个位置啦。</p>
<p>内部接口：<code>static Std_ReturnType Fee_ScanBlock(uint8 FeeInstanceId, uint8 ClusterGroup, uint16 ScanStartClusterId)</code></p>
<p>索引是从指定Cluster搜索有效的block，取最新的block信息保存至FeeBlockInfo。考虑Cluster中会有损坏的Block和之前写Block中断电的情况，Scan需要能跳过坏Block，按以下流程scan每个有效的Cluster：</p>
<ol>
<li>每个Cluster开始索引的地址为ClusterHeader后开始存放Block的地址。</li>
<li>开始检查对应地址的Block状态。</li>
<li><ol>
<li>为空，跳出此Cluster的索引。</li>
</ol>
</li>
<li><ol start="2">
<li>DataValid有效，Block正常，将Block地址存储在BlockInfo（hash表）中，根据此Block长度跳地址，继续索引（步骤2）。</li>
</ol>
</li>
<li><ol start="3">
<li>NumLenValid（BlockInfo）有效，Block数据段无效，数据段无法保证全为空, 跳过BlockHeader+BlockLen长度继续索引。</li>
</ol>
</li>
<li><ol start="4">
<li>NumLen和Data都无效，BlockHeader不为空正常情况下数据区还没被写，跳过一个BlockHeader长度继续索引。</li>
</ol>
</li>
</ol>
<p>每个Block在Fee中都有其对应的配置与RAM空间，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Fls_AddressType BlockAddr;     <span class="comment">// Block头所在的Fls地址</span></span><br><span class="line">	uint16 ClusterId;              <span class="comment">// Block所在的Cluster Id</span></span><br><span class="line">	uint16 BlockNumber;            <span class="comment">// Block Number</span></span><br><span class="line">	uint16 BlockLen;               <span class="comment">// Block Len</span></span><br><span class="line">	Fee_BlockStatusType Status;    <span class="comment">// Block头的状态</span></span><br><span class="line">&#125; Fee_BlockInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	uint16 BlockNumber;    <span class="comment">// 配置Block Number</span></span><br><span class="line">	uint16 BlockLen;       <span class="comment">// 配置Block Len</span></span><br><span class="line">	uint8 ClusterGroup;    <span class="comment">// 配置Block属于那个BlockGroup</span></span><br><span class="line">&#125; Fee_BlockConfigType;</span><br></pre></td></tr></table></figure>

<p>每个Block也像Cluster一样有Header，在Block Header中记录BlockId、BlockSize、各种标志位信息。可以通过这些标志位，判断当时存的时候有没有异常下电，Block数据是否完整可信，在Fee中不是通过CRC的方式判断数据是否可信，因为在初始化遍历读取Block的时候，给每个Block做CRC如果Flash很大那需要很长一段时间。</p>
<h5 id="交换Cluster"><a href="#交换Cluster" class="headerlink" title="交换Cluster"></a>交换Cluster</h5><p>内部接口：<code>static Std_ReturnType Fee_SwapCluster(uint8 FeeInstanceId, uint8 ClusterGroup, uint16 FromClusterId, uint16 ToClusterId)</code></p>
<p>将旧Cluster上的有效Block搬到新Cluster。</p>
<ol>
<li>遍历所有的BlockInfo，如果Block的ClusterGroup匹配，且有效数据在老的Cluster上，就将整个Block读取到函数栈空间，然后写入新Cluster的地址，在SWAPPING的时候无需考虑写BlockHeader标志位的顺序，因为SWAPPING时掉电，下次初始化时会擦除此Cluster重新SWAP。</li>
</ol>
<p>详细描述：当Cluster总数-1的Cluster被写完的情况下就需要触发Cluster交换任务了，目的是将最老Cluster上有效的Block（没有更新的数据）转移到那块空白的Cluster上，我称这个操作叫换页。换页时会给Cluster写上换页的标志位，换页过程中异常下电下次能识别到触发重新换页任务。上面说过每个Block都有ram空间，管理这其最新Block的地址（在哪个Cluster上和偏移地址），因此很容易知道最老的Cluster有哪些有效Block和其地址，可以简单的使用memcpy将其复制到最新的Cluster上，因为Block Header不用发生更改，并且写入Block时无需防止异常下电。换页结束后需改变Cluster的状态，将原先最新的那个从活跃设置为满状态，将新的那个Cluster从空设为活跃状态。</p>
<h5 id="维护任务"><a href="#维护任务" class="headerlink" title="维护任务"></a>维护任务</h5><p>内部接口：<code>static Std_ReturnType Fee_MaintainJob(uint8 FeeInstanceId)</code></p>
<p>维护任务，需要检查是否需要执行交换和擦除任务。考虑减少运行时阻塞，正常情况维护中擦除Cluster采用异步非阻塞的方式。正常情况维护操作流程如下：（非正常情况处理较复杂不写）</p>
<ol>
<li>当前操作的Cluster状态为ACTIVE，检查下个Cluster状态是否为VERIFIED，若不是，异步擦除下个Cluster。</li>
<li>当前操作的Cluster状态为ACTIVE，下个Cluster状态为VERIFIED，检查当前Cluster空闲空间是否充足，若不足，将当前Cluster写FULL标志位，2个Cluster和2个以上Cluster写入标志位顺序有差异。</li>
<li>当前操作的Cluster状态为FULL，执行SWAP任务，将最老的Cluster上有效的Block搬到新的Cluster上，SWAP成功后将当前操作的Cluster改为新的Cluster，新Cluster状态设为ACTIVE。</li>
</ol>
<p><strong>Cluster 状态转移图如下</strong>：</p>
<p><img src="https://hao0527.gitee.io/231020-MemoryStack/231020-MemoryStack-2.png" alt="img"></p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>对外接口：<code>void Fee_Init(const Fee_ConfigType* ConfigPtr, boolean IsSync)</code><br>内部初始化Job接口：<code>static Std_ReturnType Fee_InitJob(uint8 FeeInstanceId)</code></p>
<p>初始化Job中需要处理各种不同的Cluster状态，查找ACTIVE状态的Cluster和最老的Cluster，从最老的Cluster开始索引Block。</p>
<p>考虑在换页时断电和Cluster损坏的可能性，初始化处理Cluster状态有如下几种情况：（每种情况处理方式不描述了）</p>
<ol>
<li>只有1个ACTIVE状态的cluster。</li>
<li>没有ACTIVE状态的cluster，只有1个SWAPPING状态的cluster。</li>
<li>总共只有2个Cluster，没有cluster状态为ACTIVE和SWAPPING，只有1个cluster状态为FULL。</li>
<li>没有ACTIVE和SWAPPING状态的Cluster，只有FULL状态的Cluster。</li>
<li>其他。<br>原则上，大于2个Cluster只要有1个ACTIVE或1个SWAPPING状态的Cluster都能被成功初始化，如果存储在Flash中的数据受干扰异常导致无法识别ACTIVE和SWAPPING状态的Cluster，会导致初始化失败，会重新初始化Cluster，历史数据丢失。</li>
</ol>
<h5 id="写入Block"><a href="#写入Block" class="headerlink" title="写入Block"></a>写入Block</h5><p>对外接口：<code>Std_ReturnType Fee_Write(uint8 FeeInstanceId, uint16 BlockNumber, const uint8 *DataBufferPtr, boolean IsSync)</code><br>内部接口：<code>MemIf_JobResultType Fee_WriteJob(uint16 BlockIndex, const uint8* DataBufferPtr, uint8 FeeInstanceId)</code></p>
<p>上层调用Fee写入Block数据，支持异步。</p>
<p>在Fee_WriteJob()需考虑写入时Flash空间不为空的情况，若不为空应该找到空白区域，使下次可正常写入，具体写入流程如下：</p>
<ol>
<li>每次写入前都会检查要写入BlockHeader的地址空间是否为空白，如果不空白，解析BlockHeader。</li>
<li><ol>
<li>为空，跳出检查。</li>
</ol>
</li>
<li><ol start="2">
<li>DataValid或NumLenValid有效，根据此Block长度跳地址，继续检查下个地址空间是否空白（步骤1）。</li>
</ol>
</li>
<li><ol start="3">
<li>NumLen和Data都无效，跳过一个BlockHeader长度继续检查（步骤1）。</li>
</ol>
</li>
<li>写入BlockHeader中的INFO（BlockNumber、BlockLen），写入BlockHeader中的NUMLEN有效标志位。</li>
<li>检查要写入数据的区域是否为空，不为空则退出。</li>
<li>写入BlockData，写入Data有效标志位。</li>
<li>数据写入Flash成功，更新BlockInfo，指向最新的Block地址。</li>
</ol>
<h5 id="读取Block"><a href="#读取Block" class="headerlink" title="读取Block"></a>读取Block</h5><p>对外接口：<code>Std_ReturnType Fee_Read(uint8 FeeInstanceId, uint16 BlockNumber, uint16 BlockOffset, uint8 *DataBufferPtr, uint16 Length, boolean IsSync)</code><br>内部接口：<code>MemIf_JobResultType Fee_ReadJob(uint16 BlockIndex, uint16 BlockOffset, uint8* DataBufferPtr, uint16 Length, uint8 FeeInstanceId)</code></p>
<p>上层调用Fee读取数据，支持异步，读取通过偏移和长度参数，读取Block中的部分数据内容。</p>
<p>Block读取较为简单，判断参数正确未越界即可直接读取Flash中的数据到内存，如果Flash中未保存此数据返回MEMIF_BLOCK_INVALID。</p>
<h5 id="同异步、多实例"><a href="#同异步、多实例" class="headerlink" title="同异步、多实例"></a>同异步、多实例</h5><p>Fee和Fls都支持同步和异步的调用方式，为了实现异步调用，需要有一个管理任务的内存空间，Fee和Fls都使用JobInfo结构体来管理。每个实例都有独立的ram空间，所以多实例问题也很好解决。</p>
<p>Fee对外接口中，读Block、写Block、失效Block三个接口支持异步的方式，Fls对外接口中，读Flash、写、擦、比较、空校验这些接口支持异步方式调用。</p>
<ul>
<li>异步调用Fee对外接口，接口函数会检测参数正确性，无误后将任务参数写入JobInfo，Fee状态变为Busy，然后接口return，在Fee_main中执行Job。</li>
<li>同步调用Fee读写接口和异步方式相同，写入JobInfo后会在对外接口函数内调用执行Job函数，直到状态变为IDLE。</li>
</ul>
<h4 id="MemIf"><a href="#MemIf" class="headerlink" title="MemIf"></a>MemIf</h4><p>内存抽象接口（MemIf）模块提供对底层Fee或Ea模块的抽象，由NvM调用传入形参实例号（DeviceIndex），MemIf根据实例号区分该调用Fee或是Ea模块。</p>
<p>MemIf也做成了可配置的形式，可通过配置将需要用的子模块链接到程序中，不用的模块不链接，实现整套协议栈功能可裁剪。</p>
<h4 id="NvM"><a href="#NvM" class="headerlink" title="NvM"></a>NvM</h4><p>NvM模块包含：下电写入、周期写入、事件触发写入、Block标定、Block清除（恢复默认值）、Block读取写入、Block结构体变更处理、Block校验失败处理、Block数据和RTE同步功能。</p>
<p>NvM是基于原本EPara模块重构的，使用MemIf的接口，对上提供原EPara有的那些服务接口，如标定、同步这些AUTOSAR中没有的功能。其余读写Block，接口改的与AUTOSAR一致，一些AUTOSAR中有的但用不到的接口部分也没有实现。</p>
<p>初始化接口：<code>void NvM_Init( const NvM_ConfigType* ConfigPtr )</code><br>流程：校验config参数，读取所有Block，创建NvM周期任务。</p>
<p>读取Block任务接口：<code>static void NvM_ReadBlock(uint16 BlockId)</code><br>流程：读取NvM Block Header，根据头中的Block Len读取相应长度的数据段，做CRC16校验。CRC校验失败恢复默认值，版本不一致恢复默认值。原数据长度小于配置的Block长度，继承原先长度的Block数据，超过原先长度的部分从默认值获取。原数据长度大于等于配置的Block长度，保留Block所配置长度的数据段。</p>
<p>写入Block任务接口：<code>static void NvM_WriteBlockJob(uint16 BlockId)</code><br>流程：读取Block，比较不一致再写入，写入成功或比较一致清除Block写入标志位。</p>
<p>写入Block接口：<code>void NvM_WriteAll(boolean IsSync)</code> <code>void NvM_WriteBlock(uint16 BlockId, boolean IsSync)</code><br>流程：这两个写入Block接口会将Block写入标志位置写入标志位，如果IsSync = TRUE，会在函数内部调用<code>NvM_ExecuteJob()</code>，执行写入任务。</p>
<p>周期写入接口：<code>static void NvM_CycleWrite(void)</code><br>流程：写入周期到，会对所有配置了周期写入的Block置写入标志位。</p>
<p>下电写入接口：<code>static void NvM_PoweroffWrite(void)</code><br>流程：检测到预下电RTE信号上升沿，会对所有配置了周期写入的Block置写入标志位。</p>
<p>事件触发写入接口：<code>static void NvM_EventWrite(void)</code><br>流程：检测到对应Block事件触发信号上升沿，会对此Block置写入标志位。</p>
<p>执行任务接口：<code>static void NvM_ExecuteJob(void)</code><br>流程：执行写入任务，调用一次ExecuteJob，最多只会写入1个Block。</p>
<h5 id="NvM存储各层数据结构"><a href="#NvM存储各层数据结构" class="headerlink" title="NvM存储各层数据结构"></a>NvM存储各层数据结构</h5><p><img src="https://hao0527.gitee.io/231020-MemoryStack/231020-MemoryStack-1.png" alt="img"></p>
<h3 id="待改进点"><a href="#待改进点" class="headerlink" title="待改进点"></a>待改进点</h3><ol>
<li>Fls写入使用异步非阻塞，每写入一个页挂起，需要os支持。</li>
<li>Fee异常时的擦除也可以挂起，减少阻塞时处理器性能浪费。</li>
<li>MemIf下可以挂除Fee和Ea外的设备，支持S32K的EEP，因为S32EEP不需要均衡磨损，本身就是用Flash模拟的，所以不适合挂在Ea和Fee。为什么不直接用Flash，然后挂Fee上？因为想让用S32Eep的老项目支持这套内存协议栈。</li>
<li>NvM作为协议栈的上层，可以实现更多的功能。</li>
</ol>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>整套协议栈自己实现相比直接用AUTOSAR的组件有很多的优点，有哪些自己特殊的需求加到协议栈里比较方便。比如使用之前的均衡磨损算法、NvM支持数据不同版本继承、Fee对数据继承的支持、有同步接口的需求、外部Flash也想使用Fee等等。</p>
<p>调试的过程中云途的mcu擦flash也有坑，这么多个模块开发下来，其中感觉最为复杂的是Fee，完成一个能经得住随机下电，下次上电能自恢复的Fee是很有成就感的。这里要感谢我领导对我的支持与帮助，给我时间让我自我发挥，遇到我解决问题可以一同调试。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/23/230923-ble/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/23/230923-ble/" class="post-title-link" itemprop="url">蓝牙BLE调试记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-23 08:00:00" itemprop="dateCreated datePublished" datetime="2023-09-23T08:00:00+08:00">2023-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-10-31 08:19:03" itemprop="dateModified" datetime="2023-10-31T08:19:03+08:00">2023-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="蓝牙SOC芯片"><a href="#蓝牙SOC芯片" class="headerlink" title="蓝牙SOC芯片"></a>蓝牙SOC芯片</h2><p>国产芯片PAN1020，M0带蓝牙收发器的SOC只要2.5r/pcs，可以用来做一些低成本的小产品，带上蓝牙控制的功能。参考资料：<a target="_blank" rel="noopener" href="https://bbs.panchip.com/forum.php?mod=viewthread&tid=7480&extra=page=1">PAN1020_Public_SDK_V2.0.8</a>。</p>
<ul>
<li>RF<br>- 2.4GHz 射频收发机（兼容 BLE4.2）<br>- 接收灵敏度：-90 dBm@1Mbps<br>- 最大接收信号：0 dBm<br>- 可编程发射输出功率：最大为 13 dBm，一般为 8 dBm<br>- 单线天线：无需 RF 匹配或 RX/TX 切换</li>
<li>内核<br>- MCU 内核运行速度高达 26 MHz<br>- 一个 24 位系统定时器<br>- 支持低功耗空闲模式<br>- 单周期 32 位硬件乘法器<br>- 支持串行线调试（SWD）接口和两个观察点/四个断点</li>
<li>内存<br>- 256 KB 闪存用于程序存储器<br>- 16 KB SRAM</li>
</ul>
<p><strong>低功耗说明</strong>：</p>
<table>
<thead>
<tr>
<th>NO</th>
<th>Mode</th>
<th>Interval</th>
<th>Average Current</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Advertising</td>
<td>100ms</td>
<td>545uA</td>
<td>32K RC</td>
</tr>
<tr>
<td>2</td>
<td>Advertising</td>
<td>1000ms</td>
<td>66uA</td>
<td>32K RC</td>
</tr>
<tr>
<td>3</td>
<td>Connected</td>
<td>100ms</td>
<td>301uA</td>
<td>32K RC</td>
</tr>
<tr>
<td>4</td>
<td>Connected</td>
<td>1000ms</td>
<td>55uA</td>
<td>32K RC</td>
</tr>
<tr>
<td>5</td>
<td>Advertising</td>
<td>100ms</td>
<td>400uA</td>
<td>32K XO</td>
</tr>
<tr>
<td>6</td>
<td>Connected</td>
<td>100ms</td>
<td>230uA</td>
<td>32K XO</td>
</tr>
</tbody></table>
<h2 id="产品需求"><a href="#产品需求" class="headerlink" title="产品需求"></a>产品需求</h2><p>蓝牙温度计，能记录历史数据，手机app显示温度波形，40mah纽扣电池供电，使用5天。</p>
<h2 id="软件开发记录"><a href="#软件开发记录" class="headerlink" title="软件开发记录"></a>软件开发记录</h2><p>代码已上传 GIthub：<a target="_blank" rel="noopener" href="https://github.com/hao0527/BLE_APP">BLE_APP 源码</a></p>
<h3 id="启用中断回调"><a href="#启用中断回调" class="headerlink" title="启用中断回调"></a>启用中断回调</h3><p>我配置了 ADC 并开启中断，测试程序会卡死，最后发现与 ADC 中断是否开启相关。在 BLE 协议栈接口那发现了注册中断的接口。</p>
<p>使用如下代码将 <code>ADC_IRQ</code> 的中断回调 <code>mcu_adc_isr</code> 注册到协议栈后，问题解决。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册中断处理函数到协议栈，否则中断会卡死。</span></span><br><span class="line">((interrupt_register_handler)SVC_interrupt_register)(ADC_IRQ, mcu_adc_isr);</span><br></pre></td></tr></table></figure>

<h3 id="开启低功耗模式"><a href="#开启低功耗模式" class="headerlink" title="开启低功耗模式"></a>开启低功耗模式</h3><p>如需开启低功耗模式，只需在 <code>panip_config.h</code> 中 <code>#define SLEEP_EN (1)</code>。</p>
<p>PAN1020 SDK 定义的全局变量在使用前都必须要在函数中初始化，如果定义的时候就初始化，当前初始化的值是不生效的。</p>
<p>因为<strong>开启低功耗模式需配置编译器将 RAM 设置为 NoInit</strong>，如图所示：</p>
<p><img src="https://hao0527.gitee.io/230923-ble/230923-ble-1.jpg" alt="img"></p>
<p>设为 NoInit 后，全局变量定义后的值为随机值，没有被初始化，需要自己手动初始化。此处是为了在 PAN1020 休眠唤醒后 RAM 不被重新初始化，唤醒后的 RAM 值依旧保持为休眠前的值。</p>
<h3 id="配置软件定时器"><a href="#配置软件定时器" class="headerlink" title="配置软件定时器"></a>配置软件定时器</h3><p>按照 SDK 用户手册配置软件定时器后遇到奇怪的问题，但测试发现解决方法，如下注释说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_proj_template_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;app_proj_template_env, <span class="number">0</span>, <span class="keyword">sizeof</span>(app_proj_template_env));</span><br><span class="line">	</span><br><span class="line">	temper_resetInit();</span><br><span class="line">	<span class="comment">/* 注意：配置定时器放在此函数里没问题，放在appm_init()外部有问题，会导致无法进定时回调！</span></span><br><span class="line"><span class="comment">			函数调用关系：ble_normal_reset_init() -&gt; user_code_start() -&gt; appm_init() -&gt; app_init_ind_func()</span></span><br><span class="line"><span class="comment">			设置定时器放在appm_init()内部没问题，但是放在appm_init()外部就不行，</span></span><br><span class="line"><span class="comment">			甚至把设置定时器放在appm_init()内部的最后一行可以，放在appm_init()执行完出来的下一行不行！*/</span></span><br><span class="line">	((ke_timer_set_handler)SVC_ke_timer_set)(APP_SAMPLE_TEMPER_TIMER, TASK_APP, <span class="number">60</span>*<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置ATT数据库"><a href="#配置ATT数据库" class="headerlink" title="配置ATT数据库"></a>配置ATT数据库</h3><p>配置att数据库后发现只有数据库的前13条配置生效，后面的att没有生效，在配置att的接口调试发现有条件为满足导致的后面一些att数据库配置没配置进协议栈，一层层向上查后是以下代码，<code>db_cfg-&gt;features = 0x1fff;</code> 导致的，如下配置为 <code>db_cfg-&gt;features = 0xffffffff;</code> 后问题解决。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_proj_template_add_server</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proj_template_server_db_cfg</span>* <span class="title">db_cfg</span>;</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">// Allocate the BASS_CREATE_DB_REQ</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">gapm_profile_task_add_cmd</span> *<span class="title">req</span> =</span> KE_MSG_ALLOC_DYN(GAPM_PROFILE_TASK_ADD_CMD,</span><br><span class="line">												TASK_GAPM, TASK_APP,</span><br><span class="line">												gapm_profile_task_add_cmd,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> proj_template_server_db_cfg));</span><br><span class="line">	<span class="comment">// Fill message</span></span><br><span class="line">	req-&gt;operation	 = GAPM_PROFILE_TASK_ADD;</span><br><span class="line">	req-&gt;sec_lvl	 = (PERM(SVC_AUTH, DISABLE)| PERM(SVC_UUID_LEN, UUID_16)| PERM(SVC_EKS, DISABLE)|PERM(SVC_DIS, DISABLE));</span><br><span class="line"></span><br><span class="line">	req-&gt;prf_task_id = TASK_ID_PROJ_TEMPLATE_SERVER;</span><br><span class="line">	req-&gt;app_task	 = TASK_APP;</span><br><span class="line">	req-&gt;start_hdl	 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set parameters</span></span><br><span class="line">	db_cfg = (<span class="keyword">struct</span> proj_template_server_db_cfg* ) req-&gt;param;</span><br><span class="line">	db_cfg-&gt;features = <span class="number">0xffffffff</span>;	<span class="comment">// 注意：配置了gatt数据库，要配置这个掩码使能，32位都是1可以使能32个数据库配置</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send the message</span></span><br><span class="line">	((ke_msg_send_handler)SVC_ke_msg_send)(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="电池输出电流不足不问"><a href="#电池输出电流不足不问" class="headerlink" title="电池输出电流不足不问"></a>电池输出电流不足不问</h3><p>电池40mah，放点倍率0.1C，输出电流最大就4ma，射频瞬间最大电流有30多ma，adc采集会开启ldo和运放，最大电流有90ma。</p>
<p>adc采集的时候电流过大会将电压拉低导致单片机复位，正在通过加电容解决。</p>
<p>射频需求只需要5m范围内，所以射频的功率也可以配置低一些。</p>
<p>后面测试解决完这个问题更新……</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/14/230914-stm32cmake/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/14/230914-stm32cmake/" class="post-title-link" itemprop="url">STM32 CMake 构建工程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-14 23:30:00" itemprop="dateCreated datePublished" datetime="2023-09-14T23:30:00+08:00">2023-09-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-01 21:42:05" itemprop="dateModified" datetime="2023-11-01T21:42:05+08:00">2023-11-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a target="_blank" rel="noopener" href="https://github.com/rxdu/stm32_cmake">STM32 CMake Project Template</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/skb666/stm32l4_demo/tree/dev">stm32l4_demo - skb666</a></li>
</ol>
<h3 id="为什么使用-CMake？"><a href="#为什么使用-CMake？" class="headerlink" title="为什么使用 CMake？"></a>为什么使用 CMake？</h3><p>很早就想过用 CMake 来代替 eclipse 构建工程，优点是可以使用 VsCode 编译工程进行开发。另外还方便在 Jenkins 上使用脚本构建工程，目前使用 eclipse 构建工程，需要把生成的 Makefile 和多个 .arg 文件传 SVN，Jenkins 上通过 eclipse 生成的 Makefile 脚本编译工程，需要管控很多 Make 相关的文件，而且工程文件目录调整后，需要重新用 eclipse 生成一份 Makefile 供 Jenkins 使用。</p>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>一开始使用 CMake 遇到很多问题，主要还是我在使用 Windows 开发环境，有些地方需要注意。我后来使用 WSL 使用CMake 的时候还是很顺利的，而且 Linux 中的包管理器很好用，准备开发环境非常方便，确实比 Windows 开发优秀很多。如果可以的话，我也想拥有一台电脑装 Linux 操作系统做日常软件开发。</p>
<p>现在改了 CMake 脚本，在 Windows 下也可以完成构建和编译了！，主要是加了 <code>set(CMAKE_SYSTEM_NAME Generic)</code>，<code>CMAKE_SYSTEM_NAME</code> 变量用于指定项目的目标操作系统名称，”Generic” 通常表示你不是针对特定的操作系统进行构建，而是希望以更通用或跨平台的方式构建项目，这通常用于编写可以在多个不同平台上编译和运行的代码。否则链接时会出现以下报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[  2%] Linking C executable C:/Users/33110/Projects/stm32l4_demo/output/stm32l4_demo.elf.exe</span><br><span class="line">c:/program files (x86)/gcc-arm-none-eabi-10.3-2021.10/bin/../lib/gcc/arm-none-eabi/10.3.1/../../../../arm-none-eabi/bin/ld.exe: unrecognized option &#x27;--major-image-version&#x27;</span><br><span class="line">c:/program files (x86)/gcc-arm-none-eabi-10.3-2021.10/bin/../lib/gcc/arm-none-eabi/10.3.1/../../../../arm-none-eabi/bin/ld.exe: use the --help option for usage information</span><br><span class="line">collect2.exe: error: ld returned 1 exit status</span><br><span class="line">make[2]: *** [CMakeFiles/stm32l4_demo.elf.dir/build.make:764：C:/Users/33110/Projects/stm32l4_demo/output/stm32l4_demo.elf.exe] 错误 1</span><br><span class="line">make[1]: *** [CMakeFiles/Makefile2:83：CMakeFiles/stm32l4_demo.elf.dir/all] 错误 2</span><br><span class="line">make: *** [Makefile:91：all] 错误 2</span><br></pre></td></tr></table></figure>

<h3 id="CMake-脚本"><a href="#CMake-脚本" class="headerlink" title="CMake 脚本"></a>CMake 脚本</h3><p>CMake 脚本分为两个，将不同平台编译工具链相关的抽离出来，在一份 CMake 工程可以编译出不同平台的结果。脚本内容如下：</p>
<h4 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义工程名的变量</span></span><br><span class="line"><span class="keyword">set</span>(PROJECT_NAME <span class="string">&quot;my_ytm32_prj&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> LANGUAGES C CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更详细的编译信息</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_VERBOSE_MAKEFILE <span class="keyword">on</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;PROJECT_NAME: &quot;</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;CMAKE_TOOLCHAIN_FILE: &quot;</span> <span class="variable">$&#123;CMAKE_TOOLCHAIN_FILE&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;MCU: &quot;</span> <span class="variable">$&#123;MCU&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;LD_SCRIPT: &quot;</span> <span class="variable">$&#123;LD_SCRIPT&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;ASM_SOURCES: &quot;</span> <span class="variable">$&#123;ASM_SOURCES&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;MAP_FILE: &quot;</span> <span class="variable">$&#123;MAP_FILE&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加编译参数</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-O2 -fmessage-length=<span class="number">0</span> -fsigned-char -ffunction-sections -fdata-sections -fno-strict-aliasing)</span><br><span class="line"><span class="keyword">add_link_options</span>(-T<span class="variable">$&#123;LD_SCRIPT&#125;</span> -Xlinker --gc-sections -Wl,-Map=<span class="variable">$&#123;MAP_FILE&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归调用子文件的 CMakeLists.txt</span></span><br><span class="line"><span class="comment"># add_subdirectory(lib)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 汇编文件配置编译选项</span></span><br><span class="line"><span class="keyword">set_property</span>(SOURCE <span class="variable">$&#123;ASM_SOURCES&#125;</span> PROPERTY LANGUAGE C)</span><br><span class="line"><span class="keyword">set_source_files_properties</span>(<span class="variable">$&#123;ASM_SOURCES&#125;</span> PROPERTIES COMPILE_FLAGS <span class="string">&quot;-x assembler-with-cpp -DSTART_FROM_FLASH&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用file命令的GLOB_RECURSE选项递归搜索所有C文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCE_FILES <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/source/*.c&quot;</span> <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/Project_Settings/Startup_Code/*.c&quot;</span>)</span><br><span class="line"><span class="comment"># MESSAGE(STATUS &quot;SOURCE_FILES: &quot; $&#123;SOURCE_FILES&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标所需的源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="variable">$&#123;SOURCE_FILES&#125;</span> <span class="variable">$&#123;ASM_SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标所需宏定义</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf PUBLIC</span><br><span class="line">    CPU_YTM32B1ME0</span><br><span class="line">    YTM32B1ME0</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标所需的库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf PUBLIC m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标所需的头文件路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf PUBLIC</span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/Project_Settings/Startup_Code&quot;</span></span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/Project_Settings/Startup_Code/CMSIS/Core/Include&quot;</span></span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/source/inc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加预编译目标</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(</span><br><span class="line">    PRE_BUILD_DUMMY ALL</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 目标编译前自定义指令</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    <span class="keyword">TARGET</span> PRE_BUILD_DUMMY PRE_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../Bin/generate_version.sh</span><br><span class="line">    WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_OUTPUT_DIRECTORY&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 将预编译步骤作为主目标依赖</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf PRE_BUILD_DUMMY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标编译后自定义指令</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    <span class="keyword">TARGET</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf POST_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../Bin/BuildTools/PostBuild.bat <span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;TOOLCHAINS_PATH&#125;</span> <span class="variable">$&#123;TOOLCHAINS_PREFIX&#125;</span></span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;TOOLCHAINS_PATH&#125;</span>/<span class="variable">$&#123;TOOLCHAINS_PREFIX&#125;</span>objcopy -O binary -S <span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="variable">$&#123;PROJECT_NAME&#125;</span>.bin</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;TOOLCHAINS_PATH&#125;</span>/<span class="variable">$&#123;TOOLCHAINS_PREFIX&#125;</span>objcopy -O binary -S <span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="variable">$&#123;PROJECT_NAME&#125;</span>.srec</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;TOOLCHAINS_PATH&#125;</span>/<span class="variable">$&#123;TOOLCHAINS_PREFIX&#125;</span>objcopy -O binary -S <span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="variable">$&#123;PROJECT_NAME&#125;</span>.hex</span><br><span class="line">    WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_OUTPUT_DIRECTORY&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="toolchains-cmake"><a href="#toolchains-cmake" class="headerlink" title="toolchains.cmake"></a>toolchains.cmake</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_SYSTEM_NAME Generic)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SYSTEM_PROCESSOR ARM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择编译版本（可以通过 vscode 指定）</span></span><br><span class="line"><span class="comment"># set(CMAKE_BUILD_TYPE Release)</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(TOOLCHAINS_PATH <span class="string">&quot;C:/Yuntu/YuntuIDE/tools/bin&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(TOOLCHAINS_PREFIX <span class="string">&quot;arm-none-eabi-&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉编译器（可以通过 vscode 指定）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">&quot;$&#123;TOOLCHAINS_PATH&#125;/$&#123;TOOLCHAINS_PREFIX&#125;gcc.exe&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;$&#123;TOOLCHAINS_PATH&#125;/$&#123;TOOLCHAINS_PREFIX&#125;g++.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过编译器检查</span></span><br><span class="line"><span class="comment"># set(CMAKE_C_COMPILER_WORKS 1)</span></span><br><span class="line"><span class="comment"># set(CMAKE_CXX_COMPILER_WORKS 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成目标的存放目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/Debug)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_OUTPUT_DIRECTORY&#125;</span>)</span><br><span class="line"><span class="comment"># 默认存放静态库的文件夹位置</span></span><br><span class="line"><span class="comment"># set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY $&#123;CMAKE_OUTPUT_DIRECTORY&#125;/archive)</span></span><br><span class="line"><span class="comment"># 默认存放动态库的文件夹位置</span></span><br><span class="line"><span class="comment"># set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_OUTPUT_DIRECTORY&#125;/library)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CPU <span class="string">&quot;-mcpu=cortex-m33&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(FPU <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(FLOAT-ABI <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(MCU <span class="string">&quot;$&#123;CPU&#125; -mthumb $&#123;FPU&#125; $&#123;FLOAT-ABI&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;MCU&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS_DEBUG <span class="string">&quot;-g3&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS_RELEASE <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果CMAKE_CXX_STANDARD_REQUIRED设置为ON则必须使用CMAKE_CXX_STANDARD指定的版本</span></span><br><span class="line"><span class="comment"># 如果CMAKE_CXX_STANDARD_REQUIRED设置为OFF则CMAKE_CXX_STANDARD指定版本的为首选版本如果没有会使用上一版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;MCU&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;-g3&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(LD_SCRIPT <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/Project_Settings/Linker_Files/flash.ld&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(ASM_SOURCES <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/Project_Settings/Startup_Code/YTM32B1ME0_startup_gcc.S&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(MAP_FILE <span class="string">&quot;$&#123;CMAKE_OUTPUT_DIRECTORY&#125;/$&#123;PROJECT_NAME&#125;.map&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;--specs=nosys.specs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)</span><br></pre></td></tr></table></figure>

<h3 id="构建及编译指令"><a href="#构建及编译指令" class="headerlink" title="构建及编译指令"></a>构建及编译指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd Project</span><br><span class="line">cmake -G &quot;Unix Makefiles&quot; -S. -BDebug -DCMAKE_TOOLCHAIN_FILE=toolchains.cmake</span><br><span class="line">cmake --build Debug --target all -- -j8</span><br></pre></td></tr></table></figure>

<h3 id="写cmake脚本时遇到的问题"><a href="#写cmake脚本时遇到的问题" class="headerlink" title="写cmake脚本时遇到的问题"></a>写cmake脚本时遇到的问题</h3><ol>
<li>vscode生成cmake时需要加入指定工具链的命令<code>-DCMAKE_TOOLCHAIN_FILE=toolchains.cmake</code>，这个需在vscode cmake拓展设置中配置。</li>
<li>vscode生成cmake可以选择是Debug还是Release，还可选择工具链，既然我通过上面一个方案传入工具链的cmake，vscode配置工具链成未指定就可以了。</li>
<li>cmake生成时会有检查工具链，有些工具链可能会报错，gcc10.5需要加<code>set(CMAKE_EXE_LINKER_FLAGS &quot;--specs=nosys.specs&quot;)</code>。</li>
<li>gcc4.9就不支持<code>--specs=nosys.specs</code>这个选项，跳过编译器检查需要加 <code>set(CMAKE_C_COMPILER_WORKS 1) set(CMAKE_CXX_COMPILER_WORKS 1)</code>。</li>
<li>跨平台的编译需要加<code>set(CMAKE_SYSTEM_NAME Generic) set(CMAKE_SYSTEM_PROCESSOR ARM)</code>，否则会链接错误。</li>
<li>更详细的编译信息<code>set(CMAKE_VERBOSE_MAKEFILE on)</code>需要加在<code>project($&#123;PROJECT_NAME&#125; LANGUAGES C CXX)</code>后面，否则不起作用。</li>
<li><code>set(CMAKE_SYSTEM_NAME Generic)</code>需要加在<code>project($&#123;PROJECT_NAME&#125; LANGUAGES C CXX)</code>前面，否则不起作用，这类问题还没搞清楚为什么有的需要在project前有的需要在后，解决方法是由于未起作用试出来的。</li>
</ol>
<h3 id="待优化"><a href="#待优化" class="headerlink" title="待优化"></a>待优化</h3><ol>
<li>现在链接顺序和 eclipse 编译出来的不一致，导致二进制不同（经测试，手动改变链接顺序，改成与 eclipse 一致，编译结果 bin 一致）。</li>
<li>没根据系统选择不同的cmake脚本，linux 下可能不兼容。</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/24/230824-AutoSarNVRAM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/24/230824-AutoSarNVRAM/" class="post-title-link" itemprop="url">AUTOSAR Memory Stack 架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-08-24 16:00:00" itemprop="dateCreated datePublished" datetime="2023-08-24T16:00:00+08:00">2023-08-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-08-28 23:45:33" itemprop="dateModified" datetime="2023-08-28T23:45:33+08:00">2023-08-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AUTOSAR/" itemprop="url" rel="index"><span itemprop="name">AUTOSAR</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a target="_blank" rel="noopener" href="https://www.fer.unizg.hr/_download/repository/3._Vjestine_AUTOSAR_MemStack._v3.pdf">AUTOSAR Memory Stack(MemStack)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.autosar.org/fileadmin/standards/R20-11/CP/AUTOSAR_SWS_NVRAMManager.pdf">Specification of NVRAM Manager</a></li>
<li><a target="_blank" rel="noopener" href="https://www.autosar.org/fileadmin/standards/R21-11/CP/AUTOSAR_EXP_NVDataHandling.pdf">NV Data Handling Guideline</a></li>
</ol>
<h3 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h3><p>为了管理汽车领域中的非易失性存储器(NV Memory)，在AUTOSAR环境中使用了内存协议栈(MemStack)。</p>
<p>AUTOSAR中的MemStack主要有以下功能：</p>
<ol>
<li>数据检索：以结构化方式存储数据</li>
<li>数据存储：对NV Memory的读取与写入</li>
<li>抽象层：对不同的内部或外部NV Memory提供抽象</li>
<li>耐久性管理：管理内存写入周期</li>
<li>错误处理和纠正：管理NV Memory的纠错和错误检测机制</li>
<li>内存块管理：管理内存块(Memory Block)</li>
<li>地址映射：虚拟地址到物理地址的映射</li>
</ol>
<p>AUTOSAR的内存协议栈为应用层和基础软件(BSW)模块提供访问非易失性存储器的服务（例如读写）。使用AUTOSAR MemStack API，应用层中的软件组件(SWC)和BSW模块可以从NV Memory读取数据并将数据写入NV Memory，例如诊断事件管理器(DEM)使用MemStack服务将冻结帧数据写入NV Memory。</p>
<h3 id="存储协议栈架构"><a href="#存储协议栈架构" class="headerlink" title="存储协议栈架构"></a>存储协议栈架构</h3><p><img src="https://hao0527.gitee.io/230824-AutoSarNVRAM/230824-AutoSarNVRAM-1.jpg" alt="img"></p>
<p>NvM访问内存抽象接口(MemIf)，该接口抽象了Flash模拟Eep模块(Fee)和EEPROM抽象模块(Ea)。因此，NvM是硬件无关的。</p>
<p>应用程序通常不直接访问BSW模块的服务。它们通过RTE和BSW模块提供的服务端口进行连接。应用程序SWC或NV SWC可以从NV Memory读取或写入数据。NvM将调用传递给MemIf，调用将传递给内存驱动模块，驱动模块将数据写入NV Memory。如果是外部Flash（通过SPI连接）的情况下，将使用SPI驱动程序。</p>
<h4 id="NvM（NVRAM-Manager）"><a href="#NvM（NVRAM-Manager）" class="headerlink" title="NvM（NVRAM Manager）"></a>NvM（NVRAM Manager）</h4><p>NvM模块提供了数据存储和数据维护的服务。NvM模块位于AUTOSAR堆栈的服务层中，并向用户（即SWC）提供从NV Memory读取数据或写入数据的服务。NvM是访问NV Memory的唯一方式，或者我们可以说NvM是SWC访问NV Memory的网关。</p>
<p>NvM执行存储器的初始化、NV Block的错误更正和错误检测。</p>
<h4 id="MemIf-Fee-Ea（Memory-Abstraction-Interface）"><a href="#MemIf-Fee-Ea（Memory-Abstraction-Interface）" class="headerlink" title="MemIf/Fee/Ea（Memory Abstraction Interface）"></a>MemIf/Fee/Ea（Memory Abstraction Interface）</h4><p>MemIf提供了对底层Fee或Ea模块的抽象，因此上层模块（例如NVRAM管理器）会请求MemIf模块进行读/写操作，然后MemIf模块将请求传递给底层的Fee或Ea模块。</p>
<p>Fee和Ea提供虚拟32位地址空间，并抽象出设备特定的寻址方案。Fee和Ea将虚拟地址转换为物理地址。</p>
<h4 id="Fls-EEP（Memory-Driver）"><a href="#Fls-EEP（Memory-Driver）" class="headerlink" title="Fls/EEP（Memory Driver）"></a>Fls/EEP（Memory Driver）</h4><p>存储器驱动程序用于访问mcu的内部flash或外部存储器。存储器驱动程序提供从EEPROM或Flash存储器读取、写入和擦除的功能。Fls驱动程序与Flash存储器相关联，EEP驱动程序与EEPROM存储器相关联。</p>
<p>用于外部EEPROM的驱动程序使用处理程序（在大多数情况下为SPI）或驱动程序来访问外部EEPROM设备，它位于ECU抽象层中。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>今年的一项PBC：仿照AUTOSAR的存储器协议栈，开发一套适合自己公司使用的存储器协议栈。经过大半年零散的、自下而上的开发与测试，我的软件终于上量产车使用了，这几天整理下资料和回顾下开发过程，后续再写些文章。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/22/230822-sourceProtect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/22/230822-sourceProtect/" class="post-title-link" itemprop="url">C语言源码保护技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-08-22 20:00:00 / 修改时间：21:34:01" itemprop="dateCreated datePublished" datetime="2023-08-22T20:00:00+08:00">2023-08-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="源码保护技术"><a href="#源码保护技术" class="headerlink" title="源码保护技术"></a>源码保护技术</h2><p>对于一些大软件工程，可能有一部分模块代码是从第三方获取来的，并且可能是不开源的。前段时间给别的部门软件组提供了一份快充协议栈的模块，使用静态库的方式提供，提供头文件给用户调用协议栈中的函数及读取全局变量，快充协议栈的输入也是有模块内部调用用户提供的指定函数，或指定的全局变量实现，在工程最后链接的时候会将静态库中未链接的符号链接到外部代码的地址。</p>
<p>今天在看PAN1020的SDK，一款蓝牙SOC，它里面的协议栈是不开源的，厂家提供hex文件，于是在想用户需如何集成hex到自己工程，用户代码要如何与协议栈不开源的代码建立联系。自己的猜想基本是对的，厂家还会提供一份头文件，里面有用户需要调用的函数或全局变量，和静态库不同的是，头文件中不是变量和函数的声明，而是需要让用户知道，所需的全局变量与函数在这份hex文件中的哪个位置。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>厂家提供的hex文件需要链接到指定地址，以下是PAN1020未开源模块所提供的头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_FUN_ADDR					0x00016600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//app fun register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_dbg_sys_write_register (*(volatile uint32_t *)(STACK_FUN_ADDR))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*dbg_sys_write_register_handler)</span><span class="params">(<span class="type">void</span> (*call)(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> data))</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_appm_init_register (*(volatile uint32_t *)(STACK_FUN_ADDR + 4))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*appm_init_register_handler)</span><span class="params">(<span class="type">void</span> (*call)(<span class="type">void</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_hci_init_register  (*(volatile uint32_t *)(STACK_FUN_ADDR + 8))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*hci_init_register_handler)</span><span class="params">(<span class="type">void</span> (*call)(<span class="type">bool</span> reset))</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_hci_send_2_controller_register (*(volatile uint32_t *)(STACK_FUN_ADDR + 12))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*hci_send_2_controller_register_handler)</span><span class="params">(<span class="type">void</span> (*call)(<span class="type">void</span> *param))</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_attm_svc_create_db_register (*(volatile uint32_t *)(STACK_FUN_ADDR + 16))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*attm_svc_create_db_register_handler)</span><span class="params">(<span class="type">uint8_t</span> (*call)(<span class="type">uint16_t</span> *shdl, <span class="type">uint16_t</span> uuid, <span class="type">uint8_t</span> *cfg_flag, <span class="type">uint8_t</span> max_nb_att,</span></span><br><span class="line"><span class="params">                           <span class="type">uint8_t</span> *att_tbl, <span class="type">ke_task_id_t</span> <span class="type">const</span> dest_id,<span class="type">const</span> <span class="keyword">struct</span> attm_desc *att_db, <span class="type">uint8_t</span> svc_perm))</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_gattc_con_enable_register (*(volatile uint32_t *)(STACK_FUN_ADDR + 20))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*gattc_con_enable_register_handler)</span><span class="params">(<span class="type">void</span> (*call)(<span class="type">uint8_t</span> conidx))</span>;</span><br></pre></td></tr></table></figure>

<p>一开始，我以为是要将hex链接到0x00016600地址，头文件中给出的是函数在hex中的偏移地址。hex文件是带地址的，我用jflash一看后才明白，hex的起始地址是0，0x00016600地址上存放的是一个网表，用来存放函数的真实地址，网表其实就是函数指针类型的数组。</p>
<p>代码中的<code>(STACK_FUN_ADDR + offset)</code>其实就是函数指针的地址，所以<code>(*(volatile uint32_t *)(STACK_FUN_ADDR + offset))</code>就是取出函数指针的值，这个是函数真实所在的地址。头文件中还有函数指针的typedef，可以通过函数指针类型知道每个函数的形参和返回值。</p>
<p>有了函数地址与函数类型，用户就可以通过以下方式去调用库中的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_fun_resgister</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	((appm_init_register_handler)SVC_appm_init_register)(appm_init);</span><br><span class="line">	((hci_init_register_handler)SVC_hci_init_register)(hci_init);</span><br><span class="line">	((hci_send_2_controller_register_handler)SVC_hci_send_2_controller_register)(hci_send_2_controller);</span><br><span class="line">	((attm_svc_create_db_register_handler)SVC_attm_svc_create_db_register)(attm_svc_create_db);</span><br><span class="line">	((gattc_con_enable_register_handler)SVC_gattc_con_enable_register)(gattc_con_enable);</span><br><span class="line">	((gattm_cleanup_register_handler)SVC_gattm_cleanup_register)(gattm_cleanup);</span><br><span class="line">	((gattm_create_register_handler)SVC_gattm_create_register)(gattm_create);</span><br><span class="line">	((prf_cleanup_register_handler)SVC_prf_cleanup_register)(prf_cleanup);</span><br><span class="line">	((prf_create_register_handler)SVC_prf_create_register)(prf_create);</span><br><span class="line">	((prf_get_id_from_task_register_handler)SVC_prf_get_id_from_task_register)(prf_get_id_from_task);</span><br><span class="line">	((prf_get_task_from_id_register_handler)SVC_prf_get_task_from_id_register)(prf_get_task_from_id);</span><br><span class="line">	((prf_init_register_handler)SVC_prf_init_register)(prf_init);</span><br><span class="line">	((attm_att_update_perm_register_handler)SVC_attm_att_update_perm_register)(attm_att_update_perm);</span><br><span class="line">	((gattm_init_attr_register_handler)SVC_gattm_init_attr_register)(gattm_init_attr);</span><br><span class="line">	((hci_basic_cmd_send_2_controller_register_handler)SVC_hci_basic_cmd_send_2_controller_register)(hci_basic_cmd_send_2_controller);</span><br><span class="line">	((prf_add_profile_register_handler)SVC_prf_add_profile_register)(prf_add_profile);</span><br><span class="line">	((gattc_get_mtu_register_handler)SVC_gattc_get_mtu_register)(gattc_get_mtu);</span><br><span class="line">	((attm_init_register_handler)SVC_attm_init_register)(attm_init);</span><br><span class="line">	((gattm_init_register_handler)SVC_gattm_init_register)(gattm_init);</span><br><span class="line">	((hci_send_2_host_register_handler)SVC_hci_send_2_host_register)(hci_send_2_host);</span><br><span class="line">	((attmdb_destroy_register_handler)SVC_attmdb_destroy_register)(attmdb_destroy);</span><br><span class="line">	((sleep_handler_register)SVC_sleep_handler_register)(sleep_handler);</span><br><span class="line">	((ble_event_handler_register)SVC_ble_event_handler_register)(ble_event_handler);</span><br><span class="line">	((rf_init_handler_register)SVC_rf_init_handler_register)(rf_init_handler);</span><br><span class="line">	((ble_rx_handler_register)SVC_ble_rx_handler_register)(ble_rx_handler);</span><br><span class="line">	((rf_dev_cal_init_handler_register)SVC_rf_dev_cal_init_handler_register)(rf_dev_cal_init_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码为初始化模块中，用户将模块所需要的一些函数注册到模块中。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>PAN1020这种方式保护源码，让用户不可见源码，相比我之前封静态库的方式有以下优势：</p>
<ol>
<li>编译模块的时候不需要其他模块的头文件声明，通过模块对外提供注册函数的方式，获取外部函数地址后调用。我之前静态库的方式就需要在编译模块的时候提供其他模块的函数声明头文件，而且如果链接的时候找不到还会链接失败。</li>
<li>这种由外部注册函数的方式，模块所依赖其他模块的函数名可以关心，如果用静态库方式就外部函数的函数名就必须与声明的一致。</li>
<li>提供给用户hex，比静态库文件的信息更少，静态库中有网表信息，hex中只有二进制文件和地址。</li>
</ol>
<p>是否可以将一个工程的各模块分开独立，编译成各个hex后再集成？优点：可以使公司的源码不易泄露，每个人都维护自己的模块。</p>
<p>让各个模块编译完hex后的地址都为0开始，hex中网表的前两个为模块init和模块main。用户将所有的hex链接到指定flash地址，配置给os各模块网表起始地址，网表大小，模块调度周期。因为网表的前两个是init和main，所以os可以轻松创建好任务。模块与模块之间调用，由模块向os请求获取特定模块特定网表index的函数地址。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/06/25/230625-Linux%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/25/230625-Linux%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/" class="post-title-link" itemprop="url">Linux 内核代码风格</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-25 16:00:00" itemprop="dateCreated datePublished" datetime="2023-06-25T16:00:00+08:00">2023-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-04 09:28:41" itemprop="dateModified" datetime="2023-07-04T09:28:41+08:00">2023-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Chinese translated version of Documentation/process/coding-style.rst</p>
<p>If you have any comment or update to the content, please post to LKML directly. However, if you have problem communicating in English you can also ask the Chinese maintainer for help. Contact the Chinese maintainer, if this translation is outdated or there is problem with translation.</p>
<p>Chinese maintainer: Zhang Le &lt;<a href="mailto:r0bertz@gentoo.org">r0bertz@gentoo.org</a>&gt;</p>
<hr>
<p>Documentation/process/coding-style.rst 的中文翻译</p>
<p>如果想评论或更新本文的内容，请直接发信到LKML。如果你使用英文交流有困难的话， 也可以向中文版维护者求助。如果本翻译更新不及时或者翻译存在问题，请联系中文版 维护者:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">中文版维护者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</span><br><span class="line">中文版翻译者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</span><br><span class="line">中文版校译者： 王聪 Wang Cong &lt;xiyou.wangcong@gmail.com&gt;</span><br><span class="line">               wheelz &lt;kernel.zeng@gmail.com&gt;</span><br><span class="line">               管旭东 Xudong Guan &lt;xudong.guan@gmail.com&gt;</span><br><span class="line">               Li Zefan &lt;lizf@cn.fujitsu.com&gt;</span><br><span class="line">               Wang Chen &lt;wangchen@cn.fujitsu.com&gt;</span><br></pre></td></tr></table></figure>

<p>以下为正文</p>
<hr>
<h1 id="Linux-内核代码风格"><a href="#Linux-内核代码风格" class="headerlink" title="Linux 内核代码风格"></a>Linux 内核代码风格</h1><p>这是一个简短的文档，描述了 linux 内核的首选代码风格。代码风格是因人而异的， 而且我不愿意把自己的观点强加给任何人，但这就像我去做任何事情都必须遵循的原则 那样，我也希望在绝大多数事上保持这种的态度。请 (在写代码时) 至少考虑一下这里 的代码风格。</p>
<p>首先，我建议你打印一份 GNU 代码规范，然后不要读。烧了它，这是一个具有重大象征性意义的动作。</p>
<p>不管怎样，现在我们开始：</p>
<h2 id="1-缩进"><a href="#1-缩进" class="headerlink" title="1) 缩进"></a>1) 缩进</h2><p>制表符是 8 个字符，所以缩进也是 8 个字符。有些异端运动试图将缩进变为 4 (甚至 2！) 字符深，这几乎相当于尝试将圆周率的值定义为 3。</p>
<p>理由：缩进的全部意义就在于清楚的定义一个控制块起止于何处。尤其是当你盯着你的 屏幕连续看了 20 小时之后，你将会发现大一点的缩进会使你更容易分辨缩进。</p>
<p>现在，有些人会抱怨 8 个字符的缩进会使代码向右边移动的太远，在 80 个字符的终端屏幕上就很难读这样的代码。这个问题的答案是，如果你需要 3 级以上的缩进，不管用 何种方式你的代码已经有问题了，应该修正你的程序。</p>
<p>简而言之，<u>8 个字符的缩进可以让代码更容易阅读，还有一个好处是当你的函数嵌套太深的时候可以给你警告。留心这个警告</u>。</p>
<p>在 switch 语句中消除多级缩进的首选的方式是让 <code>switch</code> 和从属于它的 <code>case</code> 标签对齐于同一列，而不要 <code>两次缩进</code> <code>case</code> 标签。比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (suffix) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">        mem &lt;&lt;= <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">        mem &lt;&lt;= <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:</span><br><span class="line">        mem &lt;&lt;= <span class="number">10</span>;</span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要把多个语句放在一行里，除非你有什么东西要隐藏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) do_this;</span><br><span class="line">  do_something_everytime;</span><br></pre></td></tr></table></figure>

<p>也不要在一行里放多个赋值语句。内核代码风格超级简单。就是避免可能导致别人误读 的表达式。</p>
<p>除了注释、文档和 Kconfig 之外，不要使用空格来缩进，前面的例子是例外，是有意为 之。</p>
<p>选用一个好的编辑器，不要在行尾留空格。</p>
<h2 id="2-把长的行和字符串打散"><a href="#2-把长的行和字符串打散" class="headerlink" title="2) 把长的行和字符串打散"></a>2) 把长的行和字符串打散</h2><p>代码风格的意义就在于使用平常使用的工具来维持代码的可读性和可维护性。</p>
<p>每一行的长度的限制是 80 列，我们强烈建议您遵守这个惯例。</p>
<p>长于 80 列的语句要打散成有意义的片段。除非超过 80 列能显著增加可读性，并且不 会隐藏信息。子片段要明显短于母片段，并明显靠右。这同样适用于有着很长参数列表 的函数头。然而，绝对不要打散对用户可见的字符串，例如 printk 信息，因为这样就 很难对它们 grep。</p>
<h2 id="3-大括号和空格的放置"><a href="#3-大括号和空格的放置" class="headerlink" title="3) 大括号和空格的放置"></a>3) 大括号和空格的放置</h2><p>C 语言风格中另外一个常见问题是大括号的放置。和缩进大小不同，选择或弃用某种放置策略并没有多少技术上的原因，不过首选的方式，就像 Kernighan 和 Ritchie 展示 给我们的，是把起始大括号放在行尾，而把结束大括号放在行首，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (x is true) &#123;</span><br><span class="line">        we do y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这适用于所有的非函数语句块 (if, switch, for, while, do)。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (action) &#123;</span><br><span class="line">case KOBJ_ADD:</span><br><span class="line">        return &quot;add&quot;;</span><br><span class="line">case KOBJ_REMOVE:</span><br><span class="line">        return &quot;remove&quot;;</span><br><span class="line">case KOBJ_CHANGE:</span><br><span class="line">        return &quot;change&quot;;</span><br><span class="line">default:</span><br><span class="line">        return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，有一个例外，那就是函数：函数的起始大括号放置于下一行的开头，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int function(int x)</span><br><span class="line">&#123;</span><br><span class="line">        body of function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全世界的异端可能会抱怨这个不一致性是… 呃… 不一致的，不过所有思维健全的人 都知道 (a) K&amp;R 是 <strong>正确的</strong> 并且 (b) K&amp;R 是正确的。此外，不管怎样函数都是特 殊的 (C 函数是不能嵌套的)。</p>
<p>注意结束大括号独自占据一行，除非它后面跟着同一个语句的剩余部分，也就是 do 语 句中的 “while” 或者 if 语句中的 “else”，像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">        body of do-loop</span><br><span class="line">&#125; while (condition);</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (x == y) &#123;</span><br><span class="line">        ..</span><br><span class="line">&#125; else if (x &gt; y) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理由：K&amp;R。</p>
<p>也请注意这种大括号的放置方式也能使空 (或者差不多空的) 行的数量最小化，同时不失可读性。因此，由于你的屏幕上的新行是不可再生资源 (想想 25 行的终端屏幕)，你 将会有更多的空行来放置注释。</p>
<p>当只有一个单独的语句的时候，不用加不必要的大括号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">        action();</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">        do_this();</span><br><span class="line">else</span><br><span class="line">        do_that();</span><br></pre></td></tr></table></figure>

<p>这并不适用于只有一个条件分支是单语句的情况；这时所有分支都要使用大括号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">        do_this();</span><br><span class="line">        do_that();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        otherwise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-空格"><a href="#3-1-空格" class="headerlink" title="3.1) 空格"></a>3.1) 空格</h3><p>Linux 内核的空格使用方式 (主要) 取决于它是用于函数还是关键字。(大多数) 关键字后要加一个空格。值得注意的例外是 sizeof, typeof, alignof 和 __attribute__，这 些关键字某些程度上看起来更像函数 (它们在 Linux 里也常常伴随小括号而使用，尽管 在 C 里这样的小括号不是必需的，就像 <code>struct fileinfo info;</code> 声明过后的 <code>sizeof info</code>)。</p>
<p>所以在这些关键字之后放一个空格:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if, switch, case, for, do, while</span><br></pre></td></tr></table></figure>

<p>但是不要在 sizeof, typeof, alignof 或者 <strong>attribute</strong> 这些关键字之后放空格。 例如，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = sizeof(struct file);</span><br></pre></td></tr></table></figure>

<p>不要在小括号里的表达式两侧加空格。这是一个 <strong>反例</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = sizeof( struct file );</span><br></pre></td></tr></table></figure>

<p><u>当声明指针类型或者返回指针类型的函数时， <code>*</code> 的首选使用方式是使之靠近变量名或者函数名，而不是靠近类型名</u>。例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *linux_banner;</span><br><span class="line">unsigned long long memparse(char *ptr, char **retptr);</span><br><span class="line">char *match_strdup(substring_t *s);</span><br></pre></td></tr></table></figure>

<p><u>在大多数二元和三元操作符两侧使用一个空格</u>，例如下面所有这些操作符:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=  +  -  &lt;  &gt;  *  /  %  |  &amp;  ^  &lt;=  &gt;=  ==  !=  ?  :</span><br></pre></td></tr></table></figure>

<p><u>但是一元操作符后不要加空格</u>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined</span><br></pre></td></tr></table></figure>

<p>后缀自加和自减一元操作符前不加空格:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++  --</span><br></pre></td></tr></table></figure>

<p>前缀自加和自减一元操作符后不加空格:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++  --</span><br></pre></td></tr></table></figure>

<p><code>.</code> 和 <code>-&gt;</code> 结构体成员操作符前后不加空格。</p>
<p>不要在行尾留空白。有些可以自动缩进的编辑器会在新行的行首加入适量的空白，然后 你就可以直接在那一行输入代码。不过假如你最后没有在那一行输入代码，有些编辑器 就不会移除已经加入的空白，就像你故意留下一个只有空白的行。包含行尾空白的行就 这样产生了。</p>
<p>当 git 发现补丁包含了行尾空白的时候会警告你，并且可以应你的要求去掉行尾空白； 不过如果你是正在打一系列补丁，这样做会导致后面的补丁失败，因为你改变了补丁的上下文。</p>
<h2 id="4-命名"><a href="#4-命名" class="headerlink" title="4) 命名"></a>4) 命名</h2><p>C 是一个简朴的语言，你的命名也应该这样。和 Modula-2 和 Pascal 程序员不同， C 程序员不使用类似 ThisVariableIsATemporaryCounter 这样华丽的名字。C 程序员会 称那个变量为 <code>tmp</code> ，这样写起来会更容易，而且至少不会令其难于理解。</p>
<p>不过，虽然混用大小写的名字是不提倡使用的，但是全局变量还是需要一个具描述性的名字。称一个全局函数为 <code>foo</code> 是一个难以饶恕的错误。</p>
<p>全局变量 (只有当你 <strong>真正</strong> 需要它们的时候再用它) 需要有一个具描述性的名字，就像全局函数。如果你有一个可以计算活动用户数量的函数，你应该叫它 <code>count_active_users()</code> 或者类似的名字，你不应该叫它 <code>cntuser()</code> 。</p>
<p>在函数名中包含函数类型 (所谓的匈牙利命名法) 是脑子出了问题——编译器知道那些类 型而且能够检查那些类型，这样做只能把程序员弄糊涂了。难怪微软总是制造出有问题的程序。</p>
<p>本地变量名应该简短，而且能够表达相关的含义。如果你有一些随机的整数型的循环计数器，它应该被称为 <code>i</code> 。叫它 <code>loop_counter</code> 并无益处，如果它没有被误解的可能的话。类似的， <code>tmp</code> 可以用来称呼任意类型的临时变量。</p>
<p>如果你怕混淆了你的本地变量名，你就遇到另一个问题了，叫做函数增长荷尔蒙失衡综合症。请看第六章 (函数)。</p>
<h2 id="5-Typedef"><a href="#5-Typedef" class="headerlink" title="5) Typedef"></a>5) Typedef</h2><p>不要使用类似 <code>vps_t</code> 之类的东西。</p>
<p>对结构体和指针使用 typedef 是一个 <strong>错误</strong> 。当你在代码里看到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vps_t a;</span><br></pre></td></tr></table></figure>

<p>这代表什么意思呢？</p>
<p>相反，如果是这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct virtual_container *a;</span><br></pre></td></tr></table></figure>

<p>你就知道 <code>a</code> 是什么了。</p>
<p>很多人认为 typedef <code>能提高可读性</code> 。实际不是这样的。它们只在下列情况下有用：</p>
<blockquote>
<ol>
<li><p>完全不透明的对象 (这种情况下要主动使用 typedef 来 <strong>隐藏</strong> 这个对象实际上是什么)。</p>
<p>例如： <code>pte_t</code> 等不透明对象，你只能用合适的访问函数来访问它们。</p>
<p>Note：不透明性和 “访问函数” 本身是不好的。我们使用 pte_t 等类型的原因在于真的是完全没有任何共用的可访问信息。</p>
</li>
<li><p>清楚的整数类型，如此，这层抽象就可以 <strong>帮助</strong> 消除到底是 <code>int</code> 还是 <code>long</code> 的混淆。</p>
<p>u8/u16/u32 是完全没有问题的 typedef，不过它们更符合类别 (d) 而不是这里。</p>
<p>Note：要这样做，必须事出有因。如果某个变量是 <code>unsigned long</code> ，那么没有必要 typedef unsigned long myflags_t;</p>
<p>不过如果有一个明确的原因，比如它在某种情况下可能会是一个 <code>unsigned int</code> 而在其他情况下可能为 <code>unsigned long</code> ，那么就不要犹豫，请务必使用 typedef。</p>
</li>
<li><p>当你使用 sparse 按字面的创建一个 <strong>新</strong> 类型来做类型检查的时候。</p>
</li>
<li><p>和标准 C99 类型相同的类型，在某些例外的情况下。</p>
<p>虽然让眼睛和脑筋来适应新的标准类型比如 <code>uint32_t</code> 不需要花很多时间，可是有些人仍然拒绝使用它们。</p>
<p>因此，Linux 特有的等同于标准类型的 <code>u8/u16/u32/u64</code> 类型和它们的有符号类型是被允许的——尽管在你自己的新代码中，它们不是强制要求要使用的。</p>
<p>当编辑已经使用了某个类型集的已有代码时，你应该遵循那些代码中已经做出的选择。</p>
</li>
<li><p>可以在用户空间安全使用的类型。</p>
<p>在某些用户空间可见的结构体里，我们不能要求 C99 类型而且不能用上面提到的 <code>u32</code> 类型。因此，我们在与用户空间共享的所有结构体中使用 __u32 和类似 的类型。</p>
</li>
</ol>
</blockquote>
<p>可能还有其他的情况，不过基本的规则是 <strong>永远不要</strong> 使用 typedef，除非你可以明确的应用上述某个规则中的一个。</p>
<p>总的来说，如果一个指针或者一个结构体里的元素可以合理的被直接访问到，那么它们就不应该是一个 typedef。</p>
<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6) 函数"></a>6) 函数</h2><p><u>函数应该简短而漂亮，并且只完成一件事情</u>。函数应该可以一屏或者两屏显示完 (我们 都知道 ISO/ANSI 屏幕大小是 80x24)，只做一件事情，而且把它做好。</p>
<p>一个函数的最大长度是和该函数的复杂度和缩进级数成反比的。所以，如果你有一个理论上很简单的只有一个很长 (但是简单) 的 case 语句的函数，而且你需要在每个 case 里做很多很小的事情，这样的函数尽管很长，但也是可以的。</p>
<p>不过，如果你有一个复杂的函数，而且你怀疑一个天分不是很高的高中一年级学生可能甚至搞不清楚这个函数的目的，你应该严格遵守前面提到的长度限制。使用辅助函数， 并为之取个具描述性的名字 (如果你觉得它们的性能很重要的话，可以让编译器内联它们，这样的效果往往会比你写一个复杂函数的效果要好。)</p>
<p>函数的另外一个衡量标准是本地变量的数量。此数量不应超过 5－10 个，否则你的函数 就有问题了。重新考虑一下你的函数，把它分拆成更小的函数。人的大脑一般可以轻松的同时跟踪 7 个不同的事物，如果再增多的话，就会糊涂了。即便你聪颖过人，你也可能会记不清你 2 个星期前做过的事情。</p>
<p>在源文件里，使用空行隔开不同的函数。如果该函数需要被导出，它的 <strong>EXPORT</strong> 宏 应该紧贴在它的结束大括号之下。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int system_is_up(void)</span><br><span class="line">&#123;</span><br><span class="line">        return system_state == SYSTEM_RUNNING;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(system_is_up);</span><br></pre></td></tr></table></figure>

<p>在函数原型中，包含函数名和它们的数据类型。虽然 C 语言里没有这样的要求，在 Linux 里这是提倡的做法，因为这样可以很简单的给读者提供更多的有价值的信息。</p>
<h2 id="7-集中的函数退出途径"><a href="#7-集中的函数退出途径" class="headerlink" title="7) 集中的函数退出途径"></a>7) 集中的函数退出途径</h2><p>虽然被某些人声称已经过时，但是 goto 语句的等价物还是经常被编译器所使用，具体形式是无条件跳转指令。</p>
<p>当一个函数从多个位置退出，并且需要做一些类似清理的常见操作时，goto 语句就很方便了。如果并不需要清理操作，那么直接 return 即可。</p>
<p>选择一个能够说明 goto 行为或它为何存在的标签名。如果 goto 要释放 <code>buffer</code>, 一个不错的名字可以是 <code>out_free_buffer:</code> 。别去使用像 <code>err1:</code> 和 <code>err2:</code> 这样的GW_BASIC 名称，因为一旦你添加或删除了 (函数的) 退出路径，你就必须对它们重新编号，这样会难以去检验正确性。</p>
<p>使用 goto 的理由是：</p>
<ul>
<li>无条件语句容易理解和跟踪</li>
<li>嵌套程度减小</li>
<li>可以避免由于修改时忘记更新个别的退出点而导致错误</li>
<li>让编译器省去删除冗余代码的工作 ;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int fun(int a)</span><br><span class="line">&#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        char *buffer;</span><br><span class="line"></span><br><span class="line">        buffer = kmalloc(SIZE, GFP_KERNEL);</span><br><span class="line">        if (!buffer)</span><br><span class="line">                return -ENOMEM;</span><br><span class="line"></span><br><span class="line">        if (condition1) &#123;</span><br><span class="line">                while (loop1) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                &#125;</span><br><span class="line">                result = 1;</span><br><span class="line">                goto out_free_buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">out_free_buffer:</span><br><span class="line">        kfree(buffer);</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个需要注意的常见错误是 <code>一个 err 错误</code> ，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err:</span><br><span class="line">        kfree(foo-&gt;bar);</span><br><span class="line">        kfree(foo);</span><br><span class="line">        return ret;</span><br></pre></td></tr></table></figure>

<p>这段代码的错误是，在某些退出路径上 <code>foo</code> 是 NULL。通常情况下，通过把它分离 成两个错误标签 <code>err_free_bar:</code> 和 <code>err_free_foo:</code> 来修复这个错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err_free_bar:</span><br><span class="line">       kfree(foo-&gt;bar);</span><br><span class="line">err_free_foo:</span><br><span class="line">       kfree(foo);</span><br><span class="line">       return ret;</span><br></pre></td></tr></table></figure>

<p>理想情况下，你应该模拟错误来测试所有退出路径。</p>
<h2 id="8-注释"><a href="#8-注释" class="headerlink" title="8) 注释"></a>8) 注释</h2><p>注释是好的，不过有过度注释的危险。永远不要在注释里解释你的代码是如何运作的： 更好的做法是让别人一看你的代码就可以明白，<u>解释写的很差的代码是浪费时间</u>。</p>
<p>一般的，你想要你的注释告诉别人你的代码做了什么，而不是怎么做的。也请你不要把注释放在一个函数体内部：如果函数复杂到你需要独立的注释其中的一部分，你很可能需要回到第六章看一看。你可以做一些小注释来注明或警告某些很聪明 (或者槽糕) 的做法，但不要加太多。你应该做的，是把注释放在函数的头部，告诉人们它做了什么， 也可以加上它做这些事情的原因。</p>
<p>当注释内核 API 函数时，请使用 kernel-doc 格式。请看 Documentation/doc-guide/ 和 scripts/kernel-doc 以获得详细信息。</p>
<p>长 (多行) 注释的首选风格是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This is the preferred style for multi-line</span><br><span class="line"> * comments in the Linux kernel source code.</span><br><span class="line"> * Please use it consistently.</span><br><span class="line"> *</span><br><span class="line"> * Description:  A column of asterisks on the left side,</span><br><span class="line"> * with beginning and ending almost-blank lines.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>对于在 net/ 和 drivers/net/ 的文件，首选的长 (多行) 注释风格有些不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* The preferred comment style for files in net/ and drivers/net</span><br><span class="line"> * looks like this.</span><br><span class="line"> *</span><br><span class="line"> * It is nearly the same as the generally preferred comment style,</span><br><span class="line"> * but there is no initial almost-blank line.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>注释数据也是很重要的，不管是基本类型还是衍生类型。为了方便实现这一点，每一行 应只声明一个数据 (不要使用逗号来一次声明多个数据)。这样你就有空间来为每个数据 写一段小注释来解释它们的用途了。</p>
<h2 id="9-你已经把事情弄糟了"><a href="#9-你已经把事情弄糟了" class="headerlink" title="9) 你已经把事情弄糟了"></a>9) 你已经把事情弄糟了</h2><p>这没什么，我们都是这样。可能你的使用了很长时间 Unix 的朋友已经告诉你 <code>GNU emacs</code> 能自动帮你格式化 C 源代码，而且你也注意到了，确实是这样，不过它 所使用的默认值和我们想要的相去甚远 (实际上，甚至比随机打的还要差——无数个猴子 在 GNU emacs 里打字永远不会创造出一个好程序) (译注：Infinite Monkey Theorem)</p>
<p>所以你要么放弃 GNU emacs，要么改变它让它使用更合理的设定。要采用后一个方案， 你可以把下面这段粘贴到你的 .emacs 文件里。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(defun c-lineup-arglist-tabs-only (ignored)</span><br><span class="line">  &quot;Line up argument lists by tabs, not spaces&quot;</span><br><span class="line">  (let* ((anchor (c-langelem-pos c-syntactic-element))</span><br><span class="line">         (column (c-langelem-2nd-pos c-syntactic-element))</span><br><span class="line">         (offset (- (1+ column) anchor))</span><br><span class="line">         (steps (floor offset c-basic-offset)))</span><br><span class="line">    (* (max steps 1)</span><br><span class="line">       c-basic-offset)))</span><br><span class="line"></span><br><span class="line">(add-hook &#x27;c-mode-common-hook</span><br><span class="line">          (lambda ()</span><br><span class="line">            ;; Add kernel style</span><br><span class="line">            (c-add-style</span><br><span class="line">             &quot;linux-tabs-only&quot;</span><br><span class="line">             &#x27;(&quot;linux&quot; (c-offsets-alist</span><br><span class="line">                        (arglist-cont-nonempty</span><br><span class="line">                         c-lineup-gcc-asm-reg</span><br><span class="line">                         c-lineup-arglist-tabs-only))))))</span><br><span class="line"></span><br><span class="line">(add-hook &#x27;c-mode-hook</span><br><span class="line">          (lambda ()</span><br><span class="line">            (let ((filename (buffer-file-name)))</span><br><span class="line">              ;; Enable kernel mode for the appropriate files</span><br><span class="line">              (when (and filename</span><br><span class="line">                         (string-match (expand-file-name &quot;~/src/linux-trees&quot;)</span><br><span class="line">                                       filename))</span><br><span class="line">                (setq indent-tabs-mode t)</span><br><span class="line">                (setq show-trailing-whitespace t)</span><br><span class="line">                (c-set-style &quot;linux-tabs-only&quot;)))))</span><br></pre></td></tr></table></figure>

<p>这会让 emacs 在 <code>~/src/linux-trees</code> 下的 C 源文件获得更好的内核代码风格。</p>
<p>不过就算你尝试让 emacs 正确的格式化代码失败了，也并不意味着你失去了一切：还可以用 <code>indent</code> 。</p>
<p>不过，GNU indent 也有和 GNU emacs 一样有问题的设定，所以你需要给它一些命令选项。不过，这还不算太糟糕，因为就算是 GNU indent 的作者也认同 K&amp;R 的权威性 (GNU 的人并不是坏人，他们只是在这个问题上被严重的误导了)，所以你只要给 indent 指定选项 <code>-kr -i8</code> (代表 <code>K&amp;R，8 字符缩进</code>)，或使用 <code>scripts/Lindent</code> 这样就可以以最时髦的方式缩进源代码。</p>
<p><code>indent</code> 有很多选项，特别是重新格式化注释的时候，你可能需要看一下它的手册。 不过记住： <code>indent</code> 不能修正坏的编程习惯。</p>
<h2 id="10-Kconfig-配置文件"><a href="#10-Kconfig-配置文件" class="headerlink" title="10) Kconfig 配置文件"></a>10) Kconfig 配置文件</h2><p>对于遍布源码树的所有 Kconfig* 配置文件来说，它们缩进方式有所不同。紧挨着 <code>config</code> 定义的行，用一个制表符缩进，然而 help 信息的缩进则额外增加 2 个空格。举个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config AUDIT</span><br><span class="line">      bool &quot;Auditing support&quot;</span><br><span class="line">      depends on NET</span><br><span class="line">      help</span><br><span class="line">        Enable auditing infrastructure that can be used with another</span><br><span class="line">        kernel subsystem, such as SELinux (which requires this for</span><br><span class="line">        logging of avc messages output).  Does not do system-call</span><br><span class="line">        auditing without CONFIG_AUDITSYSCALL.</span><br></pre></td></tr></table></figure>

<p>而那些危险的功能 (比如某些文件系统的写支持) 应该在它们的提示字符串里显著的声 明这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config ADFS_FS_RW</span><br><span class="line">      bool &quot;ADFS write support (DANGEROUS)&quot;</span><br><span class="line">      depends on ADFS_FS</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<p>要查看配置文件的完整文档，请看 Documentation/kbuild/kconfig-language.txt。</p>
<h2 id="11-数据结构"><a href="#11-数据结构" class="headerlink" title="11) 数据结构"></a>11) 数据结构</h2><p>如果一个数据结构，在创建和销毁它的单线执行环境之外可见，那么它必须要有一个引用计数器。内核里没有垃圾收集 (并且内核之外的垃圾收集慢且效率低下)，这意味着你绝对需要记录你对这种数据结构的使用情况。</p>
<p>引用计数意味着你能够避免上锁，并且允许多个用户并行访问这个数据结构——而不需要担心这个数据结构仅仅因为暂时不被使用就消失了，那些用户可能不过是沉睡了一阵或者做了一些其他事情而已。</p>
<p>注意上锁 <strong>不能</strong> 取代引用计数。上锁是为了保持数据结构的一致性，而引用计数是一个内存管理技巧。通常二者都需要，不要把两个搞混了。</p>
<p>很多数据结构实际上有 2 级引用计数，它们通常有不同 <code>类</code> 的用户。子类计数器统计子类用户的数量，每当子类计数器减至零时，全局计数器减一。</p>
<p>这种 <code>多级引用计数</code> 的例子可以在内存管理 (<code>struct mm_struct</code>: mm_users 和 mm_count)，和文件系统 (<code>struct super_block</code>: s_count 和 s_active) 中找到。</p>
<p>记住：如果另一个执行线索可以找到你的数据结构，但这个数据结构没有引用计数器， 这里几乎肯定是一个 bug。</p>
<h2 id="12-宏，枚举和RTL"><a href="#12-宏，枚举和RTL" class="headerlink" title="12) 宏，枚举和RTL"></a>12) 宏，枚举和RTL</h2><p>用于定义常量的宏的名字及枚举里的标签需要大写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define CONSTANT 0x12345</span><br></pre></td></tr></table></figure>

<p>在定义几个相关的常量时，最好用枚举。</p>
<p>宏的名字请用大写字母，不过形如函数的宏的名字可以用小写字母。</p>
<p>一般的，如果能写成内联函数就不要写成像函数的宏。</p>
<p>含有多个语句的宏应该被包含在一个 do-while 代码块里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define macrofun(a, b, c)                       \</span><br><span class="line">        do &#123;                                    \</span><br><span class="line">                if (a == 5)                     \</span><br><span class="line">                        do_this(b, c);          \</span><br><span class="line">        &#125; while (0)</span><br></pre></td></tr></table></figure>

<p>使用宏的时候应避免的事情：</p>
<ol>
<li>影响控制流程的宏：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define FOO(x)                                  \</span><br><span class="line">        do &#123;                                    \</span><br><span class="line">                if (blah(x) &lt; 0)                \</span><br><span class="line">                        return -EBUGGERED;      \</span><br><span class="line">        &#125; while (0)</span><br></pre></td></tr></table></figure>

<p><strong>非常</strong> 不好。它看起来像一个函数，不过却能导致 <code>调用</code> 它的函数退出；不要打 乱读者大脑里的语法分析器。</p>
<ol>
<li>依赖于一个固定名字的本地变量的宏：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define FOO(val) bar(index, val)</span><br></pre></td></tr></table></figure>

<p>可能看起来像是个不错的东西，不过它非常容易把读代码的人搞糊涂，而且容易导致看起来不相关的改动带来错误。</p>
<ol>
<li>作为左值的带参数的宏： FOO(x) = y；如果有人把 FOO 变成一个内联函数的话，这 种用法就会出错了。</li>
<li>忘记了优先级：使用表达式定义常量的宏必须将表达式置于一对小括号之内。带参数 的宏也要注意此类问题。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define CONSTANT 0x4000</span><br><span class="line">#define CONSTEXP (CONSTANT | 3)</span><br></pre></td></tr></table></figure>

<ol>
<li>在宏里定义类似函数的本地变量时命名冲突：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define FOO(x)                          \</span><br><span class="line">(&#123;                                      \</span><br><span class="line">        typeof(x) ret;                  \</span><br><span class="line">        ret = calc_ret(x);              \</span><br><span class="line">        (ret);                          \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><u>ret 是本地变量的通用名字 - __foo_ret 更不容易与一个已存在的变量冲突。</u></p>
<p>cpp 手册对宏的讲解很详细。gcc internals 手册也详细讲解了 RTL，内核里的汇编语言经常用到它。</p>
<h2 id="13-打印内核消息"><a href="#13-打印内核消息" class="headerlink" title="13) 打印内核消息"></a>13) 打印内核消息</h2><p>内核开发者应该是受过良好教育的。请一定注意内核信息的拼写，以给人以好的印象。 不要用不规范的单词比如 <code>dont</code>，而要用 <code>do not</code> 或者 <code>don&#39;t</code> 。保证这些信息简单明了，无歧义。</p>
<p>内核信息不必以英文句号结束。</p>
<p>在小括号里打印数字 (%d) 没有任何价值，应该避免这样做。</p>
<p>&lt;linux/device.h&gt; 里有一些驱动模型诊断宏，你应该使用它们，以确保信息对应于正确的设备和驱动，并且被标记了正确的消息级别。这些宏有：dev_err(), dev_warn(), dev_info() 等等。对于那些不和某个特定设备相关连的信息，&lt;linux/printk.h&gt; 定义了 pr_notice(), pr_info(), pr_warn(), pr_err() 和其他。</p>
<p>写出好的调试信息可以是一个很大的挑战；一旦你写出后，这些信息在远程出错时能提供极大的帮助。然而打印调试信息的处理方式同打印非调试信息不同。其他 pr_XXX() 函数能无条件地打印，pr_debug() 却不；默认情况下它不会被编译，除非定义了 DEBUG 或设定了 CONFIG_DYNAMIC_DEBUG。实际这同样是为了 dev_dbg()，一个相关约定是在一个已经开启了 DEBUG 时，使用 VERBOSE_DEBUG 来添加 dev_vdbg()。</p>
<p>许多子系统拥有 Kconfig 调试选项来开启 -DDEBUG 在对应的 Makefile 里面；在其他情况下，特殊文件使用 #define DEBUG。当一条调试信息需要被无条件打印时，例如，如果已经包含一个调试相关的 #ifdef 条件，printk(KERN_DEBUG …) 就可被使用。</p>
<h2 id="14-分配内存"><a href="#14-分配内存" class="headerlink" title="14) 分配内存"></a>14) 分配内存</h2><p>内核提供了下面的一般用途的内存分配函数： kmalloc(), kzalloc(), kmalloc_array(), kcalloc(), vmalloc() 和 vzalloc()。 请参考 API 文档以获取有关它们的详细信息。</p>
<p>传递结构体大小的首选形式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = kmalloc(sizeof(*p), ...);</span><br></pre></td></tr></table></figure>

<p>另外一种传递方式中，sizeof 的操作数是结构体的名字，这样会降低可读性，并且可能会引入 bug。有可能指针变量类型被改变时，而对应的传递给内存分配函数的 sizeof 的结果不变。</p>
<p>强制转换一个 void 指针返回值是多余的。C 语言本身保证了从 void 指针到其他任何指针类型的转换是没有问题的。</p>
<p>分配一个数组的首选形式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = kmalloc_array(n, sizeof(...), ...);</span><br></pre></td></tr></table></figure>

<p>分配一个零长数组的首选形式是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = kcalloc(n, sizeof(...), ...);</span><br></pre></td></tr></table></figure>

<p>两种形式检查分配大小 n * sizeof(…) 的溢出，如果溢出返回 NULL。</p>
<h2 id="15-内联弊病"><a href="#15-内联弊病" class="headerlink" title="15) 内联弊病"></a>15) 内联弊病</h2><p>有一个常见的误解是 <code>内联</code> 是 gcc 提供的可以让代码运行更快的一个选项。虽然使 用内联函数有时候是恰当的 (比如作为一种替代宏的方式，请看第十二章)，不过很多情况下不是这样。inline 的过度使用会使内核变大，从而使整个系统运行速度变慢。 <u>因为体积大内核会占用更多的指令高速缓存</u>，而且会导致 pagecache 的可用内存减少。 想象一下，一次 pagecache 未命中就会导致一次磁盘寻址，将耗时 5 毫秒。5 毫秒的 时间内 CPU 能执行很多很多指令。</p>
<p><u>一个基本的原则是如果一个函数有 3 行以上，就不要把它变成内联函数</u>。这个原则的一个例外是，如果你知道某个参数是一个编译时常量，而且因为这个常量你确定编译器在编译时能优化掉你的函数的大部分代码，那仍然可以给它加上 inline 关键字。 kmalloc() 内联函数就是一个很好的例子。</p>
<p>人们经常主张给 static 的而且只用了一次的函数加上 inline，如此不会有任何损失， 因为没有什么好权衡的。虽然从技术上说这是正确的，但是实际上这种情况下即使不加 inline gcc 也可以自动使其内联。而且其他用户可能会要求移除 inline，由此而来的争论会抵消 inline 自身的潜在价值，得不偿失。</p>
<h2 id="16-函数返回值及命名"><a href="#16-函数返回值及命名" class="headerlink" title="16) 函数返回值及命名"></a>16) 函数返回值及命名</h2><p>函数可以返回多种不同类型的值，最常见的一种是表明函数执行成功或者失败的值。这样 的一个值可以表示为一个错误代码整数 (-Exxx＝失败，0＝成功) 或者一个 <code>成功</code> 布尔值 (0＝失败，非0＝成功)。</p>
<p>混合使用这两种表达方式是难于发现的 bug 的来源。如果 C 语言本身严格区分整形和布尔型变量，那么编译器就能够帮我们发现这些错误… 不过 C 语言不区分。为了避免 产生这种 bug，请遵循下面的惯例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果函数的名字是一个动作或者强制性的命令，那么这个函数应该返回错误代</span><br><span class="line">码整数。如果是一个判断，那么函数应该返回一个 &quot;成功&quot; 布尔值。</span><br></pre></td></tr></table></figure>

<p>比如， <code>add work</code> 是一个命令，所以 add_work() 在成功时返回 0，在失败时返回 -EBUSY。类似的，因为 <code>PCI device present</code> 是一个判断，所以 pci_dev_present() 在成功找到一个匹配的设备时应该返回 1，如果找不到时应该返回 0。</p>
<p>所有 EXPORTed 函数都必须遵守这个惯例，所有的公共函数也都应该如此。私有 (static) 函数不需要如此，但是我们也推荐这样做。</p>
<p>返回值是实际计算结果而不是计算是否成功的标志的函数不受此惯例的限制。一般的， 他们通过返回一些正常值范围之外的结果来表示出错。典型的例子是返回指针的函数， 他们使用 NULL 或者 ERR_PTR 机制来报告错误。</p>
<h2 id="17-不要重新发明内核宏"><a href="#17-不要重新发明内核宏" class="headerlink" title="17) 不要重新发明内核宏"></a>17) 不要重新发明内核宏</h2><p>头文件 include/linux/kernel.h 包含了一些宏，你应该使用它们，而不要自己写一些它们的变种。比如，如果你需要计算一个数组的长度，使用这个宏</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))</span><br></pre></td></tr></table></figure>

<p>类似的，如果你要计算某结构体成员的大小，使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)-&gt;f))</span><br></pre></td></tr></table></figure>

<p>还有可以做严格的类型检查的 min() 和 max() 宏，如果你需要可以使用它们。你可以自己看看那个头文件里还定义了什么你可以拿来用的东西，如果有定义的话，你就不应在你的代码里自己重新定义。</p>
<h2 id="18-编辑器模式行和其他需要罗嗦的事情"><a href="#18-编辑器模式行和其他需要罗嗦的事情" class="headerlink" title="18) 编辑器模式行和其他需要罗嗦的事情"></a>18) 编辑器模式行和其他需要罗嗦的事情</h2><p>有一些编辑器可以解释嵌入在源文件里的由一些特殊标记标明的配置信息。比如，emacs 能够解释被标记成这样的行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-*- mode: c -*-</span><br></pre></td></tr></table></figure>

<p>或者这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Local Variables:</span><br><span class="line">compile-command: &quot;gcc -DMAGIC_DEBUG_FLAG foo.c&quot;</span><br><span class="line">End:</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>Vim 能够解释这样的标记：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* vim:set sw=8 noet */</span><br></pre></td></tr></table></figure>

<p>不要在源代码中包含任何这样的内容。每个人都有他自己的编辑器配置，你的源文件不应该覆盖别人的配置。这包括有关缩进和模式配置的标记。人们可以使用他们自己定制的模式，或者使用其他可以产生正确的缩进的巧妙方法。</p>
<h2 id="19-内联汇编"><a href="#19-内联汇编" class="headerlink" title="19) 内联汇编"></a>19) 内联汇编</h2><p>在特定架构的代码中，你可能需要内联汇编与 CPU 和平台相关功能连接。需要这么做时就不要犹豫。然而，当 C 可以完成工作时，不要平白无故地使用内联汇编。在可能的情况下，你可以并且应该用 C 和硬件沟通。</p>
<p>请考虑去写捆绑通用位元 (wrap common bits) 的内联汇编的简单辅助函数，别去重复地写下只有细微差异内联汇编。记住内联汇编可以使用 C 参数。</p>
<p>大型，有一定复杂度的汇编函数应该放在 .S 文件内，用相应的 C 原型定义在 C 头文 件中。汇编函数的 C 原型应该使用 <code>asmlinkage</code> 。</p>
<p>你可能需要把汇编语句标记为 volatile，用来阻止 GCC 在没发现任何副作用后就把它 移除了。你不必总是这样做，尽管，这不必要的举动会限制优化。</p>
<p>在写一个包含多条指令的单个内联汇编语句时，把每条指令用引号分割而且各占一行， 除了最后一条指令外，在每个指令结尾加上 nt，让汇编输出时可以正确地缩进下一条 指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asm (&quot;magic %reg1, #42\n\t&quot;</span><br><span class="line">     &quot;more_magic %reg2, %reg3&quot;</span><br><span class="line">     : /* outputs */ : /* inputs */ : /* clobbers */);</span><br></pre></td></tr></table></figure>

<h2 id="20-条件编译"><a href="#20-条件编译" class="headerlink" title="20) 条件编译"></a>20) 条件编译</h2><p>只要可能，就不要在 .c 文件里面使用预处理条件 (#if, #ifdef)；这样做让代码更难阅读并且更难去跟踪逻辑。替代方案是，<u>在头文件中用预处理条件提供给那些 .c 文件使用，再给 #else 提供一个空桩 (no-op stub) 版本</u>，然后在 .c 文件内无条件地调用 那些 (定义在头文件内的) 函数。这样做，编译器会避免为桩函数 (stub) 的调用生成任何代码，产生的结果是相同的，但逻辑将更加清晰。</p>
<p>最好倾向于编译整个函数，而不是函数的一部分或表达式的一部分。与其放一个 ifdef 在表达式内，不如分解出部分或全部表达式，放进一个单独的辅助函数，并应用预处理 条件到这个辅助函数内。</p>
<p>如果你有一个在特定配置中，可能变成未使用的函数或变量，编译器会警告它定义了但未使用，把它标记为 __maybe_unused 而不是将它包含在一个预处理条件中。(然而，如果一个函数或变量总是未使用，就直接删除它。)</p>
<p>在代码中，尽可能地使用 IS_ENABLED 宏来转化某个 Kconfig 标记为 C 的布尔 表达式，并在一般的 C 条件中使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (IS_ENABLED(CONFIG_SOMETHING)) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会做常量折叠，然后就像使用 #ifdef 那样去包含或排除代码块，所以这不会带来任何运行时开销。然而，这种方法依旧允许 C 编译器查看块内的代码，并检查它的正确性 (语法，类型，符号引用，等等)。因此，如果条件不满足，代码块内的引用符号就不存在时，你还是必须去用 #ifdef。</p>
<p>在任何有意义的 #if 或 #ifdef 块的末尾 (超过几行的)，在 #endif 同一行的后面写下注解，注释这个条件表达式。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_SOMETHING</span><br><span class="line">...</span><br><span class="line">#endif /* CONFIG_SOMETHING */</span><br></pre></td></tr></table></figure>

<h2 id="附录-I-参考"><a href="#附录-I-参考" class="headerlink" title="附录 I) 参考"></a>附录 I) 参考</h2><p>The C Programming Language, 第二版 作者：Brian W. Kernighan 和 Denni M. Ritchie. Prentice Hall, Inc., 1988. ISBN 0-13-110362-8 (软皮), 0-13-110370-9 (硬皮).</p>
<p>The Practice of Programming 作者：Brian W. Kernighan 和 Rob Pike. Addison-Wesley, Inc., 1999. ISBN 0-201-61586-X.</p>
<p>GNU 手册 - 遵循 K&amp;R 标准和此文本 - cpp, gcc, gcc internals and indent, 都可以从 <a target="_blank" rel="noopener" href="http://www.gnu.org/manual/">http://www.gnu.org/manual/</a> 找到</p>
<p>WG14 是 C 语言的国际标准化工作组，URL: <a target="_blank" rel="noopener" href="http://www.open-std.org/JTC1/SC22/WG14/">http://www.open-std.org/JTC1/SC22/WG14/</a></p>
<p>Kernel process/coding-style.rst，作者 <a href="mailto:greg@kroah.com">greg@kroah.com</a> 发表于 OLS 2002： <a target="_blank" rel="noopener" href="http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/">http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/05/15/230515-gitSubTree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/15/230515-gitSubTree/" class="post-title-link" itemprop="url">如何从Git仓库中将模块分离成独立仓库并保留其提交历史？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-15 08:00:00" itemprop="dateCreated datePublished" datetime="2023-05-15T08:00:00+08:00">2023-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-06 09:11:57" itemprop="dateModified" datetime="2023-07-06T09:11:57+08:00">2023-07-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%89%88%E6%9C%AC%E7%AE%A1%E6%8E%A7/" itemprop="url" rel="index"><span itemprop="name">版本管控</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="如何从Git仓库中将模块分离成独立仓库并保留其提交历史？"><a href="#如何从Git仓库中将模块分离成独立仓库并保留其提交历史？" class="headerlink" title="如何从Git仓库中将模块分离成独立仓库并保留其提交历史？"></a>如何从Git仓库中将模块分离成独立仓库并保留其提交历史？</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><ul>
<li>部门代码管理使用的SVN，由于Git可以提交至本地，自己在本地又使用Git管理代码，使用Git管理了一整个工程，在开发不同模块时切到不同分支，一开始没把模块独立放到一个Git仓库，现在想独立模块，又想保留其提交历史，故有此文。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://shantanoo-desai.github.io/posts/technology/git_subtree/">subtrees in Git: How to split Directories into individual standalone repositories</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/25559260/assertion-failed-errors-when-trying-to-git-subtree-split">assertion failed errors when trying to git subtree split</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/74486167/git-clone-recurse-submodules-throws-error-on-macos-transmission-type-file-n">Git clone –recurse-submodules throws error on MacOs: Transmission type ‘file’ not allowed</a></li>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">Git 工具 - 子模块</a></li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol>
<li>将子目录拆分独立库：<code>git subtree split -P &lt;name-of-folder&gt; -b &lt;name-of-new-branch&gt;</code>，注意此行命令需要在Git仓库toplevel目录执行，<code>&lt;name-of-folder&gt;</code>需要避免在前面加<code>./</code>，避免使用反斜杠，否则会产生assertion failed errors，解决方案就是改掉就行，参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/25559260/assertion-failed-errors-when-trying-to-git-subtree-split">assertion failed errors when trying to git subtree split</a></li>
<li>拆分独立库后此仓库在<code>&lt;name-of-new-branch&gt;</code>分支中会保存模块代码和提交记录，然后<code>mkdir &lt;name-of-new-branch&gt; &amp;&amp; cd &lt;name-of-new-branch&gt; &amp;&amp; git</code>，我参考别人的操作使用<code>git pull &lt;/path/to/big-repo&gt; &lt;name-of-new-branch&gt;</code>拉取上级目录的指定分支到一个新的文件夹好像不太行，网上暂时没查到<code>/path/to</code>的用法。我使用的方式是将老仓库<code>&lt;name-of-new-branch&gt;</code>分支代码push，然后使用<code>git pull &lt;repo-path.git&gt; &lt;name-of-new-branch&gt;</code>拉来的代码。</li>
<li>上一步操作后就已经将代码和历史提交记录全部拉到了一个新仓库，后续就可以将新仓库Push。</li>
</ol>
<h3 id="如何在工程的Git仓库中引用模块仓库？"><a href="#如何在工程的Git仓库中引用模块仓库？" class="headerlink" title="如何在工程的Git仓库中引用模块仓库？"></a>如何在工程的Git仓库中引用模块仓库？</h3><ol>
<li><p>参考Git文档：<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">Git 工具 - 子模块</a></p>
<blockquote>
<p>我们首先将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。 你可以通过在 git submodule add 命令后面加上想要跟踪的项目的相对或绝对 URL 来添加新的子模块。 在本例中，我们将会添加一个名为 “DbConnector” 的库。<br>$ git submodule add <a target="_blank" rel="noopener" href="https://github.com/chaconinc/DbConnector">https://github.com/chaconinc/DbConnector</a><br>Cloning into ‘DbConnector’…<br>remote: Counting objects: 11, done.<br>remote: Compressing objects: 100% (10/10), done.<br>remote: Total 11 (delta 0), reused 11 (delta 0)<br>Unpacking objects: 100% (11/11), done.<br>Checking connectivity… done.<br>默认情况下，子模块会将子项目放到一个与仓库同名的目录中，本例中是 “DbConnector”。 如果你想要放到其他地方，那么可以在命令结尾添加一个不同的路径。</p>
</blockquote>
</li>
<li><p>如果一个分支有子模块，另一个分支没有，直接 checkout 后会造成子模块的文件在另一个分支未被删除，可以在 checkout 前使用<code>git submodule deinit --all</code>命令来卸载当前分支已安装的所有子模块，在 checkout 后，如果另一个分支也有子模块，可以使用<code>git submodule init</code>命令注册子模块，再使用<code>git submodule update</code>从子模块库中取出文件。</p>
</li>
<li><p>我使用的子模块库是本地的Git仓库，在拉库的时候首次会报<code>Transmission type &#39;file&#39; not allowed</code>的错误，需通过<code>git config --global protocol.file.allow always</code>配置Git，参考：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/74486167/git-clone-recurse-submodules-throws-error-on-macos-transmission-type-file-n">Git clone –recurse-submodules throws error on MacOs: Transmission type ‘file’ not allowed</a></p>
</li>
</ol>
<h3 id="Git子模块和子树区别"><a href="#Git子模块和子树区别" class="headerlink" title="Git子模块和子树区别"></a>Git子模块和子树区别</h3><p>Git子模块（submodule）和子树（subtree）都是Git中用于将外部仓库包含到自己的仓库中的机制。虽然它们的目的相似，但在功能和使用方式上有一些区别。</p>
<h4 id="Git子模块："><a href="#Git子模块：" class="headerlink" title="Git子模块："></a>Git子模块：</h4><ul>
<li>子模块是对外部仓库中特定提交的引用。</li>
<li>当你将一个子模块添加到你的仓库时，你在自己的仓库中包含了指向另一个仓库的链接，它作为一个子目录存在。</li>
<li>子模块维护着独立的Git历史，被视为独立的仓库。它们有自己的分支、标签和提交历史。</li>
<li>每个子模块引用指向外部仓库中的特定提交。你可以通过显式地拉取变更来更新子模块到新的提交。</li>
<li>子模块通常用于在你的仓库中包含另一个项目作为依赖项，但希望保持两个代码库的分离。</li>
</ul>
<h4 id="Git子树："><a href="#Git子树：" class="headerlink" title="Git子树："></a>Git子树：</h4><ul>
<li>子树允许你直接将外部仓库的内容嵌入到自己仓库的子目录中。</li>
<li>当你向你的仓库添加子树时，你将另一个仓库的文件导入并合并到你的仓库的子目录中。导入的文件成为你的仓库历史的一部分。</li>
<li>子树不维护独立的Git历史。相反，外部仓库的提交会合并到你的仓库的历史中。</li>
<li>子树允许你在你的仓库中直接对导入的代码进行修改。如果你有写入权限，你也可以将修改的内容推送回原始仓库。</li>
<li>子树通常用于将另一个项目的代码作为你仓库的一部分，并将其视为你代码库的一个组成部分。</li>
</ul>
<p>总结而言，子模块提供了一种将外部仓库作为独立实体包含在你的仓库中的方式，而子树允许你将外部仓库的内容合并到你的仓库历史中。选择使用子模块还是子树取决于你的具体需求和工作流程。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/10/230310-macro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/03/10/230310-macro/" class="post-title-link" itemprop="url">C语言 宏的高级用法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-10 16:00:00" itemprop="dateCreated datePublished" datetime="2023-03-10T16:00:00+08:00">2023-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-13 07:35:35" itemprop="dateModified" datetime="2023-03-13T07:35:35+08:00">2023-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="字符串转换符"><a href="#字符串转换符" class="headerlink" title="字符串转换符"></a>字符串转换符</h3><p>使用<code>#</code>运算符可以将宏参数替换为一个字符串，并用双引号括起来，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_STR(x) printf(<span class="string">&quot;The string is: %s\n&quot;</span>, #x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    PRINT_STR(Hello World);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例程序中，定义了一个宏PRINT_STR，它的参数x通过#运算符被转换为一个字符串，并被传递给printf函数进行输出。运行这个程序会输出：<code>The string is: Hello World</code></p>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>在C语言中，宏定义可以使用##运算符进行字符串拼接，称为连接运算符（Token Pasting Operator）。<code>##</code>运算符可以将两个标记（Token）连接成一个标记，从而实现字符串拼接的功能。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONCAT(x, y) x##y</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> xy = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, CONCAT(x, y));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例程序中，定义了一个宏CONCAT，它使用<code>##</code>运算符将两个参数x和y连接成一个标记。在main函数中定义了一个变量xy，并将连接后的标记xy作为参数传递给printf函数进行输出。输出结果是：<code>10</code></p>
<h3 id="变长参数宏"><a href="#变长参数宏" class="headerlink" title="变长参数宏"></a>变长参数宏</h3><p>C语言中的变长参数宏（Variadic Macro）可以接受可变数量的参数。变长参数宏是通过使用特殊的预处理符号<code>__VA_ARGS__</code>来实现的，它表示可变参数的列表。下面是一个简单的示例，展示了如何使用变长参数宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF(...) printf(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    PRINTF(<span class="string">&quot;x = %d, str = %s\n&quot;</span>, x, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例程序中，定义了一个宏PRINTF，它使用printf函数打印可变数量的参数。使用<code>__VA_ARGS__</code>表示可变参数的列表。在main函数中，PRINTF宏被调用，传递了三个参数，包括一个整数和一个字符串。输出结果是：<code>x = 10, str = hello</code></p>
<h3 id="宏：取最大值"><a href="#宏：取最大值" class="headerlink" title="宏：取最大值"></a>宏：取最大值</h3><p>一种方式：<code>#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))</code><br>这种方式需要注意参数如果有自增运算，需要在传参的时候加括号，否则自增运算会重复两次。<br>正确调用方法如：<code>z = MAX((x++), (y++));</code></p>
<p>使用下面一种方式可以避免此类问题</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) (&#123; \</span></span><br><span class="line"><span class="meta">    typeof(a) _a = (a); \</span></span><br><span class="line"><span class="meta">    typeof(b) _b = (b); \</span></span><br><span class="line"><span class="meta">    (void)(&amp;_a == &amp;_b); \</span></span><br><span class="line"><span class="meta">    _a &gt; _b ? _a : _b; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>

<p><code>typeof</code>是GNU C编译器内置的一种类型描述符，用于表示表达式的类型。在编译时，编译器会根据<code>typeof(x)</code>对象的类型生成一个类型的值，并将其插入到代码中。</p>
<p>比较难理解的是<code>(void)(&amp;_a == &amp;_b);</code>，看起来很多余，仔细分析一下，你会发现这条语句很有意思。它的作用有两个： </p>
<ol>
<li>用来给用户提示一个警告，对于不同类型的指针比较，编译器会发出一个警告， 提示两种数据的类型不同。<code>warning: comparison of distinct pointer types lacks a cast.</code></li>
<li>两个数进行比较运算，运算的结果却没有用到，有些编译器可能会给出一个warning，加一个<code>(void)</code>后，就可以消除这个警告。</li>
</ol>
<h3 id="宏：offsetof"><a href="#宏：offsetof" class="headerlink" title="宏：offsetof"></a>宏：offsetof</h3><p><code>offsetof</code>是一个宏，用于获取结构体中成员的偏移量。实现是使用指针运算来计算结构体成员的偏移量。具体实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(type, member) ((size_t) &amp;((type *)0)-&gt;member)</span></span><br></pre></td></tr></table></figure>

<p>其中，type表示结构体类型，member表示结构体成员。在宏展开时，(type *)0将一个空指针强制转换为结构体指针类型，然后通过指针运算获取成员的地址。由于空指针的地址为0，因此可以确保这个地址不会指向任何实际的内存位置，避免了访问非法内存的风险。最后，将成员的地址转换为size_t类型的偏移量，并返回。</p>
<p>需要注意的是，offsetof宏只能用于标准布局的结构体，即结构体中的成员按照其定义顺序依次存储，没有嵌套、位域、虚函数等。对于非标准布局的结构体，offsetof可能无法正确计算成员的偏移量。</p>
<h3 id="宏：container-of"><a href="#宏：container-of" class="headerlink" title="宏：container_of"></a>宏：container_of</h3><p><code>container_of</code>是一个宏，用于从结构体的成员指针计算出结构体的地址。其实现通常基于<code>offsetof</code>宏和指针运算。实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    ((type *)((char *)(ptr) - offsetof(type, member)))</span></span><br></pre></td></tr></table></figure>

<p>其中，ptr表示结构体成员的指针，type表示结构体类型，member表示结构体成员名。offsetof(type, member)用于计算结构体成员在结构体中的偏移量，(char *)(ptr)将成员指针转换为char类型指针，以便进行指针运算。通过成员指针的地址减去成员在结构体中的偏移量，可以得到结构体的地址。最后，将地址转换为type类型的指针，并返回。</p>
<p>container_of宏常用于实现Linux内核中的数据结构，如链表、哈希表等。它可以方便地从链表节点或哈希桶中获取对应的数据结构。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao</p>
  <div class="site-description" itemprop="description">保持热爱，奔赴山海。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">73</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
