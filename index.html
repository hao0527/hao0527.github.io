<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/heng32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/heng16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="保持热爱，奔赴山海。">
<meta property="og:type" content="website">
<meta property="og:title" content="永恆博客网">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="永恆博客网">
<meta property="og:description" content="保持热爱，奔赴山海。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Hao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>永恆博客网</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">永恆博客网</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/04/16/250416-mcalspi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/04/16/250416-mcalspi/" class="post-title-link" itemprop="url">MCAL SPI 学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-04-16 21:00:00" itemprop="dateCreated datePublished" datetime="2025-04-16T21:00:00+08:00">2025-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-17 21:07:48" itemprop="dateModified" datetime="2025-04-17T21:07:48+08:00">2025-04-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Autosar-中-SPI-关键概念"><a href="#Autosar-中-SPI-关键概念" class="headerlink" title="Autosar 中 SPI 关键概念"></a>Autosar 中 SPI 关键概念</h2><p><img src="/2025/04/16/250416-mcalspi/250416-mcalspi-1.jpg"></p>
<h3 id="Autosar-中的描述"><a href="#Autosar-中的描述" class="headerlink" title="Autosar 中的描述"></a>Autosar 中的描述</h3><table>
<thead>
<tr>
<th>Definition</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Sequences</td>
<td>Channel是使用相同标准定义的数据的软件交换介质：参数配置，具有相同大小和数据指针（源和目标）或位置的数据元素数量。</td>
</tr>
<tr>
<td>Job</td>
<td>Job由具有相同片选的一个或多个Channel组成（在处理Job期间不会释放）。 一个Job被视为原子作业，因此不能被另一个Job打断。Job具有分配的优先级。</td>
</tr>
<tr>
<td>Channel</td>
<td>Sequence是要传输的多个连续Job，但是可以使用优先级机制在Job之间重新安排Sequence。 Sequence传输是可中断的（通过另一Sequence传输）或不可中断，这取决于静态配置。</td>
</tr>
</tbody></table>
<h2 id="关键-API-使用"><a href="#关键-API-使用" class="headerlink" title="关键 API 使用"></a>关键 API 使用</h2><h3 id="读写-Channel-Buffer"><a href="#读写-Channel-Buffer" class="headerlink" title="读写 Channel Buffer"></a>读写 Channel Buffer</h3><p>在 SPI 通信中，<strong>在开始传输之前</strong> ，必须先准备好发送的数据；<strong>传输完成后</strong> ，则需要读取接收到的数据。这就涉及到对 <strong>读写缓冲区</strong>  的操作。</p>
<ul>
<li><strong>IB 模式</strong> 下，缓冲区由驱动内部维护，因此需要调用专用接口进行读写：<ul>
<li>写入待发送数据：<code>Std_ReturnType Spi_WriteIB(Spi_ChannelType Channel, const Spi_DataBufferType* DataBufferPtr);</code></li>
<li>读取接收到的数据：<code>Std_ReturnType Spi_ReadIB(Spi_ChannelType Channel, Spi_DataBufferType* DataBufferPointer);</code></li>
</ul>
</li>
<li><strong>EB 模式</strong> 下，用户自行提供发送和接收缓冲区，在配置阶段通过以下接口设置发送数据地址、接收数据地址、数据长度：<ul>
<li>配置缓冲地址和长度：<code>Std_ReturnType Spi_SetupEB(Spi_ChannelType Channel, const Spi_DataBufferType* SrcDataBufferPtr, Spi_DataBufferType* DesDataBufferPtr, Spi_NumberOfDataType Length);</code></li>
</ul>
</li>
</ul>
<h4 id="IB-EB"><a href="#IB-EB" class="headerlink" title="IB / EB"></a>IB / EB</h4><p>Autosar 标准下的 SPI Channel 有 IB / EB 两种类型：<br>IB 通道由驱动内部提供缓冲区，适用于短数据传输（如 &lt;10 字节）和 daisy-chain 场景。优点是简单易用，能利用硬件缓冲提升效率（如果硬件支持），但不适合大数据传输。<br>EB 通道需要用户提供缓冲区，适合大数据通信或控制复杂外设。优点是灵活高效、支持从 ROM 发送常量数据，缺点是实现复杂，对上层要求高。</p>
<h3 id="开始传输-Sequence"><a href="#开始传输-Sequence" class="headerlink" title="开始传输 Sequence"></a>开始传输 Sequence</h3><p>完成 Buffer 设置后（无论是 IB 还是 EB），SPI 通信需要通过 <strong>传输接口</strong> 来启动传输。Autosar SPI 支持两种传输方式：</p>
<ul>
<li><strong>同步传输（Sync）</strong> ：调用后会 <strong>阻塞等待</strong> 传输完成：<code>Std_ReturnType Spi_SyncTransmit(Spi_SequenceType Sequence);</code></li>
<li><strong>异步传输（Async）</strong> ：调用后 <strong>立即返回</strong> ，传输在后台进行，完成后通过回调函数通知：<code>Std_ReturnType Spi_AsyncTransmit(Spi_SequenceType Sequence);</code></li>
</ul>
<h3 id="获取状态-结果"><a href="#获取状态-结果" class="headerlink" title="获取状态 / 结果"></a>获取状态 / 结果</h3><p>在 SPI 异步传输中，为了判断传输是否完成以及传输是否成功，Autosar 提供了多种状态获取接口：</p>
<ul>
<li>获取 SPI 驱动的整体状态，如未初始化（UNINIT）、空闲（IDLE）、忙（BUSY）：<code>Spi_StatusType Spi_GetStatus(void)</code></li>
<li>查询某个具体 SPI 硬件单元的当前状态是否空闲。适用于多个 SpiDevice 通过不同片选挂在同一路 SpiPhyUni 系统：<code>Spi_StatusType Spi_GetHWUnitStatus(Spi_HWUnitType HWUnit)</code></li>
<li>获取指定 Job 的最近一次传输结果，如成功（OK）、失败（FAILED）、进行中（PENDING）、取消（CANCELED）：<code>Spi_JobResultType Spi_GetJobResult(Spi_JobType Job)</code></li>
<li>获取指定 Sequence 的最近一次传输结果，如成功（OK）、失败（FAILED）、进行中（PENDING）、排队中（QUEUED）：<code>Spi_SeqResultType Spi_GetSequenceResult(Spi_SequenceType Sequence)</code></li>
</ul>
<h3 id="取消传输"><a href="#取消传输" class="headerlink" title="取消传输"></a>取消传输</h3><p><code>void Spi_Cancel(Spi_SequenceType Sequence);</code> 接口仅在异步传输模式下使用，并且只有在一个 <strong>Sequence</strong>  包含多个 <strong>Job</strong>  时才会涉及。<br><strong>注意</strong>：这是个异步接口，调用后传输 Sequence 会等当前的 Job 传输完成后取消剩余其他的 Job。</p>
<blockquote>
<p><strong>使用场景</strong> ：当你有多个 <strong>Job</strong>  在同一个 <strong>Sequence</strong>  中异步执行，且突然需要优先传输其他重要的 <strong>Sequence</strong>  时，可以调用此接口取消当前的传输，然后立即启动新的传输。</p>
</blockquote>
<h2 id="调用时序图"><a href="#调用时序图" class="headerlink" title="调用时序图"></a>调用时序图</h2><h3 id="Write-AsyncTransmit-Read-IB-One-Channel-one-Job-then-one-Sequence"><a href="#Write-AsyncTransmit-Read-IB-One-Channel-one-Job-then-one-Sequence" class="headerlink" title="Write/AsyncTransmit/Read (IB), One Channel, one Job then one Sequence"></a>Write/AsyncTransmit/Read (IB), One Channel, one Job then one Sequence</h3><p><img src="/2025/04/16/250416-mcalspi/250416-mcalspi-2.jpg"></p>
<h2 id="关键配置"><a href="#关键配置" class="headerlink" title="关键配置"></a>关键配置</h2><p><img src="/2025/04/16/250416-mcalspi/250416-mcalspi-3.png"></p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>SpiChannelBuffersAllowed</td>
<td>指定支持的 Channel 缓冲区类型： <br> 0 - 仅允许内部缓冲（IB） <br> 1 - 仅允许外部缓冲（EB） <br> 2 - 同时支持内部（IB）和外部（EB）缓冲</td>
</tr>
<tr>
<td>SpiInterruptibleSeqAllowed</td>
<td>是否允许中断 Sequence： <br> 0 - 不可中断，已启动的 Sequence 传输期间不会被挂起  <br> 1 - 允许中断，具体是否中断由配置决定，Handler/Driver 可在两个连续 Job 之间中断 Sequence</td>
</tr>
<tr>
<td>SpiLevelDelivered</td>
<td>驱动提供的功能等级： <br> 0 - 仅支持简单同步传输  <br> 1 - 支持基本异步传输  <br> 2 - 支持增强型传输行为</td>
</tr>
<tr>
<td>SpiSupportConcurrentSyncTransmit</td>
<td>是否支持多个不同 Sequence 的 Spi_SyncTransmit() 同时并发调用（配置项是否允许并发） <br> <strong>注意</strong>：如果不勾选这项，即使不是同一路 SPI 的两个设备也不能同时传输</td>
</tr>
</tbody></table>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.autosar.org/fileadmin/standards/R21-11/CP/AUTOSAR_SWS_SPIHandlerDriver.pdf">Spec­i­fi­ca­tion of SPI Handler/Driver</a></li>
<li><a target="_blank" rel="noopener" href="https://www.autosar.org/fileadmin/standards/R21-11/CP/AUTOSAR_SRS_SPIHandlerDriver.pdf">Require­ments on SPI Handler/Driver</a></li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/08/20/240820-canfd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/20/240820-canfd/" class="post-title-link" itemprop="url">云途单片机CAN FD调试记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-20 18:00:00" itemprop="dateCreated datePublished" datetime="2024-08-20T18:00:00+08:00">2024-08-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-08 21:03:41" itemprop="dateModified" datetime="2025-04-08T21:03:41+08:00">2025-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="云途-CAN-FD-介绍"><a href="#云途-CAN-FD-介绍" class="headerlink" title="云途 CAN FD 介绍"></a>云途 CAN FD 介绍</h2><h3 id="MailBox"><a href="#MailBox" class="headerlink" title="MailBox"></a>MailBox</h3><p>之前对MB理解有误，在芯片参考手册中，MB有两种意思，一种是MessageBuff，一种是Mailbox。云途ME0芯片CAN0~2有64MBs，CAN3~5有32MBs，这里的MB指的是MailBox。另外此芯片CAN0~2有20个ERF（Ehanced RX FIFO），而且每个都是64Bytes Payload的，在FD模式下要用Rx Fifo 必须用它。</p>
<blockquote>
<p>The Legacy Rx FIFOs cannot be used in CAN FD mode. The Enhanced Rx FIFO, if implemented, can be used in CAN FD mode</p>
</blockquote>
<p><img src="/2024/08/20/240820-canfd/240820-canfd-6.jpg"></p>
<p>8Byte Payload MailBox每个邮箱占用16字节，此芯片CAN0~2由两个512Bytes RAM Block组成，所以总共是64个 8 Byte Payload MailBox。</p>
<p><img src="/2024/08/20/240820-canfd/240820-canfd-5.jpg"></p>
<p>邮箱是RAM区域，在使用前需要初始化邮箱（写初始值），防止首次读取时ECC错误。在CAN模块中除了邮箱还有很多其他的寄存器也是在RAM中，需要先写再读防止ECC错误，参考文档中介绍了RAM Initialization，这些RAM区域都是从寄存器的地址被访问到，我主要用的是两种如下，一个是标准CAN，一个是CANFD开启ERF：</p>
<p><img src="/2024/08/20/240820-canfd/240820-canfd-7.jpg"><br><img src="/2024/08/20/240820-canfd/240820-canfd-8.jpg"></p>
<h3 id="Message-Buffer"><a href="#Message-Buffer" class="headerlink" title="Message Buffer"></a>Message Buffer</h3><p>MessageBuffer是CAN中发送或接收一帧存放的消息缓冲区，MessageBuffer是由一个或多个MailBox组成，发送还是接收需要配置MessageBuffer中的Code，Code描述如下图：</p>
<p><img src="/2024/08/20/240820-canfd/240820-canfd-1.jpg"><br><img src="/2024/08/20/240820-canfd/240820-canfd-2.jpg"><br><img src="/2024/08/20/240820-canfd/240820-canfd-3.jpg"><br><img src="/2024/08/20/240820-canfd/240820-canfd-4.jpg"></p>
<p>在初始化MessageBuffer过程中，要设置为发送就将code初始化为8，要设为接收就初始化为4。</p>
<p><strong>那么我们要如何分配MailBox，配成各种MessageBuffer呢？</strong></p>
<p>在S32K1中，开启了FD不能使用RX FIFO，为了设计简单，且能防止接收到多帧报文在读取时顺序错误，所以就只配置了1个MessageBuffer用于接收，其余用于发送。</p>
<p>其实也可以根据MessageBuffer中的时间戳来分析哪个先收到，目前还没做，每次MB中断时还要看看其他MB时间戳，感觉效率不是很高。</p>
<p>以下是初始化MessageBuffer的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CanFdMb = (CANFD_MB_TYPE *)p_mcuCanTable[channel].p_can-&gt;RAMn;</span><br><span class="line">CanFdMb[<span class="number">0</span>].mb.t_cs.cs_mb.code = <span class="number">0x4</span>; <span class="comment">//RX EMPTY — MB is active and empty</span></span><br><span class="line"><span class="comment">//剩下全部mb用于发送</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MailBox; i++)&#123;</span><br><span class="line">    CanFdMb[i].mb.t_cs.cs_mb.code = <span class="number">0x8</span>; <span class="comment">//TX INACTIVE — MB is not active</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>云途芯片CAN资源比S32K1丰富很多，开启FD后还能使用ERF，可缓存20个64Bytes Payload的报文并通过FIFO读取没有顺序错误问题。MailBox总共可以配14个64Bytes Payload的MessageBuffer全部用于发送报文，两块MailBox的RAM也可以配置成不同长度的MessageBuffer，如下FDCTRL寄存器：</p>
<p><img src="/2024/08/20/240820-canfd/240820-canfd-9.jpg"></p>
<h3 id="Rx-Filter-Elements"><a href="#Rx-Filter-Elements" class="headerlink" title="Rx Filter Elements"></a>Rx Filter Elements</h3><p>云途的ERF必须要配置Filter才可以用，因为默认就会开1个Filter，不配置的话可能收不到拓展帧，于是我配置了1个标准帧Filter（占4字节）和1个拓展帧Filter（占8字节），配置为Mask模式，Mask都为0，就是都不过滤。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p_mcuCanTable[channel].p_can-&gt;ERFCR |= CAN_ERFCR_NEXIF(<span class="number">1</span>) | CAN_ERFCR_NFE(<span class="number">1</span>); <span class="comment">// 1 extended id filter element, 1 standard id filter element</span></span><br><span class="line">p_mcuCanTable[channel].p_can-&gt;ERFFELn[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">p_mcuCanTable[channel].p_can-&gt;ERFFELn[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">p_mcuCanTable[channel].p_can-&gt;ERFFELn[<span class="number">2</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>标准帧和拓展帧的 Rx Filter Elements 结构体定义如下：</p>
<p><img src="/2024/08/20/240820-canfd/240820-canfd-10.jpg"><br><img src="/2024/08/20/240820-canfd/240820-canfd-11.jpg"></p>
<h2 id="CAN-FD-调试问题"><a href="#CAN-FD-调试问题" class="headerlink" title="CAN FD 调试问题"></a>CAN FD 调试问题</h2><ol>
<li>MessageBuffer 配成64Bytes Payload时，RAM区最后一个MessageBuffer结束地址和下一个MessageBuffer起始地址不连续，导致发送，初始化时操作部分MessageBuff时地址不对。</li>
<li>发送存在错误帧，波特率配置对，但采样率不对。</li>
<li>接收不到，手册说ERF写0使能，找FAE确认没问题，但就是写1使能。</li>
<li>初始化28个MessageBuffer进Hardfault，实际没28个，FAE确认说有28个，最后在应用笔记上找到是14个。</li>
<li>接收不到拓展帧，需要配ERF Filter，1个拓展帧，1个标准帧。</li>
<li>要使用pll后时钟，配时钟源无效。</li>
<li>发送使用14个MessageBuffer，会导致发送的时候顺序乱，使用7个正常，可能是因为2个ram block不同步。</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/20/240520-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/20/240520-cache/" class="post-title-link" itemprop="url">S32K344 Cache 调试记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-20 18:00:00" itemprop="dateCreated datePublished" datetime="2024-05-20T18:00:00+08:00">2024-05-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-23 08:29:01" itemprop="dateModified" datetime="2024-07-23T08:29:01+08:00">2024-07-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Cache概述"><a href="#Cache概述" class="headerlink" title="Cache概述"></a>Cache概述</h2><p>在嵌入式系统中，缓存（Cache）是一种重要的存储器，位于CPU和主存储器（如SRAM、DRAM）之间。它用于存储经常访问的数据和指令，以减少访问主存的时间，从而提高系统的整体性能。缓存可以显著减少CPU等待数据的时间，提高系统的响应速度和处理能力。</p>
<h2 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h2><p>缓存通过存储从主存储器中读取的常用数据或指令来加快访问速度。当CPU需要访问某个数据或指令时，会首先检查缓存。如果缓存中存在所需数据（称为缓存命中），则直接从缓存中读取。如果缓存中不存在（称为缓存未命中），则从主存储器中读取数据，并将其存储到缓存中，以备后续访问。</p>
<h2 id="S32K344-Cache资源情况"><a href="#S32K344-Cache资源情况" class="headerlink" title="S32K344 Cache资源情况"></a>S32K344 Cache资源情况</h2><p>NXP S32K344拥有8KB I-Cache 和 8KB D-Cache，从系统框图看这个芯片，对于锁步核的应用，两个核的Cache无法共用，而TCM内存是可以共用的，锁步情况下TCM内存容量是不锁步的2倍。在Memory table里还能看到存在672Bytes的I-Cache tag和800Bytes的D-Cache tag，缓存需要一种机制来管理哪些数据当前存储在缓存中，这就是tag的作用。S32K344的RAM和ROM都有ECC校验，Cache也包含了ECC校验，RAM和ROM每64位数据有8位是存ECC校验值，这意味着实际设计的Cache资源还要更大一些用于存ECC校验值。</p>
<h2 id="Cache维护"><a href="#Cache维护" class="headerlink" title="Cache维护"></a>Cache维护</h2><p>在缓存管理中，无效化（Invalidate）和清除（Clean）是两个不同的操作。这两个操作帮助维持缓存一致性，确保系统性能和数据正确性。</p>
<h3 id="无效化（Invalidate）"><a href="#无效化（Invalidate）" class="headerlink" title="无效化（Invalidate）"></a>无效化（Invalidate）</h3><p>作用：使缓存中的数据无效，但不写回主存。<br>使用场景：当你确定缓存中的数据已经过期或不再需要时，可以无效化缓存来避免使用陈旧数据。</p>
<h3 id="清除（Clean）"><a href="#清除（Clean）" class="headerlink" title="清除（Clean）"></a>清除（Clean）</h3><p>作用：将缓存中的数据写回主存，但不使数据无效。<br>使用场景：当需要确保缓存中的最新数据已经同步到主存时，可以进行清除操作，特别是在DMA操作前后。</p>
<h2 id="实际使用问题"><a href="#实际使用问题" class="headerlink" title="实际使用问题"></a>实际使用问题</h2><h3 id="开启Cache后Flash读写擦"><a href="#开启Cache后Flash读写擦" class="headerlink" title="开启Cache后Flash读写擦"></a>开启Cache后Flash读写擦</h3><p>S32K344，MCAL的INFLS代码可以配置开启<code>Mem Synchronize Cache</code>选项用于确保缓存与Flash存储之间的数据一致性。</p>
<p>功能：在每次Flash高电压操作（写入、擦除）后，通过调用MCL（Memory Control Layer）缓存API函数来无效化缓存，以确保缓存与修改后的Flash存储同步。但也存在缺点，如果要无效化的区域大于缓存的一半，则整个缓存会被无效化。</p>
<p><strong>在实际使用中如果开启Cache，没开这个选项部分代码擦写Flash不生效，写入异常</strong>。</p>
<h3 id="代码加载到RAM运行"><a href="#代码加载到RAM运行" class="headerlink" title="代码加载到RAM运行"></a>代码加载到RAM运行</h3><p>S32K344，MCAL的INFLS代码可以配置开启<code>Mem Clean Cache After Load Access Code</code>选项用于确保加载到RAM中的Access Code函数与缓存一致。</p>
<p>如果该选项启用，在将Access Code函数加载到RAM后，清除缓存，将缓存数据写入实际RAM内存。此操作可确保缓存和RAM之间的数据同步，避免缓存数据不一致的问题。<strong>在实际使用中遇到了开启这个选项但没开Cache功能，有概率会在加载RAM代码缓存操作时卡死问题</strong>。</p>
<h3 id="DMA-搬运到-Cache-区域"><a href="#DMA-搬运到-Cache-区域" class="headerlink" title="DMA 搬运到 Cache 区域"></a>DMA 搬运到 Cache 区域</h3><p>在使用 DMA 将 UART 收到的数据搬运到 Cache 区域前，必须先 Invalidate 那片区域的 Cache。这是为了确保在 DMA 操作过程中，该区域的 Cache 中不会有未写入内存的脏数据。这些脏数据如果存在，可能会在 DMA 写入数据时被覆盖，导致数据不一致的问题。</p>
<p>虽然在 DMA 搬运前也可以使用 Clean 操作，但相较于 Invalidate 操作，效率较低。Clean 操作会将 Cache 中的脏数据写回到内存，而 Invalidate 直接使 Cache 无效，避免了写回的开销，因此通常更高效。</p>
<p>数据搬运完成后，也需要 Invalidate 那片区域的 Cache。这一步是为了防止在接下来的数据访问过程中，Cache 中的陈旧数据被直接读取，而不是从内存中读取 DMA 搬运来的新数据。</p>
<h2 id="内存区域配置不使用Cache"><a href="#内存区域配置不使用Cache" class="headerlink" title="内存区域配置不使用Cache"></a>内存区域配置不使用Cache</h2><p>不同MCU实现不一样，有使用<strong>MPU（内存保护单元）</strong>，配置MPU区域属性，将指定内存区域设置为不可缓存，设置MPU的Region属性，使该区域不可缓存。也有配置<strong>MMU（内存管理单元）</strong>，如果使用MMU，可以通过设置页表条目属性将内存区域设置为不可缓存。或者是<strong>芯片特定的寄存器</strong>，参考芯片手册进行配置。</p>
<p>S32K344如何配置目前还没了解到，在链接脚本中看到有一块 SRAM 没有被缓存。顺着链接脚本中定义的变量应该能查到程序中哪里配置的不缓存，也有可能那块区域就是不缓存区域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">    int_pflash              : ORIGIN = 0x00440000, LENGTH = 0x00394000    /* 4096KB - 176KB (sBAF + HSE) - 256KB(boot) = 3664KB*/</span><br><span class="line">    int_dflash              : ORIGIN = 0x10000000, LENGTH = 0x00020000    /* 128KB */</span><br><span class="line">    int_itcm                : ORIGIN = 0x00000000, LENGTH = 0x00010000    /* 64KB */</span><br><span class="line">    int_dtcm                : ORIGIN = 0x20000000, LENGTH = 0x0001F000    /* 124KB */</span><br><span class="line">    int_stack_dtcm          : ORIGIN = 0x2001F000, LENGTH = 0x00001000    /* 4KB */</span><br><span class="line">    int_sram                : ORIGIN = 0x20400000, LENGTH = 0x0002FF00    /* 184KB, needs to include int_sram_fls_rsv */</span><br><span class="line">    int_sram_fls_rsv        : ORIGIN = 0x2042FF00, LENGTH = 0x00000100</span><br><span class="line">    int_sram_no_cacheable   : ORIGIN = 0x20430000, LENGTH = 0x0000FF00    /* 64KB, needs to include int_sram_results  */</span><br><span class="line">    int_sram_results        : ORIGIN = 0x2043FF00, LENGTH = 0x00000100</span><br><span class="line">    int_sram_shareable      : ORIGIN = 0x20440000, LENGTH = 0x00004000    /* 16KB */</span><br><span class="line">    ram_rsvd2               : ORIGIN = 0x20444000, LENGTH = 0             /* End of SRAM */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/03/240403-lvgl/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/03/240403-lvgl/" class="post-title-link" itemprop="url">LVGL显示实时图像信息</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-03 20:00:00 / 修改时间：22:17:46" itemprop="dateCreated datePublished" datetime="2024-04-03T20:00:00+08:00">2024-04-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="LVGL介绍"><a href="#LVGL介绍" class="headerlink" title="LVGL介绍"></a><a target="_blank" rel="noopener" href="https://lvgl.io/">LVGL</a>介绍</h2><p><strong>LVGL</strong> 是最流行的免费和开源嵌入式图形库，可为任何 MCU 和 MPU 显示类型创建漂亮的 UI。</p>
<h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>这是去年做的一个小项目，手持热像仪，需要LCD显示摄像头的实时图像。之前做过直接用LCD驱动显示图片效率会高些，这一次需要加一下UI给用户选配置等功能，所以选择使用LVGL。做UI是小问题，主要是如何显示实时图像，本文将介绍使用图像解码器的方法。</p>
<h2 id="Image-decoder（图像解码器）"><a href="#Image-decoder（图像解码器）" class="headerlink" title="Image decoder（图像解码器）"></a><a target="_blank" rel="noopener" href="https://lvgl.100ask.net/master/overview/image.html#image-decoder">Image decoder（图像解码器）</a></h2><p>图像解码器原本被用来解码通用图像格式，如 PNG 或 JPG。我把摄像头读来数据通过图像解码器封装了一下，当做自定义格式去解码，解码器接口如下，最后注册到LVGL，主要实现了 get_info 和 read_line 这两个接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> img_ram[MY_IMG_H][MY_IMG_W];	<span class="comment">// 摄像机读来的图像数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">lv_res_t</span> <span class="title function_">my_decoder_get_info</span><span class="params">(<span class="type">lv_img_decoder_t</span>* decoder, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">lv_img_header_t</span>* header)</span></span><br><span class="line">&#123;</span><br><span class="line">    LV_UNUSED(decoder);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;use my_decoder&quot;</span>, src))</span><br><span class="line">    &#123;<span class="comment">// 如果src 不等于 &quot;use my_decoder&quot;，不使用此解码器</span></span><br><span class="line">        <span class="keyword">return</span> LV_RES_INV;</span><br><span class="line">    &#125;</span><br><span class="line">    header-&gt;w = MY_IMG_W;</span><br><span class="line">    header-&gt;h = MY_IMG_H;</span><br><span class="line">    header-&gt;always_zero = <span class="number">0</span>;</span><br><span class="line">    header-&gt;cf = LV_IMG_CF_TRUE_COLOR;  <span class="comment">// 使用lv_conf.h 中 LV_COLOR_DEPTH 配置的颜色</span></span><br><span class="line">    <span class="keyword">return</span> LV_RES_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">lv_res_t</span> <span class="title function_">my_decoder_open</span><span class="params">(<span class="type">lv_img_decoder_t</span>* decoder, <span class="type">lv_img_decoder_dsc_t</span>* dsc)</span></span><br><span class="line">&#123;</span><br><span class="line">    LV_UNUSED(decoder);</span><br><span class="line">    LV_UNUSED(dsc);</span><br><span class="line">    <span class="keyword">return</span> LV_RES_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">lv_res_t</span> <span class="title function_">my_decoder_read_line</span><span class="params">(<span class="type">lv_img_decoder_t</span>* decoder, <span class="type">lv_img_decoder_dsc_t</span>* dsc, <span class="type">lv_coord_t</span> x, <span class="type">lv_coord_t</span> y, <span class="type">lv_coord_t</span> len, <span class="type">uint8_t</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    LV_UNUSED(decoder);</span><br><span class="line">    LV_UNUSED(dsc);</span><br><span class="line">    <span class="type">uint16_t</span>* destBuff = (<span class="type">uint16_t</span>*)buf;</span><br><span class="line">    <span class="type">uint16_t</span>* srcBuff = (<span class="type">uint16_t</span>*)img_ram;</span><br><span class="line">    <span class="type">uint32_t</span> offset = x + y * MY_IMG_W;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        destBuff[i] = srcBuff[offset + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LV_RES_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_decoder_close</span><span class="params">(<span class="type">lv_img_decoder_t</span>* decoder, <span class="type">lv_img_decoder_dsc_t</span>* dsc)</span></span><br><span class="line">&#123;</span><br><span class="line">    LV_UNUSED(decoder);</span><br><span class="line">    LV_UNUSED(dsc);</span><br><span class="line">    <span class="keyword">return</span> LV_RES_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建一个解码器，将自定义解码器的接口注册到此解码器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_decoder_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">lv_img_decoder_t</span>* dec = lv_img_decoder_create();</span><br><span class="line">    lv_img_decoder_set_close_cb(dec, my_decoder_close);</span><br><span class="line">    lv_img_decoder_set_info_cb(dec, my_decoder_get_info);</span><br><span class="line">    lv_img_decoder_set_open_cb(dec, my_decoder_open);</span><br><span class="line">    lv_img_decoder_set_read_line_cb(dec, my_decoder_read_line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定时刷新和 main 函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_timer</span><span class="params">(<span class="type">lv_timer_t</span> * timer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">lv_obj_t</span> * img = timer-&gt;user_data;  <span class="comment">// 取出定时器的userdata</span></span><br><span class="line">    <span class="comment">// 这里需实现更新摄像机的图像数据到 img_ram 数组的代码</span></span><br><span class="line">    lv_obj_invalidate(img); <span class="comment">// 将img对象标记为无效以重新绘制其区域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_show_img</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">lv_obj_t</span> * img = lv_img_create(lv_scr_act());</span><br><span class="line">    lv_img_set_src(img, <span class="string">&quot;use my_decoder&quot;</span>);</span><br><span class="line">    lv_obj_align(img, LV_ALIGN_CENTER, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    lv_obj_set_size(img, MY_IMG_W, MY_IMG_H);</span><br><span class="line">    lv_timer_create(my_timer, <span class="number">100</span>, (<span class="type">void</span>*)img); <span class="comment">// 创建定时器，周期100ms，定时器userdata设为img对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> APIENTRY <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR szCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Initialize LittlevGL*/</span></span><br><span class="line">    lv_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Initialize the HAL for LittlevGL*/</span></span><br><span class="line">    lv_win32_init(hInstance, SW_SHOWNORMAL, <span class="number">800</span>, <span class="number">480</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Output prompt information to the console, you can also use printf() to print directly*/</span></span><br><span class="line">    LV_LOG_USER(<span class="string">&quot;LVGL initialization completed!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Run the demo*/</span></span><br><span class="line">    my_decoder_init();</span><br><span class="line">    my_show_img();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!lv_win32_quit_signal) &#123;</span><br><span class="line">        <span class="comment">/* Periodically call the lv_task handler.</span></span><br><span class="line"><span class="comment">         * It could be done in a timer interrupt or an OS task too.*/</span></span><br><span class="line">        lv_task_handler();</span><br><span class="line">        usleep(<span class="number">10000</span>);       <span class="comment">/*Just to let the system breath*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p><a target="_blank" rel="noopener" href="https://lvgl.100ask.net/master/widgets/canvas.html">Canvas（画布）(lv_canvas)</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/01/26/240126-wincmd/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/01/26/240126-wincmd/" class="post-title-link" itemprop="url">Windows CMD 脚本学习，实现 Markdown Table 解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-01-26 20:00:00" itemprop="dateCreated datePublished" datetime="2024-01-26T20:00:00+08:00">2024-01-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-02-02 17:00:07" itemprop="dateModified" datetime="2024-02-02T17:00:07+08:00">2024-02-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%84%9A%E6%9C%AC/" itemprop="url" rel="index"><span itemprop="name">脚本</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h2><p>命令提示符是在操作系统中，提示进行命令输入的一种工作提示符。在不同的操作系统环境下，命令提示符各不相同。在windows环境下，命令行程序为cmd.exe，是一个32位的命令行程序（在64位系统中 cmd.exe 也存在于 SysWOW64 目录，WOW64 是 x86 模拟器，允许基于 Windows 的 32 位应用程序在 64 位 Windows 上运行），微软Windows系统基于Windows上的命令解释程序，类似于微软的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/DOS">DOS操作系统</a>（可惜，我这个年代的人都没见过DOS~）。</p>
<h2 id="批处理文件"><a href="#批处理文件" class="headerlink" title="批处理文件"></a>批处理文件</h2><p>批处理文件是无格式的文本文件，它包含一条或多条命令。它的文件扩展名为 .bat 或 .cmd。在命令提示下输入批处理文件的名称，或者双击该批处理文件，系统就会调用 cmd.exe 按照该文件中各个命令出现的顺序来逐个运行它们。使用批处理文件（也被称为批处理程序或脚本），可以简化日常或重复性任务。</p>
<h2 id="BAT实现些小功能"><a href="#BAT实现些小功能" class="headerlink" title="BAT实现些小功能"></a>BAT实现些小功能</h2><h3 id="echo-和"><a href="#echo-和" class="headerlink" title="echo 和 @"></a>echo 和 @</h3><p>Cmd中的echo命令通过<code>echo /?</code>可以看介绍。</p>
<p>用于显示消息：<code>ECHO [message]</code>，（注意：echo不会去message引号）<br>启用或关闭命令回显：<code>ECHO [ON | OFF]</code>，（提一句：Cmd命令不区分大小写）</p>
<p>还有个关回显的方式：<code>@</code>表示本条命令不回显，仅在本条命令生效，优先级高于echo off。</p>
<h3 id="设变量"><a href="#设变量" class="headerlink" title="设变量"></a>设变量</h3><p>和Shell不同，Cmd中设变量需要加set，如<code>set VariableName=100</code>，等号两边不应有空格。设好变量后可用<code>echo %VariableName%</code>来打印刚才设置的变量。</p>
<p>如果要看系统所有的环境变量可以在Cmd中输入<code>set</code>就会打印到终端里，如果要保存到文件中可以<code>set &gt; Variable.txt</code>，<code>&gt;</code>和Shell一样，可以将左边命令输出重定向到指定文件，用<code>&gt;&gt;</code>就是追加写入。</p>
<p>系统中有很多自带的环境变量，下面几个是我感觉可能会用到的：</p>
<ul>
<li>%CD% 本地 返回当前目录字符串。</li>
<li>%USERNAME% 本地 返回当前登录的用户的名称。</li>
<li>%DATE% 系统 返回当前日期。使用与 date /t 命令相同的格式。</li>
<li>%ERRORLEVEL% 系统 返回上一条命令的错误代码。（通常用非零值表示错误）</li>
<li>%PATH% 系统 指定可执行文件的搜索路径。（有多个版本Gcc工具链可以通过设这个环境变量再指定，越在前优先级越高，可以把要用的加在前面）</li>
<li>%WINDIR% 系统 返回操作系统目录的位置。</li>
</ul>
<p>值得思考：变量来自哪里？不同地方定义的环境变量哪个优先级高？</p>
<h3 id="发现异常"><a href="#发现异常" class="headerlink" title="发现异常"></a>发现异常</h3><p>用上面提到的ERRORLEVEL环境变量可以知道上一次命令的返回结果，成功为0（默认值），失败非0。可以根据这个变量去做命令执行失败的处理。</p>
<h3 id="变长参数解析"><a href="#变长参数解析" class="headerlink" title="变长参数解析"></a>变长参数解析</h3><p>配合shift命令，将参数一个个解析。</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> Usage: build.bat [--relese ^&lt;LOG_FILE^&gt;] [make target ...]</span><br><span class="line">:parse-args</span><br><span class="line"><span class="comment">rem 检测到没有下个参数，跳到编译</span></span><br><span class="line"><span class="keyword">if</span> &quot;%<span class="number">1</span>&quot;==&quot;&quot; ( <span class="keyword">goto</span> pre-build1 )</span><br><span class="line"><span class="keyword">if</span> &quot;%<span class="number">1</span>&quot;==&quot;--release&quot; (</span><br><span class="line"><span class="comment">    rem 解析到--release，还需再读一个后面跟的文件地址</span></span><br><span class="line">    <span class="built_in">set</span> RELEASE_FLAG=<span class="number">1</span></span><br><span class="line">	<span class="built_in">set</span> SVN_LOG_FILE=<span class="variable">%RUN_PATH%</span>\%<span class="number">2</span></span><br><span class="line">	<span class="built_in">shift</span></span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line"><span class="comment">    rem 其他参数都归自定义make参数</span></span><br><span class="line">    <span class="built_in">set</span> CUSTOM_MAKE_ARGS=<span class="variable">%CUSTOM_MAKE_ARGS%</span> %<span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">rem shift更改参数的位置</span></span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="keyword">goto</span> parse-args</span><br></pre></td></tr></table></figure>

<h3 id="传地址参数"><a href="#传地址参数" class="headerlink" title="传地址参数"></a>传地址参数</h3><p>脚本经常会遇到传地址参数，比如我的–release参数后面就要跟一个LOG_FILE的参数，需要传递文件路径。</p>
<p>传进来的相对参数正常是基于脚本启动路径，脚本里如果有切换执行路径，在使用地址参数时要加这个路径偏移。可以在执行脚本刚开始记录启动路径（绝对路径）<code>set RUN_PATH=%cd%</code>，后面在解析文件参数时加上启动路径<code>set SVN_LOG_FILE=%RUN_PATH%\%2</code>。</p>
<p>这样可以解决相对路径的传参问题，但是绝对路径无法解决，Cmd脚本如何识别传入的路径是相对or绝对？</p>
<p>在Windows中，绝对路径组成有：<code>驱动器号:\目录名\目录名\...\文件名</code>，可以通过识别有无<code>:</code>来判断是否为绝对路径。</p>
<h3 id="丢弃异常输出"><a href="#丢弃异常输出" class="headerlink" title="丢弃异常输出"></a>丢弃异常输出</h3><p>在Windows命令行脚本中，<code>&gt; nul</code> 是一种将命令输出重定向到空设备的方式。这通常用于抑制命令的输出，使其不显示在命令行窗口中。通常在删除时不报找不到文件错可以加，让异常输出不显示使用 <code>2 &gt; nul</code>。</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> FILE_PATH=%<span class="number">1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%FILE_PATH%</span> | <span class="built_in">find</span> &quot;:&quot; &gt; <span class="built_in">nul</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">errorlevel</span> <span class="number">1</span> (</span><br><span class="line">    <span class="built_in">echo</span> 传入的路径为相对路径</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">echo</span> 传入的路径为绝对路径</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="延迟拓展"><a href="#延迟拓展" class="headerlink" title="延迟拓展"></a>延迟拓展</h3><p>在cmd执行命令前会对脚本进行预处理，其中有一个过程是变量识别过程，在这个过程中，如果有两个%括起来的如<code>%value%</code>类似这样的变量，就会对其进行识别，并且查找这个变量对应的值，再而将值替换掉这个变量，这个替换值的过程，就叫做<strong>变量扩展</strong>，然后再执行命令。</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"><span class="built_in">set</span> a=<span class="number">4</span></span><br><span class="line"><span class="built_in">set</span> a=<span class="number">5</span>&amp; <span class="built_in">echo</span> <span class="variable">%a%</span></span><br></pre></td></tr></table></figure>
<p>Cmd脚本会逐行预处理（用到括号会被当成一行，开<code>@echo on</code>可以看到），上面脚本在预处理时第三行会被变量拓展为<code>set a=5&amp; echo 4</code>，所以就算设置了a=5，打印内容已经被拓展了还是4。</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"><span class="built_in">setlocal</span> enabledelayedexpansion</span><br><span class="line"><span class="built_in">set</span> a=<span class="number">4</span></span><br><span class="line"><span class="built_in">set</span> a=<span class="number">5</span>&amp; <span class="built_in">echo</span> <span class="variable">!a!</span></span><br></pre></td></tr></table></figure>

<p>设置本地开启延时拓展：<code>setlocal enabledelayedexpansion</code>，设置本地关闭延时拓展：<code>setlocal disabledelayedexpansion</code>。这两个也相当于命令，<strong>需要运行到才会起作用</strong>。如果不开启延时拓展，使用到的延时拓展变量不会被拓展echo的内容为<code>!a!</code>。</p>
<p>开启延时拓展后，要被延时拓展的变量要用一对叹号<code>!value!</code>括起来，上面脚本在预处理后为<code>set a=5&amp;echo !a!</code>，在执行echo时才会解析变量a，打印的内容是5。</p>
<p>小技巧：可以开启延时拓展后使用<code>echo %value% !value!</code>看是否一致，如果一致可以不使用延时拓展该变量（最好还是理解原理）。</p>
<h3 id="调子程序"><a href="#调子程序" class="headerlink" title="调子程序"></a>调子程序</h3><p>子程序写法：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:getSum</span><br><span class="line"><span class="built_in">set</span> /a sum+=%<span class="number">1</span></span><br><span class="line"><span class="built_in">shift</span> /<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> &quot;%<span class="number">1</span>&quot;==&quot;&quot; <span class="keyword">goto</span> getSum</span><br><span class="line"><span class="keyword">goto</span> :eof</span><br></pre></td></tr></table></figure>

<p>调用方法：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> sum=<span class="number">0</span></span><br><span class="line"><span class="function">call:<span class="title">getSum</span> 1 2 3</span></span><br><span class="line"><span class="function"><span class="title">echo</span> %<span class="title">sum</span>%</span></span><br></pre></td></tr></table></figure>

<p>输出：<code>6</code></p>
<p>脚本不用像C一样先声明后使用，子程序可以写在调用的下方。</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>语法格式：<code>if [not] &lt;条件&gt; (执行语句)</code>，注意：执行语句如果用括号，左括号和条件间必须有个空格。</p>
<p>多个条件与：<code>if [not] &lt;条件&gt; [if [not] &lt;条件&gt; ...] (执行语句)</code></p>
<p>多个条件或（写法比较不优雅）：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [<span class="keyword">not</span>] &lt;条件&gt; <span class="keyword">goto</span> <span class="keyword">do</span>-something</span><br><span class="line"><span class="keyword">if</span> [<span class="keyword">not</span>] &lt;条件&gt; <span class="keyword">goto</span> <span class="keyword">do</span>-something</span><br><span class="line">...</span><br><span class="line">:<span class="keyword">do</span>-something</span><br><span class="line">执行语句</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>Windows bat脚本的for语句基本形态如下：<br>在cmd窗口中：<code>for %I in (command1) do command2</code><br>在批处理文件中：<code>for %%I in (command1) do command2</code></p>
<p>for、in、do是for语句的关键字，它们三个缺一不可。%%I是for语句中对形式变量的引用，即使变量I在do后的语句中没有参与语句的执行，也是必须出现的。in之后，do之前的括号不能省略。command1表示字符串或变量，command2表示字符串、变量或命令语句。具体使用可以看下面的BAT解析 MarkdownTable。</p>
<h3 id="脱引号（转载）"><a href="#脱引号（转载）" class="headerlink" title="脱引号（转载）"></a>脱引号（<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dongzhiquan/p/3594614.html">转载</a>）</h3><p>很多情况下，我们需要脱除一个字符串中可能会存在的引号，然后在加上自己的引号使其中的特殊字符（命令连接符&amp; 、| 、&amp;&amp;、||，命令行参数界定符Space 、tab 、 ; 、= ，字符化转义符^ 、” ，变量化转义符%等）字符化，失去特定的作用，而作为普通的字符成为字符串的一个组成部分。</p>
<p>如果字符串存在于命令行参数<code>%1</code>中，可以使用<code>%~1</code>脱去第一对外侧引号，如果没有外侧引号则字符串不变。</p>
<p>如果字符串存在于for替代变量<code>%%i</code>中，可以使用<code>%%~i</code>脱去第一对外侧引号，如果没有外侧引号则字符串不变。</p>
<p>如果字符串存在于环境变量<code>%temp%</code>中，可以使用<code>%temp:&quot;=%</code>脱去其中所有的引号，如果没有引号则字符串不变。</p>
<h2 id="BAT解析-MarkdownTable"><a href="#BAT解析-MarkdownTable" class="headerlink" title="BAT解析 MarkdownTable"></a>BAT解析 MarkdownTable</h2><p>解析 MarkdownTable 子程序：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">::==============================Parse Markdown Function============================</span><br><span class="line"><span class="comment">rem 定位Markdown中相应标题所在起始行和结束行</span></span><br><span class="line">:locateMarkdownTitleFunc</span><br><span class="line"><span class="built_in">echo</span> Entering Function %<span class="number">0</span></span><br><span class="line"><span class="built_in">echo</span> inFileName %<span class="number">1</span></span><br><span class="line"><span class="comment">rem titleName需加引号</span></span><br><span class="line"><span class="built_in">echo</span> titleName %<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> startLineNum=</span><br><span class="line"><span class="built_in">set</span> endLineNum=</span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem 查找所有#开头的标题行</span></span><br><span class="line"><span class="keyword">for</span> /F &quot;tokens=*&quot; <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;<span class="built_in">findstr</span> /i /n &quot;^#&quot; %<span class="number">1</span>&#x27;) <span class="keyword">do</span> (</span><br><span class="line">	<span class="built_in">set</span> &quot;line=<span class="variable">%%i</span>&quot;</span><br><span class="line"><span class="comment">	rem 解析标题行的行号和内容</span></span><br><span class="line">	<span class="keyword">for</span> /F &quot;tokens=<span class="number">1</span>* delims=:&quot; <span class="variable">%%j</span> <span class="keyword">in</span> (&quot;<span class="variable">!line!</span>&quot;) <span class="keyword">do</span> (</span><br><span class="line">		<span class="built_in">set</span> linenum=<span class="variable">%%j</span></span><br><span class="line">		<span class="built_in">set</span> &quot;linestr=<span class="variable">%%k</span>&quot;</span><br><span class="line"><span class="comment">		rem 已有起始行 没有结束行，设置结束行</span></span><br><span class="line">		<span class="keyword">if</span> &quot;<span class="variable">!startLineNum!</span>&quot; <span class="keyword">neq</span> &quot;&quot; <span class="keyword">if</span> &quot;<span class="variable">!endLineNum!</span>&quot; <span class="keyword">equ</span> &quot;&quot; (</span><br><span class="line">			<span class="built_in">set</span> endLineNum=<span class="variable">!linenum!</span></span><br><span class="line">		)</span><br><span class="line"><span class="comment">		rem 去标题内容首部#和空格</span></span><br><span class="line">		<span class="keyword">for</span> /F &quot;tokens=* delims=#&quot; <span class="variable">%%a</span> <span class="keyword">in</span> (&quot;<span class="variable">!linestr!</span>&quot;) <span class="keyword">do</span> <span class="built_in">set</span> &quot;linestr=<span class="variable">%%a</span>&quot;</span><br><span class="line">		<span class="keyword">for</span> /F &quot;tokens=* delims= &quot; <span class="variable">%%a</span> <span class="keyword">in</span> (&quot;<span class="variable">!linestr!</span>&quot;) <span class="keyword">do</span> <span class="built_in">set</span> &quot;linestr=<span class="variable">%%a</span>&quot;</span><br><span class="line"><span class="comment">		rem 标题名匹配 没有起始行，设置起始行（多个匹配使用第一个）</span></span><br><span class="line">		<span class="keyword">if</span> /i &quot;<span class="variable">!linestr!</span>&quot; <span class="keyword">equ</span> %<span class="number">2</span> <span class="keyword">if</span> &quot;<span class="variable">!startLineNum!</span>&quot; <span class="keyword">equ</span> &quot;&quot; (</span><br><span class="line">			<span class="built_in">set</span> startLineNum=<span class="variable">!linenum!</span></span><br><span class="line">		)</span><br><span class="line">	)</span><br><span class="line">)</span><br><span class="line"><span class="comment">rem 有起始行没有结束行则取文件总行数+1作为结束行</span></span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%startLineNum%</span>&quot; <span class="keyword">neq</span> &quot;&quot; <span class="keyword">if</span> &quot;<span class="variable">!endLineNum!</span>&quot; <span class="keyword">equ</span> &quot;&quot; (</span><br><span class="line">	<span class="keyword">for</span> /F <span class="variable">%%a</span> <span class="keyword">in</span> (&#x27;<span class="built_in">find</span> /c /v &quot;&quot; ^&lt; %<span class="number">1</span>&#x27;) <span class="keyword">do</span> <span class="built_in">set</span> /a endLineNum=<span class="variable">%%a</span>+<span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">echo</span> Leaving Function %<span class="number">0</span></span><br><span class="line"><span class="function">goto:<span class="title">eof</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 解析README中的Repo Link表格，设环境变量</span></span></span><br><span class="line"><span class="function">:<span class="title">parseRepoLinkFunc</span></span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">Entering</span> <span class="title">Function</span> %0</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">inFileName</span> %1</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">argsSuffix</span> %2</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 定位Markdown中Repo Link标题所在起始行和结束行</span></span></span><br><span class="line"><span class="function"><span class="title">call:locateMarkdownTitleFunc</span> %1 &quot;<span class="title">Repo</span> <span class="title">link</span>&quot;</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">RepoLinkStartLineNum</span>=%<span class="title">startLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">RepoLinkEndLineNum</span>=%<span class="title">endLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">RepoLinkStartLineNum</span>=%<span class="title">RepoLinkStartLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">RepoLinkEndLineNum</span>=%<span class="title">RepoLinkEndLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 解析svn配置行</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1,2,3,4 <span class="title">delims</span>=^|	 &quot; %%<span class="title">i</span> <span class="title">in</span> (&#x27;<span class="title">findstr</span> /<span class="title">i</span> /<span class="title">n</span> &quot;<span class="title">svn</span>.*<span class="title">http</span>&quot; %1&#x27;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function"><span class="comment">	rem 解析行号</span></span></span><br><span class="line"><span class="function">	<span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1* <span class="title">delims</span>=:&quot; %%<span class="title">a</span> <span class="title">in</span> (&quot;%%<span class="title">i</span>&quot;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function">		<span class="title">set</span> <span class="title">linenum</span>=%%<span class="title">a</span></span></span><br><span class="line"><span class="function">	)</span></span><br><span class="line"><span class="function"><span class="comment">	rem 行号大于标题开始行 且 小于标题结束行 则解析，设环境变量</span></span></span><br><span class="line"><span class="function">	<span class="title">if</span> !<span class="title">linenum</span>! <span class="title">gtr</span> %<span class="title">RepoLinkStartLineNum</span>% <span class="title">if</span> !<span class="title">linenum</span>! <span class="title">lss</span> %<span class="title">RepoLinkEndLineNum</span>% (</span></span><br><span class="line"><span class="function">		<span class="title">set</span> <span class="title">SvnUrlMd_</span>%2=%%<span class="title">l</span></span></span><br><span class="line"><span class="function">	)</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 解析git配置行</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1,2,3,4 <span class="title">delims</span>=^|	 &quot; %%<span class="title">i</span> <span class="title">in</span> (&#x27;<span class="title">findstr</span> /<span class="title">i</span> /<span class="title">n</span> &quot;<span class="title">git</span>.*<span class="title">http</span>&quot; %1&#x27;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function"><span class="comment">	rem 解析行号</span></span></span><br><span class="line"><span class="function">	<span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1* <span class="title">delims</span>=:&quot; %%<span class="title">a</span> <span class="title">in</span> (&quot;%%<span class="title">i</span>&quot;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function">		<span class="title">set</span> <span class="title">linenum</span>=%%<span class="title">a</span></span></span><br><span class="line"><span class="function">	)</span></span><br><span class="line"><span class="function"><span class="comment">	rem 行号大于标题开始行 且 小于标题结束行 则解析，设环境变量</span></span></span><br><span class="line"><span class="function">	<span class="title">if</span> !<span class="title">linenum</span>! <span class="title">gtr</span> %<span class="title">RepoLinkStartLineNum</span>% <span class="title">if</span> !<span class="title">linenum</span>! <span class="title">lss</span> %<span class="title">RepoLinkEndLineNum</span>% (</span></span><br><span class="line"><span class="function">		<span class="title">set</span> <span class="title">GitUrlMd_</span>%2=%%<span class="title">l</span></span></span><br><span class="line"><span class="function">		<span class="title">set</span> <span class="title">BranchMd_</span>%2=%%<span class="title">k</span></span></span><br><span class="line"><span class="function">	)</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">Leaving</span> <span class="title">Function</span> %0</span></span><br><span class="line"><span class="function"><span class="title">goto:eof</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 解析README中的Config表格，输出到文件</span></span></span><br><span class="line"><span class="function">:<span class="title">parseConfigFunc</span></span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">Entering</span> <span class="title">Function</span> %0</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">inFileName</span> %1</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">outFileName</span> %2</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 清空outFile</span></span></span><br><span class="line"><span class="function"><span class="title">del</span> %2 2&gt;<span class="title">nul</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 定位Markdown中Config标题所在起始行和结束行</span></span></span><br><span class="line"><span class="function"><span class="title">call:locateMarkdownTitleFunc</span> %1 &quot;<span class="title">Config</span>&quot;</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">ConfigStartLineNum</span>=%<span class="title">startLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">ConfigEndLineNum</span>=%<span class="title">endLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">ConfigStartLineNum</span>=%<span class="title">ConfigStartLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">ConfigEndLineNum</span>=%<span class="title">ConfigEndLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 查找Config标题中Config Name所在行</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=*&quot; %%<span class="title">i</span> <span class="title">in</span> (&#x27;<span class="title">findstr</span> /<span class="title">i</span> /<span class="title">n</span> /<span class="title">c</span>:&quot;<span class="title">Config</span> <span class="title">Name</span>&quot; %1&#x27;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function">	<span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1* <span class="title">delims</span>=:&quot; %%<span class="title">a</span> <span class="title">in</span> (&quot;%%<span class="title">i</span>&quot;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function">		<span class="title">set</span> <span class="title">linenum</span>=%%<span class="title">a</span></span></span><br><span class="line"><span class="function">		<span class="title">if</span> !<span class="title">linenum</span>! <span class="title">gtr</span> %<span class="title">ConfigStartLineNum</span>% <span class="title">if</span> !<span class="title">linenum</span>! <span class="title">lss</span> %<span class="title">ConfigEndLineNum</span>% (</span></span><br><span class="line"><span class="function"><span class="comment">			rem 设置Config Table内容开始行</span></span></span><br><span class="line"><span class="function">			<span class="title">set</span> /<span class="title">a</span> <span class="title">tableStart</span>=!<span class="title">linenum</span>!+2</span></span><br><span class="line"><span class="function">		)</span></span><br><span class="line"><span class="function">	)</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 逐行遍历Markdown文件</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1,2,3,4 <span class="title">delims</span>=^|	 &quot; %%<span class="title">i</span> <span class="title">in</span> (&#x27;<span class="title">findstr</span> /<span class="title">i</span> /<span class="title">n</span> &quot;^&quot; %1&#x27;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function"><span class="comment">	rem 解析行号</span></span></span><br><span class="line"><span class="function">	<span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1* <span class="title">delims</span>=:&quot; %%<span class="title">a</span> <span class="title">in</span> (&quot;%%<span class="title">i</span>&quot;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function">		<span class="title">set</span> <span class="title">linenum</span>=%%<span class="title">a</span></span></span><br><span class="line"><span class="function">	)</span></span><br><span class="line"><span class="function"><span class="comment">	rem 行号大于等于表格内容开始行则解析</span></span></span><br><span class="line"><span class="function">	<span class="title">if</span> !<span class="title">linenum</span>! <span class="title">geq</span> %<span class="title">tableStart</span>% (</span></span><br><span class="line"><span class="function">		<span class="title">set</span> <span class="title">configName</span>=%%<span class="title">j</span></span></span><br><span class="line"><span class="function">		<span class="title">set</span> <span class="title">configValue</span>=%%<span class="title">k</span></span></span><br><span class="line"><span class="function"><span class="comment">		rem 检测为空判定为表格结束，退出函数</span></span></span><br><span class="line"><span class="function">		<span class="title">if</span> &quot;!<span class="title">configName</span>!&quot; <span class="title">equ</span> &quot;&quot; ( <span class="title">goto</span> <span class="title">leaveParseConfig</span> )</span></span><br><span class="line"><span class="function">		<span class="title">if</span> &quot;!<span class="title">configValue</span>!&quot; <span class="title">equ</span> &quot;&quot; ( <span class="title">goto</span> <span class="title">leaveParseConfig</span> )</span></span><br><span class="line"><span class="function"><span class="comment">		rem 存到输出文件</span></span></span><br><span class="line"><span class="function">		<span class="title">echo</span> !<span class="title">configName</span>!=!<span class="title">configValue</span>!&gt;&gt;%2</span></span><br><span class="line"><span class="function">		<span class="title">echo</span> !<span class="title">configName</span>!=!<span class="title">configValue</span>!</span></span><br><span class="line"><span class="function"><span class="comment">		rem 是PostSyncJob 则 设环境变量</span></span></span><br><span class="line"><span class="function">		<span class="title">if</span> &quot;!<span class="title">configName</span>!&quot; <span class="title">equ</span> &quot;<span class="title">PostSyncJob</span>&quot; (</span></span><br><span class="line"><span class="function">			<span class="title">set</span> <span class="title">PostSyncJob</span>=!<span class="title">configValue</span>!</span></span><br><span class="line"><span class="function">		)</span></span><br><span class="line"><span class="function">	)</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function">:<span class="title">leaveParseConfig</span></span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">Leaving</span> <span class="title">Function</span> %0</span></span><br><span class="line"><span class="function"><span class="title">goto:eof</span></span></span><br><span class="line"><span class="function">::=================================================================================</span></span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 进入git仓库, 解析README.<span class="built_in">md</span>文件</span><br><span class="line"><span class="function">call:<span class="title">parseRepoLinkFunc</span> <span class="title">repo</span>\<span class="title">repo_git</span>\<span class="title">README.md</span> <span class="title">Git</span></span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">GitRepo</span> <span class="title">README.md</span> <span class="title">Info</span>:</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">SvnUrlMd_Git</span> = %<span class="title">SvnUrlMd_Git</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">GitUrlMd_Git</span> = %<span class="title">GitUrlMd_Git</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">BranchMd_Git</span> = %<span class="title">BranchMd_Git</span>%</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">echo</span> 进入<span class="title">svn</span>仓库, 解析<span class="title">README.md</span>文件</span></span><br><span class="line"><span class="function"><span class="title">call:parseRepoLinkFunc</span> <span class="title">repo</span>\<span class="title">repo_svn</span>\<span class="title">README.md</span> <span class="title">Svn</span></span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">SvnRepo</span> <span class="title">README.md</span> <span class="title">Info</span>:</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">SvnUrlMd_Svn</span> = %<span class="title">SvnUrlMd_Svn</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">GitUrlMd_Svn</span> = %<span class="title">GitUrlMd_Svn</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">BranchMd_Svn</span> = %<span class="title">BranchMd_Svn</span>%</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem Config写入README_Config.txt</span></span></span><br><span class="line"><span class="function"><span class="title">call:parseConfigFunc</span> <span class="title">repo</span>\<span class="title">repo_git</span>\<span class="title">README.md</span> <span class="title">README_Config.txt</span></span></span><br></pre></td></tr></table></figure>

<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>这几天边写边学BAT脚本，刚接触BAT感觉和Python比起来不够可读和易用，和Shell比起来命令功能不强大。BAT的编程能力与C语言等编程语句比起来是十分有限的，也是十分不规范的。批处理的程序语句就是一条条的DOS命令（包括内部命令和外部命令），而批处理的能力主要取决于你所使用的命令，但在Windows平台上命令确实不如Linux上的好用，在Windows上装MinGW使用Linux上的命令又涉及到了字符转义和编码不同，bat中调Linux下的命令会非常乱，不推荐我这种菜鸡使用，不如直接全部上Linux。</p>
<h2 id="好东西"><a href="#好东西" class="headerlink" title="好东西"></a>好东西</h2><p>Linux下命令有很多，不常用或者首次用比较陌生，好在可以使用tldr这个命令做提示，比命令自带的帮助文档精简。发现一个网页版的tldr，数据库还经常更新，<a target="_blank" rel="noopener" href="https://tldr.inbrowser.app/">tldr-inbrowser</a>。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/12/27/231227-argv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/12/27/231227-argv/" class="post-title-link" itemprop="url">C语言传递的参数还能这样解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-12-27 21:30:00 / 修改时间：23:17:41" itemprop="dateCreated datePublished" datetime="2023-12-27T21:30:00+08:00">2023-12-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前写脚本的时候用到过传参：python最简单，直接<code>import argparse</code>。shell中使用<code>$#</code>表示传递到脚本的参数个数，用<code>$*</code>表示以一个单字符串显示所有向脚本传递的参数，如”$*“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。bat脚本传参和shell类似，<code>%#</code>表示传递到脚本的参数个数，<code>%*</code>表示参数字符串，*可以是数字。在C语言中可以使用<code>getopt</code>，它是一个标准的C库函数，用于解析命令行参数。它可以帮助你处理短选项（-h）和长选项（–help）。</p>
<p>今天学习 <a target="_blank" rel="noopener" href="https://github.com/dbry/adpcm-xq">adpcm-xq</a> 看到一个C代码直接用指针操作argv，如*++*argv，能差不多看懂，现在回家再来理一下。</p>
<h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(argc, argv)</span> <span class="type">int</span> argc; <span class="type">char</span> **argv;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lookahead = <span class="number">3</span>, flags = ADPCM_FLAG_NOISE_SHAPING, blocksize_pow2 = <span class="number">0</span>, overwrite = <span class="number">0</span>, asked_help = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *infilename = <span class="literal">NULL</span>, *outfilename = <span class="literal">NULL</span>;</span><br><span class="line">    FILE *outfile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the name of the executable ends in &quot;encoder&quot; or &quot;decoder&quot;, just do that function</span></span><br><span class="line">    encode_only = argc &amp;&amp; <span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;encoder&quot;</span>) &amp;&amp; <span class="built_in">strlen</span> (<span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;encoder&quot;</span>)) == <span class="built_in">strlen</span> (<span class="string">&quot;encoder&quot;</span>);</span><br><span class="line">    decode_only = argc &amp;&amp; <span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;decoder&quot;</span>) &amp;&amp; <span class="built_in">strlen</span> (<span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;decoder&quot;</span>)) == <span class="built_in">strlen</span> (<span class="string">&quot;decoder&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop through command-line arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (_WIN32)</span></span><br><span class="line">        <span class="keyword">if</span> ((**++argv == <span class="string">&#x27;-&#x27;</span> || **argv == <span class="string">&#x27;/&#x27;</span>) &amp;&amp; (*argv)[<span class="number">1</span>])</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> ((**++argv == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (*argv)[<span class="number">1</span>])</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">while</span> (*++*argv)</span><br><span class="line">                <span class="keyword">switch</span> (**argv) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">                        lookahead = **argv - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                        blocksize_pow2 = strtol (++*argv, argv, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (blocksize_pow2 &lt; <span class="number">8</span> || blocksize_pow2 &gt; <span class="number">15</span>) &#123;</span><br><span class="line">                            <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nblock size power must be 8 to 15!\n&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        --*argv;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                        decode_only = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                        encode_only = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                        flags &amp;= ~ADPCM_FLAG_NOISE_SHAPING;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                        asked_help = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">                        verbosity = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">                        flags |= ADPCM_FLAG_RAW_OUTPUT;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                        verbosity = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">                        overwrite = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nillegal option: %c !\n&quot;</span>, **argv);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!infilename) &#123;</span><br><span class="line">            infilename = <span class="built_in">malloc</span> (<span class="built_in">strlen</span> (*argv) + <span class="number">10</span>);</span><br><span class="line">            <span class="built_in">strcpy</span> (infilename, *argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!outfilename) &#123;</span><br><span class="line">            outfilename = <span class="built_in">malloc</span> (<span class="built_in">strlen</span> (*argv) + <span class="number">10</span>);</span><br><span class="line">            <span class="built_in">strcpy</span> (outfilename, *argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nextra unknown argument: %s !\n&quot;</span>, *argv);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbosity &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;%s&quot;</span>, sign_on);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!outfilename || asked_help) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%s&quot;</span>, usage);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span> (infilename, outfilename)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;can&#x27;t overwrite input file (specify different/new output file name)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!overwrite &amp;&amp; (outfile = fopen (outfilename, <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">        fclose (outfile);</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;output file \&quot;%s\&quot; exists (use -y to overwrite)\n&quot;</span>, outfilename);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adpcm_converter (infilename, outfilename, flags, blocksize_pow2, lookahead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="argc-argv-知识"><a href="#argc-argv-知识" class="headerlink" title="argc argv 知识"></a>argc argv 知识</h2><p>C语言中的<code>argc</code>和<code>argv</code>通常用于处理命令行参数。在C程序中，<code>main</code>函数可以接受两个参数，分别是<code>argc</code>（参数计数）和<code>argv</code>（参数向量）。</p>
<ul>
<li><code>argc</code> 表示命令行参数的数量（包含命令），它是一个整数。</li>
<li><code>argv</code> 是一个指向字符指针数组的指针，每个指针指向一个字符串，这些字符串是命令行参数的实际内容。<code>argv[0]</code>通常是程序的名称，而<code>argv[1]</code>、<code>argv[2]</code>等则是传递给程序的参数。</li>
</ul>
<p>下面是一个简单的例子，展示了如何在C语言中使用<code>argc</code>和<code>argv</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of arguments: %d\n&quot;</span>, argc);</span><br><span class="line">    <span class="comment">// 输出所有命令行参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Argument %d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设你将上述代码保存在一个名为 <code>example.c</code> 的文件中，然后通过命令行编译并运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc example.c -o example</span><br><span class="line">./example arg1 arg2 arg3</span><br></pre></td></tr></table></figure>

<p>这将输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CopyNumber of arguments:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">Argument 0:</span> <span class="string">./example</span></span><br><span class="line"><span class="attr">Argument 1:</span> <span class="string">arg1</span></span><br><span class="line"><span class="attr">Argument 2:</span> <span class="string">arg2</span></span><br><span class="line"><span class="attr">Argument 3:</span> <span class="string">arg3</span></span><br></pre></td></tr></table></figure>

<p>这里，<code>argc</code>是4，因为有四个参数（包括程序的名称），而<code>argv</code>包含这四个参数的字符串。</p>
<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>接下来我将对代码片段中的argc argv相关代码的逐行分析：</p>
<h3 id="片段1"><a href="#片段1" class="headerlink" title="片段1"></a>片段1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if the name of the executable ends in &quot;encoder&quot; or &quot;decoder&quot;, just do that function</span></span><br><span class="line">encode_only = argc &amp;&amp; <span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;encoder&quot;</span>) &amp;&amp; <span class="built_in">strlen</span> (<span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;encoder&quot;</span>)) == <span class="built_in">strlen</span> (<span class="string">&quot;encoder&quot;</span>);</span><br><span class="line">decode_only = argc &amp;&amp; <span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;decoder&quot;</span>) &amp;&amp; <span class="built_in">strlen</span> (<span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;decoder&quot;</span>)) == <span class="built_in">strlen</span> (<span class="string">&quot;decoder&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>argc</code>：传递给程序的命令行参数数量；<code>argv[0]</code>：可执行文件的名称（第一个命令行参数）。</p>
<p><code>char *strstr(const char *haystack, const char *needle);</code> 返回一个指向第一次出现 <code>needle</code> 的指针，如果未找到，则返回 <code>NULL</code>。</p>
<p><code>strlen</code>用于计算字符串的长度，即字符串中字符的个数，不包括字符串末尾的 null 终止符。</p>
<p>这段代码用于检查可执行文件的名称（从命令行参数 <code>argv[0]</code> 获取）是否以 “encoder” 或 “decoder” 结尾（出现字符通过<code>strstr</code>保证，结尾通过<code>strlen</code>保证）。它根据这些条件设置两个布尔变量 <code>encode_only</code> 和 <code>decode_only</code>。</p>
<h3 id="片段2"><a href="#片段2" class="headerlink" title="片段2"></a>片段2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 循环了 argc - 1 次，遍历完所有命令参数</span></span><br><span class="line">    <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (_WIN32)</span></span><br><span class="line">        <span class="comment">// argv首先自增，即指向下一个字符串，**argv是字符串的第一个字符，比较是否为&#x27;-&#x27;或&#x27;/&#x27;，</span></span><br><span class="line">        <span class="comment">// &amp;&amp; (*argv)[1]，且这个字符串存在第二个字符</span></span><br><span class="line">        <span class="keyword">if</span> ((**++argv == <span class="string">&#x27;-&#x27;</span> || **argv == <span class="string">&#x27;/&#x27;</span>) &amp;&amp; (*argv)[<span class="number">1</span>])</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">// argv首先自增，即指向下一个字符串，**argv是字符串的第一个字符，比较是否为&#x27;-&#x27;，</span></span><br><span class="line">        <span class="comment">// &amp;&amp; (*argv)[1]，且这个字符串存在第二个字符</span></span><br><span class="line">        <span class="keyword">if</span> ((**++argv == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (*argv)[<span class="number">1</span>])</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="comment">// argv是指针数组，*argv是指向的字符串，++*argv是增加偏移1字节，指向字符串下一个字符，</span></span><br><span class="line">            <span class="comment">// *++*argv就是下个字符，while (*++*argv)意思就是当下个字符不为结束符&#x27;\0&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> (*++*argv)</span><br><span class="line">                <span class="comment">// **argv是字符串中的一个字符，上一行用++让字符串*argv的指向+1，**argv就是当前指向的字符串字符</span></span><br><span class="line">                <span class="keyword">switch</span> (**argv) &#123;</span><br></pre></td></tr></table></figure>

<h3 id="片段3"><a href="#片段3" class="headerlink" title="片段3"></a>片段3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">    lookahead = **argv - <span class="string">&#x27;0&#x27;</span>;	<span class="comment">// lookahead为数值，字符串转数值</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="片段4"><a href="#片段4" class="headerlink" title="片段4"></a>片段4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">    <span class="comment">// long strtol(const char *str, char **endptr, int base);</span></span><br><span class="line">    <span class="comment">// strtol 用于将字符串转换为长整型数（long）返回，str是要转换的字符串，base 10表示十进制，</span></span><br><span class="line">    <span class="comment">// endptr 如果不是 NULL，则它存储一个指向第一个无法转换的字符的指针，或者如果字符串为空，则指向 str 的开始，</span></span><br><span class="line">    <span class="comment">// 感觉这行代码endptr把 argv 传进去有风险，如果++*argv无法转换成long，argv则会被写</span></span><br><span class="line">    blocksize_pow2 = strtol (++*argv, argv, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (blocksize_pow2 &lt; <span class="number">8</span> || blocksize_pow2 &gt; <span class="number">15</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nblock size power must be 8 to 15!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 感觉这行可有可无，都要break了，接下来就是检查下个字符串了</span></span><br><span class="line">    --*argv;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h3 id="片段5"><a href="#片段5" class="headerlink" title="片段5"></a>片段5</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!infilename) &#123;</span><br><span class="line">    <span class="comment">// 先是把非&#x27;-&#x27;开头的参数赋给输入文件名字</span></span><br><span class="line">    infilename = <span class="built_in">malloc</span> (<span class="built_in">strlen</span> (*argv) + <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span> (infilename, *argv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!outfilename) &#123;</span><br><span class="line">    <span class="comment">// 再是把非&#x27;-&#x27;开头的参数赋给输出文件名字</span></span><br><span class="line">    outfilename = <span class="built_in">malloc</span> (<span class="built_in">strlen</span> (*argv) + <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span> (outfilename, *argv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果参数有问题就输出stderr，打印出是哪个参数错误</span></span><br><span class="line">    <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nextra unknown argument: %s !\n&quot;</span>, *argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在没有用解析命令参数库的情况下，竟然可以这样实现一些常见的命令选项功能，佩服！</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/14/231114-mcal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/14/231114-mcal/" class="post-title-link" itemprop="url">Autosar MCAL初步认知</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-11-14 18:00:00" itemprop="dateCreated datePublished" datetime="2023-11-14T18:00:00+08:00">2023-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-04-08 21:04:19" itemprop="dateModified" datetime="2025-04-08T21:04:19+08:00">2025-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MCAL介绍"><a href="#MCAL介绍" class="headerlink" title="MCAL介绍"></a>MCAL介绍</h1><h2 id="Autosar整体架构-Classic-Autosar"><a href="#Autosar整体架构-Classic-Autosar" class="headerlink" title="Autosar整体架构(Classic Autosar)"></a>Autosar整体架构(Classic Autosar)</h2><p>AUTOSAR体系结构在最高抽象级别上区分了三个软件层：应用软件层(ASW)、运行时环境(RTE)、运行在微控制器(Microcontroller)上的基础软基层(BSW)。</p>
<ul>
<li>ASW（Application Software）层包含若干个软件组件(SWC)，软件组件间通过端口(Port)进行交互。每个软件组件可以包含一个或者多个运行实体(RE)，运行实体中封装了相关控制算法，其可由RTE事件(RTE Event)触发。</li>
<li>RTE（Run-Time Environment）层作为应用软件层与基础软件层交互的桥梁，为软硬件分离提供了可能。RTE可以实现软件组件间、基础软件间以及软件组件与基础软件之间的通信。RTE封装了基础软基层的通信和服务，使得应用层可以通过RTE接口函数调用基础软件的服务。除此之外，RTE抽象了ECU之间的通信，即RTE通过使用标准化的接口将其统一为软件组件之间的通信。由于RTE的实现与具体的ECU相关，所以必须为每个ECU分别实现。</li>
<li>BSW（Basic Software）层负责提供基础软件功能支持。</li>
</ul>
<h2 id="MCAL层所在位置"><a href="#MCAL层所在位置" class="headerlink" title="MCAL层所在位置"></a>MCAL层所在位置</h2><ul>
<li>MCAL是MicroController Abstraction Layer（微控制器抽象层）的缩写。如下图所示，MCAL位于基本软件（Basic Software，BSW）的底层，是可以直接访问MCU寄存器和内部外设的底层驱动。这样划分的目的是使上层软件（如ECU抽象层、系统服务层等）独立于MCU硬件平台，保证上层软件的标准化和通用性。</li>
<li>ECU抽象层对MCAL所包含的驱动进行封装，同时它还包含片外设备(板上设备)的驱动。ECU抽象层提供访问各种设备的接口，不管这些设备的位置在哪里(是MCU内部还是MCU外部)，也不管它们是如何与MCU进行连接的(端口还是串行通信)。它的任务是让上层软件(服务层)独立于ECU硬件设备。</li>
<li>复杂驱动层跨越MCAL、ECU抽象层和服务层，是AUTOSAR标准之外的基础软件模块。一般是通过特定中断或复杂的MCU外设，用来实现传感器处理和执行器驱动，比如电机控制、电磁阀控制、位置检测等。复杂驱动高度依赖于MCU、ECU和应用软件。</li>
<li>服务层是BSW的最高层，为上层的应用软件提供各种服务（存储、通讯、诊断、ECU状态管理等服务）。</li>
</ul>
<h2 id="MCAL内部划分"><a href="#MCAL内部划分" class="headerlink" title="MCAL内部划分"></a>MCAL内部划分</h2><p>AUTOSAR规范根据MCU底层驱动功能的相似性，把MCAL抽象为6个驱动组，分别是微控制器驱动（Microcontroller Drivers）、存储器驱动（Memory Drivers）、加密驱动（Crypto Drivers）、无线通讯驱动（Wireless Communication Drivers）、通信驱动（Communication Drivers）、输入/输出驱动组（I/O Drivers）。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/31/231031-wdg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/31/231031-wdg/" class="post-title-link" itemprop="url">AUTOSAR Wdg Stack 架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-31 10:30:00" itemprop="dateCreated datePublished" datetime="2023-10-31T10:30:00+08:00">2023-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-09 00:21:23" itemprop="dateModified" datetime="2024-07-09T00:21:23+08:00">2024-07-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AUTOSAR/" itemprop="url" rel="index"><span itemprop="name">AUTOSAR</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Wdg-功能"><a href="#Wdg-功能" class="headerlink" title="Wdg 功能"></a>Wdg 功能</h2><p>看门狗/Wdg模块是一个独立的定时器，它的作用是提供安全功能以确保软件按计划执行，并且CPU不会陷入无限循环或执行意外的代码。如果Wdg模块在一定时间内未被触发/刷新/喂狗，它将复位MCU。</p>
<p>看门狗功能对于关键安全系统是必须的，对于非关键安全系统也是很有必要的。</p>
<p>对于汽车上使用的诸多零部件，鉴于汽车环境的恶劣，各类ECU中的软件均有可能遭受如外部电磁干扰，高温等环境因素的影响，从而导致程序“跑飞”或者“死机”现象，此时如果有看门狗的存在，便可以主动触发系统复位机制保证能够再次正常使用。</p>
<h2 id="硬件看门狗"><a href="#硬件看门狗" class="headerlink" title="硬件看门狗"></a>硬件看门狗</h2><p>硬件看门狗依赖自身定时器来完成看门狗功能，俗称“硬狗”。常见的硬件看门狗比如MCU内部自带的看门狗、外部的独立看门狗。至于选用何种的硬件看门狗，取决于自身系统设计需要。</p>
<p>在使用硬件看门狗的时候需要特别考虑以下：</p>
<ul>
<li>该硬件看门狗的最大超时时间能否满足系统设计需求，如果该超时时间过小，就会导致整个系统的不稳定性，误触发看门狗。</li>
<li>该硬件看门狗是否可以进行关闭，对于关键安全系统，一般都要求看门狗一旦打开将不允许被关闭。</li>
<li>该硬件看门狗系统上电后默认处于开狗还是关狗状态，如果是默认开狗，那么对于软件而言，需考虑芯片上电后便要进行喂狗或者重置看门狗行为，同时设计一种在刷软件或者调试软件前的物理关狗动作。</li>
<li>该硬件看门狗是采用哪种方式进行喂狗，如通过GPIO，IIC或SPI等通讯方式来喂狗。</li>
</ul>
<p>UJA1078A手册：</p>
<p><img src="/2023/10/31/231031-wdg/sbc-ds1-en.png" alt="img"></p>
<p><img src="/2023/10/31/231031-wdg/sbc-ds1-cn.png" alt="img"></p>
<h2 id="软件看门狗"><a href="#软件看门狗" class="headerlink" title="软件看门狗"></a>软件看门狗</h2><p>属于通过软件定时器的方式来实现看门狗功能，俗称“软狗”。软件看门狗的时基本质上也需要依赖硬件定时器。</p>
<p>比如常见的用systick作时基，通过一个task运行软狗监控的定时器不断递减，其他task程序则是重置软狗定时器，如果软狗监控的某个定时器归零，那么此时可以便可以判断其他task并没有被正常的执行，此时便可以通过主动复位的方式来实现看门狗功能。</p>
<p>以上可实现软狗对<strong>多个task</strong>的监控，这是硬狗没有的功能。软狗除了实现硬狗timeout和window的两种模式，还可以实现其他模式，取决于软件，监控的花样更多。</p>
<p>一般而言，运行软狗的主任务的优先级不应设置比被监控的任务优先级低，所以软狗无法检测Hardfault中卡死的问题。<strong>软狗跟硬狗搭配在一起使用</strong>，可以解决硬狗监控模式单一、软狗执行优先级没被监控任务高的问题。</p>
<h2 id="AUTOSAR-Wdg-架构"><a href="#AUTOSAR-Wdg-架构" class="headerlink" title="AUTOSAR Wdg 架构"></a>AUTOSAR Wdg 架构</h2><h3 id="内部分层"><a href="#内部分层" class="headerlink" title="内部分层"></a>内部分层</h3><p><img src="/2023/10/31/231031-wdg/wdg-stack.png" alt="img"></p>
<p>Watchdog Driver：用于实现针对硬件看门狗的寄存器操作与控制，可以分为MCU内部看门狗(Internal Watchdog)与外部看门狗(External Watchdog)，该外部看门狗可以通过GPIO、IIC或SPI来实现喂狗。</p>
<p>Watchdog Interface：其主要功能则是为了实现上层Watchdog Manager与底层Watchdog Driver的连接，当然其连接的底层Watchdog Driver可以存在多个。</p>
<p>Watchdog Manager：作为整个看门狗协议栈中的服务层，主体功能就是为了负责整个程序执行的正确性，并触发相应的硬件看门狗的喂狗动作，扮演了整个监控的核心角色。</p>
<h3 id="WdgM-依赖"><a href="#WdgM-依赖" class="headerlink" title="WdgM 依赖"></a>WdgM 依赖</h3><p><img src="/2023/10/31/231031-wdg/wdgM-dep-en.png" alt="img"></p>
<p><img src="/2023/10/31/231031-wdg/wdgM-dep-cn.png" alt="img"></p>
<h2 id="AUTOSAR-Wdg-基础知识"><a href="#AUTOSAR-Wdg-基础知识" class="headerlink" title="AUTOSAR Wdg 基础知识"></a>AUTOSAR Wdg 基础知识</h2><h3 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h3><p>在AUTOSAR架构中，针对Watchdog Driver而言，定义了看门狗控制模式存在如下三种模式：</p>
<ul>
<li>Off Mode：表示看门狗关闭状态，对于关键安全系统，一般不能将其切换至Off状态，即一旦打开，将不能被关闭。</li>
<li>Slow Mode：表示看门狗的一个长时间喂狗窗口，该模式一般用于系统启动初始化过程中。</li>
<li>Fast Mode：表示看门狗的正常喂狗模式，该模式运用在系统正常运行的过程中。</li>
</ul>
<h2 id="AUTOSAR-Wdg-各层功能"><a href="#AUTOSAR-Wdg-各层功能" class="headerlink" title="AUTOSAR Wdg 各层功能"></a>AUTOSAR Wdg 各层功能</h2><h3 id="Wdg"><a href="#Wdg" class="headerlink" title="Wdg"></a>Wdg</h3><p>Wdg通常有两种，一种是芯片内部自带的片内看门狗；还有一种是在芯片外部通过SPI这种接口连接的片外看门狗。MCAL只负责第一种片内看门狗，片内看门狗的特点是Wdg模块是直接访问相关硬件寄存器。片外看门狗属于板级设备抽象层负责，通常需要使用MCAL提供的其他模块（比如SPI等）来访问/控制外扩看门狗芯片，这种不能直接访问硬件寄存器。</p>
<p>部分flash不能在写的时候读取，所以该模块代码可以在RAM里面运行。比如在刷写Flash时，Wdg模块可能作为二进制文件里面的一部分在RAM上运行。（到底哪些部分需要放RAM？）</p>
<h4 id="Wdg-API"><a href="#Wdg-API" class="headerlink" title="Wdg API"></a>Wdg API</h4><p>Wdg 驱动层，主要接口就三个，调用方式如下图：</p>
<p><img src="/2023/10/31/231031-wdg/wdg-1.png" alt="img"></p>
<ul>
<li>wdg初始化：通过EcuM模块调用函数Wdg_Init来完成Watchdog的初始化配置。</li>
<li>触发wdg喂狗：通过WdgM模块调用WdgIf模块提供的函数WdgIf_SetTriggerCondition来触发底层驱动进行喂狗（不是wdg真正的喂狗操作），并设置下次看门狗timeout时间。</li>
<li>改变wdg模式：通过WdgM模块调用WdgIf模块提供的函数WdgIf_SetMode来实现看门狗模式的改变。</li>
</ul>
<h4 id="喂狗"><a href="#喂狗" class="headerlink" title="喂狗"></a>喂狗</h4><p>在AUTOSAR之前的版本中，看门狗服务是<strong>由上层软件来调用</strong>，会导致一些问题：</p>
<ol>
<li>很难保证针对窗口式看门狗严格的时间约束。新版对这部分做了优化，优化的基本思想是将<strong>用于维护看门狗硬件时序的服务与逻辑控制分开</strong>，触发看门狗的时基可以通过系统时钟（systick）来提供，而控制看门狗硬件的程序可直接在硬件定时器的中断函数里面实现，这样可确保满足窗口式看门狗的喂狗时间准确。</li>
<li>很难处理了快和慢两种模式。Wdg模块3种模式其中两种是Slow，Fast模式。很多时候应用层可能并不需要那么严格的时间监控，可能秒级的周期即可。但由于喂狗周期都是固定的且比较短，应用层不断去喂狗会导致性能下降，而且需要到处穿插喂狗函数。</li>
<li>应用软件频繁修改硬狗寄存器不安全。现在AUTOSAR实现方式，应用层调用喂狗函数（Wdg_SetTriggerCondition）并不是直接去操作硬件看门狗寄存器的，而是去喂软狗。<strong>真正喂硬狗靠硬件定时器</strong>，在定时器中断回调中判断软狗没问题才去操作硬狗寄存器。</li>
</ol>
<p>看门狗驱动程序和硬狗操作之间的调用方式如下图：</p>
<p><img src="/2023/10/31/231031-wdg/wdg-2.png" alt="img"></p>
<h3 id="WdgIf"><a href="#WdgIf" class="headerlink" title="WdgIf"></a>WdgIf</h3><p>和NvM下的MemIf功能相同，可以通过DeviceIndex区分要调用哪个Wdg Driver，可以用宏或函数实现，接口如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Std_ReturnType <span class="title function_">WdgIf_SetMode</span><span class="params">(uint8 DeviceIndex, WdgIf_ModeType WdgMode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">WdgIf_SetTriggerCondition</span><span class="params">(uint8 DeviceIndex, uint16 Timeout)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="WdgM"><a href="#WdgM" class="headerlink" title="WdgM"></a>WdgM</h3><p>Watchdog Manager可以理解为一种应用层软狗机制，该软件机制监控的对象被称为<strong>监控实体</strong>（SupervisedEntity, SE），通过在每个监控实体中打上对应的<strong>检查点</strong>（Checkpoint, CP）监控程序是否正常。</p>
<p>WdgM中可以创建一个或多个SE，每个SE都有对应的SEID。<br>每个SE可以创建一个或多个CP，每个CP都有对应的CheckpointID。<br>每个SE可以选择一个<strong>监控方式</strong>，这个取决于具体的需求，监控方式可以分为如下三种：</p>
<ol>
<li>Alive Supervision: 用于监控周期性任务是否周期性运行。</li>
<li>Deadline Supervision：用于监控事件型任务的运行时间是否超时。</li>
<li>Logical Supervision: 用于监控任务的执行逻辑/时序是否正确。</li>
</ol>
<p>每一个监控实体可以基于上述三种监控方式计算得出监控结果，被称为<strong>Local Status</strong>。<br>当每一个监控实体的状态得到确定，那么整个MCU的监控结果便可以最终确定，这个最终确定的状态被称为<strong>Global Status</strong>。</p>
<h4 id="WdgM-API"><a href="#WdgM-API" class="headerlink" title="WdgM API"></a>WdgM API</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">WdgM_Init</span><span class="params">(<span class="type">const</span> WdgM_ConfigType *ConfigPtr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WdgM_DeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (WDGM_VERSION_INFO_API == STD_ON)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WdgM_GetVersionInfo(_vi) STD_GET_VERSION_INFO(_vi,WDGM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_SetMode</span><span class="params">(WdgM_ModeType Mode)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_GetMode</span><span class="params">(WdgM_ModeType *Mode)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_CheckpointReached</span><span class="params">(WdgM_SupervisedEntityIdType SEID, WdgM_CheckpointIdType CheckpointID)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_GetLocalStatus</span><span class="params">(WdgM_SupervisedEntityIdType SEID, WdgM_LocalStatusType *Status)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_GetGlobalStatus</span><span class="params">(WdgM_GlobalStatusType *Status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WdgM_PerformReset</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_GetFirstExpiredSEID</span><span class="params">(WdgM_SupervisedEntityIdType *SEID)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WdgM_MainFunction</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h4><p>Figure 2: Local Supervision Status:</p>
<p><img src="/2023/10/31/231031-wdg/wdgM-1.png" alt="img"></p>
<p>在从其他状态切换至WDGM_LOCAL_STATUS_EXPIRED状态时，Watchdog Manager提供一定的时间保留机制能够允许做一些特别的操作，如设置看门狗模式或者写入NvM数据，复位原因等。</p>
<p>Figure 3: Global Supervision Status:</p>
<p><img src="/2023/10/31/231031-wdg/wdgM-2.png" alt="img"></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/20/231020-MemoryStack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/20/231020-MemoryStack/" class="post-title-link" itemprop="url">Memory Stack 开发总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-20 16:00:00" itemprop="dateCreated datePublished" datetime="2023-10-20T16:00:00+08:00">2023-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-09 00:21:23" itemprop="dateModified" datetime="2024-07-09T00:21:23+08:00">2024-07-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/AUTOSAR/" itemprop="url" rel="index"><span itemprop="name">AUTOSAR</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Memory-Stack-开发总结"><a href="#Memory-Stack-开发总结" class="headerlink" title="Memory Stack 开发总结"></a>Memory Stack 开发总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>截止目前，已经完成了 FlashDriver、Fls、Fee、MemIf、NvM 的开发。开发的 Memory Stack 只是借鉴了 AUTOSAR Memory Stack 架构，并非完全相同，为了兼容旧版软件，也有部分不符合 AUTOSAR 规范的地方。为了解决一些特殊需求，也有一些创新之处。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li>AUTOSAR 官方资料</li>
<li><a target="_blank" rel="noopener" href="https://www.embeddedtutor.com/search/label/Autosar">https://www.embeddedtutor.com/search/label/Autosar</a></li>
</ol>
<h3 id="设计方式"><a href="#设计方式" class="headerlink" title="设计方式"></a>设计方式</h3><h4 id="FlashDriver"><a href="#FlashDriver" class="headerlink" title="FlashDriver"></a>FlashDriver</h4><p>Flash驱动层，这一层AUTOSAR中是没有的，我的理解是，AUTOSAR的Fls是Fee代码组件是由芯片厂家提供，那么mcu厂家提供的代码不会兼容其他厂家的外部Flash。代码我只看了云途配置工具生成的Fls代码和NXP官网上的一些芯片的BSW库，并没有见到过有外部Flash厂家提供的Fls代码。为了解决这个问题，我对Fls做了抽象，将不同Flash相关的代码和Fls分开，故有FlashDriver层。不同Flash有共性同时也有特性，为保留特性，借鉴了Linux中对各种外设共有属性和私有属性的思想，这个我是在看《嵌入式C语言自我修养——从芯片、编译器到操作系统》里学的。</p>
<p>Flash驱动层对上层Fls通过一个成员全是函数指针的结构体提供接口，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*Flash_Init)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr);</span><br><span class="line">	MemIf_JobResultType (*Flash_Erase)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType TargetAddress);</span><br><span class="line">	MemIf_JobResultType (*Flash_Write)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType TargetAddress, <span class="type">const</span> uint8 *SourceAddressPtr, Fls_LengthType Length);</span><br><span class="line">	MemIf_JobResultType (*Flash_Read)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType SourceAddress, uint8 *TargetAddressPtr, Fls_LengthType Length);</span><br><span class="line">	MemIf_JobResultType (*Flash_Compare)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType SourceAddress, <span class="type">const</span> uint8 *TargetAddressPtr, Fls_LengthType Length);</span><br><span class="line">	MemIf_JobResultType (*Flash_GetStatus)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr);</span><br><span class="line">&#125; Fls_DriverFunType;</span><br></pre></td></tr></table></figure>
<p>此结构体在每个FlashDriver中有定义，并且是对外的全局变量。用户在配置Fls时，可以配置此结构体指针，这样Fls就可以使用不同的Flash驱动了。</p>
<h5 id="保留特性"><a href="#保留特性" class="headerlink" title="保留特性"></a>保留特性</h5><p>每种Flash驱动对应一份FlashDriver代码，目前已完成两种FlashDriver开发，一个是mcu内部Flash，另一个是spi通信的外部Flash。每个Flash共有的属性有起始地址、扇区大小（最小擦除量）、扇区个数、页大小（最大写入量），特性有不同的通信方式。如外部Flash SPI通信，需要配置其SPI ID，这是在有MCAL（mcu硬件抽象层）的基础上，如果没有MCAL FlashDriver这一层需要把SPI配置都用用户配置的方式实现，方便封库。</p>
<p>为保留特性，FlashDriver每个接口都由上层传递了<code>FlsPrivateConfigPtr</code>，接口定义里这是个void指针，在每个FlashDriver的接口实现里将其转成了自己特性配置的结构体指针类型。特性配置结构体类型声明在每个FlashDriver的头文件中，由用户在Fls用户代码中定义配置，再配置进Fls层，上层Fls只是做了传递这个配置给FlashDriver，Fls无法解析这个配置。</p>
<p>像mcu内部Flash好像并不需要什么特性配置，读写方式都是定死的。不需要<code>FlsPrivateConfigPtr</code>可以在配置Fls时将这个指针配成NULL。</p>
<h5 id="阻塞在哪"><a href="#阻塞在哪" class="headerlink" title="阻塞在哪"></a>阻塞在哪</h5><p>阻塞在哪里也是个问题，在开发Fls时才想到，一开始我都是阻塞在FlashDriver，因为实现方便，写入和擦除操作可以直接查Flash状态阻塞到完成。后来Fls想做同时支持同步也支持异步的方式，还有需求是Fls超时结束任务，这就需要有Fls去控制是否还要继续阻塞。故FlashDriver中就不阻塞，新增一个读状态接口<code>Flash_GetStatus</code>，阻塞在Fls层。</p>
<p>但阻塞在FlashDriver这个配置也保留了，可以通过宏选择是否阻塞在驱动。为什么留？写入、擦除出现问题时，改这个成阻塞也不管超时，可以判断下是不是异步导致的问题，调试也能更好的定位问题（阻塞在有问题的地方，可以分析函数调用栈）。 目前Flash底层驱动可以提供阻塞或非阻塞的接口让Fls调用，甚至可以通过私有配置实现部分地址使用阻塞，部分地址使用非阻塞的方式。</p>
<h5 id="其余问题"><a href="#其余问题" class="headerlink" title="其余问题"></a>其余问题</h5><p>其余问题是云途这个Flash驱动的问题，如果不严格按例程操作寄存器写，只按手册命令方式写的话坑比较多，可能开发的时候能用，测试也没问题，但集成到整个项目工程里时有玄学问题。</p>
<h4 id="Fls"><a href="#Fls" class="headerlink" title="Fls"></a>Fls</h4><p>按AUTOSAR手册，Fls主要是Flash驱动的功能，对上层提供各种异步读写擦的功能，支持查询任务状态、运行结果。Fls可以将不同地址统一成一个从零开始的线性地址，这个有什么用？假如我想使用两个不连续的Flash扇区，Fls做个地址映射到这两个扇区，对上层来说地址是连续的，上层无需管Flash物理地址，操作的都是逻辑地址，方便上层的使用。</p>
<p>Fls把FlashDriver抽象出来，增加一种flash需编写一份Flash底层驱动，无需修改Fls代码，可在Flash底层驱动里实现不同Flash的私有配置。Fls会传递正确的物理地址和长度等参数给FlashDriver，因此FlashDriver可不用重复检查参数。Fls可以配置多个实例，支持多个实例用同一份FlashDriver，也支持同时有多种不同的Fls实例，他们共用一份Fls代码（增加复用性）。</p>
<h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><p>为什么使用异步？同步阻塞时间过大，影响其他任务运行，异步可以将一个大任务打散成多个小任务多次执行。Fls要实现异步方式调用，任务会在Fls_main里执行，用户可配每次Fls_main执行任务最大的读写量，防止一次main阻塞时间过长。</p>
<p>异步除了在实现的时候会比同步复杂些，用户在调用的时候也会比同步复杂，有os支持下还好，当任务异步调用Fls后可以挂起，定时查询状态或回调的方式，当Fls任务结束后继续执行原任务，假如没有os支持的话，没有挂起接口，用户每次异步调完Fls后需要记录下当前运行的位置，周期调度下次继续执行。异步能让io(flash)操作阻塞时mcu去干别的事，更好的利用处理器性能，但也增加了查询、任务切换等开销。Fls异步写入时，将写入任务拆成一个个异步的页写入任务，执行后内部挂起，等下次执行查状态。像云途的Flash页大小就8字节，岂不是写256字节要分成30多次子任务，这进出函数的开销和利用阻塞的时间，异步到底有没有优化性能呢？</p>
<p>擦除任务异步挺有意义的每次阻塞的时间长，也不用把任务打的很散增大函数出入的开销。GD的外部Flash页有256字节，每次写入阻塞时间较长，这种也适用异步写，车规芯片的SPI速度较低最大4M，需要SPI中断或DMA的支持。</p>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>为何保留同步？通过一个参数来决定是同步执行还是异步执行，同步的好处使用户方便使用。</p>
<p>同步如何实现？其实异步实现了，同步自然就实现了。同步就是一直调用Fls内部的main直到任务执行完毕。</p>
<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>Fls需要配置哪些参数？凡是在Fls配置的都是Flash的共有属性，配置较多：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Fls_JobType FlsJobDoing;              <span class="comment">// 正在执行的任务</span></span><br><span class="line">	MemIf_StatusType FlsJobStatus;        <span class="comment">// 任务状态</span></span><br><span class="line">	MemIf_JobResultType FlsJobResult;     <span class="comment">// 任务返回值</span></span><br><span class="line">	Fls_AddressType FlsJobAddr;           <span class="comment">// 任务目前执行到的地址</span></span><br><span class="line">	Fls_LengthType FlsJobLength;          <span class="comment">// 任务目前执行剩余长度</span></span><br><span class="line">	<span class="type">const</span> uint8 *FlsJobDataSrcPtr;        <span class="comment">// 用于传递Write、Compare地址指针参数</span></span><br><span class="line">	uint8 *FlsJobDataDestPtr;             <span class="comment">// 用于传递Read地址指针参数</span></span><br><span class="line">	MemIf_ModeType FlsJobMode;            <span class="comment">// 快速模式或者慢速模式对应的每周期操作的字节数不同</span></span><br><span class="line">	Fls_LengthType FlsPendingEraseLen;    <span class="comment">// 挂起的擦除字节长度（异步擦除用）</span></span><br><span class="line">	Fls_LengthType FlsTotalSize;          <span class="comment">// 此Fls实例的空间总大小</span></span><br><span class="line">&#125; Fls_JobInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	uint16 FlsNumberOfSectors;                <span class="comment">// 扇区个数</span></span><br><span class="line">	uint16 FlsWriteAlignSize;                 <span class="comment">// 写入对齐大小</span></span><br><span class="line">	uint16 FlsReadAlignSize;                  <span class="comment">// 读取对齐大小</span></span><br><span class="line">	Fls_LengthType FlsSectorSize;             <span class="comment">// 单个扇区字节数</span></span><br><span class="line">	Fls_LengthType FlsPageSize;               <span class="comment">// 单个页字节数</span></span><br><span class="line">	Fls_AddressType FlsSectorStartaddress;    <span class="comment">// 第一个扇区起始地址</span></span><br><span class="line">&#125; Fls_SectorType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> Fls_DriverFunType *FlsDriverFunPtr;    <span class="comment">// 驱动函数指针结构体地址</span></span><br><span class="line">	<span class="type">const</span> Fls_SectorType *FlsSectorListPtr;      <span class="comment">// 扇区列表地址</span></span><br><span class="line">	uint8 FlsSectorListNum;                      <span class="comment">// Flash（扇区列表）个数</span></span><br><span class="line">	<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr;             <span class="comment">// 不同种类Flash私有属性配置地址</span></span><br><span class="line">	uint32 FlsMaxBlockingTime;                   <span class="comment">// Fls最大阻塞时间（ms），0表示不开启阻塞超时监测</span></span><br><span class="line">	uint8 FlsEnableNonBlockingErase;             <span class="comment">// 开启Fls非阻塞擦除的功能</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		Fls_LengthType FlsMaxReadFastMode;       <span class="comment">// 在快速模式下，一个周期内Read、Compare的最大字节数</span></span><br><span class="line">		Fls_LengthType FlsMaxReadNormalMode;     <span class="comment">// 在正常模式下，一个周期内Read、Compare的最大字节数</span></span><br><span class="line">		Fls_LengthType FlsMaxWriteFastMode;      <span class="comment">// 在快速模式下，一个周期内Write的最大字节数</span></span><br><span class="line">		Fls_LengthType FlsMaxWriteNormalMode;    <span class="comment">// 在正常模式下，一个周期内Write的最大字节数</span></span><br><span class="line">		MemIf_ModeType FlsDefaultJobMode;        <span class="comment">// 初始化后的JobMode</span></span><br><span class="line">	&#125; FlsModeConfig;                             <span class="comment">// 配置不同模式参数</span></span><br><span class="line">&#125; Fls_InstanceConfigType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*FlsBlockingCallbackPtr)(<span class="type">void</span>);                      <span class="comment">// 阻塞回调函数</span></span><br><span class="line">	Fls_JobInfoType *FlsJobInfoListPtr;                        <span class="comment">// 任务管理空间地址</span></span><br><span class="line">	<span class="type">const</span> Fls_InstanceConfigType *FlsInstanceConfigListPtr;    <span class="comment">// Fls实例配置指针</span></span><br><span class="line">	uint8 FlsInstanceNum;                                      <span class="comment">// 总实例数量</span></span><br><span class="line">&#125; Fls_ConfigType;</span><br></pre></td></tr></table></figure>

<p>由于要封模块，并且要做成可重入，所以需要由用户在配置代码中定义每个实例的管理ram，并配置到config常量中。</p>
<h5 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h5><p>从零开始的线性地址如何实现？看了上面的<code>Fls_SectorType</code>配置可以想到，Flash的地址映射关系就是映射到的“扇区列表配置”中。当时有个问题，假如有多个Flash，是不是映射成一个从零开始的地址？这样的话上层调用无需体现实例号的，因为根据地址映射关系就能找到要操作的Flash。后来想想还是不行，需要每个Flash的地址都分开从零开始，因为不同Flash的扇区大小等不同，上层不好只通过地址分辨是哪个Flash然后操作。</p>
<p><img src="/2023/10/20/231020-MemoryStack/231020-MemoryStack-3.png" alt="img"></p>
<h5 id="多实例同时运行"><a href="#多实例同时运行" class="headerlink" title="多实例同时运行"></a>多实例同时运行</h5><p>这个特性也是需要支持的，不能让一个Flash阻塞的时候另一个Flash无法使用。如何实现这个特性呢？为每个Fls实例开一个<code>Fls_JobInfoType</code>管理实例的运行状态，每次Fls_main都把不同实例都执行一遍。这里有个可改善点，每次Fls_main只执行一个实例，让Fls_main的周期短一些，可以把多个Fls实例执行的阻塞时间打散一些，整个系统的最大阻塞时间会缩短。</p>
<h5 id="对外接口"><a href="#对外接口" class="headerlink" title="对外接口"></a>对外接口</h5><p>对外接口大致遵循AUTOSAR规范，增加了实例号和是否同步的参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Fls_Init</span><span class="params">(<span class="type">const</span> Fls_ConfigType *ConfigPtr, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Erase</span><span class="params">(Fls_AddressType TargetAddress, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Write</span><span class="params">(Fls_AddressType TargetAddress, <span class="type">const</span> uint8 *SourceAddressPtr, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Read</span><span class="params">(Fls_AddressType SourceAddress, uint8 *TargetAddressPtr, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Compare</span><span class="params">(Fls_AddressType SourceAddress, <span class="type">const</span> uint8 *TargetAddressPtr, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_BlankCheck</span><span class="params">(Fls_AddressType TargetAddress, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line"></span><br><span class="line">MemIf_StatusType <span class="title function_">Fls_GetStatus</span><span class="params">(uint8 FlsInstanceId)</span>;</span><br><span class="line">MemIf_JobResultType <span class="title function_">Fls_GetJobResult</span><span class="params">(uint8 FlsInstanceId)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fls_SetMode</span><span class="params">(MemIf_ModeType Mode, uint8 FlsInstanceId)</span>;</span><br><span class="line">uint64 <span class="title function_">Fls_GetErrorCode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fls_MainFunction</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="Fee"><a href="#Fee" class="headerlink" title="Fee"></a>Fee</h4><p>AUTOSAR NvM中的Fee(Flash EEPROM Emulation)主要做Flash模拟EEPROM的功能。使用EEPROM，软件可以在任意字节读写，也无需管擦除的事情。使用Flash需要考虑每次写入是否对齐、擦除一整个扇区的时候会不会有其他的数据被擦除，总不能每次写就擦除一整个扇区，一个扇区里就放一点点要存的内容吧。不管是Flash还是EEP通常都有磨损均衡的算法，提高Flash的寿命与利用率。Fee就是干这个事情的，并且要留出和Ea(EEPROM Abstraction Layer)一样的接口供上层MemIf(Memory Abstraction Interface)调用，在NvM操作MemIf，无需关心是Fee还是Ea。这也体现了AUTOSAR Memory Stack的高扇入低扇出思想，对外统一接口，内部可以操作不同的非易失存储器。</p>
<p>Fee是我在实现AUTOSAR Memory Stack中，最复杂的一个模块，先介绍一个基础概念：在内存协议栈中，每个要读写的数据为一个Block数据块，NvM会调用MemIf读写Block，MemIf会调用相应的子设备如Fee。</p>
<h5 id="均衡算法与Cluster概念"><a href="#均衡算法与Cluster概念" class="headerlink" title="均衡算法与Cluster概念"></a>均衡算法与Cluster概念</h5><p>均衡算法参考了AUTOSAR的多Cluster与多Cluster Group，也加入了自己的均衡磨损管理算法，最终可以实现安全可靠的Block存储。</p>
<p>在Fee中，一个Flash被划分成1个或多个Cluster Group，每个Cluster Group中可以管理不同的Block；一个Cluster Group中有2个或多个Cluster，用来均衡磨损，每次写入Block都会在所属的Cluster Group中的一个活跃的Cluster上写入，当所有Cluster被写满时，最老的一个Cluster会被擦除，然后此Cluster待写入。</p>
<p>每个Cluster Group都可以由用户配置，并且都有自己运行时的一份变量空间，一下是Cluster Group的配置与变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Fls_AddressType ClusterFreeSpaceAddr;    <span class="comment">// 指向当前Cluster的空闲空间地址，又表示当前cluster已使用的空间大小</span></span><br><span class="line">	uint16 ActiveClusterId;                  <span class="comment">// 当前ACTIVE的Cluster Id</span></span><br><span class="line">	uint16 ScanStartClusterId;               <span class="comment">// scanBlock从哪块Cluster开始，0xffff为不执行scanBlock</span></span><br><span class="line">	uint32 CycleTimes;                       <span class="comment">// Cluster擦除的周期计数</span></span><br><span class="line">	boolean NeedSwap;                        <span class="comment">// 此clusterGroup是否需要swap</span></span><br><span class="line">&#125; Fee_ClusterGroupInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	uint32 CycleTimes;               <span class="comment">// Cluster擦写次数</span></span><br><span class="line">	Fee_ClusterStatusType Status;    <span class="comment">// Cluster状态</span></span><br><span class="line">	uint8 ClrInfoVerify;             <span class="comment">// ClrId ClrGroup ClusterSize信息 1:正确 0:不正确</span></span><br><span class="line">&#125; Fee_ClusterInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Fls_AddressType ClrStartAddr;          <span class="comment">// Cluster Group起始的Fls地址</span></span><br><span class="line">	Fls_LengthType ClrSize;                <span class="comment">// 每个Cluster的字节数</span></span><br><span class="line">	uint8 ClrGroup;                        <span class="comment">// Cluster Group ID</span></span><br><span class="line">	uint16 NumberOfClr;                    <span class="comment">// Cluster Group中的Cluster数量</span></span><br><span class="line">	Fee_ClusterInfoType *FeeClrInfoPtr;    <span class="comment">// 簇信息管理空间地址（用户需要提供数组大小要与NumberOfClr一致）</span></span><br><span class="line">&#125; Fee_ClusterGroupConfigType;</span><br></pre></td></tr></table></figure>

<p>每个Cluster有它的管理数据结构，Cluster Header中包含了所属哪个Cluster Group、Cluster Id、Cluster Size、擦除次数、状态等信息。初始化会检查这些Cluster头，避免Flash中的Cluster配置与代码不一致造成的数据问题，还可以通过擦除次数看Flash的使用次数，评估其寿命，异常时做云平台上报。</p>
<h5 id="查找最新的Block"><a href="#查找最新的Block" class="headerlink" title="查找最新的Block"></a>查找最新的Block</h5><p>每次上电初始化要做的事就是从Flash中读取Block，那存在Cluster中的哪个Block是最新的呢？首先要知道一个Cluster Group中哪个Cluster是最新的。Cluster Header中会有Cluster的状态，一般情况下最新的Cluster有个活跃的状态，便可知最老的那个Cluster，从最老的Cluster上遍历查找每个Block，记录每个Block最新地址，这么一轮遍历结束就可以知道各个Block最新的数据存在哪个位置啦。</p>
<p>内部接口：<code>static Std_ReturnType Fee_ScanBlock(uint8 FeeInstanceId, uint8 ClusterGroup, uint16 ScanStartClusterId)</code></p>
<p>索引是从指定Cluster搜索有效的block，取最新的block信息保存至FeeBlockInfo。考虑Cluster中会有损坏的Block和之前写Block中断电的情况，Scan需要能跳过坏Block，按以下流程scan每个有效的Cluster：</p>
<ol>
<li>每个Cluster开始索引的地址为ClusterHeader后开始存放Block的地址。</li>
<li>开始检查对应地址的Block状态。</li>
<li><ol>
<li>为空，跳出此Cluster的索引。</li>
</ol>
</li>
<li><ol start="2">
<li>DataValid有效，Block正常，将Block地址存储在BlockInfo（hash表）中，根据此Block长度跳地址，继续索引（步骤2）。</li>
</ol>
</li>
<li><ol start="3">
<li>NumLenValid（BlockInfo）有效，Block数据段无效，数据段无法保证全为空, 跳过BlockHeader+BlockLen长度继续索引。</li>
</ol>
</li>
<li><ol start="4">
<li>NumLen和Data都无效，BlockHeader不为空正常情况下数据区还没被写，跳过一个BlockHeader长度继续索引。</li>
</ol>
</li>
</ol>
<p>每个Block在Fee中都有其对应的配置与RAM空间，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	Fls_AddressType BlockAddr;     <span class="comment">// Block头所在的Fls地址</span></span><br><span class="line">	uint16 ClusterId;              <span class="comment">// Block所在的Cluster Id</span></span><br><span class="line">	uint16 BlockNumber;            <span class="comment">// Block Number</span></span><br><span class="line">	uint16 BlockLen;               <span class="comment">// Block Len</span></span><br><span class="line">	Fee_BlockStatusType Status;    <span class="comment">// Block头的状态</span></span><br><span class="line">&#125; Fee_BlockInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	uint16 BlockNumber;    <span class="comment">// 配置Block Number</span></span><br><span class="line">	uint16 BlockLen;       <span class="comment">// 配置Block Len</span></span><br><span class="line">	uint8 ClusterGroup;    <span class="comment">// 配置Block属于那个BlockGroup</span></span><br><span class="line">&#125; Fee_BlockConfigType;</span><br></pre></td></tr></table></figure>

<p>每个Block也像Cluster一样有Header，在Block Header中记录BlockId、BlockSize、各种标志位信息。可以通过这些标志位，判断当时存的时候有没有异常下电，Block数据是否完整可信，在Fee中不是通过CRC的方式判断数据是否可信，因为在初始化遍历读取Block的时候，给每个Block做CRC如果Flash很大那需要很长一段时间。</p>
<h5 id="交换Cluster"><a href="#交换Cluster" class="headerlink" title="交换Cluster"></a>交换Cluster</h5><p>内部接口：<code>static Std_ReturnType Fee_SwapCluster(uint8 FeeInstanceId, uint8 ClusterGroup, uint16 FromClusterId, uint16 ToClusterId)</code></p>
<p>将旧Cluster上的有效Block搬到新Cluster。</p>
<ol>
<li>遍历所有的BlockInfo，如果Block的ClusterGroup匹配，且有效数据在老的Cluster上，就将整个Block读取到函数栈空间，然后写入新Cluster的地址，在SWAPPING的时候无需考虑写BlockHeader标志位的顺序，因为SWAPPING时掉电，下次初始化时会擦除此Cluster重新SWAP。</li>
</ol>
<p>详细描述：当Cluster总数-1的Cluster被写完的情况下就需要触发Cluster交换任务了，目的是将最老Cluster上有效的Block（没有更新的数据）转移到那块空白的Cluster上，我称这个操作叫换页。换页时会给Cluster写上换页的标志位，换页过程中异常下电下次能识别到触发重新换页任务。上面说过每个Block都有ram空间，管理这其最新Block的地址（在哪个Cluster上和偏移地址），因此很容易知道最老的Cluster有哪些有效Block和其地址，可以简单的使用memcpy将其复制到最新的Cluster上，因为Block Header不用发生更改，并且写入Block时无需防止异常下电。换页结束后需改变Cluster的状态，将原先最新的那个从活跃设置为满状态，将新的那个Cluster从空设为活跃状态。</p>
<h5 id="维护任务"><a href="#维护任务" class="headerlink" title="维护任务"></a>维护任务</h5><p>内部接口：<code>static Std_ReturnType Fee_MaintainJob(uint8 FeeInstanceId)</code></p>
<p>维护任务，需要检查是否需要执行交换和擦除任务。考虑减少运行时阻塞，正常情况维护中擦除Cluster采用异步非阻塞的方式。正常情况维护操作流程如下：（非正常情况处理较复杂不写）</p>
<ol>
<li>当前操作的Cluster状态为ACTIVE，检查下个Cluster状态是否为VERIFIED，若不是，异步擦除下个Cluster。</li>
<li>当前操作的Cluster状态为ACTIVE，下个Cluster状态为VERIFIED，检查当前Cluster空闲空间是否充足，若不足，将当前Cluster写FULL标志位，2个Cluster和2个以上Cluster写入标志位顺序有差异。</li>
<li>当前操作的Cluster状态为FULL，执行SWAP任务，将最老的Cluster上有效的Block搬到新的Cluster上，SWAP成功后将当前操作的Cluster改为新的Cluster，新Cluster状态设为ACTIVE。</li>
</ol>
<p><strong>Cluster 状态转移图如下</strong>：</p>
<p><img src="/2023/10/20/231020-MemoryStack/231020-MemoryStack-2.png" alt="img"></p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>对外接口：<code>void Fee_Init(const Fee_ConfigType* ConfigPtr, boolean IsSync)</code><br>内部初始化Job接口：<code>static Std_ReturnType Fee_InitJob(uint8 FeeInstanceId)</code></p>
<p>初始化Job中需要处理各种不同的Cluster状态，查找ACTIVE状态的Cluster和最老的Cluster，从最老的Cluster开始索引Block。</p>
<p>考虑在换页时断电和Cluster损坏的可能性，初始化处理Cluster状态有如下几种情况：（每种情况处理方式不描述了）</p>
<ol>
<li>只有1个ACTIVE状态的cluster。</li>
<li>没有ACTIVE状态的cluster，只有1个SWAPPING状态的cluster。</li>
<li>总共只有2个Cluster，没有cluster状态为ACTIVE和SWAPPING，只有1个cluster状态为FULL。</li>
<li>没有ACTIVE和SWAPPING状态的Cluster，只有FULL状态的Cluster。</li>
<li>其他。<br>原则上，大于2个Cluster只要有1个ACTIVE或1个SWAPPING状态的Cluster都能被成功初始化，如果存储在Flash中的数据受干扰异常导致无法识别ACTIVE和SWAPPING状态的Cluster，会导致初始化失败，会重新初始化Cluster，历史数据丢失。</li>
</ol>
<h5 id="写入Block"><a href="#写入Block" class="headerlink" title="写入Block"></a>写入Block</h5><p>对外接口：<code>Std_ReturnType Fee_Write(uint8 FeeInstanceId, uint16 BlockNumber, const uint8 *DataBufferPtr, boolean IsSync)</code><br>内部接口：<code>MemIf_JobResultType Fee_WriteJob(uint16 BlockIndex, const uint8* DataBufferPtr, uint8 FeeInstanceId)</code></p>
<p>上层调用Fee写入Block数据，支持异步。</p>
<p>在Fee_WriteJob()需考虑写入时Flash空间不为空的情况，若不为空应该找到空白区域，使下次可正常写入，具体写入流程如下：</p>
<ol>
<li>每次写入前都会检查要写入BlockHeader的地址空间是否为空白，如果不空白，解析BlockHeader。</li>
<li><ol>
<li>为空，跳出检查。</li>
</ol>
</li>
<li><ol start="2">
<li>DataValid或NumLenValid有效，根据此Block长度跳地址，继续检查下个地址空间是否空白（步骤1）。</li>
</ol>
</li>
<li><ol start="3">
<li>NumLen和Data都无效，跳过一个BlockHeader长度继续检查（步骤1）。</li>
</ol>
</li>
<li>写入BlockHeader中的INFO（BlockNumber、BlockLen），写入BlockHeader中的NUMLEN有效标志位。</li>
<li>检查要写入数据的区域是否为空，不为空则退出。</li>
<li>写入BlockData，写入Data有效标志位。</li>
<li>数据写入Flash成功，更新BlockInfo，指向最新的Block地址。</li>
</ol>
<h5 id="读取Block"><a href="#读取Block" class="headerlink" title="读取Block"></a>读取Block</h5><p>对外接口：<code>Std_ReturnType Fee_Read(uint8 FeeInstanceId, uint16 BlockNumber, uint16 BlockOffset, uint8 *DataBufferPtr, uint16 Length, boolean IsSync)</code><br>内部接口：<code>MemIf_JobResultType Fee_ReadJob(uint16 BlockIndex, uint16 BlockOffset, uint8* DataBufferPtr, uint16 Length, uint8 FeeInstanceId)</code></p>
<p>上层调用Fee读取数据，支持异步，读取通过偏移和长度参数，读取Block中的部分数据内容。</p>
<p>Block读取较为简单，判断参数正确未越界即可直接读取Flash中的数据到内存，如果Flash中未保存此数据返回MEMIF_BLOCK_INVALID。</p>
<h5 id="同异步、多实例"><a href="#同异步、多实例" class="headerlink" title="同异步、多实例"></a>同异步、多实例</h5><p>Fee和Fls都支持同步和异步的调用方式，为了实现异步调用，需要有一个管理任务的内存空间，Fee和Fls都使用JobInfo结构体来管理。每个实例都有独立的ram空间，所以多实例问题也很好解决。</p>
<p>Fee对外接口中，读Block、写Block、失效Block三个接口支持异步的方式，Fls对外接口中，读Flash、写、擦、比较、空校验这些接口支持异步方式调用。</p>
<ul>
<li>异步调用Fee对外接口，接口函数会检测参数正确性，无误后将任务参数写入JobInfo，Fee状态变为Busy，然后接口return，在Fee_main中执行Job。</li>
<li>同步调用Fee读写接口和异步方式相同，写入JobInfo后会在对外接口函数内调用执行Job函数，直到状态变为IDLE。</li>
</ul>
<h4 id="MemIf"><a href="#MemIf" class="headerlink" title="MemIf"></a>MemIf</h4><p>内存抽象接口（MemIf）模块提供对底层Fee或Ea模块的抽象，由NvM调用传入形参实例号（DeviceIndex），MemIf根据实例号区分该调用Fee或是Ea模块。</p>
<p>MemIf也做成了可配置的形式，可通过配置将需要用的子模块链接到程序中，不用的模块不链接，实现整套协议栈功能可裁剪。</p>
<h4 id="NvM"><a href="#NvM" class="headerlink" title="NvM"></a>NvM</h4><p>NvM模块包含：下电写入、周期写入、事件触发写入、Block标定、Block清除（恢复默认值）、Block读取写入、Block结构体变更处理、Block校验失败处理、Block数据和RTE同步功能。</p>
<p>NvM是基于原本EPara模块重构的，使用MemIf的接口，对上提供原EPara有的那些服务接口，如标定、同步这些AUTOSAR中没有的功能。其余读写Block，接口改的与AUTOSAR一致，一些AUTOSAR中有的但用不到的接口部分也没有实现。</p>
<p>初始化接口：<code>void NvM_Init( const NvM_ConfigType* ConfigPtr )</code><br>流程：校验config参数，读取所有Block，创建NvM周期任务。</p>
<p>读取Block任务接口：<code>static void NvM_ReadBlock(uint16 BlockId)</code><br>流程：读取NvM Block Header，根据头中的Block Len读取相应长度的数据段，做CRC16校验。CRC校验失败恢复默认值，版本不一致恢复默认值。原数据长度小于配置的Block长度，继承原先长度的Block数据，超过原先长度的部分从默认值获取。原数据长度大于等于配置的Block长度，保留Block所配置长度的数据段。</p>
<p>写入Block任务接口：<code>static void NvM_WriteBlockJob(uint16 BlockId)</code><br>流程：读取Block，比较不一致再写入，写入成功或比较一致清除Block写入标志位。</p>
<p>写入Block接口：<code>void NvM_WriteAll(boolean IsSync)</code> <code>void NvM_WriteBlock(uint16 BlockId, boolean IsSync)</code><br>流程：这两个写入Block接口会将Block写入标志位置写入标志位，如果IsSync = TRUE，会在函数内部调用<code>NvM_ExecuteJob()</code>，执行写入任务。</p>
<p>周期写入接口：<code>static void NvM_CycleWrite(void)</code><br>流程：写入周期到，会对所有配置了周期写入的Block置写入标志位。</p>
<p>下电写入接口：<code>static void NvM_PoweroffWrite(void)</code><br>流程：检测到预下电RTE信号上升沿，会对所有配置了周期写入的Block置写入标志位。</p>
<p>事件触发写入接口：<code>static void NvM_EventWrite(void)</code><br>流程：检测到对应Block事件触发信号上升沿，会对此Block置写入标志位。</p>
<p>执行任务接口：<code>static void NvM_ExecuteJob(void)</code><br>流程：执行写入任务，调用一次ExecuteJob，最多只会写入1个Block。</p>
<h5 id="NvM存储各层数据结构"><a href="#NvM存储各层数据结构" class="headerlink" title="NvM存储各层数据结构"></a>NvM存储各层数据结构</h5><p><img src="/2023/10/20/231020-MemoryStack/231020-MemoryStack-1.png" alt="img"></p>
<h3 id="待改进点"><a href="#待改进点" class="headerlink" title="待改进点"></a>待改进点</h3><ol>
<li>Fls写入使用异步非阻塞，每写入一个页挂起，需要os支持。</li>
<li>Fee异常时的擦除也可以挂起，减少阻塞时处理器性能浪费。</li>
<li>MemIf下可以挂除Fee和Ea外的设备，支持S32K的EEP，因为S32EEP不需要均衡磨损，本身就是用Flash模拟的，所以不适合挂在Ea和Fee。为什么不直接用Flash，然后挂Fee上？因为想让用S32Eep的老项目支持这套内存协议栈。</li>
<li>NvM作为协议栈的上层，可以实现更多的功能。</li>
</ol>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>整套协议栈自己实现相比直接用AUTOSAR的组件有很多的优点，有哪些自己特殊的需求加到协议栈里比较方便。比如使用之前的均衡磨损算法、NvM支持数据不同版本继承、Fee对数据继承的支持、有同步接口的需求、外部Flash也想使用Fee等等。</p>
<p>调试的过程中云途的mcu擦flash也有坑，这么多个模块开发下来，其中感觉最为复杂的是Fee，完成一个能经得住随机下电，下次上电能自恢复的Fee是很有成就感的。这里要感谢我领导对我的支持与帮助，给我时间让我自我发挥，遇到我解决问题可以一同调试。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/23/230923-ble/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hao">
      <meta itemprop="description" content="保持热爱，奔赴山海。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="永恆博客网">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/09/23/230923-ble/" class="post-title-link" itemprop="url">蓝牙BLE调试记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-09-23 08:00:00" itemprop="dateCreated datePublished" datetime="2023-09-23T08:00:00+08:00">2023-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-09 00:21:23" itemprop="dateModified" datetime="2024-07-09T00:21:23+08:00">2024-07-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="蓝牙SOC芯片"><a href="#蓝牙SOC芯片" class="headerlink" title="蓝牙SOC芯片"></a>蓝牙SOC芯片</h2><p>国产芯片PAN1020，M0带蓝牙收发器的SOC只要2.5r/pcs，可以用来做一些低成本的小产品，带上蓝牙控制的功能。参考资料：<a target="_blank" rel="noopener" href="https://bbs.panchip.com/forum.php?mod=viewthread&tid=7480&extra=page=1">PAN1020_Public_SDK_V2.0.8</a>。</p>
<ul>
<li>RF<br>- 2.4GHz 射频收发机（兼容 BLE4.2）<br>- 接收灵敏度：-90 dBm@1Mbps<br>- 最大接收信号：0 dBm<br>- 可编程发射输出功率：最大为 13 dBm，一般为 8 dBm<br>- 单线天线：无需 RF 匹配或 RX/TX 切换</li>
<li>内核<br>- MCU 内核运行速度高达 26 MHz<br>- 一个 24 位系统定时器<br>- 支持低功耗空闲模式<br>- 单周期 32 位硬件乘法器<br>- 支持串行线调试（SWD）接口和两个观察点/四个断点</li>
<li>内存<br>- 256 KB 闪存用于程序存储器<br>- 16 KB SRAM</li>
</ul>
<p><strong>低功耗说明</strong>：</p>
<table>
<thead>
<tr>
<th>NO</th>
<th>Mode</th>
<th>Interval</th>
<th>Average Current</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Advertising</td>
<td>100ms</td>
<td>545uA</td>
<td>32K RC</td>
</tr>
<tr>
<td>2</td>
<td>Advertising</td>
<td>1000ms</td>
<td>66uA</td>
<td>32K RC</td>
</tr>
<tr>
<td>3</td>
<td>Connected</td>
<td>100ms</td>
<td>301uA</td>
<td>32K RC</td>
</tr>
<tr>
<td>4</td>
<td>Connected</td>
<td>1000ms</td>
<td>55uA</td>
<td>32K RC</td>
</tr>
<tr>
<td>5</td>
<td>Advertising</td>
<td>100ms</td>
<td>400uA</td>
<td>32K XO</td>
</tr>
<tr>
<td>6</td>
<td>Connected</td>
<td>100ms</td>
<td>230uA</td>
<td>32K XO</td>
</tr>
</tbody></table>
<h2 id="产品需求"><a href="#产品需求" class="headerlink" title="产品需求"></a>产品需求</h2><p>蓝牙温度计，能记录历史数据，手机app显示温度波形，40mah纽扣电池供电，使用5天。</p>
<h2 id="软件开发记录"><a href="#软件开发记录" class="headerlink" title="软件开发记录"></a>软件开发记录</h2><p>代码已上传 GIthub：<a target="_blank" rel="noopener" href="https://github.com/hao0527/BLE_APP">BLE_APP 源码</a></p>
<h3 id="启用中断回调"><a href="#启用中断回调" class="headerlink" title="启用中断回调"></a>启用中断回调</h3><p>我配置了 ADC 并开启中断，测试程序会卡死，最后发现与 ADC 中断是否开启相关。在 BLE 协议栈接口那发现了注册中断的接口。</p>
<p>使用如下代码将 <code>ADC_IRQ</code> 的中断回调 <code>mcu_adc_isr</code> 注册到协议栈后，问题解决。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册中断处理函数到协议栈，否则中断会卡死。</span></span><br><span class="line">((interrupt_register_handler)SVC_interrupt_register)(ADC_IRQ, mcu_adc_isr);</span><br></pre></td></tr></table></figure>

<h3 id="开启低功耗模式"><a href="#开启低功耗模式" class="headerlink" title="开启低功耗模式"></a>开启低功耗模式</h3><p>如需开启低功耗模式，只需在 <code>panip_config.h</code> 中 <code>#define SLEEP_EN (1)</code>。</p>
<p>PAN1020 SDK 定义的全局变量在使用前都必须要在函数中初始化，如果定义的时候就初始化，当前初始化的值是不生效的。</p>
<p>因为<strong>开启低功耗模式需配置编译器将 RAM 设置为 NoInit</strong>，如图所示：</p>
<p><img src="/2023/09/23/230923-ble/230923-ble-1.jpg" alt="img"></p>
<p>设为 NoInit 后，全局变量定义后的值为随机值，没有被初始化，需要自己手动初始化。此处是为了在 PAN1020 休眠唤醒后 RAM 不被重新初始化，唤醒后的 RAM 值依旧保持为休眠前的值。</p>
<h3 id="配置软件定时器"><a href="#配置软件定时器" class="headerlink" title="配置软件定时器"></a>配置软件定时器</h3><p>按照 SDK 用户手册配置软件定时器后遇到奇怪的问题，但测试发现解决方法，如下注释说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_proj_template_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;app_proj_template_env, <span class="number">0</span>, <span class="keyword">sizeof</span>(app_proj_template_env));</span><br><span class="line">	</span><br><span class="line">	temper_resetInit();</span><br><span class="line">	<span class="comment">/* 注意：配置定时器放在此函数里没问题，放在appm_init()外部有问题，会导致无法进定时回调！</span></span><br><span class="line"><span class="comment">			函数调用关系：ble_normal_reset_init() -&gt; user_code_start() -&gt; appm_init() -&gt; app_init_ind_func()</span></span><br><span class="line"><span class="comment">			设置定时器放在appm_init()内部没问题，但是放在appm_init()外部就不行，</span></span><br><span class="line"><span class="comment">			甚至把设置定时器放在appm_init()内部的最后一行可以，放在appm_init()执行完出来的下一行不行！*/</span></span><br><span class="line">	((ke_timer_set_handler)SVC_ke_timer_set)(APP_SAMPLE_TEMPER_TIMER, TASK_APP, <span class="number">60</span>*<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置ATT数据库"><a href="#配置ATT数据库" class="headerlink" title="配置ATT数据库"></a>配置ATT数据库</h3><p>配置att数据库后发现只有数据库的前13条配置生效，后面的att没有生效，在配置att的接口调试发现有条件为满足导致的后面一些att数据库配置没配置进协议栈，一层层向上查后是以下代码，<code>db_cfg-&gt;features = 0x1fff;</code> 导致的，如下配置为 <code>db_cfg-&gt;features = 0xffffffff;</code> 后问题解决。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_proj_template_add_server</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proj_template_server_db_cfg</span>* <span class="title">db_cfg</span>;</span></span><br><span class="line">	</span><br><span class="line">  <span class="comment">// Allocate the BASS_CREATE_DB_REQ</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">gapm_profile_task_add_cmd</span> *<span class="title">req</span> =</span> KE_MSG_ALLOC_DYN(GAPM_PROFILE_TASK_ADD_CMD,</span><br><span class="line">												TASK_GAPM, TASK_APP,</span><br><span class="line">												gapm_profile_task_add_cmd,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> proj_template_server_db_cfg));</span><br><span class="line">	<span class="comment">// Fill message</span></span><br><span class="line">	req-&gt;operation	 = GAPM_PROFILE_TASK_ADD;</span><br><span class="line">	req-&gt;sec_lvl	 = (PERM(SVC_AUTH, DISABLE)| PERM(SVC_UUID_LEN, UUID_16)| PERM(SVC_EKS, DISABLE)|PERM(SVC_DIS, DISABLE));</span><br><span class="line"></span><br><span class="line">	req-&gt;prf_task_id = TASK_ID_PROJ_TEMPLATE_SERVER;</span><br><span class="line">	req-&gt;app_task	 = TASK_APP;</span><br><span class="line">	req-&gt;start_hdl	 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set parameters</span></span><br><span class="line">	db_cfg = (<span class="keyword">struct</span> proj_template_server_db_cfg* ) req-&gt;param;</span><br><span class="line">	db_cfg-&gt;features = <span class="number">0xffffffff</span>;	<span class="comment">// 注意：配置了gatt数据库，要配置这个掩码使能，32位都是1可以使能32个数据库配置</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Send the message</span></span><br><span class="line">	((ke_msg_send_handler)SVC_ke_msg_send)(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="电池输出电流不足不问"><a href="#电池输出电流不足不问" class="headerlink" title="电池输出电流不足不问"></a>电池输出电流不足不问</h3><p>电池40mah，放点倍率0.1C，输出电流最大就4ma，射频瞬间最大电流有30多ma，adc采集会开启ldo和运放，最大电流有90ma。</p>
<p>adc采集的时候电流过大会将电压拉低导致单片机复位，正在通过加电容解决。</p>
<p>射频需求只需要5m范围内，所以射频的功率也可以配置低一些。</p>
<p>后面测试解决完这个问题更新……</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hao</p>
  <div class="site-description" itemprop="description">保持热爱，奔赴山海。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">79</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
