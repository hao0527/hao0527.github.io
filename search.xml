<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>阿里云物联网平台数据解析与物模型显示</title>
      <link href="/2023/01/21/230121-iot/"/>
      <url>/2023/01/21/230121-iot/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章是对之前文章【<a href="2021/12/17/211217-ltecat1/">LTE Cat.1模块和阿里云物联网平台使用</a>】的一个补充。之前只介绍了阿里云物联网平台如何创建产品、添加设备、添加物模型概述，缺少对消息解析、物模型展示的使用介绍，导致我这次用阿里云物联网平台时花了将近半天的时间在做之前做过又忘记怎么做的事情。本文就来介绍下<strong>消息解析</strong>、<strong>物模型展示</strong>的功能。</p><p>另外阿里云免费的物联网平台公共实例的资源包将于2023年2月20日下线，我看企业版的最便宜的也要700元/月，我这种添加一个设备调试用的不能白嫖了，到时候需要的话只能包一台服务器自己搭个MQTT划算点了，或者看看其他云服务商那能不能白嫖😂。</p><h3 id="添加物模型"><a href="#添加物模型" class="headerlink" title="添加物模型"></a>添加物模型</h3><p>在<strong>设备管理-&gt;产品-&gt;对应产品名称-&gt;功能定义-&gt;编辑草稿</strong>中添加物模型数据，功能类型有<strong>属性、服务、事件</strong>，我目前只使用到了属性类型，编辑完成后发布上线即可，下面是我这次调试模块用到的物模型功能定义：</p><p><img src="https://hao0527.gitee.io/230121-iot/230121-iot-1.jpg" alt="img"></p><h3 id="消息解析"><a href="#消息解析" class="headerlink" title="消息解析"></a>消息解析</h3><p>在<strong>设备管理-&gt;产品-&gt;对应产品名称-&gt;消息解析-&gt;编辑草稿</strong>中编写消息解析的脚本代码，有<strong>js、Python、php</strong>三种语言可供选择，我选择的是Python。消息解析有<a href="https://help.aliyun.com/document_detail/149962.html">自定义Topic消息解析</a>和<a href="https://help.aliyun.com/document_detail/66640.html">物模型消息解析</a>两种，创建产品时数据格式选择<strong>透传/自定义</strong>，消息解析里才有设备上报数据和设备接收数据，数据格式选ICA 标准数据格式(Alink JSON)，消息解析里只有自定义Topic消息解析。通过看模拟输入中模拟类型有哪些，可以知道是否支持某种消息类型的数据解析。</p><h4 id="自定义Topic消息解析"><a href="#自定义Topic消息解析" class="headerlink" title="自定义Topic消息解析"></a>自定义Topic消息解析</h4><p>设备通过携带解析标记<code>?_sn=default</code>的自定义Topic上报自定义格式消息时，物联网平台收到消息数据后，需调用消息解析脚本将自定义格式数据转换为JSON结构体，再流转给后续业务系统。例如，设备发送到Topic <code>/$&#123;productKey&#125;/$&#123;deviceName&#125;/user/update</code>的消息需要解析为JSON格式，在开发设备端时，就需配置该Topic为：<code>/$&#123;productKey&#125;/$&#123;deviceName&#125;/user/update?_sn=default</code>。</p><p>在Python脚本中，自定义Topic消息解析的接口函数名为<code>transform_payload(topic, rawData)</code>，可以根据不同的topic选择不同的解析方式。</p><h4 id="物模型消息解析"><a href="#物模型消息解析" class="headerlink" title="物模型消息解析"></a>物模型消息解析</h4><p>数据格式为<strong>ICA标准数据格式</strong>，设备按照物联网平台定义的标准数据格式生成消息上报，标准Alink JSON数据格式说明，请参见<a href="https://help.aliyun.com/document_detail/89301.htm#concept-mvc-4tw-y2b">设备属性、事件、服务</a>。</p><p>数据格式为<strong>透传/自定义</strong>，设备通信时，需要物联网平台调用您提交的消息解析脚本，将上行物模型消息解析为物联网平台定义的标准格式（Alink JSON），将下行物模型消息据解析为设备的自定义数据格式。</p><p>在Python脚本中，设备自定义数据格式转Alink JSON格式数据的函数（上行通信）为<code>raw_data_to_protocol</code>，Alink JSON格式数据转为设备自定义数据格式的函数（下行通信）为<code>protocol_to_raw_data</code>，要注意的是<code>raw_data_to_protocol</code>函数需要将rawData输入转为标准的Alink JSON，参考标准Alink JSON数据格式说明。下面是我这次用到的脚本解析代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ALINK_PROP_REPORT_METHOD = <span class="string">&#x27;thing.event.property.post&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raw_data_to_protocol</span>(<span class="params">rawData</span>):</span><br><span class="line">    uint8Array = []</span><br><span class="line">    <span class="keyword">for</span> byteValue <span class="keyword">in</span> rawData:</span><br><span class="line">        uint8Array.append(byteValue &amp; <span class="number">0xff</span>)</span><br><span class="line">    </span><br><span class="line">    jsonMap = &#123;&#125;</span><br><span class="line">    params = &#123;&#125;</span><br><span class="line">    params[<span class="string">&#x27;status&#x27;</span>] = uint8Array[<span class="number">0</span>]</span><br><span class="line">    params[<span class="string">&#x27;error&#x27;</span>] = uint8Array[<span class="number">1</span>]</span><br><span class="line">    params[<span class="string">&#x27;validIDNum&#x27;</span>] = uint8Array[<span class="number">2</span>]</span><br><span class="line">    params[<span class="string">&#x27;errorSlave&#x27;</span>] = uint8Array[<span class="number">3</span>]</span><br><span class="line">    params[<span class="string">&#x27;idallocTimes&#x27;</span>] = uint8Array[<span class="number">4</span>]</span><br><span class="line">    params[<span class="string">&#x27;costTime&#x27;</span>] = (uint8Array[<span class="number">6</span>]|(uint8Array[<span class="number">7</span>]&lt;&lt;<span class="number">8</span>))<span class="comment"># 非单字节变量注意大小端</span></span><br><span class="line">    params[<span class="string">&#x27;successCnt&#x27;</span>] = (uint8Array[<span class="number">8</span>]|(uint8Array[<span class="number">9</span>]&lt;&lt;<span class="number">8</span>)|(uint8Array[<span class="number">10</span>]&lt;&lt;<span class="number">16</span>)|(uint8Array[<span class="number">11</span>]&lt;&lt;<span class="number">24</span>))</span><br><span class="line">    params[<span class="string">&#x27;errorCnt&#x27;</span>] = (uint8Array[<span class="number">12</span>]|(uint8Array[<span class="number">13</span>]&lt;&lt;<span class="number">8</span>)|(uint8Array[<span class="number">14</span>]&lt;&lt;<span class="number">16</span>)|(uint8Array[<span class="number">15</span>]&lt;&lt;<span class="number">24</span>))</span><br><span class="line">    jsonMap[<span class="string">&#x27;params&#x27;</span>] = params<span class="comment"># 物模型中的属性添加到params中，再加到jsonMap</span></span><br><span class="line">    jsonMap[<span class="string">&#x27;method&#x27;</span>] = ALINK_PROP_REPORT_METHOD<span class="comment"># 标准的Alink JSON必须要加method</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonMap</span><br></pre></td></tr></table></figure><h3 id="物模型显示效果"><a href="#物模型显示效果" class="headerlink" title="物模型显示效果"></a>物模型显示效果</h3><p>这次应用是有软件模块过年放假期间需要测试，我用4G Cat.1模块传到阿里云物联网平台记录数据，最终物模型显示效果如下图：</p><p><img src="https://hao0527.gitee.io/230121-iot/230121-iot-2.jpg" alt="img"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言printf变长参数如何实现</title>
      <link href="/2023/01/20/230120-printf/"/>
      <url>/2023/01/20/230120-printf/</url>
      
        <content type="html"><![CDATA[<h3 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h3><p>函数原型：<code>int printf(const char *format, ...)</code><br>调用格式为：<code>printf(&quot;&lt;格式化字符串&gt;&quot;, &lt;参量表&gt;);</code><br>功能：发送格式化输出到标准输出 stdout</p><h3 id="变长参数实现思路"><a href="#变长参数实现思路" class="headerlink" title="变长参数实现思路"></a>变长参数实现思路</h3><p>C语言支持变长参数函数(Variable Argument Functions)，即参数的个数可以是不定个，在函数定义的时候用<code>...</code>表示。采用这种形式定义的变长参数函数，<strong>至少需要一个普通的形参</strong>，且<code>...</code>需要放在最后一个参数，比如printf函数中的<code>*format</code>后面的<code>...</code>是函数原型的一部分。</p><p>变长参数的实现得益于C语言默认的<em><strong>cdecl</strong></em>调用惯例，其参数是<strong>从右向左</strong>压入栈的，第一个参数位于栈顶。这样printf函数实现的时候，就无需关心调用他的函数会传递几个参数过来，而只要关心自己用到几个，将全部参数压入栈，函数处理时从栈中取即可。</p><h3 id="自己实现一个变长参数的函数"><a href="#自己实现一个变长参数的函数" class="headerlink" title="自己实现一个变长参数的函数"></a>自己实现一个变长参数的函数</h3><p>Ｃ已经有现成可用的一些东西来帮我们实现变长参数，它主要通过<code>stdarg.h</code>头文件定义的一个变量类型（va_list）和三个宏（va_start、va_arg、va_end）来实现。</p><p>实现一个可变长参数的sum函数，第一个参数<code>num</code>传递变长参数中有参数的数量，紧接着后面会传递<code>num</code>个整型变量，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, val = <span class="number">0</span>;</span><br><span class="line">    va_list ap;<span class="comment">//定义一个具有va_list型的变量，这个变量是指向参数的指针</span></span><br><span class="line">    va_start(ap, num);<span class="comment">//始化变量刚定义的va_list变量,使其指向第一个可变参数的地址,地址自动增加</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        val += va_arg(ap, <span class="type">int</span>);<span class="comment">//va_arg返回va_list中的参数，并增加指针偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);<span class="comment">//结束可变参数列表</span></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16+38+53=%d\n&quot;</span>, sum(<span class="number">3</span>, <span class="number">16</span>, <span class="number">38</span>, <span class="number">53</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变长参数实现原理"><a href="#变长参数实现原理" class="headerlink" title="变长参数实现原理"></a>变长参数实现原理</h3><p>上面的sum函数也可以不使用va_list等宏，通过其他方法实现。<br>当我们调用：<code>int n = sum(3, 16, 38, 53);</code><br>参数在栈上会形成如下布局：<br><img src="https://hao0527.gitee.io/230120-printf/230120-printf-1.jpg" alt="img"></p><p>在函数内部，函数可以使用变量<code>num</code>来访问数字3，但无法使用任何名称访问其他的几个不定参数。但此时由于栈上其他的几个参数实际恰好依序排列在参数<code>num</code>的高地址方向，因此可以很简单地通过<code>num</code>的地址计算出其他参数的地址，sum函数的另一种实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = &amp;num + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">        ret += *p++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>printf的不定参数比sum要复杂得多，因为printf的参数不仅数量不定，而且<strong>类型</strong>也不定。所以printf需要在格式字符串中注明参数的类型，例如用<code>%d</code>表明是一个整数。printf里的格式字符串如果将类型描述错误，因为不同参数的大小不同，不仅可能导致这个参数的输出错误，还有可能导致其后的一系列参数错误。[摘自《程序员的自我修养——链接、封装、库》P338]</p><p><code>printf(&quot;%lf\t%d\t%c\n&quot;, 1, 666, &#39;a&#39;);</code> 在这行函数里，printf的第一个输出参数是一个int(4 字节)，而我们告诉printf它是一个double(8字节)，因此printf的输出会错误，由于printf在读取double的时候实际造成了越界，因此后面几个参数的输出也会失败。该程序的实际输出为：<code>0.000000 97</code>（根据实际编译器和环境可能不同）</p><h3 id="va-list等宏如何实现"><a href="#va-list等宏如何实现" class="headerlink" title="va_list等宏如何实现"></a>va_list等宏如何实现</h3><p><strong>va_list</strong> 实际是一个指针，用来指向各个不定参数。由于类型不明，因此这个 va_list 以 void* 或 char*  为最佳选择。<br><strong>va_start</strong> 将 va_list 定义的指针指向函数的最后一个参数后面的位置，这个位置就是第一个不定参数。<br><strong>va_arg</strong> 获取当前不定参数的值，并根据当前不定参数的大小将指针移向下一个参数。<br><strong>va_end</strong> 将指针清 0。<br>按照以上思路，va_list等宏的一个<strong>最简单的实现</strong>就可以得到了，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_list char*</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap, arg) (ap=(va_list)&amp;arg+sizeof(arg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap, t) (*(t*)((ap+=sizeof(t))-sizeof(t)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) (ap=(va_list)0)</span></span><br></pre></td></tr></table></figure><p>注意：实际代码中还套了很多宏，不同编译器，不同架构都有可能使用不同的代码实现，但具体实现思想一致，有些x64条件编译时va_list会是一个结构体，里面会记录可变参数开始地址、结束地址、参数数量等信息。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DDR关键参数介绍</title>
      <link href="/2022/12/17/221217-ddr/"/>
      <url>/2022/12/17/221217-ddr/</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>在学习FPGA时使用了DDR3，最近学ARM处理器也用到了DDR3的外设，在FPGA是使用 MIG(Memory Interface Generators)IP核驱动DDR3，ARM处理器是通过配置MMDC(Multi Mode DDR Controller)模块驱动DDR3，这编博客将会介绍使用DDR需配置的几个关键参数。</p><p>SRAM操作流程、时序图可以浏览我之前的文章，<a href="/2021/12/19/211219-fpga%E4%B9%8Bsdram/">FPGA之SDRAM学习</a>。</p><h3 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h3><h4 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h4><p>传输速率的单位是MT/s(Mega Transfer Per Second)，即每秒传输的百万次数，常见DDR3有800MT/s、1066MT/s、1333MT/s、1600MT/s等，这是首先需要考虑的，该参数决定了DDR的最高数据传输速率。</p><h4 id="tRCD-参数"><a href="#tRCD-参数" class="headerlink" title="tRCD 参数"></a>tRCD 参数</h4><p>tRCD 全称是 RAS-to-CAS Delay，也就是<strong>行寻址到列寻址之间的延迟</strong>。 DDR 的寻址流程是先指定 BANK 地址，然后在指定行地址，最后指定列地址确定最终要寻址的单元。 BANK 地址和行地址是同时发出的，这个命令叫做<strong>行激活</strong>(Row Active)。行激活以后就发送列地址和具体的操作命令(读还是写)，这两个是同时发出的，因此一般也用<strong>读/写命令</strong>表示<strong>列寻址</strong>。在行有效(行激活)到读/写命令发出的这段时间间隔叫做 tRCD。</p><h4 id="CL-参数"><a href="#CL-参数" class="headerlink" title="CL 参数"></a>CL 参数</h4><p>当列地址发出以后就会触发数据传输，但是从数据从存储单元到内存芯片 IO 接口上还需要一段时间，这段时间就是非常著名的 CL(CAS Latency)，也就是<strong>列地址选通潜伏期</strong>。</p><h4 id="AL-参数"><a href="#AL-参数" class="headerlink" title="AL 参数"></a>AL 参数</h4><p>在 DDR 的发展中，提出了一个前置 CAS 的概念，目的是为了解决 DDR 中的指令冲突，它允许 CAS 信号紧随着 RAS 发送，相当于将 DDR 中的 CAS 前置了。但是读/写操作并没有因此提前，依旧要保证足够的延迟/潜伏期，为此引入了 AL(Additive Latency)，单位也是时钟周期数。 AL+CL 组成了 RL(Read Latency)，从 DDR2 开始还引入了写潜伏期 WL(Write Latency)，WL 表示写命令发出以后到第一笔数据写入的潜伏期。</p><h4 id="tRAS-参数"><a href="#tRAS-参数" class="headerlink" title="tRAS 参数"></a>tRAS 参数</h4><p>RAS active time，也指Active to Precharge Delay，行有效至行预充电时间。是指从收到一个请求后到初始化RAS(行地址选通脉冲)真正开始接受数据的间隔时间，tRAS 是 ACTIVE 命令到 PRECHARGE 命令之间的最小时间，tRAS=tRCD+tWR。</p><h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><h4 id="tRP-参数"><a href="#tRP-参数" class="headerlink" title="tRP 参数"></a>tRP 参数</h4><p>在发出预充电命令之后，要经过一段时间才能允许发送RAS行有效命令打开新的工作行，这个间隔被称为tRP（RAS Precharge time，预充电有效时间）。</p><h4 id="tRC-参数"><a href="#tRC-参数" class="headerlink" title="tRC 参数"></a>tRC 参数</h4><p>tRC(Row Cycle Time)，表示“SDRAM行周期时间”，它是包括行单元预充电到激活在内的整个过程所需要的最小的时钟周期数，是两个 ACTIVE 命令或者 ACTIVE 命令到 REFRESH 命令之间的周期。tRC=tRAS+tRP。如果tRC的时间过长，会因在完成整个时钟周期后激活新的地址而等待无谓的延时，而降低性能。然而如果该值设置过小，在被激活的行单元被充分充电之前，新的周期就可以被初始化，也会导致数据丢失和损坏。</p><h4 id="tWR-参数"><a href="#tWR-参数" class="headerlink" title="tWR 参数"></a>tWR 参数</h4><p>由于数据信号由控制端发出，输入时芯片无需做任何调校，只需直接传到数据输入寄存器中，然后再由写入驱动器进行对存储电容的充电操作，因此数据可以与CAS同时发送，也就是说写入延迟为0。不过，数据并不是即时地写入存储电容，因为选通三极管（就如读取时一样）与电容的充电必须要有一段时间，所以数据的真正写入需要一定的周期。为了保证数据的可靠写入，都会留出足够的写入/校正时间（tWR，Write Recovery Time），这个操作也被称作写回（Write Back）。tWR至少占用一个时钟周期或再多一点（时钟频率越高，tWR占用周期越多）。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于CAN2.0的J1939协议</title>
      <link href="/2022/11/29/221129-j1939/"/>
      <url>/2022/11/29/221129-j1939/</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>这几天在做ID自分配协议栈，使用的是J1939协议，汽车中还有其他的EOL协议、快充协议也都是使用的J1939协议。</p><h3 id="SAE-J1939与CAN2-0的关系"><a href="#SAE-J1939与CAN2-0的关系" class="headerlink" title="SAE-J1939与CAN2.0的关系"></a>SAE-J1939与CAN2.0的关系</h3><p>CAN2.0是一种总线规范，是数据链路层的技术。J1939是SAE（美国汽车协会）基于CAN总线定义的的规范，主要用于解决不同发动机厂商、不同ECU厂商之间的兼容性问题。J1939定义了一系列的PGN和SPN，这些PGN包含了发动机、变速器、车轴等汽车上各部件的信息；对参数的表示方法（状态和值）又定义了SLOT（Scaling—比例、Limit—界限、Offset—偏移、Transfer—传送）。ECU厂商开发设备时都应该遵循这个规范。ECU模块的功能不同，厂商不同，在J1939的基础上，又表现出其多样性：支持或者不支持某些PGN、SPN和SLOT；新增了某些J1939未定义的PGN和SPN。</p><h3 id="SAE-J1939消息帧格式"><a href="#SAE-J1939消息帧格式" class="headerlink" title="SAE-J1939消息帧格式"></a>SAE-J1939消息帧格式</h3><p>CAN2.0规范包括CAN2.0A（标准帧格式），CAN2.0B（扩展帧格式），二者使用不同的帧格式位码。J1939是在CAN2.0B的基础上进一步封装，对仲裁场部分的29位ID的重新定义。SAE-J1939中只为扩展帧格式定义了标准化的通信，因此，<strong>SAE-1939设备必须使用扩展帧格式</strong>。</p><h3 id="SAE-J1939数据帧结构"><a href="#SAE-J1939数据帧结构" class="headerlink" title="SAE-J1939数据帧结构"></a>SAE-J1939数据帧结构</h3><p>SAE-J1939将每个协议数据单元（PDU）融合进一个CAN2.0B数据帧中，其结构如下：</p><p><img src="https://hao0527.gitee.io/221129-j1939/221129-j1939-1.png" alt="img"></p><p>参数群编号（PGN）对于制定基于SAE-J1939的CAN协议来说十分重要，很多ECU厂商规定在接受CAN报文时识别的就是PGN而不是整个报文的ID。参数群编号是由24位组成的（其实是18位），主要包括下面几个部分：保留位（R，1bit，默认为：0），数据页位（DP，1bit，多数情况下为：0），PDU格式（PF，8bit）和特定PDU（PS，8bit，目标地址是否群扩展）。当PF值为：0~239之前时PGN的低字节将被设置为：0；当PF值为240~254之时，PGN的低字节为PS的值。PGN结构如下：</p><p><img src="https://hao0527.gitee.io/221129-j1939/221129-j1939-2.png" alt="img"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>I.MX6U Assembly LED Driver</title>
      <link href="/2022/11/13/221113-asmLed/"/>
      <url>/2022/11/13/221113-asmLed/</url>
      
        <content type="html"><![CDATA[<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="点灯流程"><a href="#点灯流程" class="headerlink" title="点灯流程"></a>点灯流程</h3><ol><li>使能指定 GPIO 的时钟</li><li>设置 IO 的复用功能</li><li>配置 GPIO 输出功能、上拉、速度等等</li><li>设置 GPIO 输出高电平或低电平</li></ol><h3 id="点灯汇编代码"><a href="#点灯汇编代码" class="headerlink" title="点灯汇编代码"></a>点灯汇编代码</h3><p>代码中的地址参考《i.MX 6ULL Applications Processor Reference Manual》</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.global _start@ global symbol</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">ldr r1, =0xffffffff</span><br><span class="line">mov r2, #6</span><br><span class="line">ldr r0, =0x020c4080@ CCM_CCGR6</span><br><span class="line">ldr r2, =0x020c4068@ CCM_CCGR0</span><br><span class="line"></span><br><span class="line">CCGR_loop_init:</span><br><span class="line">str r1, [r0]</span><br><span class="line">sub r0, #4</span><br><span class="line">cmp r2, r0</span><br><span class="line">ble CCGR_loop_init</span><br><span class="line"></span><br><span class="line">ldr r0, =0x020e0068@ IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</span><br><span class="line">ldr r1, =0x5</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =0x020e02f4@ IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03</span><br><span class="line">ldr r1, =0x10b0</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =0x0209c004@ GPIO1_GDIR</span><br><span class="line">ldr r1, =0x8</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">ldr r0, =0x0209c000@ GPIO1_DR</span><br><span class="line">ldr r1, =0x0</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =0x1f78a400@ 528M</span><br><span class="line">ldr r1, =0xfbc5200@ 264M</span><br><span class="line">delay1:</span><br><span class="line">sub r0, #100</span><br><span class="line">cmp r0, r1</span><br><span class="line">bge delay1</span><br><span class="line"></span><br><span class="line">ldr r0, =0x0209c000@ GPIO1_DR</span><br><span class="line">ldr r1, =0x8</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =0x1f78a400@ 528M</span><br><span class="line">ldr r1, =0xfbc5200@ 264M</span><br><span class="line">delay2:</span><br><span class="line">sub r0, #100</span><br><span class="line">cmp r0, r1</span><br><span class="line">bge delay2</span><br><span class="line"></span><br><span class="line">b loop</span><br></pre></td></tr></table></figure><h2 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>arm-linux-gnueabihf-gcc -g -c led.s -o led.o</code></p><p>上述命令就是将 led.s 编译为 led.o，其中“-g”选项是产生调试信息，GDB 能够使用这些调试信息进行代码调试。“-c”选项是编译源文件，但是不链接。“-o”选项是指定编译产生的文件名字。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><code>arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf</code></p><p>上述命令中-Ttext 就是指定链接地址，“-o”选项指定链接生成的 elf 文件名，这里命名为 led.elf。</p><h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><p><code>arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin</code></p><p>烧录要用到bin文件，上述命令中，“-O”选项指定以什么格式输出，后面的“binary”表示以二进制格式输出，选项“-S”表示不要复制源文件中的重定位信息和符号信息，“-g”表示不复制源文件中的调试信息。</p><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p><code>arm-linux-gnueabihf-objdump -D led.elf &gt; led.dis</code></p><p>有时候需要查看其汇编代码来调试代码，因此就需要进行反汇编，一般可以将 elf 文件反汇编，上述代码中的“-D”选项表示反汇编所有的段。</p><h2 id="Makefile脚本"><a href="#Makefile脚本" class="headerlink" title="Makefile脚本"></a>Makefile脚本</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">led.bin:led.s</span></span><br><span class="line">arm-linux-gnueabihf-gcc -g -c led.s -o led.o</span><br><span class="line">arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf</span><br><span class="line">arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin</span><br><span class="line">arm-linux-gnueabihf-objdump -D led.elf &gt; led.dis</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o led.bin led.elf led.dis</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：每一个命令行必须以 注意：每一个命令行必须以[Tab]字符开始，不能是空格开始，[Tab] 字符告诉 make 此行是一个命令行，make 按照命令完成相应的动作。这也是书写按照命令完成相应的动作，这也是书写 Makefile 中容易产生，而且比较隐蔽的错误。报错信息：<code>Makefile:2: *** 遗漏分隔符 (null)。 停止。</code></p><h2 id="反汇编-1"><a href="#反汇编-1" class="headerlink" title="反汇编"></a>反汇编</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">87800000 &lt;_start&gt;:</span><br><span class="line">87800000:e3e01000 mvnr1, #0</span><br><span class="line">87800004:e3a02006 movr2, #6</span><br><span class="line">87800008:e59f0078 ldrr0, [pc, #120]; 87800088 &lt;delay2+0x10&gt;</span><br><span class="line">8780000c:e59f2078 ldrr2, [pc, #120]; 8780008c &lt;delay2+0x14&gt;</span><br><span class="line"></span><br><span class="line">87800010 &lt;CCGR_loop_init&gt;:</span><br><span class="line">87800010:e5801000 strr1, [r0]</span><br><span class="line">87800014:e2400004 subr0, r0, #4</span><br><span class="line">87800018:e1520000 cmpr2, r0</span><br><span class="line">8780001c:dafffffb ble87800010 &lt;CCGR_loop_init&gt;</span><br><span class="line">87800020:e59f0068 ldrr0, [pc, #104]; 87800090 &lt;delay2+0x18&gt;</span><br><span class="line">87800024:e3a01005 movr1, #5</span><br><span class="line">87800028:e5801000 strr1, [r0]</span><br><span class="line">8780002c:e59f0060 ldrr0, [pc, #96]; 87800094 &lt;delay2+0x1c&gt;</span><br><span class="line">87800030:e59f1060 ldrr1, [pc, #96]; 87800098 &lt;delay2+0x20&gt;</span><br><span class="line">87800034:e5801000 strr1, [r0]</span><br><span class="line">87800038:e59f005c ldrr0, [pc, #92]; 8780009c &lt;delay2+0x24&gt;</span><br><span class="line">8780003c:e3a01008 movr1, #8</span><br><span class="line">87800040:e5801000 strr1, [r0]</span><br><span class="line"></span><br><span class="line">87800044 &lt;loop&gt;:</span><br><span class="line">87800044:e59f0054 ldrr0, [pc, #84]; 878000a0 &lt;delay2+0x28&gt;</span><br><span class="line">87800048:e3a01000 movr1, #0</span><br><span class="line">8780004c:e5801000 strr1, [r0]</span><br><span class="line">87800050:e59f004c ldrr0, [pc, #76]; 878000a4 &lt;delay2+0x2c&gt;</span><br><span class="line">87800054:e59f104c ldrr1, [pc, #76]; 878000a8 &lt;delay2+0x30&gt;</span><br><span class="line"></span><br><span class="line">87800058 &lt;delay1&gt;:</span><br><span class="line">87800058:e2400064 subr0, r0, #100; 0x64</span><br><span class="line">8780005c:e1500001 cmpr0, r1</span><br><span class="line">87800060:aafffffc bge87800058 &lt;delay1&gt;</span><br><span class="line">87800064:e59f0034 ldrr0, [pc, #52]; 878000a0 &lt;delay2+0x28&gt;</span><br><span class="line">87800068:e3a01008 movr1, #8</span><br><span class="line">8780006c:e5801000 strr1, [r0]</span><br><span class="line">87800070:e59f002c ldrr0, [pc, #44]; 878000a4 &lt;delay2+0x2c&gt;</span><br><span class="line">87800074:e59f102c ldrr1, [pc, #44]; 878000a8 &lt;delay2+0x30&gt;</span><br><span class="line"></span><br><span class="line">87800078 &lt;delay2&gt;:</span><br><span class="line">87800078:e2400064 subr0, r0, #100; 0x64</span><br><span class="line">8780007c:e1500001 cmpr0, r1</span><br><span class="line">87800080:aafffffc bge87800078 &lt;delay2&gt;</span><br><span class="line">87800084:eaffffee b87800044 &lt;loop&gt;</span><br><span class="line">87800088:020c4080 andeqr4, ip, #128; 0x80</span><br><span class="line">8780008c:020c4068 andeqr4, ip, #104; 0x68</span><br><span class="line">87800090:020e0068 andeqr0, lr, #104; 0x68</span><br><span class="line">87800094:020e02f4 andeqr0, lr, #244, 4; 0x4000000f</span><br><span class="line">87800098:000010b0 strheqr1, [r0], -r0</span><br><span class="line">8780009c:0209c004 andeqip, r9, #4</span><br><span class="line">878000a0:0209c000 andeqip, r9, #0</span><br><span class="line">878000a4:1f78a400 svcne0x0078a400</span><br><span class="line">878000a8:0fbc5200 svceq0x00bc5200</span><br></pre></td></tr></table></figure><p>和我写的汇编代码都是一一对应的，只是把直接数放在了代码段的最后，ldr通过pc+offset来取。</p><p>从反汇编来看还把ldr一些短的直接数改成了mov指令。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MCU startup.s</title>
      <link href="/2022/11/03/221103-mcustartup/"/>
      <url>/2022/11/03/221103-mcustartup/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>云途MCU内存有ECC(Error Correcting Code)功能，需要在startup.s中初始化所有内存（既赋值0），所以软复位后从startup.s中reset_handle运行，会重新初始化内存，原本内存的值会被清0，无法使用内存OTA升级程序，需要用到Flash来保存OTA信息。</p><p>这篇文章来讲下汇编启动程序做了什么，单片机启动过程，ld链接脚本中定义的变量在汇编程序中的引用，不同编译器汇编程序的区别。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li>正点原子《I.MX6U  嵌入式 x Linux  驱动开发指南 V1.6 6》——第七章 ARM  汇编基础</li><li><a href="https://developer.arm.com/zh-TW/">ARM开发人员网站</a>，可以直接搜索指令</li><li><a href="https://www.arm.com/zh-TW/resource-library">ARM资源图书馆</a>，可以下载白皮书、ARM编程手册</li><li><a href="https://sourceware.org/binutils/docs/">Documentation for binutils</a>，binutils工具链(ld, as…)的官方文档</li></ol><h2 id="启动程序和启动过程"><a href="#启动程序和启动过程" class="headerlink" title="启动程序和启动过程"></a>启动程序和启动过程</h2><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p><img src="https://hao0527.gitee.io/221103-mcustartup/2020032320502673.png" alt="启动文件使用的 ARM 汇编指令汇总"></p><h3 id="startup-stm32f40-41xxx-s-代码分析"><a href="#startup-stm32f40-41xxx-s-代码分析" class="headerlink" title="startup_stm32f40_41xxx.s 代码分析"></a>startup_stm32f40_41xxx.s 代码分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stack_Size      EQU     0x00000400</span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">Heap_Size       EQU     0x00000200</span><br><span class="line">                AREA    HEAP, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem        SPACE   Heap_Size</span><br><span class="line">__heap_limit</span><br></pre></td></tr></table></figure><p>第1行：EQU 是表示宏定义的伪指令，类似于 C 语言中的#define。伪指令的意思是指这个“指令”并不会生成二进制程序代码，也不会引起变量空间分配。0x00000400 表示栈大小，字节为单位。0x00000400 =1024字节=1KB。</p><p>第2行：开辟一段数据空间可读可写，段名 STACK，按照8字节对齐。ARER 伪指令表示下面将开始定义一个代码段或者数据段。此处是定义数据段。ARER 后面的关键字表示这个段的属性。</p><ul><li>STACK ：表示这个段的名字，可以任意命名。</li><li>NOINIT：表示此数据段不需要填入初始数据。</li><li>READWRITE：表示此段可读可写。</li><li>ALIGN=3 ：表示首地址按照 2 的 3 次方对齐，也就是按照 8 字节对齐(地址对 8 求余数等于0)。</li></ul><p>第3行：SPACE 这行指令告诉汇编器给STACK段分配 0x00000400 字节的连续内存空间。</p><p>第4行：__initial_sp 紧接着SPACE语句放置，表示了栈顶地址。__initial_sp 只是一个标号，标号主要用于表示一片内存空间的某个位置，等价于 C 语言中的“地址”概念。地址仅仅表示存储空间的一个位置，从 C 语言的角度来看，变量的地址，数组的地址或是函数的入口地址在本质上并无区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                PRESERVE8   ; 指定当前文件保持堆栈8字节对齐</span><br><span class="line">                THUMB       ; 表示后面的指令是THUMB指令集</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors       ; EXPORT申明标号为可被外部引用</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line">                </span><br><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">...... 省略</span><br><span class="line">                DCD     OTG_HS_IRQHandler                 ; USB OTG HS                   </span><br><span class="line">                DCD     DCMI_IRQHandler                   ; DCMI                         </span><br><span class="line">                DCD     CRYP_IRQHandler                   ; CRYP crypto                   </span><br><span class="line">                DCD     HASH_RNG_IRQHandler               ; Hash and Rng</span><br><span class="line">                DCD     FPU_IRQHandler                    ; FPU             </span><br><span class="line">__Vectors_End</span><br><span class="line">__Vectors_Size  EQU  __Vectors_End - __Vectors</span><br></pre></td></tr></table></figure><p>上面这块代码初始化了中断向量表，第一个是SP指针初始化地址，后面是中断向量表，包含异常处理和外设中断，DCD会定义个4Bytes空间存储中断要跳转的地址。这块RESET数据段放在Flash开始，程序从Flash首地址开始运行，先初始化SP和PC(PC就是Reset_Handler)，再跳转去Reset_Handler执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">                AREA    |.text|, CODE, READONLY</span><br><span class="line">; Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK] ; 弱定义</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0                 ; 跳转至SystemInit()函数初始化时钟</span><br><span class="line">                 LDR     R0, =__main        ; 跳转至__main()初始化堆栈, __main()由MDK自动生成</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br><span class="line"></span><br><span class="line">; Dummy Exception Handlers (infinite loops which can be modified)</span><br><span class="line"></span><br><span class="line">NMI_Handler     PROC</span><br><span class="line">                EXPORT  NMI_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">...... 省略</span><br></pre></td></tr></table></figure><p>上面这块定义了中断服务函数，都是弱定义，用户可以在别的文件中重定义。除了Reset_Handler有实现，其他都为死循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;*******************************************************************************</span><br><span class="line">; User Stack and Heap initialization</span><br><span class="line">;*******************************************************************************</span><br><span class="line">                 IF      :DEF:__MICROLIB</span><br><span class="line">                 EXPORT  __initial_sp</span><br><span class="line">                 EXPORT  __heap_base</span><br><span class="line">                 EXPORT  __heap_limit</span><br><span class="line">                </span><br><span class="line">                 ELSE</span><br><span class="line">                 IMPORT  __use_two_region_memory</span><br><span class="line">                 EXPORT  __user_initial_stackheap</span><br><span class="line">                 </span><br><span class="line">__user_initial_stackheap</span><br><span class="line">                 LDR     R0, =  Heap_Mem</span><br><span class="line">                 LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">                 LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">                 LDR     R3, = Stack_Mem</span><br><span class="line">                 BX      LR</span><br><span class="line">                 ALIGN</span><br><span class="line">                 ENDIF</span><br></pre></td></tr></table></figure><p>启动代码的最后一部分，简单的汇编语言实现 IF ELSE语句。如果定义了__MICROLIB，那么程序是不会执行ELSE分支的代码。MDK中MicroLIB的作用，参考：<a href="https://blog.csdn.net/weixin_42682108/article/details/113357057">KeilMDK配置项中Use MicroLIB</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>串口通信三种方式232, 485, 422</title>
      <link href="/2022/10/17/221017-232485422/"/>
      <url>/2022/10/17/221017-232485422/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>之前UART用的比较多，232, 485, 422通信方式用的比较少，最近储能的项目用到了485通信，在之前卡片机的项目也用到485通信，今天来归纳下232, 485, 422这三种通信的区别。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>本文搬运自 <a href="https://www.jianshu.com/p/352872a0de9d">转载：串口通信232/485/422 详细解析！</a> ，自己复习使用</li></ol><h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><p>通用异步收发传输器(Universal Asynchronous Receiver/Transmitter)。</p><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>UART作为异步串口通信协议的一种，工作原理是将传输数据的每个字符一位接一位地传输，其中各位的意义如下:</p><p><strong>起始位</strong>：先发出一个逻辑”0”的信号，表示传输字符的开始。</p><p><strong>数据位</strong>：紧接着起始位之后。数据位的个数可以是4、5、6、7、8等，构成一个字符。通常采用ASCII码。从最低位开始传送，靠时钟定位。</p><p><strong>奇偶校验位</strong>：数据位加上这一位后，使得”1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。</p><p><strong>停止位</strong>：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。 由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。<strong>因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会</strong>。<strong>适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢</strong>。</p><p><strong>空闲位</strong>：处于逻辑”1”状态，表示当前线路上没有数据传送。</p><p><img src="https://hao0527.gitee.io/221017-232485422/0.jpg" alt="图片"></p><h3 id="波特率与比特率"><a href="#波特率与比特率" class="headerlink" title="波特率与比特率"></a>波特率与比特率</h3><p><strong>比特率</strong>在数字信道中，比特率是数字信号的传输速率，它用单位时间内传输的二进制代码的有效位（bit）数来表示，其单位为每秒比特数bit/s（bps）、每秒千比特数（Kbps）或每秒兆比特数（Mbps）来表示（此处K和M分别为1000和1000000，而不是涉及计算机存储器容量时的1024和1048576）。</p><p><strong>波特率</strong>指数据信号对载波的调制速率，它用单位时间内载波调制状态改变次数来表示，其单位为波特（Baud）。波特率与比特率的关系为：比特率=波特率X单个调制状态对应的二进制位数。</p><p><strong>如何区分两者？</strong>显然，两相调制（单个调制状态对应1个二进制位）的比特率等于波特率；四相调制（单个调制状态对应2个二进制位）的比特率为波特率的两倍；八相调制（单个调制状态对应3个二进制位）的比特率为波特率的三倍；依次类推。</p><h2 id="232"><a href="#232" class="headerlink" title="232"></a>232</h2><p>232 通信主要是由RX,TX,GND三根线组成。RX与TX，TX接RX，GND接GND。因为发送和接收分别是由不同的线处理的，也就是能同时发送数据和接收数据，这就是所谓的全双工。</p><p><img src="https://hao0527.gitee.io/221017-232485422/640-1666051381273.jfif" alt="图片"></p><p>在这里扩展一下，串口通信还有一个功能叫做<strong>全功能串口通信</strong>，也叫标准串口。因为在两个设备间进行数据传输，有些设备处理速度比较快，有些数据比较慢。为了保证数据能正常传输，在RX,TX的基础上，还增加了几个控制引脚，本来好端端就R，T，G，三根线，凑着就凑齐了9个引脚，召唤出了DB9这个东西。</p><p><img src="https://hao0527.gitee.io/221017-232485422/1.jpg" alt="图片"></p><p>这要怪就怪当时使用电脑的时候，还没有互联网这个概念，但是又想在两台电脑间进行通信。所以才有这样一个东西。在后来的设备，很多控制器，人机界面，PLC等使用串口通信中，基本上就不使用标准串口，而是就直接使用RX，TX，GND三根线来通信了。但是这里为什么要提到这个呢。因为只是很多设备这样用，也就是还存在少数设备还保留了标准串口的功能。这就是为什么会遇到明明电脑通信是好的，换成触摸屏通信就不行了。因为很多触摸屏只使用了RX，TX，GND通信，遇到一些还保留标准串口功能的就比较讨厌了。</p><h2 id="485"><a href="#485" class="headerlink" title="485"></a>485</h2><p>485是为了解决232通信距离的问题。原理什么之类的就不多讲了。反正232通信距离就是不长。485主要是以一种差分信号进行传输，只需要两根线，+,-两根线，或者也叫A，B两根线。A，B两根线的差分电平信号就是作为数据信号传输。</p><p>那么问题来了，那是不是就没有RX和TX的概念了。是的，发送和接收就不能分开了。发送和接收都是靠这两根的来传输，也就是每次只能作发送或者只能作接收，这就是半双工的概念了，这在效率上就比232弱很多了。就像对讲机一样，经常是某个人讲完之后，都要说一个over，确保当前说完了，等待对方回复。</p><p><img src="https://hao0527.gitee.io/221017-232485422/640-1666051910756.jfif" alt="图片"></p><p>485就是这样牺牲了232全双工的效率来达到自己传输距离远的代价。那有没有即保留了232的全双工，又可以像485这样提高传输距离呢，于是，422出来了。</p><h2 id="422"><a href="#422" class="headerlink" title="422"></a>422</h2><p>422呢，有些标注为485-4。而485就标注为485-2。有什么区别呢。就是为了好记呢。485-2就是2根线。485-4就是4根线。</p><p><img src="https://hao0527.gitee.io/221017-232485422/640-1666051950808.jfif" alt="图片"></p><p>422就是把232的RX分成两根线，RX+，RX-，把TX分成TX+,TX-。这样就可以同时发送和同时接收了，还可以像485这样，有较远的传输距离。可是这样一种很有优势的通信方式，为什么用的不多呢。我个人的答案和理解就是：线太多了。特别是像我这样懒得接线的人，超过3根线就头晕的。搞个通信还需要接这么多线，什么TX,RX，正啊负啊。交换来交换去。</p><p>因为在很多设备通信中，基本上是属于一问一答式的，因此，232的全双工通信优势其实也并没有发挥出来。就像现在打电话，虽然两个人可以同时说话，但是两个人同时说话，叽叽歪歪的，谁知道说什么呀。特别是一个主站与多个从站通信的时候，485的接线就就方便多了，反正大家就两根线，把+都接一块，把-都接一块。如果是<strong>422作一主多从</strong>，接线上还要理半天呢，而且通信异常了也不好解决。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用Python做文件加密解密</title>
      <link href="/2022/10/14/221014-pyEncrypt/"/>
      <url>/2022/10/14/221014-pyEncrypt/</url>
      
        <content type="html"><![CDATA[<h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><p><a href="https://docs.python.org/zh-cn/3/library/argparse.html#module-argparse">argparse</a> — 命令行选项、参数和子命令解析器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个解析器</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;use for Encrypting/Decrypting.&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-d&#x27;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Decryption command&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-e&#x27;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Encryption command&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-r&#x27;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Rename command&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-p&#x27;</span>, action=<span class="string">&quot;store&quot;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;file path or folder path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    args = <span class="built_in">vars</span>(parser.parse_args())</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>指令 -p 为必须，通过 -p 传入文件或文件夹路径参数，指令 -d -e -r 告知脚本要执行什么任务。</p><p><strong><a href="https://www.runoob.com/python/python-func-vars.html">Python vars() 函数</a></strong> 返回对象object的属性和属性值的字典对象。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\decipherer&gt; python main.py <span class="literal">-p</span> .\test1.c</span><br><span class="line">&#123;<span class="string">&#x27;d&#x27;</span>: False, <span class="string">&#x27;e&#x27;</span>: False, <span class="string">&#x27;r&#x27;</span>: False, <span class="string">&#x27;p&#x27;</span>: <span class="string">&#x27;.\\test1.c&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="解析路径"><a href="#解析路径" class="headerlink" title="解析路径"></a>解析路径</h2><p><a href="https://www.runoob.com/python/python-os-path.html">Python os.path() 模块</a> — 主要用于获取文件的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main_file_path = os.path.dirname(os.path.realpath(__file__))</span><br><span class="line">file_name = os.path.basename(file_path)</span><br><span class="line">file_content = fp.read()</span><br><span class="line">file_name_md5 = hashlib.md5(file_name.encode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>)).hexdigest()</span><br><span class="line">file_relative_path = os.path.realpath(file_path).replace(main_file_path, <span class="string">&#x27;&#x27;</span>)  <span class="comment"># 相对地址</span></span><br><span class="line">file_relative_dir = os.path.dirname(file_path).replace(main_file_path, <span class="string">&#x27;&#x27;</span>)  <span class="comment"># 相对地址不带文件名</span></span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/python3/python3-os-walk.html">Python3 os.walk() 方法</a> — 用于遍历文件夹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rename_dir</span>(<span class="params">dir_path</span>):</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(dir_path, topdown=<span class="literal">False</span>):</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">            rename_file(os.path.join(root, name))</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3/library/shutil.html?highlight=shutil%20rmtree#shutil.rmtree">shutil.rmtree()</a> — 删除一个完整的目录树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&#x27;./output_rename&#x27;</span>):</span><br><span class="line">    shutil.rmtree(<span class="string">&#x27;./output_rename&#x27;</span>)  <span class="comment"># 删除之前的目录</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3/library/os.html?highlight=os%20makedirs#os.makedirs">makedirs()</a> — 递归目录创建函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&#x27;./output_rename&#x27;</span> + file_relative_dir) == <span class="number">0</span>:</span><br><span class="line">    os.makedirs(<span class="string">&#x27;./output_rename&#x27;</span> + file_relative_dir)  <span class="comment"># 如果目录不存在 创建新目录</span></span><br></pre></td></tr></table></figure><h2 id="MD5加解密"><a href="#MD5加解密" class="headerlink" title="MD5加解密"></a>MD5加解密</h2><p><a href="https://docs.python.org/zh-cn/3/library/hashlib.html?highlight=hashlib#hash-algorithms">hashlib</a> — 安全哈希与消息摘要</p><h2 id="字符串编解码"><a href="#字符串编解码" class="headerlink" title="字符串编解码"></a>字符串编解码</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python/att-string-decode.html">string.decode(encoding=’UTF-8’, errors=’strict’)</a></td><td>以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</td></tr><tr><td><a href="https://www.runoob.com/python/att-string-encode.html">string.encode(encoding=’UTF-8’, errors=’strict’)</a></td><td>以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr></tbody></table><p>保存文件名是用encode指定编码格式，再读取时用decode指定格式解码，否则遇到中文字读取会出问题。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread使用笔记</title>
      <link href="/2022/10/13/221013-rtthread/"/>
      <url>/2022/10/13/221013-rtthread/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今天在移植陀螺仪项目时，之前的代码全局变量过多，函数功能不够独立，现在使用国产雅特力MCU，M4主频120MHz，64K ROM，16K RAM，想使用RTOS重新写代码，实践一次嵌入式RTOS编程。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>参考RT-Thread官网教程：<a href="https://www.rt-thread.org/document/site/#/">https://www.rt-thread.org/document/site/#/</a></li></ol><h2 id="开始干"><a href="#开始干" class="headerlink" title="开始干"></a>开始干</h2><h3 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h3><p>选用RT-Thread Nano版本，资源占用小：对 RAM 与 ROM 的开销非常小，在支持 semaphore 和 mailbox 特性，并运行两个线程 (main 线程 + idle 线程) 情况下，ROM 和 RAM 依然保持着极小的尺寸，RAM 占用约 1K 左右，ROM 占用 4K 左右。</p><h3 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h3><p>移植参考官网教程：<a href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-nano/nano-port-keil/an0039-nano-port-keil">使用 MDK 移植</a></p><h4 id="移植时遇到的几个问题"><a href="#移植时遇到的几个问题" class="headerlink" title="移植时遇到的几个问题"></a>移植时遇到的几个问题</h4><ol><li><code>#error &quot;TODO 1: OS Tick Configuration.&quot;</code>一直报错，这个只是编译时提醒我们要配置OS Tick，配置后需手动注释掉这条。</li><li><code>SysTick_Handler()</code>有时进有时不进，检查方法查看SysTick结构体，发现CTRL中使能位0，原因：后面的代码使用了delay函数关闭SysTick的使能位。</li></ol><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="初始化静态线程"><a href="#初始化静态线程" class="headerlink" title="初始化静态线程"></a>初始化静态线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_init</span><span class="params">(<span class="keyword">struct</span> rt_thread* thread,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> (*entry)(<span class="type">void</span>* parameter), <span class="type">void</span>* parameter,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span>* stack_start, <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                        <span class="type">rt_uint8_t</span> priority, <span class="type">rt_uint32_t</span> tick)</span>;</span><br></pre></td></tr></table></figure><h4 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h4><p><code> rt_err_t rt_thread_startup(rt_thread_t thread);</code></p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol><li><p>遇到rt_thread_init()函数卡死，百度竟然啥都查不到（rt-thread用的人这么少的吗），后尝试将栈大小增加至256后成功初始化线程。虽然任务里没什么局部变量，但是一个简单的按键任务竟然占了500多字节内存，可能是因为栈中还保存了寄存器、TCB等信息，那我这单片机16K字节内存可能不够。</p></li><li><p>需要在main函数while(1)中加入rt_thread_mdelay(10); 否则main线程优先级更高，其他线程无法运行。</p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CAN (控制器域网, Controller Area Network)</title>
      <link href="/2022/09/27/220927-CAN/"/>
      <url>/2022/09/27/220927-CAN/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>这几天在做云途单片机的CAN接口移植，学习了CAN通信，还看了一些通信时用到的环形队列、通信协议栈。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p>本文搬运自 <a href="https://zhuanlan.zhihu.com/p/538834760">CAN通信讲解</a> ，自己复习使用</p></li><li><p>s32k144、云途ME0单片机参考手册</p></li></ol><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>CAN是<strong>控制器局域网络</strong>(Controller Area Network, CAN)的简称，是一种能够实现分布式实时控制的串行通信网络。</p><p>CAN的发展历史节点：</p><ul><li><strong>1983</strong>年，BOSCH开始着手开发CAN总线；</li><li><strong>1986</strong>年，在SAE会议上，CAN总线正式发布；</li><li><strong>1987</strong>年，Intel和Philips推出第一款CAN控制器芯片；</li><li><strong>1991</strong>年，奔驰 500E 是世界上第一款基于CAN总线系统的量产车型；</li><li><strong>1991</strong>年，Bosch发布CAN 2.0标准，分 <strong>CAN 2.0A</strong> （11位标识符）和 <strong>CAN 2.0B</strong> （29位标识符）；</li><li><strong>1993</strong>年，ISO发布CAN总线标准（<strong>ISO 11898</strong>），随后该标准主要有三部分：</li><li>ISO 11898-1：数据链路层协议</li><li>ISO 11898-2：高速CAN总线物理层协议，通信速度为 125kbps-1Mbps。</li><li>ISO 11898-3：（整合了ISO11519）低速CAN总线物理层协议，通信速度为 125kbps 以下。</li><li><strong>2011</strong>年，开始CAN FD协议的开发。</li><li><strong>2015</strong>年ISO11898-1进行了修订，将CAN FD加入其中。</li></ul><h2 id="CAN总线协议介绍"><a href="#CAN总线协议介绍" class="headerlink" title="CAN总线协议介绍"></a>CAN总线协议介绍</h2><p>CAN总线协议有CAN1.0、CAN2.0（CAN2.0A、CAN2.0B），其中CAN2.0对比1.0，主要是增加了CAN的扩展帧定义。现在我们所说的CAN通常都是指CAN2.0标准的总线。</p><p>CAN-FD协议在原有的CAN协议基础上，增加了可变波特率、扩大数据场、提升校验算法安全性等改进。</p><p>本文主要讲述CAN的数据通信，CAN-FD的区别会在其他文章单独讲解。</p><h2 id="CAN的物理通信形式"><a href="#CAN的物理通信形式" class="headerlink" title="CAN的物理通信形式"></a>CAN的物理通信形式</h2><p>通过两条通信线（双绞线）产生的电压差传输数据，一个CAN网络里的所有节点都挂在这两条通信线上，使用差分信号半双工通信。</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-23d364e14ef20208bac9b47fed047ada_r.jpg" alt="img"></p><p>CAN 使用称为 CANH / CANL 的通信线路执行传输和接收。没有电位差的信号称为隐性(Recessive)信号，其逻辑值为1。具有电位差的信号称为显性（Dominant）信号，其逻辑值0。如果通信总线上发生显性和隐性(Recessive)冲突，则显性（Dominant）优先。总线空闲时保持隐性。</p><p>CAN总线的物理层逻辑电平，分为高速ISO11898标准（125kbps ~ 1Mbps）和低速ISO11519标准（10kbps ~ 125kbps）；</p><p>低速的物理层电平如图：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-3667818bfa85894c20ee09fb428f363d_r.jpg" alt="img"></p><p>而我们现在通常使用的CAN2.0，都是使用高速CAN标准，其物理层电平如图：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-aabdb0a85b5bc7446840ed2b8c4d788e_r.jpg" alt="img"></p><p>对于高速CAN，总结一下，也就是：</p><ul><li>CAN_H-CAN_L &lt; 0.5V 时候为隐性的，逻辑信号表现为”逻辑1”- 高电平。</li><li>CAN_H-CAN_L &gt; 0.9V 时候为显性的，逻辑信号表现为”逻辑0”- 低电平。</li></ul><p>关于CAN通信的电平传输，一个<strong>重要概念</strong>就是：</p><p>CAN总线在电平传输上，具有仲裁判断逻辑，优先级为：显性（低电平）&gt;隐形（高电平）！</p><p>在理解CAN总线传输的整个过程中，主要就是清楚这一规则在传输时的灵活运用，并定义的各种帧形式。</p><h2 id="CAN的数据格式"><a href="#CAN的数据格式" class="headerlink" title="CAN的数据格式"></a>CAN的数据格式</h2><p>CAN的数据定义了有5种帧类型：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-1f0d94451bb01c75375b4c912012e39d_r.jpg" alt="img"></p><p>其中，遥控帧也常被称为远程帧。CAN的应用开发者只能使用“数据帧”和“遥控帧”，其他的3种帧类型是由CAN的底层固件自动帮我们在特定场景下进行收发，开发者无需担心也无法直接参与控制。</p><p>所以，本文把“数据帧”和“遥控帧”与其他的3种帧类型分别进行介绍。</p><h3 id="数据帧与遥控帧"><a href="#数据帧与遥控帧" class="headerlink" title="数据帧与遥控帧"></a>数据帧与遥控帧</h3><p>关于数据帧，也就是我们最常用的帧类型，用于数据的收发；也是CAN通信里最主要的内容。</p><p>而遥控帧，只是CAN网络里的某一节点发送一个遥控帧请求其他的节点反馈数据给自己，关于<em><strong>遥控帧其实在实际使用中，显得很鸡肋</strong></em>，原因有：</p><p>1、CAN通信作为一种半双工通信形式，在实际使用中的应用层通信协议往往会定义好数据的应答机制与时间间隔，节点与节点之间只要按照协议规定进行数据的收发即可。</p><p>2、遥控帧与数据帧对比，其实就是一条数据长度为0的数据帧而已，只是在帧格式里的仲裁段RTR位为隐性。那么，似乎有数据帧就足够了。</p><p>3、遥控帧的概念定义只是一个预定义，所谓的请求其他节点给自己发送数据并不是强制的，与数据帧一样完全根据应用层协议来规定其具体的使用。</p><p>综上所述，CAN里定义的遥控帧实际作用不大，而且可以用数据帧配合应用协议的定义，进行替代。所以在后来的CAN-FD中已经取消了遥控帧的定义了。</p><p>本文主要以数据帧进行介绍，并简单介绍遥控帧。</p><h3 id="数据帧与遥控帧的数据格式"><a href="#数据帧与遥控帧的数据格式" class="headerlink" title="数据帧与遥控帧的数据格式"></a>数据帧与遥控帧的数据格式</h3><p>不管是Classic CAN Frame还是CANFD Frame，其帧结构都由以下7个段组成：</p><p>— SOF帧起始;</p><p>— arbitration field仲裁段；</p><p>— control field控制段;</p><p>— data field数据段;</p><p>— CRC field;</p><p>— ACK field;</p><p>— EOF.</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-94586126c0989e25599b758d8ecc5295_r.jpg" alt="img"></p><p>这7个段，每个段里又都有自己的格式细分，有两种格式：标准格式和扩展格式。</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-f58bfd8f6bb42cf469dfb4c2243750ca_r.jpg" alt="img"></p><p><strong>CAN的应用开发者只使用其中的仲裁段、控制段和数据段。其他部分都由CAN底层固件自动封装！</strong></p><p>由上图可以看到，对于仲裁段和控制段在标准帧与扩展帧里有不同的定义，其他段一致。</p><h3 id="帧起始与帧结束"><a href="#帧起始与帧结束" class="headerlink" title="帧起始与帧结束"></a>帧起始与帧结束</h3><p>SOF帧起始：由一个显性位（低电平）组成，发送节点发送帧起始，其他节点同步于帧起始；</p><p>EOF帧结束：由7个隐形位（高电平）组成。</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-5d0c0aa1ef7750f0620e92407a09f4b8_r.jpg" alt="img"></p><h3 id="仲裁段"><a href="#仲裁段" class="headerlink" title="仲裁段"></a>仲裁段</h3><h4 id="仲裁机制"><a href="#仲裁机制" class="headerlink" title="仲裁机制"></a>仲裁机制</h4><p>只要总线空闲，总线上任何节点都可以发送报文，如果有两个或两个以上的节点开始传送报文，那么就会存在总线访问冲突的可能。但是CAN使用了标识符的逐位仲裁方法可以解决这个问题。帧ID越小，优先级越高。</p><p>CAN总线控制器在发送数据的同时监控总线电平，如果电平不同，则停止发送并做其他处理。如果该位位于仲裁段，则退出总线竞争；如果位于其他段，则产生错误事件。</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-b31c6be2bf95f5553e9b236fd5f8a562_r.jpg" alt="img"></p><h4 id="仲裁段内容"><a href="#仲裁段内容" class="headerlink" title="仲裁段内容"></a>仲裁段内容</h4><p>RTR位：用于指示这包数据是遥控帧还是数据帧，数据帧的RTR位为显性电平，远程帧为隐性电平。</p><p>所以帧格式和帧ID相同的情况下，数据帧优先于远程帧。</p><p>IDE位：用于指示这包数据是标准帧还是扩展帧，标准帧的IDE位为显性电平，扩展帧的IDE位为隐形电平。</p><p>对于前11位ID相同的标准帧（RTR为显性的遥控帧）和扩展帧，标准帧优先级比扩展帧高。</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-c1baaa702dd521f883248bf5d69357ce_r.jpg" alt="img"></p><p>可以看到，在标准格式里，仲裁段没有IDE位，其实这个位在标准格式里是放在控制段的第一位的，这样就正好可以和扩展格式的IDE位对应上进行仲裁了。</p><h3 id="控制段"><a href="#控制段" class="headerlink" title="控制段"></a>控制段</h3><p>仲裁段之后紧跟控制段，控制段共6位，标准帧的控制段由IDE、保留位r0和数据长度代码DLC组成；扩展帧控制段则由保留位r1、r0和DLC组成，如图：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-d7b37d72e67ba4fdc89dc6374a640754_r.jpg" alt="img"></p><p>在这里可以看到，在标准格式里，IDE位放到了控制段的第一位来了，对应前文仲裁段的内容，就可以使标准格式与扩展格式进行仲裁了。</p><p>保留位（ r0 、 r1 ）：保留位必须全部以显性电平发送。</p><p>数据长度码（ DLC ）：数据的字节数必须为 0 ～ 8 字节。数据帧的DLC表示的就是当前包数据段所带的字节数，遥控帧的DLC表示的是请求返回的数据长度。</p><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p>一个数据帧传输的数据量为0~8个字节。遥控帧的数据段长度固定为0。</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-ea717bbfd46d990dffefa9d6d78e7b88_r.jpg" alt="img"></p><h3 id="CRC段"><a href="#CRC段" class="headerlink" title="CRC段"></a>CRC段</h3><p>CAN-bus使用CRC校验进行数据检错，CRC校验值存放于CRC段。 CRC校验段由15位CRC值和1位CRC界定符构成如图：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-d153142849cef02d8701015681d3ef9b_r.jpg" alt="img"></p><h3 id="ACK段"><a href="#ACK段" class="headerlink" title="ACK段"></a>ACK段</h3><p>当一个接收节点接收的帧起始到CRC段之间的内容没发生错误时，它将在ACK段发送一个显性电平如图：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-123b6f8079ca6645f96c0a4b0379933d_r.jpg" alt="img"></p><h2 id="位填充"><a href="#位填充" class="headerlink" title="位填充"></a>位填充</h2><p>CAN数据在收发上除了会遵循以上数据格式定义之外，还有一个“位填充”的底层规则（类似通信协议里的“转义符”），这个操作是在CAN的底层固件中自动判断执行的，其目的是为了增强数据正确性，以便识别错误信号。</p><p>为防止突发错误而设定，CAN协议中规定，当相同极性的电平持续五位时，则添加一个极性相反的位。填充位的添加和删除是由发送节点和接收节点完成的，CAN-BUS只负责传输，不会操纵信号。</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-1886bf7c09fedcdb6d34a025e4f63d9d_r.jpg" alt="img"></p><ul><li>对于发送节点而言：</li></ul><p>在发送数据帧和遥控帧时，对于SOF~CRC(除去CRC界定符) 之间的位流，相同极性的电平如果持续5位，那么在下一个位插入一个与之前5位反型的电平；</p><ul><li>对于接收节点而言：</li></ul><p>在接收数据帧和遥控帧时，对于SOF~CRC(除去CRC界定符)之间的位流，相同极性的电平如果持续5位，那么需要删除下一位再接收。如果这个第 6 个位的电平与前 5 位相同，将被视为错误并发送<strong>位填充错误帧</strong>。</p><h2 id="错误帧、过载帧与帧间隔"><a href="#错误帧、过载帧与帧间隔" class="headerlink" title="错误帧、过载帧与帧间隔"></a>错误帧、过载帧与帧间隔</h2><p>对于这三种帧，都是在使用数据帧或遥控帧的过程当中进行错误、时序管理的辅助信号，并不会单独出现在CAN网络中；如前文所述是由CAN的底层固件自动判断并执行他们收发的，但是CAN的开发人员有必要对它们进行了解，以对CAN网络有一个整体的认识。</p><h3 id="错误帧"><a href="#错误帧" class="headerlink" title="错误帧"></a>错误帧</h3><p>尽管CAN-bus是可靠性很高的总线，但依然可能出现错误；CAN-bus的错误类型共有5种：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-873a92aa91e65481dc812b1bc85a3841_r.jpg" alt="img"></p><p>当出现5种错误类型之一时，发送或接收节点将发送错误帧。但是错误帧又有两种格式：主动错误格式和被动错误格式。</p><p>主动错误和被动错误，指的并不是发送方与接收方。而是指某一CAN节点的“错误状态”，无论发送方还是接收方，都会处于自己的错误状态，并根据自身的状态来决定自己要发送主动错误格式还是被动错误格式：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-32a00c5310f9ddb0f89f391b60fbd1ae_r.jpg" alt="img"></p><p>由上图可知，6个连续的显性或隐性电平位，正好违反了之前所提及的“位填充”规则，CAN总线设计上就是利用了自己的这一规则对错误数据进行刻意的覆盖破坏，使总线上其他节点都知道错误的发生。</p><h4 id="错误状态"><a href="#错误状态" class="headerlink" title="错误状态"></a>错误状态</h4><p>在CAN节点内，有两个计数器：发送错误计数器（TEC）和接收错误计数器（REC），当该节点检测到错误后，内部REC/TEC计数器会相应的增加，基于REC/TEC的值判定节点状态，CAN的错误状态如图：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-fddf34e76afc765a8030e7ec7feac111_r.jpg" alt="img"></p><p>节点错误状态的转换就是一个 “量变”到“质变” 的过程：</p><ul><li><strong>主动错误状态：【REC&lt;127 且TEC&lt;127】</strong></li></ul><p>初步可判定该节点相对稳定可靠，该错误计数很可能是由于某个节点异常导致的，那么其他节点很可能也会触发该错误，那么允许该节点破坏CAN总线的异常报文并告知其他节点；<br>节点检测到一个错误就会发送带有主动错误标志的错误帧，因为主动错误标志是连续六个显性位，所以这个时候主动错误标志将会“覆盖”掉总线上其它节点的发送，而之前在CAN总线上传输的报文就被这“六个连续显性位”破坏掉了。<br>如果发出主动错误帧的节点是发送节点，这个情况下就相当于：刚刚发送的那一帧报文我发错了，现在我破坏掉它（发送主动错误帧），你们不管收到什么都不算数；</p><p>如果发出主动错误帧的节点是接收节点，这个情况就相当于：刚刚我收报文的时候发现了错误，不管你们有没有发现这个错误，我现在主动站出来告诉大家这个错误，并把这一帧报文破坏掉（发送主动错误帧），刚才你们收到的东西不管对错都不算数了。</p><ul><li><strong>被动错误状态：【REC&gt;128 或TEC&gt;128】</strong></li></ul><p>节点发送错误帧的次数较多，初步可判定该节点相对不可靠，该错误计数很可能是由于自身节点问题导致，即该错误很可能仅有该节点才有，对于其他节点而言是可以正常交互的，总线不信任该节点提供的错误标识，将不允许破坏总线数据，那么允许该节点发送错误帧“6个连续隐性位”至CAN总线，仅告知其他节点异常；<br>如果发出被动错误帧的节点为报文的发送节点，那么在发送被动错误帧之后，刚刚正在发送的报文被破坏，并且该节点不能在错误帧之后随着连续发送刚刚发送失败的那个报文。随之而来的是帧间隔，并且连带着8位隐性位的 “延迟传送” 段；这样总线电平就呈现出连续11位隐性位，总线上的其它节点就能判定总线处于空闲状态，就能参与总线竞争。</p><p>此时如果该节点能够竞争成功，那么它就能接着发送，如果竞争不能成功，那么就接着等待下一次竞争。这种机制的目的正是为了让其它正常节点（处于主动错误）优先使用总线。</p><ul><li><strong>总线关闭状态：【TEC&gt;255】</strong></li></ul><p>一个处于被动错误状态的节点，仍然多次发送被动错误帧，使该节点转为总线关闭态；<br>该节点不能向总线上发送报文，也不能从总线上接收报文，整个节点脱离总线。等到检测到128次11个连续的隐性位时，TEC和REC置0，重新回到主动错误状态。<br>由于存在实现方式的不同，CAN总线关闭状态存在只允许用户请求恢复和检测到128个11位连续的隐性位时自恢复两种不同的恢复形式。</p><p>如果总线上只有一个节点，该节点发送数据帧后得不到应答，TEC最大只能计数到128，即这种情况下节点只会进入被动错误状态而不会进入总线关闭状态。</p><h4 id="错误帧的发送"><a href="#错误帧的发送" class="headerlink" title="错误帧的发送"></a>错误帧的发送</h4><p>按照CAN协议的规定：<br>发生位错误、填充错误、格式错误、ACK错误时，则在错误产生的那一位的下一位开始发送错误帧。<br>发生CRC错误时，紧随ACK界定符后的位发送错误帧。</p><p>错误帧发送完成后，总线空闲时自动重发出错的数据帧。</p><p><strong>【位错误】举例（情况1）：</strong></p><ul><li>设总线上所有节点处于主动错误状态；</li><li>当一个发送节点监控到总线上的位数值与发送的位数值不一致时，检测为位错误，并发送主动错误标志（6个连续的显性位）；</li><li>接收节点接收到发送节点发送的6个连续的显性位时，会检测为位填充错误，也会发送主动错误标志；</li><li>发送节点发送完主动错误标志后，开始监控总线是否为隐性位，当总线为隐性位时，开始发送错误界定符（8个连续的隐性位）；</li><li>当接收节点发送完主动错误标志后，开始向总线发送错误界定符； 等待错误帧发送完成，总线空闲后，发送节点重新发送出错的报文.</li></ul><blockquote><p>由于发送节点发送6个连续的显性位会破坏位填充规则，触发接收节点发送主动错误标志，发送节点和接收节点的结合是形成错误标志叠加部分的原因。</p></blockquote><p><img src="https://hao0527.gitee.io/220927-CAN/v2-2266e218b6061b77c37b34e3eb58c723_r.jpg" alt="img"></p><p><strong>【位错误】举例（情况2）：</strong></p><ul><li>假设发送节点处于被动错误状态，接收节点处于主动错误状态；</li><li>当发送节点监控到总线上的位数值与发送的位数值不一致时，检测为位错误，并发送被动错误标志（6个连续的隐性位）；</li><li>接收节点接收到发送节点发送的6个连续的隐性位时，会检测为位填充错误，并会发送主动错误标志；</li><li>发送节点发送完被动错误标志后，开始监控总线是否为隐性位，当总线为隐性位时，开始发送错误界定符（8个连续的隐性位）；</li><li>接收节点发送完主动错误标志后，开始监控总线是否为隐性位，当总线为隐性位时，开始发送错误界定符（8个连续的隐性位）；</li></ul><p><img src="https://hao0527.gitee.io/220927-CAN/v2-bc7b7162a61a7861ebf895c765122302_r.jpg" alt="img"></p><h3 id="过载帧与帧间隔"><a href="#过载帧与帧间隔" class="headerlink" title="过载帧与帧间隔"></a>过载帧与帧间隔</h3><p>过载帧与主动错误帧非常相似，甚至可以把过载帧直接理解成也是一种错误帧，只是它的错误触发条件不同罢了。</p><p>当某个接收节点没有做好接收下一帧数据的准备时，将发送过载帧以通知发送节点；过载帧由过载标志和过载帧界定符组成，如图所示：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-ae4660f6be52518c6ca8f24b9a5b39ce_r.jpg" alt="img"></p><p>由于存在多个节点同时过载且过载帧发送有时间差问题，可能出现过载标志叠加后超过6个位的现象，如图所示：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-443d97a46a841c5bb2900f0304414ac1_r.jpg" alt="img"></p><p>过载帧是用于接收单元通知发送单元它尚未完成接收准备的帧。在两种情况下，节点会发送过载帧：</p><ul><li>接收单元条件的制约，要求发送节点延缓下一个数据帧或远程帧的传输；</li><li>帧间隔（Intermission）的 <em><strong>3 bit</strong></em> 内检测到显性位</li></ul><p>帧间隔是用于分隔数据帧、遥控帧这些有效数据的帧。数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、 遥控帧、错误帧、过载帧）分开。</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-09da8cc2f7158aeb3e7ab5a05aed0bff_r.jpg" alt="img"></p><p>注意，过载帧和错误帧由于要按照发送条件立即执行，前不能插入帧间隔</p><h2 id="CAN的采样点与波特率"><a href="#CAN的采样点与波特率" class="headerlink" title="CAN的采样点与波特率"></a>CAN的采样点与波特率</h2><p>根据前文描述，由于CAN总线在通信时，每个节点都会不断的监控总线上的实际电平用于仲裁、判断错误等功能，因此CAN定义了采样点这一概念指明节点对总线的监控时间点。</p><p>因为CAN要对总线上特定数据里的每一个位都要进行一次单独的监控，所以这个监控的时间点，指的是在一个“位”的时间范围之内的一个“相对时间”，比如：一个位时间的中间时刻，就把它称为50%采样点（率）。这个解释只是让读者直接理解它的大体概念，实际情况并不是这么简单。</p><p>实际的CAN采样点的位时间划分如下：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-40e0a834157ea339143219a350f88373_r.jpg" alt="img"></p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-88bed791a65bcd50ec1eee089c1f067f_r.jpg" alt="img"></p><p>由上图可知，CAN每发送一个位，需要涉及的内容有：</p><p><strong>时间单元（Tq）：</strong>指的是CAN模块时钟提供的单位时间，与其他的芯片外设一样，任何外设模块都需要提供合适的时钟才能正常工作，在很多芯片里CAN时钟还会配合一个分频器，也就是：CAN时钟= CAN时钟源（如图中的晶振时钟） / CAN_Prescaler。<strong>时间单元</strong>指的就是分频后的实际<strong>CAN时钟</strong>的单位时间。</p><p><strong>位时间：</strong>就是我们理解的<strong>CAN波特率</strong>里一位的时间，由上图可知，CAN每发送一个位都由几个“段”组成，而每个段又需要占用几个“时间单元（Tq）”，所以我们在使用CAN的时候，就需要通过指定这些段的Tq个数来得到CAN的波特率。</p><p><strong>同步段（SS：Synchronization Segment）：</strong>用于同步CAN总线上的各个节点。输入信号的跳变沿就发生在同步段，该段持续时间固定为 1 Tq。同步段用于同步总线上的各个节点，一个位的跳变边沿在此时间段内。</p><p><strong>传播段（PTS：Propagation Time Segment）：</strong>用于补偿各节点之间的物理传输延迟时间。传输延迟时间为信号在总线上传播时间的两倍，包括总线驱动器延迟时间。传播段的长度一般有一个取值范围，不同的控制器不完全一致，典型值为 1 – 8 TQ。在CAN-FD中取消了传播段。</p><p><strong>相位缓冲段1（PBS1：Phase Buffer Segment 1）：</strong>用于补偿节点间的晶振误差，允许通过<strong>重同步（SJW）</strong>对该段<strong>加长</strong>。在该时间段结束时进行总线电平<strong>采样点</strong>的采样。</p><p><strong>相位缓冲段2（PBS2：Phase Buffer Segment 2）：</strong>用于补偿节点间的晶振误差，允许通过<strong>重同步（SJW）</strong>对该段<strong>缩短。</strong></p><p>不同的控制器，PBS1/PBS2 的取值范围不完全一致，一般 PS1 为 1 – 8 TQ，PS2 为 2 – 8 TQ。</p><p>在有的控制器里，把传播段与相位缓冲段1合并称为“<strong>时间段1</strong>”,而相位缓冲段2称为“<strong>时间段2</strong>”，如图：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-0ddb4086a6638f5d70a106bc583e55f6_r.jpg" alt="img"></p><p><strong>重同步（SJW）：</strong>在<strong>时间段1</strong>而不是在<strong>同步段(SS)<strong>检测到有效跳变，那么</strong>相位缓冲段1(PBS1)</strong> 的时间就被延长最多SJW那么长，从而采样点被延迟了。相反如果在<strong>时间段2</strong>而不是在<strong>同步段(SS)<strong>检测到有效跳变，那么</strong>相位缓冲段2(PBS2)</strong> 的时间就被缩短最多SJW那么长，从而采样点被提前了。如图：</p><p><img src="https://hao0527.gitee.io/220927-CAN/v2-e731e178deca7a637b6e36e6976f9d5f_r.jpg" alt="img"></p><p>综上所述：</p><p>CAN时钟 = CAN时钟源 / 分频值CAN_Prescaler；</p><p>CAN波特率 = CAN时钟 / (SS(1Tq) + PTS + PBS1 + PBS2)的Tq总个数；</p><p>CAN采样点（率） = (SS(1Tq) + TSEG1) / (SS(1Tq) + TSEG1 + TSEG2) * 100%</p><p>= (SS(1Tq) + PTS + PBS1) / (SS(1Tq) + PTS + PBS1 + PBS2) * 100%；</p><p><strong>注意：</strong>在实际的CAN使用中，一个CAN网络的各节点最好把采样点设置成一样，如果采样点的设置偏差较大，虽然可能不会造成完全不能通信的情况，但是由于不同节点的判断时间点不同，会造成CAN通信上出现较大概率的错误数据。</p><p>如果发现通信误码率较高，不妨可以排查一下各个节点的CAN采样点设置。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>eeprom， norflash， nandflash</title>
      <link href="/2022/09/09/220909-flash/"/>
      <url>/2022/09/09/220909-flash/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>这几天在做云途单片机的flash接口移植，同时陀螺仪的代码也需要将校准参数保存到flash每次开机读取，于是就看了s32k单片机的flash操作和模拟eeprom，同时看了云途的手册和sdk，也看了stm32闪存编程参考手册和hal库。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.bilibili.com/video/BV1Lx411Z7Qa?p=66&spm_id_from=pageDriver&vd_source=67da16e91bf092509864c6a51f44c92e">【正点原子】 手把手教你学STM32入门教学视频单片机 嵌入式 之 F103-基于新战舰V3/精英/MINI板</a></li><li>《STM32F10xxx闪存编程参考手册》，《STM32 FLASH  模拟 EEPROM 使用和优化》</li><li>云途、s32k的参考手册，云途和stm32的sdk</li><li><a href="https://blog.csdn.net/qq_38179373/article/details/111660812">nor flash原理详细讲解</a></li><li><a href="https://blog.csdn.net/gongjiwei/article/details/83475544">NANDFlash原理</a></li></ol><h2 id="eeprom-norflash-nandflash特性"><a href="#eeprom-norflash-nandflash特性" class="headerlink" title="eeprom, norflash, nandflash特性"></a>eeprom, norflash, nandflash特性</h2><p>搬运自<a href="https://blog.csdn.net/qq_43564374/article/details/122602141">EEPROM, NAND FLASH, NOR FLASH</a></p><h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><p><strong>EEPROM</strong>基于浮栅管单元（Floating gate transister）的结构。 EEPROM 的 单元是由FLOTOX（Floating- gate tuneling oxide transister）及一个附加的Transister 组成。由于FLOTOX 的特性及两管结构，所以可以单bit写。它的每个存储单元并联。</p><p>flash属于广义的EEPROM。FLASH 基于EEPROM， 与EEPROM主要的不同是FLASH 去除了 EEPROM 存储单元里的Tansister， 简化了存储电路(注意不是控制电路)。除此之外FLASH 的浮栅工艺不同， 所以写入速度更快。</p><p><strong>NOR FLASH</strong>的每个存储单元(bit)以并联的方式连接到数据bit线，方便对每一位进行随机存取。同时具有专用的地址线(可以理解为字线)，可以实现byte的直接寻址。NORFLASH具有足够的地址和数据线来映射整个存储区域，类似于SRAM的工作方式。例如，具有16位数据总线的2Gbit（256MB）NOR闪存将具有27条地址线，可以对任何byte进行随机读取访问。所以NORFLASH可以按byte读取。</p><p><strong>NAND FLASH</strong>各存储单元(bit)之间是串联的。在读取数据时，当字线和位线锁定某个晶体管时，该晶体管的控制极不加偏置电压，其它的 7 个都加上偏置电压而导通，如果这个晶体管的浮栅中有电荷就会导通使位线为低电平，读出的数就是 0，反之就是 1。所以每次读取都是读取一行bytes里面的同一个bit， 最后整合为一个块:它是按块读取。</p><h3 id="成本，容量"><a href="#成本，容量" class="headerlink" title="成本，容量"></a>成本，容量</h3><p>EEPROM存储电路并联， 每个bit的存储单元还要多加一个三极管， 最复杂所以单位成本也最高(注意不是控制电路)<br>因此它容量最低。EEPROM都是几十kbytes到几百kbytes，基本没有有超过512K。</p><p>NOR FLASH去除了EEPROM存储单元的三极管，每个存储单元并联， 去除了EEPROM存储单元的三极管， 集成度较小， 所以单位成本高。容量一般为1～16MB。</p><p>NAND FLASH， 去除了EEPROM存储单元的三极管， 各存储单元之间串联， 所以集成度大，单位成本最低。容量一般为8～512MB。</p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>EEPROM和FLASH在写入新数据之前，必须先将一个单元擦除(写 1)。 然后再在相应位写0。</p><p>NOR&amp;NAND FLASH 去除了EEPROM存储单元的三极管。 所以只能整块的擦除。每次擦除只能擦除一行字节的一个bit。这是一个降低了单位成本的折衷办法，因为这容易导致损耗：减少了总擦除/写入次数。擦除块越小擦除越快。 然而擦除块越小芯片面积和存储器成本增加。 与NOR闪存相比NAND闪存可以更经济高效地支持更小的擦除块。目前，NAND闪存的典型块大小为8KB至32KB， NOR Flash为64KB至256KB。</p><p>除此之外在NOR闪存中，每个字节在擦除之前都需要写入“0”。这使得NOR闪存的擦除操作比NAND闪存慢得多。例如，NAND闪存S34ML04G2需要3。5ms才能擦除128KB块，而NOR闪存S70GL02GT则需要约520ms来擦除类似的128KB扇区。这相差近150倍。除此之外NOR的擦除块更大，这就更慢了。</p><p>EEPROM和FLASH的浮栅工艺不同， 所以NANDFLASH写入速度最快， EEPROM居中， NOR最慢。</p><h3 id="读取数据粒度与速度"><a href="#读取数据粒度与速度" class="headerlink" title="读取数据粒度与速度"></a>读取数据粒度与速度</h3><p>EEPROM可以单字节读取。EERPOM一般用于低端产品，读的速度不需要那么快，真要做的话，其实也是可以做的和FLASH 差不多。它的每个存储单元并联。 所以它的特点是可以随机访问和修改任何一个字节，可以往每个bit中写入0或者1。</p><p>NOR FLASH可以单字节读取。NORFLASH的每个存储单元(bit)以并联的方式连接到数据bit线，方便对每一位进行随机存取；同时具有专用的地址线(可以理解为字线)，可以实现byte的直接寻址。NORFLASH具有足够的地址和数据线来映射整个存储区域，类似于SRAM的工作方式。例如，具有16位数据总线的2Gbit（256MB）NOR闪存将具有27条地址线，可以对任何byte进行随机读取访问。所以NORFLASH可以按byte读取， 随机读取(给一个地址读一个字节)时间很短。</p><p>NAND FLASH以页为单位读取。NAND FLASH各存储单元(bit)之间是串联的。在读取数据时，当字线和位线锁定某个晶体管时，该晶体管的控制极不加偏置电压，其它的 7 个都加上偏置电压而导通，如果这个晶体管的浮栅中有电荷就会导通使位线为低电平，读出的数就是 0，反之就是 1。所以每次读取都是读取一行bytes里面的同一个bit， 最后整合为一个页:它是按页读取。 随机读取时间很长。NAND 的全部存储单元分为若干个块，每个块又分为若干个页，每个页是 512byte: 每个页有 512 条位线，每条位线下有 8 个存储单元。</p><p>NAND FLASH每页存储的数据正好跟硬盘的一个块存储的数据相同，这是设计时为了方便与磁盘进行数据交换而特意安排的。在NAND闪存中，使用多路复用地址和数据总线访问存储器。典型的NAND闪存使用8位或16位多路复用地址/数据总线以及其他信号，如芯片使能，写使能，读使能，地址锁存使能，命令锁存使能和就绪/忙碌。 NAND Flash需要提供命令（读，写或擦除），然后是地址和数据。这些额外的操作也使NAND闪存的随机读取速度慢得多。</p><p>NAND闪存的顺序访问持续时间通常低于NOR闪存设备中的随机访问持续时间。利用NOR Flash的随机访问架构，需要在每个读取周期切换地址线，从而累积随机访问以进行顺序读取。随着要读取的数据块的大小增加，NOR闪存中的累积延迟变得大于NAND闪存。因此，NAND Flash顺序读取可以更快。但是由于NAND Flash的初始读取访问持续时间要长得多，两者的性能差异只有在传输大数据块(超过1 KB)时才明显。</p><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>EEPROM存储电路复杂， 具有较高的可靠性， 最稳定可以保存100年。</p><p>NOR FLASH存储电路比复杂， 具有比较高的可靠性。</p><p>NAND FLASH存储电路简单， 可靠性比较低。</p><p>闪存会遭遇称为位翻转的现象，其中一些位可以被反转。这种现象在NAND存储电路简单中所以位翻转比NOR更常见。NAND器件中的坏块是随机分布的。以前也曾有过消除坏块的努力，但发现成品率太低，代价太高，根本不划算。NAND需要对介质进行初始化扫描以发现坏块，并将坏块标记为不可用。一般来说NAND的Block0是没有位翻转的。随着擦除和编程周期在NAND闪存的整个生命周期中持续，更多的存储器单元变坏。因此坏块处理(错误探测/错误更正(EDC/ECC)算法。)是NAND闪存的强制性功能。 这导致NAND的控制器电路复杂。这个问题对于用NAND存储多媒体信息时不是致命的。 但如果用本地存储设备来存储操作系统，配置文件或其他敏感信息时，必须使用EDC/ECC系统以确保可靠性。</p><p>另一方面， NOR闪存坏块少，在存储器的使用寿命期间具有非常低的坏块累积。因此，当涉及存储数据的可靠性时，NOR Flash优于NAND Flash。可靠性的另一个方面是数据保留，这方面，NOR Flash再次占据优势，例如，NOR Flash闪存S70GL02GT提供20年的数据保留，最高可达1K编程/擦除周期，NAND闪存S34ML04G2提供10年的典型数据保留。</p><h3 id="擦除次数"><a href="#擦除次数" class="headerlink" title="擦除次数"></a>擦除次数</h3><p>EEPROM 每次只需要擦除一个字节所以不容易损耗，可以擦写100w次。</p><p>NAND闪存编程和擦除次数比NOR闪存好10倍。在NAND闪存中每个块的最大擦写次数是一百万次，NOR的擦写次数是十万次，NAND存储器除了块擦除次数优势， 典型的NAND块尺寸要比NOR器件小8倍， 每个NAND存储器块在给定的时间内的删除次数要少一些。编程和擦除的数量曾是一个需要考虑的重要特性。随着技术进步，这已不再适用，因为这两种存储器在这方面的性能已经很接近。例如，S70GL02GT NOR和S34ML04G2 NAND都支持100，000个编程 - 擦除次数。但是，由于NAND闪存中使用的块尺寸较小，因此每次操作都会擦除较小的区域， 与NOR Flash相比其整体寿命更长。</p><h3 id="XIP（eXecute-In-Place）"><a href="#XIP（eXecute-In-Place）" class="headerlink" title="XIP（eXecute In Place）"></a>XIP（eXecute In Place）</h3><p>eXecute In Place，即芯片内执行、就地执行，是指CPU直接从存储器中读取程序代码执行，而不用再读到内存中。应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。</p><p>flash内执行是指nor flash不需要初始化，可以直接在flash内执行代码。但往往只执行部分代码，比如初始化RAM。好处即是程序代码无需占用内存，减少内存的要求。</p><p>EEPROM&amp;NORFLASH 可以像内存一样读任意地址(任意字节)，可以XIP，当然这也要看接口是不是内存接口，如果不支持随机读取就一般不行，大部分NOR flash带有SRAM接口，有足够的地址引脚来寻址，可以很容易地存取其内部的每一个字节。可以非常直接地使用基于NOR的闪存，可以像其他存储器那样连接，并可以在上面直接运行代码。有的Norflash可以并行连接实现XIP，也可以串行通过SPI实现XIP。对于PC这需要相应的总线桥(内存控制器)芯片支持， Soc内部要集成相应桥芯片， 挂接到PCIE或者AMBA总线。 桥芯片的硬件逻辑会实现串并转换，总线仲裁，Cache结构，Burst等逻辑。</p><p>NANDFLASH 是按块读取，随机读取太慢所以不适合XIP当然这也要看接口是不是内存接口，如果不支持随机读取就一般不行，NAND使用复杂的I/O口来串行地存取数据。 一般是8个引脚用来传送控制，地址和数据信息 NANDFLASH只是不适合做XIP，但并不是不能做XIP，它坏块多，读取也太慢。比如EMMC启动就必须要把代码load到RAM里才能启动，你看到某些芯片支持EMMC启动，必定是有片内程序把EMMC的代码读到了RAM里。</p><h3 id="驱动复杂程度"><a href="#驱动复杂程度" class="headerlink" title="驱动复杂程度"></a>驱动复杂程度</h3><p>NAND更容易遇到位翻转， 驱动和控制电路要复杂的多。在使用NAND器件时，必须先写入驱动程序，才能继续执行其他操作。NAND在每一行上有CRC位标记，以及一些用于指示行是否为好的位。NAND处理芯片将管理CRC计算，允许在读取时纠正位错误，并管理坏行。</p><p>在USB驱动器中，这一切都由USB接口芯片处理。在SSD中，它由SATA（或其他接口模式）芯片处理，因此CRC错误和坏点映射对用户来说都是不可见的。这意味着在NAND器件上自始至终都必须进行虚拟映射。NAND内存的可靠运行还需要损耗均衡(就是把擦除平均到每个块上)，损耗均衡也由USB或SSD控制器处理，因此用户也不可见。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>通常，NOR闪存是需要较低容量，快速随机读取访问和更高数据可靠性的应用的理想选择，例如代码执行。<br>NAND闪存则非常适用于需要更高内存容量和更快写入和擦除操作的数据存储等应用。</p><p>LINUX嵌入式系统多用一个小容量的nor flash存储引导代码，用一个大容量的nand flash存放文件系统和内核。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ADC采样滤波算法</title>
      <link href="/2022/08/24/220824-adc%E9%87%87%E6%A0%B7/"/>
      <url>/2022/08/24/220824-adc%E9%87%87%E6%A0%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="ADC过采样"><a href="#ADC过采样" class="headerlink" title="ADC过采样"></a>ADC过采样</h2><p>用过不少模块中有ADC采样，如陀螺仪、磁罗盘、气压计、AFE中，都有ADC过采样率的配置，这些模块配置过采样率，输出的ADC量化位数没变，ADC值静态偏移量减小（信噪比提高），所以可以理解为多次采样取平均值。使用ADC过采样能提升精度，但是由于输出ADC值为多次采样平均，并不是单次采样时刻的值，AFE采电池电压的同时采电流，电压的值不是采电流那一时刻的瞬时值，导致SOC估算不准确。使用ADC过采样会提升采样次数，增大ADC的功耗。</p><p>下面来说说书里介绍的过采样。首先是结论：<strong>过采样率每提高4倍，可以提高ADC 1bit的有效分辨率</strong>。</p><p>假设ADC过采样率为4，ADC会采集4次将值相加，这其实增加了2bits的有效分辨率，这个过程还需要降低采样，或者下抽，下抽是将四次采样累计值&gt;&gt;1，这么做除了降低数据量外，就是可以提高分辨率。</p><h2 id="ADC降采样-减采样-下采样-down-sampling"><a href="#ADC降采样-减采样-下采样-down-sampling" class="headerlink" title="ADC降采样(减采样/下采样/down sampling)"></a>ADC降采样(减采样/下采样/down sampling)</h2><p>降采样网上的资料比较少，一般是原有的采样率比实际信号的有效最高频率要高很多，就可以对采到的信号做低通滤波，除去高频干扰后向下抽样。</p><p>采样这一块还得向香农和奈奎斯特学习，<a href="https://baike.baidu.com/item/%E9%A6%99%E5%86%9C%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86/7259506">香农-奈奎斯特采样定理</a>，当一个信号被减采样时，必须满足采样定理以避免混叠。为了满足采样定理的要求，信号在进行减采样操作前，必须通过一个具有适当截止频率的低通滤波器。这个用于避免混叠的低通滤波器，称为抗混叠滤波器。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GPS报文解析</title>
      <link href="/2022/08/17/220817-gps/"/>
      <url>/2022/08/17/220817-gps/</url>
      
        <content type="html"><![CDATA[<h2 id="GPS模块"><a href="#GPS模块" class="headerlink" title="GPS模块"></a>GPS模块</h2><p>商品链接：<a href="https://detail.tmall.com/item.htm?spm=a1z0d.6639537/tb.1997196601.377.28fa7484mpFNB4&id=619952916530&skuId=4626828970522">Beitian北天高精度GPS模块NEO-M8M陶瓷天线GPS北斗GLONASS三模GNSS授时BN-357</a></p><p>输出协议：NMEA-0183协议</p><h2 id="NMEA-0183协议"><a href="#NMEA-0183协议" class="headerlink" title="NMEA-0183协议"></a>NMEA-0183协议</h2><p><code>&lt;CR&gt;</code> 回车，(ASCII 13, \r)<br><code>&lt;LF&gt;</code> 换行，(ASCII 10, \n)<br><code>hh</code> 报文$到*之间数据的异或校验</p><h3 id="RMC"><a href="#RMC" class="headerlink" title="RMC"></a>RMC</h3><p>Recommended Minimum Specific GPS/TRANSIT Data（<strong>RMC</strong>）推荐定位信息</p><p>报文：<code>$GPRMC,&lt;1&gt;,&lt;2&gt;,&lt;3&gt;,&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;,&lt;8&gt;,&lt;9&gt;,&lt;10&gt;,&lt;11&gt;,&lt;12&gt;*hh&lt;CR&gt;&lt;LF&gt;</code><br>&lt;1&gt; UTC 时间，hhmmss.sss（时分秒）格式<br>&lt;2&gt; 定位状态，A=有效定位，V=无效定位<br>&lt;3&gt; 纬度ddmm.mmmm（度分）格式（前面的0也将被传输）<br>&lt;4&gt; 纬度半球N（北半球）或S（南半球）<br>&lt;5&gt; 经度dddmm.mmmm（度分）格式（前面的0也将被传输）<br>&lt;6&gt; 经度半球E（东经）或W（西经）<br>&lt;7&gt; 地面速率（000.0~999.9 节，前面的0 也将被传输）<br>&lt;8&gt; 地面航向（000.0~359.9 度，以真北为参考基准，前面的0 也将被传输）<br>&lt;9&gt; UTC 日期，ddmmyy（日月年）格式<br>&lt;10&gt; 磁偏角（000.0~180.0 度，前面的0 也将被传输）<br>&lt;11&gt; 磁偏角方向，E（东）或W（西）<br>&lt;12&gt; 模式指示（仅NMEA0183 3.00 版本输出，A=自主定位，D=差分，E=估算，N=数据无效）</p><h3 id="GGA"><a href="#GGA" class="headerlink" title="GGA"></a>GGA</h3><p>Global Positioning System Fix Data（<strong>GGA</strong>）GPS 定位信息</p><p>报文：<code>$GPGGA,&lt;1&gt;,&lt;2&gt;,&lt;3&gt;,&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;,&lt;8&gt;,&lt;9&gt;,M,&lt;10&gt;,M,&lt;11&gt;,&lt;12&gt;*hh&lt;CR&gt;&lt;LF&gt;</code><br>&lt;1&gt; UTC 时间，hhmmss.sss（时分秒）格式<br>&lt;2&gt; 纬度ddmm.mmmm（度分）格式（前面的0 也将被传输）<br>&lt;3&gt; 纬度半球N（北半球）或S（南半球）<br>&lt;4&gt; 经度dddmm.mmmm（度分）格式（前面的0 也将被传输）<br>&lt;5&gt; 经度半球E（东经）或W（西经）<br>&lt;6&gt; GPS 状态：0=未定位，1=非差分定位，2=差分定位，6=正在估算<br>&lt;7&gt; 正在使用解算位置的卫星数量（00~12）（前面的0 也将被传输）<br>&lt;8&gt; HDOP 水平精度因子（0.5~99.9）<br>&lt;9&gt; 海拔高度（-9999.9~99999.9）<br>&lt;10&gt; 地球椭球面相对大地水准面的高度<br>&lt;11&gt; 差分时间（从最近一次接收到差分信号开始的秒数，如果不是差分定位将为空<br>&lt;12&gt; 差分站ID 号0000~1023（前面的0 也将被传输，如果不是差分定位将为空）</p><h3 id="GSA"><a href="#GSA" class="headerlink" title="GSA"></a>GSA</h3><p>GPS DOP and Active Satellites（<strong>GSA</strong>）当前卫星信息</p><p>报文：<code>$GPGSA,&lt;1&gt;,&lt;2&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;4&gt;,&lt;5&gt;,&lt;6&gt;*hh&lt;CR&gt;&lt;LF&gt;</code><br>&lt;1&gt; 模式，M=手动，A=自动<br>&lt;2&gt; 定位类型，1=没有定位，2=2D 定位，3=3D 定位<br>&lt;3&gt; PRN 码（伪随机噪声码），正在用于解算位置的卫星号（01~32，前面的0 也将被传输）<br>&lt;4&gt; PDOP 位置精度因子（0.5~99.9）<br>&lt;5&gt; HDOP 水平精度因子（0.5~99.9）<br>&lt;6&gt; VDOP 垂直精度因子（0.5~99.9）</p><h3 id="GSV"><a href="#GSV" class="headerlink" title="GSV"></a>GSV</h3><p>报文：<code>$GPGSV,&lt;1&gt;,&lt;2&gt;,&lt;3&gt;,&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;,…&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;*hh&lt;CR&gt;&lt;LF&gt;</code></p><p>&lt;1&gt; GSV 语句的总数<br>&lt;2&gt; 本句GSV 的编号<br>&lt;3&gt; 可见卫星的总数（00~12，前面的0 也将被传输）<br>&lt;4&gt; PRN 码（伪随机噪声码）（01~32，前面的0 也将被传输）<br>&lt;5&gt; 卫星仰角（00~90 度，前面的0 也将被传输）<br>&lt;6&gt; 卫星方位角（000~359 度，前面的0 也将被传输）<br>&lt;7&gt; 信噪比（00~99dB，没有跟踪到卫星时为空，前面的0 也将被传输）<br>注：&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;信息将按照每颗卫星进行循环显示，每条GSV 语句最多可以显示4 颗卫星的信息。其他卫星信息将在下一序列的NMEA0183 语句中输出。</p><h3 id="VTG"><a href="#VTG" class="headerlink" title="VTG"></a>VTG</h3><p>Track Made Good and Ground Speed（<strong>VTG</strong>）地面速度信息</p><p>报文：<code>$GPVTG,&lt;1&gt;,T,&lt;2&gt;,M,&lt;3&gt;,N,&lt;4&gt;,K,&lt;5&gt;*hh&lt;CR&gt;&lt;LF&gt;</code><br>&lt;1&gt; 以真北为参考基准的地面航向（000~359 度，前面的0 也将被传输）<br>&lt;2&gt; 以磁北为参考基准的地面航向（000~359 度，前面的0 也将被传输）<br>&lt;3&gt; 地面速率（000.0~999.9 节，前面的0 也将被传输）<br>&lt;4&gt; 地面速率（0000.0~1851.8 公里/小时，前面的0 也将被传输）<br>&lt;5&gt; 模式指示（仅NMEA0183 3.00 版本输出，A=自主定位，D=差分，E=估算，N=数据无效）</p><h3 id="GLL"><a href="#GLL" class="headerlink" title="GLL"></a>GLL</h3><p>Geographic Position（<strong>GLL</strong>）定位地理信息</p><p>报文：<code>$GPGLL,&lt;1&gt;,&lt;2&gt;,&lt;3&gt;,&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;*hh&lt;CR&gt;&lt;LF&gt;</code><br>&lt;1&gt; 纬度ddmm.mmmm（度分）格式（前面的0 也将被传输）<br>&lt;2&gt; 纬度半球N（北半球）或S（南半球）<br>&lt;3&gt; 经度dddmm.mmmm（度分）格式（前面的0 也将被传输）<br>&lt;4&gt; 经度半球E（东经）或W（西经）<br>&lt;5&gt; UTC 时间，hhmmss（时分秒）格式<br>&lt;6&gt; 定位状态，A=有效定位，V=无效定位<br>&lt;7&gt; 模式指示（仅NMEA0183 3.00 版本输出，A=自主定位，D=差分，E=估算，N=数据无效）</p><h2 id="str转int-float函数"><a href="#str转int-float函数" class="headerlink" title="str转int/float函数"></a>str转int/float函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hexStr2Int</span><span class="params">(<span class="type">char</span> *pStr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*pStr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">num *= <span class="number">16</span>;</span><br><span class="line">num += *pStr - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(*pStr &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">num *= <span class="number">16</span>;</span><br><span class="line">num += *pStr - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(*pStr &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">num *= <span class="number">16</span>;</span><br><span class="line">num += *pStr - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">decStr2Int</span><span class="params">(<span class="type">char</span> *pStr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> isMinus = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(*pStr == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">isMinus = <span class="number">1</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(*pStr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">num *= <span class="number">10</span>;</span><br><span class="line">num += *pStr - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isMinus)</span><br><span class="line">num = -num;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">str2Float</span><span class="params">(<span class="type">char</span> *pStr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> intNum = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> isMinus = <span class="number">0</span>;</span><br><span class="line">intNum = decStr2Int(pStr);</span><br><span class="line"><span class="keyword">if</span>(*pStr == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">isMinus = <span class="number">1</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(*pStr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(*pStr == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">pStr++;</span><br><span class="line"><span class="keyword">if</span>(*pStr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">num = decStr2Int(pStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(*pStr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">num /= <span class="number">10.f</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isMinus)</span><br><span class="line">num = intNum - num;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">num = intNum + num;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找char和异或校验函数"><a href="#查找char和异或校验函数" class="headerlink" title="查找char和异或校验函数"></a>查找char和异或校验函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">findChar</span><span class="params">(<span class="type">uint8_t</span> findValue, <span class="type">uint8_t</span> *pStr, <span class="type">uint16_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++, pStr++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*pStr == findValue)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0xffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint8_t</span> <span class="title function_">calcXorCheck</span><span class="params">(<span class="type">uint8_t</span> *pStart, <span class="type">uint8_t</span> *pEnd)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(pStart &lt; pEnd)</span><br><span class="line">&#123;</span><br><span class="line">ret ^= *pStart;</span><br><span class="line">pStart++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="utcTime增加一秒函数"><a href="#utcTime增加一秒函数" class="headerlink" title="utcTime增加一秒函数"></a>utcTime增加一秒函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">gps_addSecondUtcTime</span><span class="params">(<span class="type">uint32_t</span> now)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> hh, mm, ss;</span><br><span class="line">ss = now%<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(ss &lt; <span class="number">59</span>)</span><br><span class="line">&#123;</span><br><span class="line">now++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ss = <span class="number">0</span>;</span><br><span class="line">mm = (now/<span class="number">100</span>)%<span class="number">100</span>;</span><br><span class="line">hh = (now/<span class="number">10000</span>)%<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(mm &lt; <span class="number">59</span>)</span><br><span class="line">&#123;</span><br><span class="line">mm++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">mm = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(hh &lt; <span class="number">23</span>)</span><br><span class="line">&#123;</span><br><span class="line">hh++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">hh = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">now = hh*<span class="number">10000</span> + mm*<span class="number">100</span> + ss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析函数"><a href="#解析函数" class="headerlink" title="解析函数"></a>解析函数</h2><p>Github：<a href="https://github.com/hao0527/gps_data_parse">https://github.com/hao0527/gps_data_parse</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows C/C++编程</title>
      <link href="/2022/07/31/220731-WindowsC%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/07/31/220731-WindowsC%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows串口接收代码"><a href="#Windows串口接收代码" class="headerlink" title="Windows串口接收代码"></a>Windows串口接收代码</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/weixin_39100510/article/details/124292893">windows串口通信函数API</a></li><li><a href="http://www.yfvb.com/help/win32sdk/webhelplefth.htm">Win32API参考手册</a></li><li><a href="http://t.zoukankan.com/zhuguanhao-p-2887210.html">使用CreateFile()打开COM10及以上串口的问题</a></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">serial_openSerial</span><span class="params">(<span class="type">void</span>* lpFileName, <span class="type">unsigned</span> <span class="type">int</span> baudRate, <span class="type">unsigned</span> <span class="type">int</span> dwInQueue, <span class="type">unsigned</span> <span class="type">int</span> dwOutQueue)</span> &#123;</span><br><span class="line">    HANDLE hComm = <span class="literal">NULL</span>;</span><br><span class="line">    DCB dcb;</span><br><span class="line">    COMMTIMEOUTS commTimeOuts;</span><br><span class="line">    hComm = CreateFile(lpFileName,       <span class="comment">//串口名称</span></span><br><span class="line">                        GENERIC_READ | GENERIC_WRITE, <span class="comment">//允许读和写</span></span><br><span class="line">                        <span class="number">0</span>,             <span class="comment">//独占方式</span></span><br><span class="line">                        <span class="literal">NULL</span>,          <span class="comment">// 无安全属性，不可被子程序继承</span></span><br><span class="line">                        OPEN_EXISTING, <span class="comment">//创建文件的性质，打开而不是创建</span></span><br><span class="line">                        <span class="number">0</span>,             <span class="comment">// Non Overlapped I/O</span></span><br><span class="line">                        <span class="literal">NULL</span>);         <span class="comment">// Null for Comm Devices</span></span><br><span class="line">    SetupComm(hComm, dwInQueue, dwOutQueue);</span><br><span class="line">    GetCommState(hComm, &amp;dcb);</span><br><span class="line">    dcb.BaudRate = baudRate;</span><br><span class="line">    SetCommState(hComm, &amp;dcb);</span><br><span class="line">    commTimeOuts.ReadIntervalTimeout = <span class="number">0</span>;</span><br><span class="line">    commTimeOuts.ReadTotalTimeoutMultiplier = <span class="number">0</span>;</span><br><span class="line">    commTimeOuts.ReadTotalTimeoutConstant = <span class="number">0</span>;</span><br><span class="line">    commTimeOuts.WriteTotalTimeoutMultiplier = <span class="number">0</span>;</span><br><span class="line">    commTimeOuts.WriteTotalTimeoutConstant = <span class="number">0</span>;</span><br><span class="line">    SetCommTimeouts(hComm, &amp;commTimeOuts);<span class="comment">// 配置Timeout参数(ms)，0表示不Timeout</span></span><br><span class="line">    <span class="keyword">return</span> hComm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">serial_readLen</span><span class="params">(<span class="type">void</span>* hComm, <span class="type">unsigned</span> <span class="type">char</span>* pBuff, <span class="type">unsigned</span> <span class="type">int</span> len, <span class="type">unsigned</span> <span class="type">int</span>* pLenRead)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ReadFile(hComm, pBuff, len, pLenRead, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">serial_closeSerial</span><span class="params">(<span class="type">void</span>* hComm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CloseHandle(hComm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">serial_purgeSerial</span><span class="params">(<span class="type">void</span>* hComm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PurgeComm(hComm, PURGE_RXCLEAR | PURGE_TXCLEAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>Windows.h的api是<strong>正确返回非0</strong></p><h2 id="不同系统编译各数据类型所占内存空间大小"><a href="#不同系统编译各数据类型所占内存空间大小" class="headerlink" title="不同系统编译各数据类型所占内存空间大小"></a>不同系统编译各数据类型所占内存空间大小</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th>类型</th><th>win32</th><th>win64</th><th>linux32</th><th>linux64</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>short</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>int</td><td>4</td><td>4</td><td>4</td><td>4</td></tr><tr><td>long</td><td>4</td><td>4</td><td>4</td><td>8</td></tr><tr><td>long long</td><td>8</td><td>8</td><td>8</td><td>8</td></tr><tr><td>float</td><td>4</td><td>4</td><td>4</td><td>4</td></tr><tr><td>double</td><td>8</td><td>8</td><td>8</td><td>8</td></tr><tr><td>void*</td><td>4</td><td>8</td><td>4</td><td>8</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>指针所占空间看系统是16位、32位还是64位。</li><li>win64把long编成4字节，linux64把long编成8字节。</li><li>在32位系统中，int和long都是4字节，取值范围相同。</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX使用上遇到的一些问题</title>
      <link href="/2022/07/31/220731-CubeMX/"/>
      <url>/2022/07/31/220731-CubeMX/</url>
      
        <content type="html"><![CDATA[<h2 id="使用DMA发送串口数据问题"><a href="#使用DMA发送串口数据问题" class="headerlink" title="使用DMA发送串口数据问题"></a>使用DMA发送串口数据问题</h2><ol><li>CubeMX生成的代码初始化DMA和UART顺序问题，应该先初始化DMA再UART，可以在CubeMX中调整生成初始化代码的顺序。<img src="https://hao0527.gitee.io/220731-CubeMX/2207031-CubeMX-1.jpg" alt="2207031-CubeMX-1.jpg"></li><li>CubeMX生成的代码使用<code>HAL_UART_Transmit_DMA()</code>后需要手动将串口状态配置成空闲状态，可以在DMA传输完成中断中加<code>(&amp;huart1)-&gt;gState = HAL_UART_STATE_READY;</code></li></ol><h2 id="串口接收溢出后接收不到数据"><a href="#串口接收溢出后接收不到数据" class="headerlink" title="串口接收溢出后接收不到数据"></a>串口接收溢出后接收不到数据</h2><ol><li>产生问题的原因：超出接收size、在没接收的时候接收超过1个字节的数据。</li><li>解决方法参考：<a href="https://blog.csdn.net/chengj_/article/details/122689442">stm32cube，HAL库 HAL_UART_Receive_IT中断接收多个字符，串口溢出卡死问题</a>。</li><li>关闭检测Overrun功能，或者使用错误处理回调函数。</li></ol><h2 id="串口接收一帧不定长数据"><a href="#串口接收一帧不定长数据" class="headerlink" title="串口接收一帧不定长数据"></a>串口接收一帧不定长数据</h2><ol><li>可使用<code>tm32f7xx_hal_uart_ex.h</code>中的<code>HAL_UARTEx_ReceiveToIdle()</code>函数。</li></ol><h2 id="HAL库操作Flash"><a href="#HAL库操作Flash" class="headerlink" title="HAL库操作Flash"></a>HAL库操作Flash</h2><ol><li>参考：<a href="https://blog.csdn.net/shoufei403/article/details/81978731">基于STM32F407 HAL库的Flash编程操作</a> 和 STM32F10xxx闪存编程参考手册</li><li>在每次擦除或编程前先要解锁Flash，在HAL库中，只需要调用<code>stm32f1xx_hal_flash.h</code>中的<code>HAL_FLASH_Unlock()</code>函数。</li><li>擦除时最小要以页为单位，传入的地址需要注意是否是页的起始地址。</li><li>编程时要注意4字节对齐，不同单片机可能不同。</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用Python统计花费</title>
      <link href="/2022/07/24/220724-python%E8%B4%A6%E6%9C%AC%E5%A4%84%E7%90%86/"/>
      <url>/2022/07/24/220724-python%E8%B4%A6%E6%9C%AC%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>不喜欢用现成的账本app记账，喜欢在手机记事本里记账，没次统计花费总额都需要按计算器，比较麻烦也不确定会不会按错，所以用Python写个脚本算算总共花费多少，额外也可以统计些自己想知道的数据。</p><h2 id="账本格式"><a href="#账本格式" class="headerlink" title="账本格式"></a>账本格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7.8 两餐-29 电费-57 开箱-30 充气宝-160</span><br><span class="line">7.9 一餐-10 充话费-54</span><br><span class="line">7.10 两餐-33 鼠标脚垫-11 早餐包-24</span><br><span class="line">7.11 两餐-22 出行-7 理发-13</span><br></pre></td></tr></table></figure><h2 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">costStruct = [  &#123;&#x27;date&#x27;: &#x27;7.1&#x27;, &#x27;item&#x27;: [&#x27;两餐&#x27;], &#x27;consume&#x27;: [33]&#125;,</span></span><br><span class="line"><span class="string">                &#123;&#x27;date&#x27;: &#x27;7.2&#x27;, &#x27;item&#x27;: [&#x27;两餐&#x27;, &#x27;遮阳布&#x27;, &#x27;出行&#x27;], &#x27;consume&#x27;: [25, 6, 13]&#125;,</span></span><br><span class="line"><span class="string">                ...</span></span><br><span class="line"><span class="string">             ]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">costStruct = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file=<span class="string">&#x27;cost.txt&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    costStrList = fp.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除空白行</span></span><br><span class="line">delNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(costStrList)):</span><br><span class="line">    j = i - delNum</span><br><span class="line">    costStrList[j] = costStrList[j].strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(costStrList[j].replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)) == <span class="number">0</span>:</span><br><span class="line">        delNum = delNum + <span class="number">1</span></span><br><span class="line">        <span class="keyword">del</span>(costStrList[j])</span><br><span class="line"><span class="comment"># print(costStrList)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(costStrList)):</span><br><span class="line">    costDic = &#123;<span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;item&#x27;</span>: [], <span class="string">&#x27;consume&#x27;</span>: []&#125;</span><br><span class="line">    strList = costStrList[i].split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    costDic[<span class="string">&#x27;date&#x27;</span>] = strList[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(strList)):</span><br><span class="line">        cost = strList[j].split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        costDic[<span class="string">&#x27;item&#x27;</span>].append(cost[<span class="number">0</span>])</span><br><span class="line">        costDic[<span class="string">&#x27;consume&#x27;</span>].append(<span class="built_in">int</span>(cost[<span class="number">1</span>]))</span><br><span class="line">    costStruct.append(costDic)</span><br><span class="line"><span class="comment"># print(costStruct)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算总共花费</span></span><br><span class="line">dayCost = []</span><br><span class="line">dateStr = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(costStruct)):</span><br><span class="line">    dayCost.append(<span class="built_in">sum</span>(costStruct[i][<span class="string">&#x27;consume&#x27;</span>]))</span><br><span class="line">    dateStr.append(costStruct[i][<span class="string">&#x27;date&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(costStruct[i][<span class="string">&#x27;date&#x27;</span>] + <span class="string">&#x27; cost ￥&#x27;</span> + <span class="built_in">str</span>(dayCost[i]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;total cost ￥&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">sum</span>(dayCost)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">3</span>+<span class="number">0.25</span>*<span class="built_in">len</span>(dayCost), <span class="number">8</span>), dpi=<span class="number">100</span>)    <span class="comment"># 自适应长度</span></span><br><span class="line">plt.bar(dateStr, dayCost)</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;total cost &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">sum</span>(dayCost)) + <span class="string">&#x27; yuan&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;consume&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>代码存放在<a href="https://github.com/hao0527/costSummary">https://github.com/hao0527/costSummary</a>，以后有新的统计分析需求，会直接在我的Github更新。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RC振荡器 晶体振荡器</title>
      <link href="/2022/07/10/220710-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/"/>
      <url>/2022/07/10/220710-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="RC振荡器"><a href="#RC振荡器" class="headerlink" title="RC振荡器"></a>RC振荡器</h2><p>在振荡电路中的频率选择部分可以只用电阻和电容构成，这种只用电阻和电容构成的振荡器称为RC振荡器。RC振荡器需要起振电路，常用的正弦波荡电路有文氏桥振荡电路，要起振所以电路是正反馈，RC构成选频网络，两个二极管和R3构成稳幅电路。</p><p><img src="https://hao0527.gitee.io/220710-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8-1.jpg" alt="2207010-RC与晶体振荡器-1.jpg"></p><p>RC振荡器容易封装到芯片中，MCU内部的时钟一般就是RC振荡器。成本低、功耗小、电路板上无需外部晶振，这些都是RC振荡器的优点。</p><p>缺点：MCU的内部振荡电路对外界干扰很敏感，非常容易受到外界环境温度的影响。同时精度也低，下图是用F767内部和外部振荡器生成1Hz方波的区别。</p><p><img src="https://hao0527.gitee.io/220710-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8-2.jpg" alt="2207010-RC与晶体振荡器-2.jpg"></p><h2 id="晶体振荡器"><a href="#晶体振荡器" class="headerlink" title="晶体振荡器"></a>晶体振荡器</h2><p>只要在晶体板级上施加交变电压，就会是晶片产生机械变形振动，此现象即所谓逆压电效应。当外加电压频率等于晶体谐振器的固有频率时，就会发生压电谐振，从而导致机械变形的振幅突然增大。一般而言，晶振的振荡频率比较稳定。但是价格稍微高点，还有用晶体振荡器一般还要接两个15-33pF起振电容。</p><p>有源晶振（Oscillator，晶振）只需要供电自身就能起振，无源晶振（Crystal，晶体）最高精度为5ppm，而有源晶振的精度则可以达到0.1ppm。有源晶振的信号电平是固定，所以需要选择好合适输出电平，灵活性较差。无源晶振单片机可以配置振荡输出电压。</p><p><img src="https://hao0527.gitee.io/220710-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8-3.jpg" alt="有源晶振"><img src="https://hao0527.gitee.io/220710-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8-4.jpg" alt="无源晶振"></p><h2 id="STM32CubeMX中的时钟配置"><a href="#STM32CubeMX中的时钟配置" class="headerlink" title="STM32CubeMX中的时钟配置"></a>STM32CubeMX中的时钟配置</h2><p><img src="https://hao0527.gitee.io/220710-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8-5.jpg" alt="STM32中的时钟配置"></p><p>BYPASS Clock Source：使用有源晶振的话，则只需要给它加上电源，即可输出时钟到MCU的时钟输入端，绕过MCU的OSC模块，时钟直接供MCU使用。</p><p>Crystal/Ceramic Resonator：使用晶体的话，除了外部需要加上谐振电容（有些会加上MΩ的反馈电阻）之外，还需要<strong>MCU内部的OSC振荡电路辅助</strong>才能正常产生所需时钟。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Xilinx FPGA 点灯</title>
      <link href="/2022/07/08/220708-XilinxFPGA%E7%82%B9%E7%81%AF/"/>
      <url>/2022/07/08/220708-XilinxFPGA%E7%82%B9%E7%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="好久不见，甚是想念"><a href="#好久不见，甚是想念" class="headerlink" title="好久不见，甚是想念"></a>好久不见，甚是想念</h2><p>一个多月没写博客了，毕业后学习时间少了，白天忙公司的项目，偶尔晚上有空看看自己想学的资料，自己还在做个地质分析仪的项目，每周日会花一天的时间做。为自己加油，2022年我还要完成这块FPGA的学习，感谢那位支持我学这块开发板的人。</p><h2 id="安装Vivado"><a href="#安装Vivado" class="headerlink" title="安装Vivado"></a>安装Vivado</h2><ol><li>下载vivado安装包，资料链接B盘：<a href="https://pan.baidu.com/s/1eM7Sx-RmeYFE1ht_RPqxhw">https://pan.baidu.com/s/1eM7Sx-RmeYFE1ht_RPqxhw</a> 提取码：a8vu</li><li>解压安装包到<strong>无中文路径的目录</strong>下，否则会出现安装包无法打开的情况。打开安装包，我在安装选件的页面取消了K系列、V系列和Soc Zynq的选件，安装空间要70GB左右，因此我还买了个1T的固态。</li><li>激活只需要网上下载对应版本的激活licences，在激活页面load a licences即可。</li></ol><h2 id="软件操作"><a href="#软件操作" class="headerlink" title="软件操作"></a>软件操作</h2><ol><li>Tools -&gt; Settings -&gt; Text Editor中选择编辑器，我选择的是notepad++，需要将编辑器路径加到系统环境变量。</li><li>创建PLL IP核：<img src="https://hao0527.gitee.io/220708-XilinxFPGA%E7%82%B9%E7%81%AF/220708-XilinxFPGA%E7%82%B9%E7%81%AF-2.jpg" alt="220708-XilinxFPGA点灯-2.jpg"></li><li>功能仿真，RTL分析，综合，约束输入，设计实现都在左侧的Flow Navigator中。</li></ol><h2 id="流水灯"><a href="#流水灯" class="headerlink" title="流水灯"></a>流水灯</h2><ol><li>New Project，芯片选择xc7a35tfgg484-2。<img src="https://hao0527.gitee.io/220708-XilinxFPGA%E7%82%B9%E7%81%AF/220708-XilinxFPGA%E7%82%B9%E7%81%AF-1.jpg" alt="220708-XilinxFPGA点灯-1.jpg"></li><li>Add Sources -&gt; Create File，创建led_top.v文件。</li><li>Vivado中打开文件会调用Notepad++编辑器，编写流水灯代码：<img src="https://hao0527.gitee.io/220708-XilinxFPGA%E7%82%B9%E7%81%AF/220708-XilinxFPGA%E7%82%B9%E7%81%AF-5.jpg" alt="220708-XilinxFPGA点灯-5.jpg"></li><li>再功能仿真（可选），再综合、约束输入。</li><li>最后生成bit流下载到开发板：<img src="https://hao0527.gitee.io/220708-XilinxFPGA%E7%82%B9%E7%81%AF/220708-XilinxFPGA%E7%82%B9%E7%81%AF-4.jpg" alt="220708-XilinxFPGA点灯-4.jpg"></li><li>Xilinx的集成开发环境要比Altera的好用不少，就是编译速度较慢。</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>交叉编译工具链的使用</title>
      <link href="/2022/05/22/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
      <url>/2022/05/22/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="交叉编译简介"><a href="#交叉编译简介" class="headerlink" title="交叉编译简介"></a>交叉编译简介</h2><p>交叉编译，是一个和本地编译相对应的概念，交叉编译通俗地讲就是一种平台上编译出的程序能够运行在不同体系结构的平台上，比如在PC平台（X86 CPU）上编译出能运行在ARM CPU的程序。</p><h2 id="使用交叉编译的原因"><a href="#使用交叉编译的原因" class="headerlink" title="使用交叉编译的原因"></a>使用交叉编译的原因</h2><p>主要原因是：嵌入式系统中的资源太少。具体的解释就是：所要运行的目标环境中，各种资源，都相对有限，所以很难进行直接的本地编译。嵌入式开发板的CPU、RAM、Falsh等硬件资源相对比较紧张，在已经运行了嵌入式Linux的前提下，没法方便的进行本地编译。因为编译，开发，都需要相对比较多的CPU，内存，硬盘等资源，而嵌入式开发上的资源，只够嵌入式（Linux）系统运行的，没太多剩余的资源，供你本地编译。</p><h2 id="交叉编译工具链组成"><a href="#交叉编译工具链组成" class="headerlink" title="交叉编译工具链组成"></a>交叉编译工具链组成</h2><p>常用交叉编译工具有交叉编译器、交叉连接器、交叉解释器还有交叉ELF文件工具、交叉反汇编器等工具。交叉编译工具链主要由binutils、gcc和glibc三个部分组成。有时出于减小 libc 库大小的考虑，也可以用别的 c 库来代替 glibc，例如 uClibc、dietlibc 和 newlib。</p><p>编译器能将我们编写的语言转成计算机可以识别的机器语言，解释器能够执行用其他计算机语言编写的程序的系统软件，它是一种翻译程序，转换一行，运行一行，再转换一行，再运行一行。<strong>解释性</strong>语言：Python，JavaScript，<strong>编译性</strong>语言：Java，c，c++。</p><h2 id="交叉工具链命名规则"><a href="#交叉工具链命名规则" class="headerlink" title="交叉工具链命名规则"></a>交叉工具链命名规则</h2><p>交叉编译工具链的命名规则为：arch - vendor - os - (gnu)eabi</p><p>arch – 体系架构，如ARM，MIPS，表示该编译器用于编译哪个目标平台的程序<br>vendor – 工具链提供商，通常是把vendor写成体系架构的值，比如cortex_a8<br>os – 运行编译产生的程序的目标操作系统，一般用linux表示有操作系统，none表示裸系统，uboot编译无os<br>eabi – 嵌入式应用二进制接口（Embedded Application Binary Interface），abi是计算机上的</p><h2 id="编译工具使用（持续更新）"><a href="#编译工具使用（持续更新）" class="headerlink" title="编译工具使用（持续更新）"></a>编译工具使用（持续更新）</h2><p>交叉编译工具使用方法与本地编译工具链基本一样，只是命名不同。</p><h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><p>Linux系统下的GCC编译器实际上是GNU编译工具链中的一款软件，可以用它来调用其他不同的工具进行诸如预处理、编译、汇编和链接这样的工作。gcc编译器从拿到一个c源文件到生成一个可执行程序，中间一共经历了四个步骤：</p><p><img src="https://hao0527.gitee.io/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE-1.jpg" alt="220522-交叉编译工具链-1.jpg"></p><h3 id="ld"><a href="#ld" class="headerlink" title="ld"></a>ld</h3><p>ld是GNU操作系统上的连接器，把二进制文件连接成可执行文件。<strong>ELF文件</strong>可用于程序的链接，重定位目标文件。用于链接的ELF文件格式：</p><p><img src="https://hao0527.gitee.io/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE-2.jpg" alt="220522-交叉编译工具链-2.jpg"></p><p>从编译和链接角度看ELF文件<strong>ELF头</strong>，每个ELF文件都必须存在一个ELF_Header，这里存放了很多重要的信息用来<strong>描述整个文件的组织</strong>，如：版本信息、入口信息、偏移信息等，程序执行也必须依靠其提供的信息。</p><p><strong>段头表</strong>，存放的是所有<strong>不同段将在内存中的位置</strong>。代码段.text section，存放已编译程序的机器代码，一般是只读的。只读数据段.rodata section，此段的数据不可修改，存放常量。数据段.data section，存放已初始化的全局变量。.bss section，未初始化全局变量，仅是占位符，不占据任何实际磁盘空间，目标文件格式区分初始化和非初始化是为了空间效率。</p><p>符号表.symtab section，它存放在程序中定义和引用的函数和全局变量的信息。.text节的重定位信息.rel.txt section，用于重新修改代码段的指令中的地址信息。.data节的重定位信息.rel.data section，用于对被模块使用或定义的全局变量进行重定位的信息。调试用的符号表.debug section。.strtab section，包含symtab和debug节中符号及节名。.line section，存储调试的行号信息，描述源代码和机器码之间的对应关系。</p><p>ELF(Executable and Linkable Format)的完整描述，可以参考这个文档 - <a href="http://www.uclibc.org/docs/elf-64-gen.pdf">这里</a></p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p><img src="https://hao0527.gitee.io/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE-3.jpg" alt="220522-交叉编译工具链-3.jpg"></p><p>用于显示二进制文件各节的大小。</p><p>text段最终是存放在FLASH存储器中的，text段不仅包含函数，还有常量。</p><p>data段是用于初始化数据（全局/外部），既有初始化值的数据。</p><p>bss段包含着所有未初始化（或初始化值为0）的数据（全局/外部）。</p><p>dec（decimal的缩写，即十进制数）是text，data和bss的算术和。</p><h3 id="objcopy"><a href="#objcopy" class="headerlink" title="objcopy"></a>objcopy</h3><p><img src="https://hao0527.gitee.io/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE-4.jpg" alt="220522-交叉编译工具链-4.jpg"></p><p>把一种目标文件中的内容复制到另一种类型的目标文件中。</p><p><code>objcopy -O ihex xxxxxx.elf xxxxxx.hex</code> 将编译生成的elf文件转换为hex格式的文件。</p><p><code>objcopy -O srec xxxxxx.elf xxxxxx.srec</code> 将编译生成的elf文件转换为srec格式的文件。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git和SVN</title>
      <link href="/2022/05/12/220512-Git%E5%92%8CSVN/"/>
      <url>/2022/05/12/220512-Git%E5%92%8CSVN/</url>
      
        <content type="html"><![CDATA[<h2 id="Git和SVN"><a href="#Git和SVN" class="headerlink" title="Git和SVN"></a>Git和SVN</h2><p>公司里常用的两种版本控制工具：Git和SVN，两者最大的区别就是Git是分布式，SVN是集中式。<strong>集中式</strong>的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 <strong>分布式</strong>的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们在自己本地也会创建一个库，用于保存自己的修改与提交，之后再将自己库提交至服务器库进行更新。</p><p><strong>Subversion的特点概括起来主要由以下几条：</strong></p><ul><li>每个版本库有唯一的URL（官方地址），每个用户都从这个地址获取代码和数据；</li><li>获取代码的更新，也只能连接到这个唯一的版本库，同步以取得最新数据；</li><li>提交必须有网络连接（非本地版本库）；</li><li>提交需要授权，如果没有写权限，提交会失败；</li><li>提交并非每次都能够成功。如果有其他人先于你提交，会提示“改动基于过时的版本，先更新再提交”… 诸如此类；</li><li>冲突解决是一个提交速度的竞赛：手快者，先提交，平安无事；手慢者，后提交，可能遇到麻烦的冲突解决；</li></ul><p><strong>Git具有以下特点：</strong></p><ul><li>Git中每个克隆(clone)的版本库都是平等的。你可以从任何一个版本库的克隆来创建属于你自己的版本库，同时你的版本库也可以作为源提供给他人，只要你愿意；</li><li>Git的每一次提取操作，实际上都是一次对代码仓库的完整备份；</li><li>提交完全在本地完成，无须别人给你授权，你的版本库你作主，并且提交总是会成功；</li><li>甚至基于旧版本的改动也可以成功提交，提交会基于旧的版本创建一个新的分支；</li><li>Git的提交不会被打断，直到你的工作完全满意了，PUSH给他人或者他人PULL你的版本库，合并会发生在PULL和PUSH过程中，不能自动解决的冲突会提示您手工完成；</li><li>冲突解决不再像是SVN一样的提交竞赛，而是在需要的时候才进行合并和冲突解决；</li><li>Git 也可以模拟集中式的工作模式，Git版本库统一放在服务器中，Git 的集中式工作模式非常灵活；</li><li>可以为 Git 版本库进行授权：谁能创建版本库，谁能向版本库PUSH，谁能够读取（克隆）版本库;</li><li>团队的成员先将服务器的版本库克隆到本地；并经常的从服务器的版本库拉（PULL）最新的更新；</li><li>团队的成员将自己的改动推（PUSH）到服务器的版本库中，当其他人和版本库同步（PULL）时，会自动获取改变；</li><li>你完全可以在脱离Git服务器所在网络的情况下，如移动办公或出差时，照常使用代码库；</li><li>你只需要在能够接入Git服务器所在网络时，PULL和PUSH即可完成和服务器同步以及提交；</li><li>Git提供 rebase 命令，可以让你的改动看起来是基于最新的代码实现的改动；</li><li>Git 有更多的工作模式可以选择，远非 Subversion可比；</li><li>Git 分支是指针指向某次提交，而 SVN 分支是拷贝的目录，这个特性使 Git 的分支切换非常迅速，且创建成本非常低；</li></ul><h2 id="Git基本概念和常用命令"><a href="#Git基本概念和常用命令" class="headerlink" title="Git基本概念和常用命令"></a>Git基本概念和常用命令</h2><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库，版本库可分为远程仓库和本地仓库。<br><img src="https://hao0527.gitee.io/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-1.jpg" alt="220512-Git和SVN-1.jpg"></li></ul><p>Git 常用的是以下 6 个命令：<strong>git clone</strong>、<strong>git push</strong>、<strong>git add</strong> 、<strong>git commit</strong>、<strong>git checkout</strong>、<strong>git pull</strong><br><img src="https://hao0527.gitee.io/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-2.jpg" alt="220512-Git和SVN-2.jpg"></p><p> git 创建仓库的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化仓库</td></tr><tr><td align="left"><code>git clone</code></td><td align="left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><p>提交与修改的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git add</code></td><td align="left">添加文件到暂存区</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="left"><code>git commit</code></td><td align="left">提交暂存区到本地仓库。</td></tr><tr><td align="left"><code>git reset</code></td><td align="left">回退版本。</td></tr><tr><td align="left"><code>git rm</code></td><td align="left">删除工作区文件。</td></tr><tr><td align="left"><code>git mv</code></td><td align="left">移动或重命名工作区文件。</td></tr></tbody></table><p>提交日志的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看历史提交记录</td></tr><tr><td align="left"><code>git blame </code></td><td align="left">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><p>远程操作的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote</code></td><td align="left">远程仓库操作</td></tr><tr><td align="left"><code>git fetch</code></td><td align="left">从远程获取代码库</td></tr><tr><td align="left"><code>git pull</code></td><td align="left">下载远程代码并合并</td></tr><tr><td align="left"><code>git push</code></td><td align="left">上传远程代码并合并</td></tr></tbody></table><p>Git 分支管理：<a href="https://www.runoob.com/git/git-branch.html">https://www.runoob.com/git/git-branch.html</a><br>Git 查看提交历史：<a href="https://www.runoob.com/git/git-commit-history.html">https://www.runoob.com/git/git-commit-history.html</a><br>Git 标签：<a href="https://www.runoob.com/git/git-tag.html">https://www.runoob.com/git/git-tag.html</a><br>更多命令查看Git完整命令手册地址：<a href="http://git-scm.com/docs">http://git-scm.com/docs</a></p><h2 id="Tortoise-SVN"><a href="#Tortoise-SVN" class="headerlink" title="Tortoise SVN"></a>Tortoise SVN</h2><p>SVN教程：<a href="https://www.runoob.com/svn/svn-tutorial.html">https://www.runoob.com/svn/svn-tutorial.html</a></p><p>TortoiseSVN 是 SVN(Subversion) 版本控制系统的一个免费开源客户端，可以超越时间的管理文件和目录。TortoiseSVN 使用教程：<a href="https://www.runoob.com/svn/tortoisesvn-intro.html">https://www.runoob.com/svn/tortoisesvn-intro.html</a></p><p>企业通常是使用TortoiseSVN提供的图像化界面操作，使用较简单。Windows的Git提供了GitGUI，也可以使用TortoiseGit，配置参数也有图形化界面，之前实习的一家公司就是 TortoiseGit 和 TortoiseSVN 。</p><h2 id="版本管控工具分支管理"><a href="#版本管控工具分支管理" class="headerlink" title="版本管控工具分支管理"></a>版本管控工具分支管理</h2><h3 id="SVN分支管理策略"><a href="#SVN分支管理策略" class="headerlink" title="SVN分支管理策略"></a>SVN分支管理策略</h3><ul><li>trunk(主干|主线|主分支)：是用来做主方向开发的，新功能的开发应放在主线中，当模块开发完成后，需要修改，就用branch。</li><li>branches(分支)：分支开发和主线开发是可以同时进行的，也就是并行开发，分支通常用于修复bug时使用。</li><li>tags (标记)：用于标记某个可用的版本，可以标记已经上线发布的版本，也可以标记正在测试的版本，通常是只读的。</li></ul><p>branch是用来做并行开发的，这里的并行是指和trunk进行比较。比如，3.0开发完成，这个时候要做一个tag，tag_release_3_0，然后基于这个tag做release，比如安装程序等。trunk进入3.1的开发，但是3.0发现了bug，那么就需要基于tag_release_3_0做一个branch，branch_bugfix_3_0，基于这个branch进行bugfix，等到bugfix结束，做一个tag，tag_release_3_0_1，然后，根据需要决定branch_bugfix_3_0是否并入trunk。</p><h3 id="Git分支管理策略"><a href="#Git分支管理策略" class="headerlink" title="Git分支管理策略"></a>Git分支管理策略</h3><p><strong>Git Flow模型</strong>中定义了主分支和辅助分支两类分支。其中主分支用于组织与软件开发、部署相关的活动，辅助分支组织用于解决特定的问题而进行的各种开发活动。Git Flow开发模型从源代码管理角度对通常意义上的软件开发活动进行了约束，为软件开发提供了一个可供参考的管理模型。Git Flow开发模型让代码仓库保持整洁，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。</p><p>Git Flow模型的特点是只有2个主干分支，Master和Develop分支：Master分支上只有稳定的生产版本，Develop分支用于集成。其中还涉及到HotFix分支。而其他还有三类分支：Feature分支用于开发人员各自开发；Release用于代码合并和集成；HotFix用于产品版本代码的紧急修订。</p><p><strong>master分支</strong>通常只能从其它分支合并，不能在master分支直接修改。master分支上存放的是随时可供在生产环境中部署的代码（Production Ready state）。当开发活动到一定阶段，产生一份新的可供部署的代码时，master分支上的代码会被更新。同时，每一次更新，最好添加对应的版本号标签（TAG），所有在Master分支上的Commit应该打Tag。</p><p><strong>develop分支</strong>是保持当前开发最新成果的分支，一般会在此分支上进行晚间构建（Nightly Build）并执行自动化测试。develop分支产生于master分支, 并长期存在。当一个版本功能开发完毕且通过测试功能稳定时，就会合并到master分支上，并打好带有相应版本号的tag。develop分支是主开发分支，包含所有要发布到下一个Release的代码，主要合并其它分支，比如Feature分支。</p><p><strong>辅助分支</strong>是用于组织解决特定问题的各种软件开发活动的分支。辅助分支主要用于组织软件新功能的并行开发、简化新功能开发代码的跟踪、辅助完成版本发布工作以及对生产代码的缺陷进行紧急修复工作。辅助分支通常只会在有限的时间范围内存在。辅助分支包括用于开发新功能时所使用的feature分支，用于辅助版本发布的release分支，用于修正生产代码中的缺陷的hotfix分支。辅助分支都有固定的使用目的和分支操作限制。通过对分支的命名，定义了使用辅助分支的方法。</p><p><strong>feature分支</strong>可以从develop分支派生。feature分支的命名可以使用除master，develop，release-*，hotfix-*之外的任何名称。feature分支（topic分支）通常在开发一项新的软件功能的时候使用，分支上的代码变更最终合并回develop分支或者干脆被抛弃掉（例如实验性且效果不好的代码变更）。一般而言，feature分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里。Feature分支开发完成后，必须合并回Develop分支，合并完分支后一般会删feature分支，但也可以保留。</p><p><strong>release分支</strong>可以从develop分支派生。release分支是为发布新的产品版本而设计的。在release分支上的代码允许做测试、bug修改、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等）。通过在release分支上进行发布相关工作可以让develop分支空闲出来以接受新的feature分支上的代码提交，进入新的软件开发迭代周期。当develop分支上的代码已经包含了所有即将发布的版本中所计划包含的软件功能，并且已通过所有测试时，可以考虑准备创建release分支。而所有在当前即将发布的版本外的业务需求一定要确保不能混到release分支内（避免由此引入一些不可控的系统缺陷）。成功的派生release分支并被赋予版本号后，develop分支就可以为下一个版本服务。版本号的命名可以依据项目定义的版本号命名规则进行。发布Release分支时，合并Release到Master和Develop， 同时在Master分支上打个Tag记住Release版本号，然后就可以删除Release分支。</p><p><strong>hotfix分支</strong>可以从master分支派生。hotfix分支是计划外创建的，可以产生一个新的可供在生产环境部署的软件版本。当生产环境中的软件遇到异常情况或者发现了严重到必须立即修复的软件缺陷时，就需要从master分支上指定的TAG版本派生hotfix分支来组织代码的紧急修复工作。优点是不会打断正在进行的develop分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行的开展工作。hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag。</p><h2 id="使用Git遇到的问题"><a href="#使用Git遇到的问题" class="headerlink" title="使用Git遇到的问题"></a>使用Git遇到的问题</h2><h3 id="Git-tag"><a href="#Git-tag" class="headerlink" title="Git tag"></a>Git tag</h3><p>参考：<a href="https://blog.csdn.net/qq_21746331/article/details/1207767">GIT 中如何打标签（git tag）</a></p><p><img src="https://hao0527.gitee.io/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-3.jpg" alt="220512-Git和SVN-3.jpg"></p><h3 id="Git-show"><a href="#Git-show" class="headerlink" title="Git show"></a>Git show</h3><p>给历史版本打标签时用的commit可以通过git show查看历史版本的hash。</p><p><img src="https://hao0527.gitee.io/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-4.jpg" alt="220512-Git和SVN-4.jpg"></p><h3 id="Git-log"><a href="#Git-log" class="headerlink" title="Git log"></a>Git log</h3><p>查看提交日志，当你要修改历史提交前，你可以通过git log看看要修改第几次的提交。</p><p><img src="https://hao0527.gitee.io/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-5.jpg" alt="220512-Git和SVN-5.jpg"></p><h3 id="Git-rebase"><a href="#Git-rebase" class="headerlink" title="Git rebase"></a>Git rebase</h3><p>通过git rebase可以修改历史的版本，参考：<a href="https://blog.csdn.net/weixin_62277266/article/details/124260568">Git系列之修改历史提交信息</a>，使用rebase指令后会在vi编辑器中选择要修改哪次提交，然后通过vi编辑器修改提交的内容。</p><p>注意：异常退出可能导致文件丢失，不要慌终端有提示如何恢复。</p><p><img src="https://hao0527.gitee.io/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-6.jpg" alt="220512-Git和SVN-6.jpg"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言预处理</title>
      <link href="/2022/05/11/220511-C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/"/>
      <url>/2022/05/11/220511-C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="ANSI-C标准"><a href="#ANSI-C标准" class="headerlink" title="ANSI C标准"></a><a href="https://baike.baidu.com/item/ANSI%20C%E6%A0%87%E5%87%86/6044290?fr=aladdin">ANSI C标准</a></h3><p>ANSI C是<a href="https://baike.baidu.com/item/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E5%8D%8F%E4%BC%9A/5709537">美国国家标准协会</a>（ANSI）对<a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>发布的标准。使用C的软件开发者被鼓励遵循ANSI C文档的要求，因为它鼓励使用<a href="https://baike.baidu.com/item/%E8%B7%A8%E5%B9%B3%E5%8F%B0/8558902">跨平台</a>的代码。</p><p>发展过程中产生了C89、C90、C99、C11四套标准，最早的C89在1983年创立，C90是1990年创立的ANSI C标准（带有一些小改动），C99在2000年3月创立，C11在2011年12月创立。</p><h3 id="C预处理器"><a href="#C预处理器" class="headerlink" title="C预处理器"></a><a href="https://www.runoob.com/cprogramming/c-preprocessors.html">C预处理器</a></h3><table><thead><tr><th align="left">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">#define</td><td align="left">定义宏</td></tr><tr><td align="left">#include</td><td align="left">包含一个源代码文件</td></tr><tr><td align="left">#undef</td><td align="left">取消已定义的宏</td></tr><tr><td align="left">#ifdef</td><td align="left">如果宏已经定义，则返回真</td></tr><tr><td align="left">#ifndef</td><td align="left">如果宏没有定义，则返回真</td></tr><tr><td align="left">#if</td><td align="left">如果给定条件为真，则编译下面代码</td></tr><tr><td align="left">#else</td><td align="left">#if 的替代方案</td></tr><tr><td align="left">#elif</td><td align="left">如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td></tr><tr><td align="left">#endif</td><td align="left">结束一个 #if……#else 条件编译块</td></tr><tr><td align="left">#error</td><td align="left">当遇到标准错误时，输出错误消息</td></tr><tr><td align="left">#pragma</td><td align="left">使用标准化方法，向编译器发布特殊的命令到编译器中</td></tr></tbody></table><h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>ANSI C 定义了许多宏。在编程中可以使用这些宏，但是不能直接修改这些预定义的宏。</p><table><thead><tr><th align="left">宏</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">__DATE__</td><td align="left">当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td></tr><tr><td align="left">__TIME__</td><td align="left">当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td></tr><tr><td align="left">__FILE__</td><td align="left">这会包含当前文件名，一个字符串常量。</td></tr><tr><td align="left">__LINE__</td><td align="left">这会包含当前行号，一个十进制常量。</td></tr><tr><td align="left">__STDC__</td><td align="left">当编译器以 ANSI 标准编译时，则定义为 1。</td></tr></tbody></table><h3 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a><a href="https://blog.csdn.net/weixin_39640298/article/details/84503428">#pragma</a></h3><p>#pragma指令的作用是：用于指定计算机或操作系统特定的编译器功能。C 和 C++ 的每个实现均支持某些对其主机或操作系统唯一的功能。 例如，某些程序必须对将数据放入的内存区域进行准确的控制或控制某些函数接收参数的方式。 在保留与 C 和 C++ 语言的总体兼容性的同时，#pragma 指令使每个编译器均能够提供特定于计算机和操作系统的功能。</p><p>根据定义，#pragma指令是计算机或操作系统特定的，并且通常对于每个编译器而言都有所不同。 #pragma指令可用于条件语句以提供新的预处理器功能，或为编译器提供实现所定义的信息。</p><p><code>#pragma pack([ show ] | [ push | pop ] [, identifier ] , n)</code>，用于内存对齐。<br><code>#pragma message(messageString)</code>，用于不中断编译的情况下，发送一个字符串文字量到标准输出。</p><p>编译器可识别的指令还有很多。</p><h3 id="和…"><a href="#和…" class="headerlink" title="##和…"></a><a href="https://blog.csdn.net/ysds20211402/article/details/122300354">##和…</a></h3><p><code>##</code> 起连接字符串的作用，用于把参数宏中的“形参”与其它没有天然分割的内容粘连在一起。<br>例如：<code>#define def_u32_array(__name, __size)    uint32_t array_##__name[__size];</code><br><code>def_u32_array(sample_buffer, 64)</code>，宏展开后为：<code>uint32_t array_sample_buffer[64];</code></p><p><code>...</code> 是ANSI-C99标准引入的另外一个参数宏扩展，“可变参数宏”，其实就是将__VA_ARGS__替换为…中的值。<br>例如：<code>#define log_info(__STRING, ...)    printf(__STRING, __VA_ARGS__)</code><br><code>log_info(&quot;Count:%d&quot;, total_cycle_cnt);</code>，宏展开后：<code>printf(&quot;Count:%d&quot;, total_cycle_cnt);</code><br><code>log_info(&quot;-----------------\r\n&quot;);</code>，宏展开后：<code>printf(&quot;-----------------\r\n&quot;,);</code>，…无参数，__VA_ARGS__为空，但是宏展开后仍有逗号。</p><p>逗号后无内容可能会产生个warning，想解决逗号问题，可以##和…一起使用。<br>例如：<code>\#define log_info(__STRING, ...)    printf(__STRING,##__VA_ARGS__)</code><br><code>log_info(&quot;-----------------\r\n&quot;);</code>，宏展开后：<code>printf(&quot;-----------------\r\n&quot;);</code></p><h3 id="…初始化数组"><a href="#…初始化数组" class="headerlink" title="…初始化数组"></a>…初始化数组</h3><p><code>int a[5] = &#123;[0...2] = 1, [3...4] = 2&#125;;</code>使数组a[0]~a[2] = 1, a[3]和a[4] = 2。</p><p>这种写法只可以在gcc编译C的情况下使用，gcc编译c++也不行。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Altera FPGA的网络摄像机设计与实现</title>
      <link href="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h3><p>本文介绍了如何设计一个以Altera FPGA为核心的网络摄像机，将图像传感器和MEMS麦克风作为的主要传感器，辅以千兆以太网模块、电源模块等模块，最终完成实现一个低成本易使用的网络摄像机的功能。要求该网络摄像机能够实时传输图像和音频信息，在电脑端可以将图像实时处理显示并将音频实时播放。此外，还能够将数据流存储在设备中，便于用户对视频进行回放等操作。</p><h2 id="总体设计方案描述"><a href="#总体设计方案描述" class="headerlink" title="总体设计方案描述"></a>总体设计方案描述</h2><p>本设计方案是以Altera FPGA为核心，在Quartus 18.0开发平台上，实现FPGA接收图像传感器和麦克风数据，并通过千兆以太网PHY芯片，将图像和声音数据发送至电脑上位机，电脑上位机利用Python3编程语言编写，在PyCharm IDE中执行，实现音视频实时播放和音视频回放的功能。主要由Altera FPGA控制器、图像传感器模块、麦克风模块、以太网模块和电脑上位机组成，系统框图如下图所示。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-1.png" alt="220501-毕业设计-1.png"></p><h3 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h3><p>FPGA选用Cyclone IV EP4CE15 Starter Kit开发板。开发板板载W25Q64 SPI Flash芯片，8MB字节的存储容量，开发板给主控提供了50MHz的外部时钟源，芯片逻辑单元数为 15K LE，开发板引出了芯片的JTAG调试端口，引出了GMII千兆以太网接口，采用了RealTek的RTL8211EG芯片，引出了一个CMOS/CCD摄像头接口和40P的排座。开发板条件满足本设计的所有需求。</p><p>图像传感器选择经典的OV2640模组，OV2640适配开发板引出的40P的排座，提供了SCCB接口，可供配置传感器参数，可以配置最大1600*1200分辨率的图像输出，还可以配置JPEG压缩格式输出图像，模组拥有8位并口，可以高速输出图像信息，拥有帧场同步信号管脚，和电源使能管脚，方便FPGA控制和接收图像信息。</p><p>麦克风选择INMP441全向麦克风传感器，INMP441麦克风直接输出数字信号，采用的接口是I2S，非常适合FPGA去读取总线数据。传统驻极体麦克风输出模拟信号，选用INMP441省去了传统驻极体麦克所需的放大器、滤波器和模数转换器等硬件设计。</p><h3 id="FPGA设计方案"><a href="#FPGA设计方案" class="headerlink" title="FPGA设计方案"></a>FPGA设计方案</h3><p>FPGA设计采用模块化设计的方案，通过模块化设计，可以使一个大型设计分成多个模块，这样分工协作可使仿真测试更加容易，并且代码维护和代码升级也会更加方便。顶层模块不做逻辑设计，只通过例化调用子模块接口。因此，顶层模块下就由各功能模块组成，各功能模块下还可以分成多个子功能模块来实现。通过编译器对每个模块的综合仿真约束等设计，最后将所有模块连在一起，构成整个网络摄像机FPGA部分的设计。</p><p>本设计模块层次设计图如下所示，由时钟模块、数据交互模块、图像传感器模块、麦克风模块、千兆网络模块总共5个模块组成，各模块又由各个子模块组成，顶层模块通过例化的方式，将5个模块之间的接口互相连接起来，实现顶层模块的最终设计。该模块层次设计的各个子模块功能相对独立，各模块内部联系紧密，模块之间的连接简单，满足FPGA的模块化设计基本规则。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-2.png" alt="220501-毕业设计-2.png"></p><h3 id="上位机设计方案"><a href="#上位机设计方案" class="headerlink" title="上位机设计方案"></a>上位机设计方案</h3><p>上位机采用Python3编程语言设计，主要功能分为接收数据包、实时解码播放、保存回放。FPGA传来的UDP数据包包含了音频和图像，两者通过两个不同的端口传输，这样更便于应用层的分开处理。在UDP数据包中还加入了帧序列号，上位机可通过校验前后两帧的序列号是否对应，来判断是否发生掉包的现象。实时解码播放是通过数据包的传输协议将有用数据部分取出，图像数据为JPEG压缩图像，通过OpenCV对JPEG图像解码，通过图像流的方式显示在屏幕上。音频是通过PCM码流传输，通过约定好的采样频率、量化位数、声道数等信息，调用PyAudio函数库接口进行播放。回放功能是将图片流保存成avi视频格式，音频流保存成wav音频格式，然后在电脑文件系统中可以打开进行回放。通过多进程多线程将这三个功能配合起来，通过流水线操作的方式，让整个上位机程序执行更加的高效、稳定。上位机的程序流程图如下图所示。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-3.png" alt="220501-毕业设计-3.png"></p><h2 id="FPGA各模块功能实现"><a href="#FPGA各模块功能实现" class="headerlink" title="FPGA各模块功能实现"></a>FPGA各模块功能实现</h2><h3 id="时钟模块实现"><a href="#时钟模块实现" class="headerlink" title="时钟模块实现"></a>时钟模块实现</h3><h4 id="系统时钟输入和PLL配置"><a href="#系统时钟输入和PLL配置" class="headerlink" title="系统时钟输入和PLL配置"></a>系统时钟输入和PLL配置</h4><p>下图为FPGA开发板硬件原理图中的时钟部分，FPGA系统时钟信号由一颗50MHz有源晶振，从FPGA的T2引脚传入，由该时钟通过PLL锁相环和分频器，得到各模块所需的时钟，为整个系统提供准确的时钟信号。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-4.jpg" alt="220501-毕业设计-4.jpg"></p><p>锁相环（Phase Locked Loop, PLL）是一种反馈型的控制电路，可以通过PLL对输入时钟进行系统级的时钟控制，可以配置管理时钟相位、偏移，具有倍频、分频和可编程占空比等功能。由于本设计使用到的模块较多，使用单一的时钟通过软件分频无法得到精准音频采样的频率，所以满足本设计要求。故使用PLL模块来满足该设计的不同时钟频率和不同时钟相位偏移的要求。通过Quartus提供的PLL IP核，对Altera FPGA片上的可编程PLL进行控制，使其输出各种时钟信号提供给各个模块使用。</p><p>下图为在Quartus 18.0中通过PLL IP核配置输入50Mhz时钟，输出2.205MHz时钟提供给麦克风模块的采样频率使用，配置软件会根据输入输出时钟频率自动计算出PLL的各个参数（时钟倍频参数、时钟分频参数），提供给麦克风模块的采样频率不需要相位偏移和特殊的占空比，故设置相位偏移为0，占空比为50%。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-5.jpg" alt="220501-毕业设计-5.jpg"></p><h4 id="软件分频器实现"><a href="#软件分频器实现" class="headerlink" title="软件分频器实现"></a>软件分频器实现</h4><p>由于片上PLL资源数量有限，部分对时钟精准度要求不高的模块也可以采用软件分频器实现。例如I²C模块中的时钟信号采用250KHz，通过对输入的50MHz系统时钟上升沿或者下降沿计数，计数器值累加到100时，让输出信号产生翻转，即可产生250KHz的I²C驱动信号。这就是软件分频器的实现原理，占用硬件资源少，像这种整数倍分频，也可以提供较好的精度。</p><h3 id="数据交互模块实现"><a href="#数据交互模块实现" class="headerlink" title="数据交互模块实现"></a>数据交互模块实现</h3><p>设计FPGA各模块交互时，需要将图像和音频的数据传送给网络模块封装发送，故使用FIFO来做数据的缓冲。而网络模块的时钟信号是125MHz，与图像传感器模块24MHz和麦克风模块44100Hz有较大的区别，所以不能直接将数据通过同读写同时钟的FIFO传送给网络模块发送。FIFO模块可以配置读写相同时钟和读写不同时钟，在实际测试中，由于读取时钟为125MHz高频率信号，读写不同时钟情况下，FIFO的读写会产生严重的数据错误。因此本设计采用读写同时钟，FIFO模块输入时钟为网络模块的时钟125MHz，再手动编写跨时钟数据交互的时序逻辑，实现不同时钟域数据通过FIFO的转换。</p><h4 id="FIFO模块配置"><a href="#FIFO模块配置" class="headerlink" title="FIFO模块配置"></a>FIFO模块配置</h4><p>FIFO（First In First Out）模块是对数据缓冲时用到存储器，使模块可以被突发性读写。通常也被用于高速信号跨时钟域的数据交互，它可以被顺序写入，然后可以被顺序读出，先进先出的特性是FIFO不同于其他存储器的地方。</p><p>在Quartus 18.0中也可以通过IP核的方式来配置FIFO模块，关系FIFO容量的两个参数是FIFO的宽度和深度，宽度是指同时多少位可以被读写，深度是指可以存储多少该宽度的数据。由于FPGA中以太网是以字（4Bytes）的宽度来发送数据，并且以太网一帧默认最长大小是1500个字节，其中有用的数据为1472个字节，因此这里选择宽度为32bits，深度为512words可以满足缓冲一阵的以太网数据包。这里配置时我们采用读写相同时钟，从而使FIFO高速稳定的运行。需要打开usedw[]的功能，让网络模块读取已经使用的FIFO数量，当已经使用的数量大于等于1472字节时，可以开始发送一帧以太网数据。在输出寄存器一选项中，选择要求时间同步，Yes(best speed)，由于FIFO时钟是125MHz，不选速度优先的话也会导致FIFO读写混乱错误。同时关闭上下溢出检测以提升FIFO模块性能。下图为最后FIFO模块配置的部分参数，配置时一定要使性能最优。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-6.jpg" alt="220501-毕业设计-6.jpg"></p><h4 id="将数据写入FIFO模块实现"><a href="#将数据写入FIFO模块实现" class="headerlink" title="将数据写入FIFO模块实现"></a>将数据写入FIFO模块实现</h4><p>FIFO模块的时钟为125MHz，在图像FIFO存储模块中，图像传感器的时钟是24MHz，并且是8位宽度，需要手动编写跨时钟数据交互的时序逻辑，实现不同时钟域数据通过FIFO的转换。图像FIFO写模块输入有时钟、复位、图像数据、数据有效使能、垂直同步信号，输出有32位FIFO写入、FIFO写使能信号。捕获四个数据有效使能信号上升沿，将4个8位数据合并成1个32位数据，并向FIFO模块发送写使能，由于FIFO模块的时钟为125MHz，要写1个数据到FIFO模块，写使能信号高电平时间只能为8ns。为了使每幅图像不会等到下一张图像数据写入FIFO，直到FIFO满1472字节才发送，即使每幅图像都可以在该图像接收结束被发送完成，在垂直同步（一幅图像数据结束）信号产生后就向FIFO中追加写入1472个字节的0x00数据。</p><p>麦克风模块和网络模块也通过FIFO传递数据，麦克风模块的采样频率为44100Hz，也需要做个时钟转换和数据宽度转换，转换成FIFO模块的125MHz和32位宽才能写入FIFO，实现方法与图像数据写入FIFO模块类似。由于音频数据的采样量化位数是24位，转换成32位数据需要在首位补0x00，为了上位机方便保存成wav格式，采用小段存储方方式写入FIFO模块。</p><h4 id="从FIFO模块读取数据实现"><a href="#从FIFO模块读取数据实现" class="headerlink" title="从FIFO模块读取数据实现"></a>从FIFO模块读取数据实现</h4><p>网络模块在判断FIFO存储数量大于等于1472字节时会开始发送数据，发送数据时会请求读取FIFO模块数据，以太网发送数据的时钟是125MHz的，读取FIFO数据后要及时锁存，在锁存进入稳态后才可以被网络模块读取发送，否则由于FIFO发送速度过快，数据在信号线上容易未进入稳态被读取，造成读取和发送的数据出现错误。因为音频传送的数据量小，且实时性要求高，所以音频FIFO模块读取的优先级要设置比图像FIFO模块读取的优先级高。</p><h3 id="图像传感器模块实现"><a href="#图像传感器模块实现" class="headerlink" title="图像传感器模块实现"></a>图像传感器模块实现</h3><h4 id="I²C驱动模块实现"><a href="#I²C驱动模块实现" class="headerlink" title="I²C驱动模块实现"></a>I²C驱动模块实现</h4><p>使用OV2640传感器，需要用SCCB类I²C总线配置OV2640传感器的寄存器。I²C总线协议由飞利浦公司发明，由一根数据线和一根时钟线构成，属于半双工同步通信，较常用的时钟速率有低速模式100KHz，高速模式400KHz，超高速模式3.4MHz。I²C总线协议支持一主多从，由于I²C总线协议中设备标识符占7位空间，所以I²C总线理论可以挂载128个设备，但实际考虑I²C总线上设备的驱动能力，只可以挂载5个左右从设备。</p><p>I²C总线协议发送起始位后开始通信，起始位的标识是时钟线为高电平时，数据线从高电转变为低电平。通信时发送的第一个字节高7位内容为从设备的设备地址，末一位为读或写请求，低标识写标志位，反之则是读标志位。I²C通信协议中每发送一个字节后一位（第9位），对应的从机接收到就要发送应答响应，即第9位需要将数据线拉低响应，若主机读取到第9位仍为高电平，则标识无对应从机应答。发送设备地址后，若从机有应答，则主从双方继续通信，若主机写请求，就可以发送数据，向从机对应寄存器地址写入数据，从机收到数据后会返回应答信号，若主机读请求，则从机会向主机发送对应地址的数据内容，主机在接收后也需要拉低数据线响应。通信结束后主机发送停止位信号，停止位的标识是时钟线保持高电平，数据线从低电平转变为高电平的状态。</p><p>在FPGA中实现I²C驱动相对别的通信方式（USART、SPI等）难度较高，因为I²C驱动存在有多个工作状态，需要采用复杂的有限状态机来实现I²C驱动。下图是FPGA程序的有限状态机状态转移图，I²C驱动部分程序的代码见附录。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-7.jpg" alt="220501-毕业设计-7.jpg"></p><h4 id="图像传感器配置模块实现"><a href="#图像传感器配置模块实现" class="headerlink" title="图像传感器配置模块实现"></a>图像传感器配置模块实现</h4><p>OV2640图像传感器有较多的寄存器，参考数据手册配置，在图像传感器配置模块中总共配置了201个寄存器，通过case语句，用查表的形式读取相应寄存器地址和寄存器数据，发送给I²C驱动模块，配置OV2640图像传感器。</p><p>先对传感器软复位，后根据本设计的需要配置寄存器，例如：分辨率采用UXGA模式，对输入时钟不分频，倍频系数2，配置JPEG输出，设置图像窗口大小和图像尺寸大小等。配置的程序代码和各寄存器的配置的值见附录。在配置完成后，图像传感器配置模块会发送给图像数据读取模块OV2640初始化完成信号。</p><h4 id="图像数据读取模块实现"><a href="#图像数据读取模块实现" class="headerlink" title="图像数据读取模块实现"></a>图像数据读取模块实现</h4><p>图像传感器数据通讯接口采用的是DCMI接口，在OV2640中DCMI接口是8位数据并口，并且配有行同步垂直同步信号。行同步信号高电平时为图片中一行像素点有效数据，低电平为无效数据，所以每当出现行同步信号上升沿时就是该幅图像传输新的一行标识位。垂直同步信号是一张图片中有效数据的标识，当垂直同步高电平时为有效，每当出现垂直信号的下降沿时，表示该幅图像传输完成，当出现垂直信号的上升沿时，表示新的一幅图像传输开始。</p><p>图像数据读取模块收到配置模块发来的初始化完成信号后开始采集数据，在OV2640传感器实际应用中，图像传感器传来的前几幅图像会有显示问题，所以将开始传来的数据丢弃，根据垂直同步信号计数，第10幅图像开始开始采集图像数据发送给写FIFO模块。数据读取模块实现的代码见附录。</p><h3 id="麦克风模块实现"><a href="#麦克风模块实现" class="headerlink" title="麦克风模块实现"></a>麦克风模块实现</h3><h4 id="I²S总线数据读取模块实现"><a href="#I²S总线数据读取模块实现" class="headerlink" title="I²S总线数据读取模块实现"></a>I²S总线数据读取模块实现</h4><p>使用的MEMS硅麦克风采用的是I²S通信协议，当INMP441的L/R引脚为低电平时，INMP441提供单个左通道音频数据，时序图如下图所示。和I²C比较而言，I²S多了个WS接口，WS接口是串行数据声道选择，为低时左声道麦克风模块在I²S总线上发送数据，右声道是高阻态。WS为高时右声道麦克风模块在I²S总线上发送数据，而左声道是高阻态。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-8.jpg" alt="220501-毕业设计-8.jpg"></p><p>根据时序图可以编写FPGA的I²S驱动，可见经过WS的一周期会得到一组声音信号，WS在SCK下降沿时跳变，在WS跳变后的第二个SCK上升沿可以读取音频数据的最高位，依次24个SCK后得到完整的24位左声道音频数据。设计FPGA程序时，一周期WS会有50次SCK上升沿，因此SCK的频率会比WS高50倍，要保证采样率为44100Hz，就需要通过PLL模块给麦克风模块提供2.205MHz的SCK信号。具体的I²S驱动代码见附录。</p><h3 id="千兆以太网模块实现"><a href="#千兆以太网模块实现" class="headerlink" title="千兆以太网模块实现"></a>千兆以太网模块实现</h3><p>千兆以太网模块是本设计FPGA部分实现起来最复杂和困难的模块，由于千兆以太网PHY芯片采用125MHz高速时钟和8位并口数据传输，容易导致数据传输时未进入稳定态，出现时序混乱的现象。网络模块由三个部分组成，分别是网络发送模块、网络接收模块、CRC-32校验模块，三个模块之间的连接关系RTL视图如下图所示。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-9.jpg" alt="220501-毕业设计-9.jpg"></p><h4 id="CRC-32校验模块实现"><a href="#CRC-32校验模块实现" class="headerlink" title="CRC-32校验模块实现"></a>CRC-32校验模块实现</h4><p>以太网帧组成如下图所示，它是由前导、帧起始定界符、以太网帧头、以太网数据、帧校验序列组成，其中网络中帧校验序列使用最广泛的是采用4字节的循环冗余校验方式，即CRC-32校验。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-10.jpg" alt="220501-毕业设计-10.jpg"></p><p>CRC-32计算方式可以采用串行或并行计算，为了发挥FPGA并行优势，本设计采用并行的方式计算CRC-32校验码，并行CRC-32计算的表可以由工具生成。在FPGA设计中，该模块输入的值有时钟、使能、一字节数据，以太网每发送一字节数据，就要将发送的数据值发送给CRC-32校验模块，会根据上次CRC-32的结果和本次传来的数据值，同步更新CRC-32的值，最后输出为CRC-32校验的结果加在以太网帧的帧尾发送出去，如果目的主机校验CRC-32结果失败，则会在数据链路层丢弃该帧。具体的CRC-32校验模块实现代码见附录。</p><h4 id="千兆以太网数据发送模块实现"><a href="#千兆以太网数据发送模块实现" class="headerlink" title="千兆以太网数据发送模块实现"></a>千兆以太网数据发送模块实现</h4><p>实现以太网数据发送模块，要解决两个问题，需要发送的数据包含哪些信息，需要如何控制千兆以太网PHY芯片。</p><p>在CRC-32校验模块实现一节中介绍了以太网帧的组成结构，在发送目的MAC地址时使用ff-ff-ff-ff-ff-ff广播地址。以太网帧中的以太网数据段格式如下图所示，由于网络摄像机传输要满足实时性，且网络传输在局域网环境下环境不复杂，所以采用UDP协议传输数据，即在IP首部选择协议的地址中写入17表示UDP，生存时间一般为64，标识部分需要每次发送后累加，首部校验和是对IP首部内容累加保留末四位进行校验，在本设计中将源IP地址（FPGA的IP地址）设置为192.168.0.2，目的IP地址（电脑的IP地址）设置为192.168.0.3。以太网数据一般不超过1500字节，IP首部占了24字节，所以IP数据部分最大可为1476字节，其中IP数据的首四字节为用户自定义的帧序列号，用于上位机校验是否有丢包现象产生，所以实际每帧的IP数据中传输有用信息的只有1472个字节。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-11.jpg" alt="220501-毕业设计-11.jpg"></p><p>下图为物理层芯片RTL8211的硬件原理图，可见RTL8211与FPGA的连接主要包含8个发送引脚、8个接收引脚，还有发送和接收的时钟引脚，MDC和MDIO属于配置RTL8211芯片寄存器的接口，在本设计中采用默认寄存器值，所以未用到配置引脚。RTL8211发送和接收时钟均为125MHz，上升沿采样，发送和接收均为8位并口，可以满足1000Mbps全双工通信。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-12.jpg" alt="220501-毕业设计-12.jpg"></p><p>设计千兆以太网数据发送模块也是用有限状态机实现，使用了idle, start, make, send55, sendmac, sendheader, sendpicdata, sendmicdata, sendcrc共9个状态。在idle状态的时候，程序主要是初始化数据，并且检测图像FIFO和音频FIFO是否有超过1472个字节，其中先检测音频FIFO的使用量，若有超过1472个字节跳转到下个状态start。在start状态中会对IP首部进行配置，如果是图像FIFO大于1472字节，会配置端口号为8080，如果是音频FIFO大于1472字节，会配置端口号为8081，配置完成后会跳到下一个状态。make状态中会对IP首部计算校验和，并写入IP首部配置变量ip_header中，跳转至send55状态。在send55状态下，FPGA会和RTL8211通信，发送7字节前导码0x55和1字节帧起始界定符0xD5，发送完成后跳转到下个状态sendmac。在sendmac状态中会发送以太网帧头，包含目的MAC地址，源MAC地址，长度类型这些信息。下个状态sendheader，即发送start状态下存入ip_header变量中的IP首部信息，接下来进入发送数据的状态。发送数据的状态分两种一种是发送图像的状态，另一种是发送音频数据的状态，两个实现的方法一致，只是FIFO读请求所对应的FIFO不同，在发送数据状态中要先发送帧序列号，图像和音频的帧序列号是分开的，发送完帧序列号后循环请求读FIFO368次，将1472字节数据发送给RTL8211芯片，RTL8211会将从FPGA接收到的数据通过网线中的两对差分信号线发送到电脑网口。发送数据状态结束后进入最后一个sendcrc状态，该状态下会读取最后CRC-32的校验值发送给以太网PHY芯片，该状态结束后，表示一帧以太网数据传输结束，状态又跳转至空闲状态检测两个FIFO使用量。具体实现详见附录代码。</p><h2 id="上位机功能实现"><a href="#上位机功能实现" class="headerlink" title="上位机功能实现"></a>上位机功能实现</h2><h3 id="图像功能实现"><a href="#图像功能实现" class="headerlink" title="图像功能实现"></a>图像功能实现</h3><h4 id="接收和解析图像数据包功能实现"><a href="#接收和解析图像数据包功能实现" class="headerlink" title="接收和解析图像数据包功能实现"></a>接收和解析图像数据包功能实现</h4><p>接收UDP的数据包使用了Python中socket库，在程序开始引用该库，通过socket.socket(socket.AF_INET, socket.SOCK_DGRAM)构造函数构造一个套接字，配置使用UDP协议，并且通过server.bind(‘192.168.0.3’, 8080)绑定该套接字对应的IP地址和端口号。接收UDP数据包通过函数server.recvfrom(BUFSIZE)，其中BUFSIZE为缓冲大小，由于一帧以太网数据1472字节，这里将BUFSIZE设置为1472*1000，以实现每次接收缓冲区满足处理的速度。在每次接收UDP数据包后，首先会校验帧序列号，即数据区前四字节，帧序列号是否为上次接收的累加1，若帧序列号不连续则表示存在丢包的现象，通过打印verify error告诉用户帧序列号校验失败。处理图像数据时，传来的图像数据时JPEG编码格式，由于JPEG编码格式帧起始标识符值为0xFFD8、帧结束标识符值为0xFFD9，提取数据包中的有用数据就是通过find(0xff, index)函数找到0xff功能标识符，然后再判断的下一字节是否为0xD8，若判断为真即表示找到JPEG图像数据头，再找尾标识符0xFFD9，通过同样的方法找到数据尾标识符后，将JPEG图像数据包头到包尾数据通过fp.write(data)函数写入jpg格式的文件，就完成了一张图像的保存。</p><h4 id="图像流实时播放功能实现"><a href="#图像流实时播放功能实现" class="headerlink" title="图像流实时播放功能实现"></a>图像流实时播放功能实现</h4><p>要实现图像流实时播放功能，需按照拍摄图像的帧率，连续读取保存在磁盘中的图像，再在屏幕上不断刷新显示。本设计上位机程序采用OpenCV函数库实现图像的读取，解码和显示的功能。首先，在程序的开头通过import cv2引用OpenCV库。通过img = cv2.imread(img_root + str(i)+’.jpg’, cv2.IMREAD_COLOR)读取jpg格式的文件，其中img_root为图像所在文件夹的名字，imread的第一个参数就是图像路径，将读取到的数据保存在mat对象img中。调用cv2.namedWindow(“video”, cv2.WINDOW_AUTOSIZE)创建一个显示图像的窗口，窗口名为video。最后通过cv2.imshow(“video”, img)函数，该函数可以让名为video的显示窗口中显示img图像信息。cv2.waitKey(55)函数是使该窗口显示时间为55ms，这个延时时间由视频的帧数决定。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-13.jpg" alt="220501-毕业设计-13.jpg"></p><h4 id="图像流存储功能实现"><a href="#图像流存储功能实现" class="headerlink" title="图像流存储功能实现"></a>图像流存储功能实现</h4><p>OpenCV库中有支持导出avi视频的函数，fourcc = cv2.VideoWriter_fourcc(*’XVID’)函数，其中XVID参数是指将视频以MPEG-4编码类型保存，保存成avi格式的文件。videoWriter = cv2.VideoWriter(‘./avi/‘ + str(j) + ‘.avi’, fourcc, fps, size)函数配置了视频保存的路径，编码格式，帧率和每帧图像的分辨率，size = (1600, 1200)图像为1600 * 1200的分辨率。通过videoWriter.write(img)函数可以将img图像信息传入，让OpenCV处理生成视频。每隔150张图像发布一个10秒钟时长的avi视频，通过函数videoWriter.release()实现avi视频的发布。每次发布成功后程序会打印release告诉用户，可以在avi文件夹下查看保存的回放视频。</p><h3 id="音频功能实现"><a href="#音频功能实现" class="headerlink" title="音频功能实现"></a>音频功能实现</h3><h4 id="接收和解析音频数据包功能实现"><a href="#接收和解析音频数据包功能实现" class="headerlink" title="接收和解析音频数据包功能实现"></a>接收和解析音频数据包功能实现</h4><p>接收音频数据的方式与接收图像数据方式相同，通过Python的socket库。在接收音频数据后做帧序列号校验，并提取有效部分。接收到的音频数据是24位的麦克风adc原始值，由于自己电脑声卡输出只支持16位，播放24位音频会没有声音，故在上位机上做了个24位转换为16位的操作，即提取高16位数据，保存到pcm文件中。使用20ms的数据缓冲时间，分别将20ms的pcm数据保存到电脑中。</p><h4 id="音频流实时播放功能实现"><a href="#音频流实时播放功能实现" class="headerlink" title="音频流实时播放功能实现"></a>音频流实时播放功能实现</h4><p>上位机使用pyaudio库播放PCM音频，在程序的开始通过import pyaudio引用该库，读取已经保存在硬盘中的音频数据，通过p = pyaudio.PyAudio()初始化音频播放器，由于PCM是音频的原始数据，不包含量化位数、通道数、采样率等参数，所以，通过stream = p.open(format=p.get_format_from_width(2), channels=1, rate=44563, output=True)配置要播放音频的参数，并赋值给stream对象。通过stream.write(data)向stream播放器对象中写入音频数据，就可以完成音频的实时播放。</p><h4 id="音频流存储功能实现"><a href="#音频流存储功能实现" class="headerlink" title="音频流存储功能实现"></a>音频流存储功能实现</h4><p>使用wave库，将pcm音频保存成wav格式的音频文件写入磁盘，为了方便回放，每10s中保存一个wav音频。通过wavfile = wave.open(‘./wav/‘ + str(j) + ‘.wav’, ‘wb’)打开一个wav文件，通过设置函数给wavfile对象设置音频的通道数、量化位数和采样率。最后通过wavfile.writeframes(data)就可以往wav文件中追加音频内容，每10s保存成一个文件。</p><h3 id="通过多进程实现各个功能"><a href="#通过多进程实现各个功能" class="headerlink" title="通过多进程实现各个功能"></a>通过多进程实现各个功能</h3><h4 id="多进程并行工作实现"><a href="#多进程并行工作实现" class="headerlink" title="多进程并行工作实现"></a>多进程并行工作实现</h4><p>为了让程序高效运行，发挥CPU的多核优势，采用多进程并行的思想来实现上位机的设计。使用多进程可以实现流水线架构，例如，让解码显示图像的操作不阻塞接收UDP数据。在本上位机中共使用了四个进程，分别是图像接收数据和解析数据进程、音频接收数据和解析数据进程、图像实时显示和保存回放进程、音频实时播放和保存回放进程，四个进程互不影响，并行运行。在Python中使用multiprocessing库可实现多进程，例如创建接收和保存数据的进程p1 = multiprocessing.Process(target=receive_save_process, args=(pipe[0], ))，第一个参数是传入进程所执行的函数，第二个参数是所要执行的函数对外的参数接口。通过p1.start()就可以使进程开始运行。</p><h4 id="数据包进程间通信实现"><a href="#数据包进程间通信实现" class="headerlink" title="数据包进程间通信实现"></a>数据包进程间通信实现</h4><p>在Python中进程间通信的常用方式有文件IO，共享内存，管道，消息队列等。通过文件的方式内存通信比较占用IO资源，为了使视频有更好的实时性，本设计采用管道和IO流的方式进程间通信。通过fp = io.BytesIO()创建IO流让fp指向该字节流，fp可以像文件一样通过write函数被写入，通过read函数读取IO流中的数据。多进程库提供了管道这种通信方式，通过multiprocessing.Pipe()创建管道。在多进程通信中，将数据写入IO流，并通过管道传输IO流的地址，使数据可以在内存中被交互，从而达到减小传输时延，使视频更具实时性。</p><h2 id="系统性能测试与功能展示"><a href="#系统性能测试与功能展示" class="headerlink" title="系统性能测试与功能展示"></a>系统性能测试与功能展示</h2><h3 id="系统性能测试"><a href="#系统性能测试" class="headerlink" title="系统性能测试"></a>系统性能测试</h3><h4 id="FIFO和以太网高带宽传输测试"><a href="#FIFO和以太网高带宽传输测试" class="headerlink" title="FIFO和以太网高带宽传输测试"></a>FIFO和以太网高带宽传输测试</h4><p>FPGA编写测试模块，往FIFO模块中高速写入数据，再从FIFO中读取出进行对比，若对比不正确则亮红灯提示。测试的数据需要每次都不一致，竟可能有多个位产生变化，可以采用随机值。噪声的ADC值可以作为硬件真随机值，在本设计中通过麦克风传感器的低八位ADC值来作为测试数据，通过测试FIFO可以在125MHz频率下全速读写。</p><p>以太网测试也是采用比对发送和接收到的数据，由于发送和接收数据无法简单的通过其他的方式高速传输，所以要发送的数据选择有规律的数据。数据选择从0x00开始，下一字节都发送上一个数据加一后的补码，这样可以使每次发送的数据较上一次数据有更多的位会产生变化，通过此方法可以检测出更多的异常数据，若只通过单纯的数据累加测试，无法发现异常数据。经测试，以太网数据在200Mbps带宽下有较好的准确性，丢包现象不常发生，以太网在P2P模式下，全速传输千兆带宽数据时，丢包率为2%左右。</p><h4 id="系统稳定性测试"><a href="#系统稳定性测试" class="headerlink" title="系统稳定性测试"></a>系统稳定性测试</h4><p>对本设计经过长时间的稳定性测试，本设计不会产生图像卡顿，回放保存失败等现象，说明本设计具有良好的系统稳定性。</p><h3 id="作品展示"><a href="#作品展示" class="headerlink" title="作品展示"></a>作品展示</h3><p>下图为FPGA部分的图片，包含FPGA开发板、图像传感器和麦克风传感器。</p><p><img src="https://hao0527.gitee.io/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-14.jpg" alt="220501-毕业设计-14.jpg"></p><h2 id="总结与不足"><a href="#总结与不足" class="headerlink" title="总结与不足"></a>总结与不足</h2><p>毕业设计是对学生四年所学知识的一次考察，也是对我们四年学习成绩的一次考验。本次毕业设计让我学习了FPGA设计和上位机开发，经过此次毕业设计，我懂得了如何将一整个设计划分成多个小功能逐个实现，在联调的过程中也学习了如何分析问题和解决问题。通过本次毕业设计，让我懂得了学习其实是长期积累的过程，越往深的学会发现自己有越多的不会，所以在今后工作是也要学会敬畏知识，学习是个长期积累的过程，就算毕业工作会我也会持续学习，努力提高自己的综合水平。</p><p>本次毕业设计还有几个可以改进的地方：第一，在传输UDP的时候为采用丢包重传，上位机具备发现丢包的能力，可以在丢包发生时将帧序列号发回FPGA，请求FPGA重发数据。第二，上位机软件没有图形化界面，可以使用QT对上位机的图形化界面做开发。第三，FPGA可以尝试设计个MCU，在MCU中跑操作系统和lwip协议栈，使用TCP协议传输语音数据。本设计还有更多功能待完善。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GPIO输入输出各种模式（推挽、开漏、准双向端口）详解</title>
      <link href="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>此文章是搬运来的，<a href="https://blog.csdn.net/techexchangeischeap/article/details/72569999">原地址点击此处</a>，写的真好，能看的非常懂，原作者有个地方可能笔误写错了，做了改正。</p><h2 id="输入IO"><a href="#输入IO" class="headerlink" title="输入IO"></a>输入IO</h2><p>这里所说的输入IO，指的是只作为输入，不具有输出功能。此时对于input引脚的要求就是高阻（高阻与三态是同一个概念）。基本输入电路的类型大致可以分为3类：基本输入IO电路、施密特触发输入电路以及弱上拉输入电路。</p><p>先从最基本的基本输入IO电路说起，其电路如图 1所示。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-1.jpg" alt="220426-GPIO输入输出各种模式-1.jpg"></p><p>其中的缓冲器U1是具有控制输入端，且具有高阻抗特性的三态缓冲器。通俗地说就是这个缓冲器对外来说是高阻的，相当于在控制输入端不使能的情况下，物理引脚与内部总线之间是完全隔离的，完全不会影响内部电路。而控制输入端的作用就是可以发出读Pin状态的操作指令。其过程如图 2所示。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-2.jpg" alt="220426-GPIO输入输出各种模式-2.jpg"></p><p>这种基本电路的一个缺点是在读取外部信号的跳变沿时会出现抖动，如下图所示。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-3.jpg" alt="220426-GPIO输入输出各种模式-3.jpg"></p><p>于是施密特触发输入电路就是解决了上述这种抖动的问题，其经过施密特触发器后的信号如图 4所示。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-4.jpg" alt="220426-GPIO输入输出各种模式-4.jpg"></p><p>对于输入电路还存在另外一个问题，就是当输入引脚悬空的时候，输入端检测到的电平是高还是低？当输入信号没有被驱动，即悬空(Floating)时，输入引脚上任何的噪声都会改变输入端检测到的电平，如图 5所示。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-5.jpg" alt="220426-GPIO输入输出各种模式-5.jpg"></p><p>为了解决这个问题，可以在输入引脚处加一个弱上拉电阻，如图 6所示。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-6.jpg" alt="220426-GPIO输入输出各种模式-6.jpg"></p><p>这样，当输入引脚悬空时，会被RP上拉到高电平，在内部总线上就有确定的状态了。</p><p>但是这种结构是有一定问题的。首先很明显的一点是，当输入引脚悬空时读到的是1，当输入引脚被高电平驱动时读到的也是1，只有当输入引脚被低电平驱动时读到的才是0。也就是对于读1采取的方式是”读取非零”的方式。</p><p>另一个问题是该电路对外呈现的不是高阻，某种意义上说也在向外输出，当外部驱动电路不同时可能出现错误的检测结果。例如外部驱动电路是如图 7所示的结构，该电路结构中通过K打到不同端可以输出高电平或者低电平。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-7.jpg" alt="220426-GPIO输入输出各种模式-7.jpg"></p><p>如果将如图 7所示的电路输出低电平，连接到带有弱上拉电阻的输入引脚，其结构如下所示。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-8.jpg" alt="220426-GPIO输入输出各种模式-8.jpg"></p><p>由欧姆定律知，测试点处的电平是4.545V，于是CPU测得的输入信号为高，而外部驱动电路希望输出的电平为低。这种错误的原因就在于这种结构的输入电路并不是真正的高阻，或者说这个输入IO其实也在输出，而且影响了外部输入电路。</p><p>这种情况的发生也说明了：信号前后两级传递，为什么需要输出阻抗小，输入阻抗大的原因。在这个例子中，外围驱动电路的输出阻抗很大，达到了100Kohm;而输入端的阻抗又不够大，只有10Kohm，于是就出现了问题。如果输入端的输入阻抗真正做到高阻（无穷大），如下所示，就不会出现问题。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-9.jpg" alt="220426-GPIO输入输出各种模式-9.jpg"></p><p>上面提到的这个带弱上拉的输入电路，也就是在后续章节会提到的准双向端口的情况。</p><h2 id="输出IO"><a href="#输出IO" class="headerlink" title="输出IO"></a>输出IO</h2><p>IO输出电路最主要的两种模式分别是推挽输出（Push-Pull Output）和开漏输出（Open Drain Output）。</p><h3 id="推挽输出（Push-Pull-Output）"><a href="#推挽输出（Push-Pull-Output）" class="headerlink" title="推挽输出（Push-Pull Output）"></a>推挽输出（Push-Pull Output）</h3><p>推挽输出的结构是由两个三极管或者MOS管受到互补信号的控制，两个管子始终保持一个处于截止，另一个处于导通的状态。如图 10所示。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-10.jpg" alt="220426-GPIO输入输出各种模式-10.jpg"></p><p>推挽输出的最大特点是可以真正能真正的输出高电平和低电平，在两种电平下都具有驱动能力。</p><p><em><strong>补充说明</strong></em>：所谓的驱动能力，就是指输出电流的能力。对于驱动大负载（即负载内阻越小，负载越大）时，例如IO输出为5V，驱动的负载内阻为10ohm，于是根据欧姆定律可以正常情况下负载上的电流为0.5A（推算出功率为2.5W）。显然一般的IO不可能有这么大的驱动能力，也就是没有办法输出这么大的电流。于是造成的结果就是输出电压会被拉下来，达不到标称的5V。</p><p>当然如果只是数字信号的传递，下一级的输入阻抗理论上最好是高阻，也就是只需要传电压，基本没有电流，也就没有功率，于是就不需要很大的驱动能力。</p><p>对于推挽输出，输出高、低电平时电流的流向如图 11所示。所以相比于后面介绍的开漏输出，输出高电平时的驱动能力强很多。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-11.jpg" alt="220426-GPIO输入输出各种模式-11.jpg"></p><p>但推挽输出的一个缺点是，如果当两个推挽输出结构相连在一起，一个输出高电平，即上面的MOS导通，下面的MOS闭合时；同时另一个输出低电平，即上面的MOS闭合，下面的MOS导通时。电流会从第一个引脚的VCC通过上端MOS再经过第二个引脚的下端MOS直接流向GND。整个通路上电阻很小，会发生短路，进而可能造成端口的损害。这也是为什么推挽输出不能实现” 线与”的原因。</p><h3 id="开漏输出（Open-Drain-Output）"><a href="#开漏输出（Open-Drain-Output）" class="headerlink" title="开漏输出（Open Drain Output）"></a>开漏输出（Open Drain Output）</h3><p>常说的与推挽输出相对的就是开漏输出，对于开漏输出和推挽输出的区别最普遍的说法就是开漏输出无法真正输出高电平，即高电平时没有驱动能力，需要借助外部上拉电阻完成对外驱动。下面就从内部结构和原理上说明为什么开漏输出输出高电平时没有驱动能力，以及进一步比较与推挽输出的区别。</p><p>首先需要介绍一些开漏输出和开集输出。这两种输出的原理和特性基本是类似的，区别在于一个是使用MOS管，其中的”漏”指的就是MOS管的漏极；另一个使用三极管，其中的”集”指的就是MOS三极管的集电极。这两者其实都是和推挽输出相对应的输出模式，由于使用MOS管的情况较多，很多时候就用”开漏输出”这个词代替了开漏输出和开集输出。</p><p>介绍就先从开集输出开始，其原理电路结如图 12所示。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-12.jpg" alt="220426-GPIO输入输出各种模式-12.jpg"></p><p>图 12左边的电路是开集（OC）输出最基本的电路，当输入为高电平时，NPN三极管导通，Output被拉到GND，输出为低电平；当输入为低电平时，NPN三极管闭合，Output相当于开路（输出高阻）。高电平时输出高阻（高阻、三态以及floating说的都是一个意思），此时对外没有任何的驱动能力。这就是开漏和开集输出最大的特点，如何利用该特点完成各种功能稍后介绍。这个电路虽然完成了开集输出的功能，但是会出现input为高，输出为低；input为低，输出为高的情况。</p><p>图 12右边的电路中多使用了一个三极管完成了”反相”。当输入为高电平时，第一个三极管导通，此时第二个三极管的输入端会被拉到GND，于是第二个三极管闭合，输出高阻；当输入为低电平时，第一个三极管闭合，此时第二个三极管的输入端会被上拉电阻拉到高电平，于是第二个三极管导通，输出被拉到GND。这样，这个电路的输入与输出是同相的了。</p><p>接下来介绍开漏输出的电路，如图 13所示。原理与开集输出基本相同，只是将三极管换成了MOS而已。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-13.jpg" alt="220426-GPIO输入输出各种模式-13.jpg"></p><p>接着说说开漏、开集输出的特点以及应用，由于两者相似，后文中若无特殊说明，则用开漏表示开漏和开集输出电路。</p><ol><li><p>开漏输出最主要的特性就是高电平没有驱动能力，需要借助外部上拉电阻才能真正输出高电平，其电路如图 14所示。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-14.jpg" alt="220426-GPIO输入输出各种模式-14.jpg"></p></li></ol><p>当MOS管<em><strong>断开</strong></em>时，开漏输出电路输出高电平，且连接着负载时，电流流向是从外部电源，流经上来电阻RPU，流进负载，最后进入GND。</p><ol><li>开漏输出的这一特性一个明显的优势就是可以很方便的调节输出的电平，因为输出电平完全由上拉电阻连接的电源电平决定。所以在需要进行电平转换的地方，非常适合使用开漏输出。</li><li>开漏输出的这一特性另一个好处在于可以实现”线与”功能，所谓的”线与”指的是多个信号线直接连接在一起，只有当所有信号全部为高电平时，合在一起的总线为高电平；只要有任意一个或者多个信号为低电平，则总线为低电平。而推挽输出就不行，如果高电平和低电平连在一起，会出现电流倒灌，损坏器件。</li></ol><h3 id="推挽与开漏输出的区别"><a href="#推挽与开漏输出的区别" class="headerlink" title="推挽与开漏输出的区别"></a>推挽与开漏输出的区别</h3><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-15.jpg" alt="220426-GPIO输入输出各种模式-15.jpg"></p><h2 id="双向IO"><a href="#双向IO" class="headerlink" title="双向IO"></a>双向IO</h2><p>很多处理器的引脚可以设置为双向端口，双向端口的要求就是既可以输出信号，又可以读回外部信号输入。要同时做到这两点从原理上来说有点困难，首先从处理器的开漏输出IO口的内部结构说起，如图 16所示。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-16.jpg" alt="220426-GPIO输入输出各种模式-16.jpg"></p><p>该结构是在图 13的基础上，在三极管之前加入了一个FF，目的是用于控制输出信号的时间。比较常见的一个应用场合是多个IO作为一个总线时，需要总线上的各个引脚同时将数据输出。</p><p>对于开漏输出结构，会将FF的输出Q端连接会输入驱动缓冲器，这样的话执行读操作是读的并不是外部引脚的状态，而是自己输出的状态。</p><h3 id="双向开漏IO"><a href="#双向开漏IO" class="headerlink" title="双向开漏IO"></a>双向开漏IO</h3><p>但是对图 16的结构稍作修改，如图 17所示时，该结构称为双向开漏IO的结构。所做的改动是将输入驱动缓冲器连接到了PIN上。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-17.jpg" alt="220426-GPIO输入输出各种模式-17.jpg"></p><p>该结构输出为”1”时，T1断开，此时pin对外呈现高阻，作为输入引脚没有任何问题。但是如果该结构输出”0”时，T1导通，此时pin对外短路到地，即无论外部输入什么信号，U2读回的全部是低。所以对于这样的结构，如果需要作为输入引脚使用时，必须给U1输出”1”后才能读取外部引脚数据。</p><h3 id="准双向开漏IO"><a href="#准双向开漏IO" class="headerlink" title="准双向开漏IO"></a>准双向开漏IO</h3><p>很多文献中还提到了准双向端口，其实准双向端口就是图 17的结构中加了一个上拉电阻，如图 18所示。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-18.jpg" alt="220426-GPIO输入输出各种模式-18.jpg"></p><p>这个结构与图 17相比有以下相同与不同之处：</p><ol><li>作为输入引脚使用时，也必须先向U1中写”1”，以达到断开T1的目的。所以是否需要提前写”1”并不是双向IO与准双向IO的区别。两者做输入端口时都需要提前写”1”。</li><li>双向端口作为输入时是真正的高阻态，而准双向IO作为输入端口时，输入阻抗不为高阻，于是有可能出现如本文图 8所示的问题。</li><li>准双向端口读取输入状态，默认为高。也就是判断外部输入信号的方法是”非低则为高”。即该结构只能准确的识别外部的低电平，无法区分悬空和真正的高。于是只要读到的不是0，都认为外部为1。</li></ol><h3 id="推挽输出作为双向IO"><a href="#推挽输出作为双向IO" class="headerlink" title="推挽输出作为双向IO"></a>推挽输出作为双向IO</h3><p>如果双向端口中的输出部分采用的是推挽输出结构，那么作为输入时必须将上下两个管子全部端口才能成为高阻，作为输入。</p><h3 id="51单片机的P0端口"><a href="#51单片机的P0端口" class="headerlink" title="51单片机的P0端口"></a>51单片机的P0端口</h3><p>在双向端口的讨论中，比较复杂的就是51单片机的P0端口了。这里就详细讨论一下51单片机的P0端口结构和工作原理。</p><p>P0端口的内部结构如图 19所示。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-19.jpg" alt="220426-GPIO输入输出各种模式-19.jpg"></p><p>内部结构比较复杂，包括以下这些器件：</p><ol><li>U1：与门。一个输入连着控制线，另一个输入连接这地址/数据信号。由于与门的特性，当控制线为1时，与门输出与地址/数据信号的电平保持一致；如果控制线为0，则输出恒为。于是控制信号线相当于与门的使能信号。</li><li>U2：反相器，输出信号为地址/数据信号的反相信号。</li><li>U3和U6都是具有控制输入端且具有高阻抗特性的三态缓冲器，作用是对于外部呈现高阻态。当控制端使能时可以将外部信号的电平读进数据总线。</li><li>U4：为锁存器，目的就是控制引脚输出信号的时间。</li><li>U5：模拟开关，可以控制V2的输入信号是来自锁存器U4的Q非输出还是来自于反相器U2的输出。</li><li>V1和V2分别是两个MOS管。</li></ol><p>了解了各个独立器件之后就开始介绍工作在各个模式下的工作原理：</p><p><strong>P0用于地址/数据线时：</strong></p><p>在P0作为地址/数据线时，是地址、数据复用总线，P0需要输出地址，同时需要读回数据信号。</p><p>当P0需要输出地址信息时，U1的控制信号为0，模拟开关U5接到U2反相器的输出。于是当地址信号线传来的信号为1，与控制线”1”相与之后输出到V1的输入信号为”0”，V1截止。地址信号”1”经反相之后，通过模拟开关输出到V2的输入端为”1”，V2导通，于是情况如图 20所示，pin输出”0”。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-20.jpg" alt="220426-GPIO输入输出各种模式-20.jpg"></p><p>当地址信号线传来的信号为1，与控制线”1”相与之后输出到V1的输入信号为”1”，V1导通。地址信号”0”经反相之后，通过模拟开关输出到V2的输入端为”0”，V2截止，于是情况如图 21所示，pin输出”1”。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-21.jpg" alt="220426-GPIO输入输出各种模式-21.jpg"></p><p>于是在作为地址线输出时，V1、V2两个MOS管均使用了，是推挽输出。</p><p>当P0在输出低8位地址信息后，将变为数据总线，此时CPU的操作是控制端输出0，模拟开关打到锁存器的Q非端，且向锁存器中打入”1”。于是Q非输出为0，V2截止。同时控制线为0使得与门输出为0，V1截止。由于V1和V2都截止，所以此时pin对外完全呈现高阻，作为输入端口，外部数据通过U6进入内部总线，情况如图 22所示。（相当于将推挽输出的两个MOS管全部断开了）此时由于对外呈现高阻，所以是真正的输入引脚。这就解释了为什么说P0是真正的双线端口。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-22.jpg" alt="220426-GPIO输入输出各种模式-22.jpg"></p><p><strong>P0用于普通IO时：</strong></p><p>在P0作为普通IO并作为输出时，控制信号为0，使V1始终处于截止状态。模拟开关连接到Q非输出，当作为输出时，锁存器的输入端直接输入0或者1，Q非将反相信号输入到V2的输入端。即当输出”0”时，V2输入端为”1”，V2导通，pin输出”0”；当输出”1”时，V2输入端为”0”，V2截止，pin输出高阻的0。即当P0工作在普通IO模式下，输出为开漏输出，且内部没有上拉电阻。</p><p>在P0作为普通IO并作为输入时，控制信号为0，使V1始终处于截止状态。模拟开关连接到Q非输出，且CPU自动向锁存器输入端写1，则V2输入端为0，V2截止。与之前在作为地址/数据线，作为输入时一样，也是两个MOS管全部断开，pin直接连接到U6，对外呈现高阻。于是也是真正的输入引脚。</p><p>综上P0无论工作在哪种模式下都是真正的双端口IO。</p><h3 id="51单片机的P1～P3端口"><a href="#51单片机的P1～P3端口" class="headerlink" title="51单片机的P1～P3端口"></a>51单片机的P1～P3端口</h3><p>51单片机的其他三个端口的内部结构如图 23所示，与P0相比简单了很多，没有了顶部的MOS管，也没有了地址/数据信号的选项。作为输出时是带有上拉电阻的的开漏输出，作为输入时是有上拉电阻存在的，于是输入端口对外不是高阻。这就解释了为什么P1～P3只能是准双向端口。</p><p><img src="https://hao0527.gitee.io/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F-23.jpg" alt="220426-GPIO输入输出各种模式-23.jpg"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C/C++中几个易混淆的点</title>
      <link href="/2022/04/04/220404-C%E7%9A%84%E7%96%91%E6%83%91/"/>
      <url>/2022/04/04/220404-C%E7%9A%84%E7%96%91%E6%83%91/</url>
      
        <content type="html"><![CDATA[<h2 id="数组指针-amp-指针数组"><a href="#数组指针-amp-指针数组" class="headerlink" title="数组指针&amp;指针数组"></a>数组指针&amp;指针数组</h2><p>参考：<a href="https://www.cnblogs.com/mq0036/p/3382732.html%EF%BC%8C%E4%B8%A4%E8%80%85%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%86%99%E7%9A%84%E5%BE%88%E8%AF%A6%E7%BB%86%E3%80%82">https://www.cnblogs.com/mq0036/p/3382732.html，两者内存分布写的很详细。</a></p><h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>定义<code>int (*p)[n];</code></p><p>()优先级比[]高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。</p><p>如要将二维数组赋给一指针，应这样赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>];   <span class="comment">//该语句是定义一个数组指针，指向含4个元素的一维数组。</span></span><br><span class="line">p = a;     <span class="comment">//将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span></span><br><span class="line">p++;       <span class="comment">//该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</span></span><br></pre></td></tr></table></figure><p>所以数组指针也称指向一维数组的指针，亦称行指针。</p><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>定义<code>int *p[n];</code></p><p>[]优先级比*高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]…p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 <em>p=a; 这里</em>p表示指针数组第一个元素的值，a的首地址的值。<br>如要将二维数组赋给一指针数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">p++;  <span class="comment">//该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    p[i] = a[i];</span><br></pre></td></tr></table></figure><p>这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]，所以要分别赋值。</p><h2 id="常量指针-amp-指针常量"><a href="#常量指针-amp-指针常量" class="headerlink" title="常量指针&amp;指针常量"></a>常量指针&amp;指针常量</h2><h3 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h3><p>定义<code>int * const p = &amp;a;</code></p><p>p是个常量，p的类型是int*，所以p的值不能改变，但是*p的值可以改变。</p><h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>定义<code>const int * p = NULL;</code></p><p>*p是个常量，p的类型是int*，所以*p的值不能改变，但是p的值可以改变。利用这个特性，在函数传参时使用常量指针可以防止函数对变量值的误修改。</p><h3 id="常量指针常量"><a href="#常量指针常量" class="headerlink" title="常量指针常量"></a>常量指针常量</h3><p>定义<code>const int * const p = &amp;a;</code></p><p>p是个常量，*p也是个常量，p的类型是int*，所以*p的值不能改变，p的值也不能改变。</p><h2 id="引用-amp-常量引用"><a href="#引用-amp-常量引用" class="headerlink" title="引用&amp;常量引用"></a>引用&amp;常量引用</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>定义<code>int&amp; r = a;</code></p><p><a href="https://www.runoob.com/cplusplus/cpp-references.html">C++ 引用</a>，引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。</p><p>函数可以通过引用传参，<code>void foo(int &amp;a)&#123;a = 1;&#125;</code>修改引用形参可以改变实参。</p><h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><p>定义<code>const int&amp; r = a;</code></p><p>函数可以通过常量引用传参，<code>void foo(const int &amp;a) &#123;;&#125;</code>只能读取a，不能修改a。利用这个特性，在函数传参时使用常量指针可以防止函数对变量值的误修改。</p><h2 id="函数指针-amp-指针函数"><a href="#函数指针-amp-指针函数" class="headerlink" title="函数指针&amp;指针函数"></a>函数指针&amp;指针函数</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>定义函数指针<code>void (*pFun)(int a, int b);</code></p><p>定义函数<code>void Fun(int a, int b) &#123;;&#125;</code></p><p>将Fun函数的首地址赋给指针变量pFun<code>pFun = Fun;</code>也可以是<code>pFun = &amp;Fun;</code></p><p>通过指针函数调用<code>pFun(1, 2);</code>也可以是<code>(*pFun)(1, 2);</code></p><p>函数指针定义时返回值，参数类型，个数都必须与要指向的函数相同。</p><h3 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h3><p>指针函数是返回类型为指针的函数。</p><h2 id="C结构体内存对齐"><a href="#C结构体内存对齐" class="headerlink" title="C结构体内存对齐"></a>C结构体内存对齐</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《操作系统》笔记</title>
      <link href="/2022/03/26/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/03/26/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="课程链接"><a href="#课程链接" class="headerlink" title="课程链接"></a>课程链接</h2><ul><li><p><a href="https://www.bilibili.com/video/BV1d4411v7u7?p=1">操作系统（哈工大李治军老师）32讲（全）超清</a></p></li><li><p><a href="https://www.shiyanlou.com/courses/115">配套实验课</a></p></li></ul><h2 id="课程笔记"><a href="#课程笔记" class="headerlink" title="课程笔记"></a>课程笔记</h2><h3 id="L1-L3"><a href="#L1-L3" class="headerlink" title="L1~L3"></a>L1~L3</h3><ol><li><p>课程目标：进入操作系统，学习操作系统的运作。</p></li><li><p>计算机工作方式：取址执行，取CS和PC指针指向内存中的指令，在CPU执行</p></li><li><p>操作系统引导：启动引导时内核在内存中的位置和移动后的位置情况图<img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.jpg" alt="220326-操作系统-1.jpg"></p><p>开机时，CS=0xffff，IP=0x0000，CPU处于实模式。实模式寻址CS&lt;&lt;4+IP，CS存放段地址，IP存放4位段偏移量，共20位。0xffff0地址属于BIOS映射区，在BIOS里检查硬件（RAM，键盘，…）；</p><p>将磁盘0磁道0扇区（引导扇区）读到内存0x7c00，引导扇区代码存放在bootsect.s；</p><p>将引导扇区代码从内存0x7c00处移动到0x90000处；</p><p><code>jmpi go, INITSEG</code>，INITSEG=0x9000，跳至bios的go标号处；</p><p><code>jmpi 0, SETUPSEG</code>，SETUPSEG=0x9020，跳至setup.s；</p><p>在setup.s  start:中读取扩展内存大小，读取显卡参数，…；</p><p>do_move:中将system模块移动到0地址，<code>jmpi 0, 8</code>，跳转到system模块，system模块开始是head.s；</p><p>通过设置cr0最后一位，PE=1由16位实模式转到32位保护模式，在保护模式下，CS表示选择子，查GDT表得到；</p><p>在head.s中初始化GDT表和IDT表，setup_paging执行ret后，会执行函数main()，进入main()后的栈为0，0，0，L6，三个0表示main函数的参数，L6表示main函数返回时进入死循环；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">after_page_tables:</span><br><span class="line">    pushl $0 # These are the parameters to main :-)</span><br><span class="line">    pushl $0 # 这些是调用 main 程序的参数（指 init/main.c）。</span><br><span class="line">    pushl $0 # 其中的&#x27;$&#x27;符号表示这是一个立即操作数。</span><br><span class="line">    pushl $L6 # return address for main, if it decides to.</span><br><span class="line">    pushl $_main # &#x27;_main&#x27;是编译程序对 main 的内部表示方法。</span><br><span class="line">    jmp setup_paging # 跳转至第 198 行。</span><br><span class="line">L6:</span><br><span class="line">    jmp L6 # main should never return here, but</span><br><span class="line">    # just in case, we know what happens.</span><br><span class="line">    # main 程序绝对不应该返回到这里。不过为了以防万一，</span><br><span class="line">    # 所以添加了该语句。这样我们就知道发生什么问题了。</span><br><span class="line">setup_paging:</span><br><span class="line">    设置页表...</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></li></ol><h3 id="L4-L7"><a href="#L4-L7" class="headerlink" title="L4~L7"></a>L4~L7</h3><ol><li>操作系统接口：接口表现为函数调用，又由系统提供，所以称为系统调用，可移植操作系统接口(Portable Operating System Interface of uniX, POSIX)</li><li>系统调用的实现：应用层要通过接口访问内核，不能直接读内核内存，内核是受保护的。中断是进入内核的唯一方法；<img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.jpg" alt="220326-操作系统-2.jpg"><img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3.jpg" alt="220326-操作系统-3.jpg"></li><li>课程任务：操作系统要学习CPU管理、内存管理、文件管理；</li></ol><h3 id="L8-L19"><a href="#L8-L19" class="headerlink" title="L8~L19"></a>L8~L19</h3><ol><li><p>CPU管理：多道程序，交替执行（并发）。运行的程序是进程，多进程切换时要保存现场。通过进程控制块(Process Control Block, PCB)来记录进程信息。操作系统要把这些进程记录好，要按照合理的次序分配资源、调度；</p></li><li><p>进程状态图：<img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-4.jpg" alt="220326-操作系统-4.jpg"></p></li><li><p>通过进程内存映射表来实现内存分离，切换进程时要切换内存映射表；通过上锁，来保证共享内存的正确被读写；</p></li><li><p>用户级线程和核心级线程区别：用户级线程创建、切换无需进内核，一个线程阻塞进程会被切换；</p></li><li><p>线程的优点：线程切换无需切换内存映射表。<img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-5.jpg" alt="220326-操作系统-5.jpg"></p></li><li><p>用户级线程切换通过Yield()，要先切换栈，栈会存在TCB（线程控制块）中，每个线程对应一个TCB；</p></li><li><p>核心级线程切换时除了用户栈还有内核栈也要一起切换。在内核阻塞时要进行TCB切换，使用<code>switch_to(cur, next);</code>TCB切换完后根据TCB完成内核栈切换，最后IRET返回用户态，切换用户栈；</p></li><li><p>前台任务需要响应时间小-&gt;导致切换次数多-&gt;导致系统内耗大-&gt;导致吞吐量（完成任务的量）小。后台任务更加关注周转时间。任务可分成IO约束型任务和CPU约束型任务；</p></li><li><p>CPU调度策略：FIFO、Priority；CPU调度算法：先来先服务（First come, first served），短作业优先（SJF）这个算法周转时间最小，按时间片来轮转调度（RR），优先级调度（前台&gt;后台）；</p></li><li><p>linux0.11中的调度函数既考虑了优先级又考虑了时间片：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Schedule</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// 在 kernel/sched.c 中</span></span><br><span class="line">&#123; <span class="keyword">while</span>(<span class="number">1</span>)&#123; c=<span class="number">-1</span>; next=<span class="number">0</span>; i=NR_TASKS; p=&amp;task[NR_TASKS];</span><br><span class="line">    <span class="keyword">while</span>(--i)&#123; <span class="keyword">if</span>((*p-&gt;state == TASK_RUNNING&amp;&amp;(*p)-&gt;counter&gt;c)</span><br><span class="line">        c=(*p)-&gt;counter, next=i; &#125;</span><br><span class="line">    <span class="keyword">if</span>(c) <span class="keyword">break</span>; <span class="comment">// 找到了最大的counter,跳出，执行switch_to()</span></span><br><span class="line">    <span class="keyword">for</span>(p=&amp;LAST_TASK;p&gt;&amp;FIRST_TASK;--p)</span><br><span class="line">        (*p)-&gt;counter=((*p)-&gt;counter&gt;&gt;<span class="number">1</span>)+(*p)-&gt;priority; </span><br><span class="line">    &#125;</span><br><span class="line">switch_to(next);&#125;</span><br></pre></td></tr></table></figure></li><li><p>进程间同步看信号量（Semaphore），可使多个进程合理有序运行。<strong>读写信号量的代码一定在临界区</strong>，或者原子操作。临界区：一次只允许一个进程进入该进程的那段代码。原子操作：不会被线程调度机制打断的操作;</p></li><li><p>保护临界区的方法：关闭中断<code>cli();</code>，临界区，开中断<code>sti();</code>，剩余区。这种方法只适用于小系统，不适用于多核CPU。还可以采取硬件原子指令法，硬件一条指令修改mutex变量；</p></li><li><p>信号量未互斥使用会造成死锁。死锁处理：死锁预防，死锁避免，死锁检测+恢复，死锁忽略；</p></li></ol><h3 id="L20-L25"><a href="#L20-L25" class="headerlink" title="L20~L25"></a>L20~L25</h3><ol><li><p>内存使用：将程序放到内存中，PC指向开始的地址。将程序从硬盘载入内存需要重定位，物理地址=基址+逻辑地址。重定位可以在编译时（静态系统）、载入时执行、<strong>运行时执行</strong>。编译时重定位的程序只能放在内存固定位，载入时重定位的程序一旦载入内存就不能动了；<img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6.jpg" alt="220326-操作系统-6.jpg"></p></li><li><p>程序载入后还需要移动，引入<strong>交换</strong>（swap）概念，可以把暂时不用的内存搬到交换分区，充分利用内存。</p></li><li><p>引入分段，程序由若干部分(段)组成，每个段有各自的特点、用途：主程序（只读）、变量集（可写、不会动态增长）、函数集、动态数组（会动态增长）、栈。使用分段思想可以让用户分治每个段，可以让内存更高效使用。定位具体指令<code>mov [es:bx], ax</code>。地址组成：&lt;段号，段内偏移&gt;。进程段表存放在LDT表，系统段表存放在GDT表，LDT存放在PCB中；<img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-7.jpg" alt="220326-操作系统-7.jpg"></p></li><li><p><strong>内存分区</strong>可分为固定分区和可变分区。可变分区的管理：空闲分区表、已分配分区表。可变分区分配内存算法：首先适配（最快）、最佳适配和申请空间长度最接近（会导致内存碎片）、最差适配；</p></li><li><p>实际物理内存采用<strong>分页</strong>来管理，分区是对虚拟内存（交换分区）的管理方法。分区会造成内存碎片，分页会将物理内存分割（比如每4k分割），程序也会被分页，每段都会被分页，分页会使内存存储离散化。地址翻译有专门的硬件内存管理单元（MMU）执行；<img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8.jpg" alt="220326-操作系统-8.jpg"></p></li><li><p>为了提高内存空间利用率，页应该小，但是页小了页表就大了。如果页表只存放用到的页，则需要顺序查找页表，速度慢。采用多级页表可兼顾速度和空间，即页目录表+页表，地址组成&lt;10bits页目录号，10bits页号，12bits偏移&gt;，12bits偏移刚好是4K。</p></li><li><p>多级页表增加了访存的次数，尤其是64位系统。硬件上引入转译后备缓冲区（Translation Look-aside Buffer，TLB，快表），快表能存放最近查过多级页表的逻辑页和物理页，可以根据页号直接查物理页号；<img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-9.jpg" alt="220326-操作系统-9.jpg"></p></li><li><p>段页结合：段面向用户，页面向硬件。实际的段页内存管理，程序如何载入内存，fork后内存做了什么可以看<a href="https://www.bilibili.com/video/BV1d4411v7u7?p=23">L23 段页结合的实际内存管理</a>；<img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-10.jpg" alt="220326-操作系统-10.jpg"></p></li><li><p>用内存换入换出实现“大内存”，虚拟内存4G，物理内存可以只有1G。当程序运行缺页时， page fault中断请求do_no_page调页（读磁盘），这就是换入；</p></li><li><p>内存换出：将内存中不用的页换出到磁盘。如何找不用的页？换出算法：FIFO（先来的先被换出，不太行）、MIN（将未来最远要使用的页淘汰，是最优方案，但无法预测未来）、LRU（Least Recently Used，最近最少使用）；</p></li><li><p>LUR的准确实现：可以用时间戳，每次地址访问都需要修改时间戳，需维护一个全局时钟，实现代价较较大，可以用页码栈，选择栈底淘汰，代价也太大。在实际中内存换出算法采用LUR的近似实现：时钟算法（环形队列）<img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-11.jpg" alt="220326-操作系统-11.jpg"><img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-12.jpg" alt="220326-操作系统-12.jpg"></p></li><li><p>给进程分配多少页框？分配多了，请求调页导致的内存高效利用就没有了。分配少了，会频繁请求调页导致系统低效。系统低效解释：系统内进程增多多，每个进程的缺页率增大大，缺页率增大到一定程度，进程总等待调页完成，CPU利用率降低低，进程进一步增多，缺页率更大，称这一现象为颠簸(thrashing)；</p></li></ol><h3 id="L26-L32"><a href="#L26-L32" class="headerlink" title="L26~L32"></a>L26~L32</h3><ol><li><p>IO设备、显示器、键盘，让这些外设工作的基本思想就是往外设硬件寄存器写值，外设处理完再产生中断，CPU处理。在Linux中无论什么设备都用文件接口open、read、write、close，例如<code>int fd = open(&quot;/dev/xxx&quot;);</code>到最后是通过out写对应寄存器；</p></li><li><p>生磁盘的使用：磁盘驱动负责从盘块号（block）计算出柱面（cgl）、磁头（head）、扇区号（sec）。从CHS到扇区号，从扇区到盘块（第一层抽象）：<strong>扇区号 = C×H×S+H×S+S</strong> 。<img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-13.jpg" alt="220326-操作系统-13.jpg"></p></li><li><p>多个进程通过<strong>请求队列</strong>使用磁盘（第二层抽象）；<img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-14.jpg" alt="220326-操作系统-14.jpg"></p></li><li><p><strong>访问磁盘时间 = 写入控制器时间 + 寻道时间（8~12ms）+ 旋转时间（7200rmp，半周4ms）+ 传输时间（50MB/s，约0.3ms）</strong>。可见访问磁盘主要时间花在寻道，block相邻的盘块可以快速读出，因此需要考虑寻道算法。寻道调度算法有FCFS（先来先服务）、SSTF（短寻道优先算法，可能有磁道长时间访问不到）、SCAN（SSTF+中途不折回）、C-SCAN（SCAN+直接移动到另一端，电梯算法）；</p></li><li><p>引入文件（第三层抽象），文件是建立字符流在磁盘块集合的映射关系，每个文件都对应一个文件控制块（FCB），连续结构存储FCB包含文件名、起始块、块数的信息，链式结构存储FCB包含文件名、起始块的信息，链式结构存储顺序访问慢、可靠性差，<strong>索引结构</strong>存储文件是连续和链式的有效折中，FCB包含文件名、索引块的信息。在实际系统中采用的是<strong>多级索引结构</strong>，根据不同大小文件分成不同级索引通过<strong>inode</strong>一级级查询访问，因此可以标识很大的文件，很小的文件可以高效访问，中等大小的文件访问速度也不慢；</p></li><li><p>引入文件系统（第四层抽象），文件系统引入目录树，文件目录也是个文件，存放目录下其他文件名和对应文件的FCB指针。inode位图：哪些inode空闲，哪些被占用。盘块位图：哪些盘块是空闲的，硬盘大小不同这个位图的大小也不同。超级块：存放i节点位图和盘块位图的大小，因此可以计算出i节点起始地址；<img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-15.jpg" alt="220326-操作系统-15.jpg"><img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-16.jpg" alt="220326-操作系统-16.jpg"><img src="https://hao0527.gitee.io/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-17.jpg" alt="220326-操作系统-17.jpg"></p></li></ol><h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><p>通过本次操作系统的学习，了解了操作系统全图（CPU、内存、文件设备），学习了多进程视图、文件视图。哈工大的几个实验非常的难，Study OS by coding !!!</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用GDB调试C/C++程序</title>
      <link href="/2022/03/17/220317-gdb/"/>
      <url>/2022/03/17/220317-gdb/</url>
      
        <content type="html"><![CDATA[<h2 id="GDB介绍"><a href="#GDB介绍" class="headerlink" title="GDB介绍"></a>GDB介绍</h2><h3 id="GDB是什么"><a href="#GDB是什么" class="headerlink" title="GDB是什么"></a>GDB是什么</h3><p><a href="http://www.sourceware.org/gdb/">GDB: The GNU Project Debugger</a>，GDB是GNU开源组织发布的一个强大的Linux下的程序调试工具，GDB主要帮助你完成下面四个方面的功能：</p><ul><li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li><li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li><li>当程序被停住时，可以检查此时你的程序中所发生的事。</li><li>你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。</li></ul><h3 id="GDB支持哪些语言"><a href="#GDB支持哪些语言" class="headerlink" title="GDB支持哪些语言"></a>GDB支持哪些语言</h3><p>GDB主要来调试C/C++语言写的程序，当然也就可以调试其他语言程序，另外的语言没了解过。</p><h2 id="GDB使用"><a href="#GDB使用" class="headerlink" title="GDB使用"></a>GDB使用</h2><h3 id="在Ubuntu中安装GDB"><a href="#在Ubuntu中安装GDB" class="headerlink" title="在Ubuntu中安装GDB"></a>在Ubuntu中安装GDB</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install gdb</span><br></pre></td></tr></table></figure><h3 id="补一下GCC的知识"><a href="#补一下GCC的知识" class="headerlink" title="补一下GCC的知识"></a>补一下GCC的知识</h3><p><a href="https://www.runoob.com/w3cnote/gcc-parameter-detail.html">GCC参数详解</a>，gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：</p><ul><li><p>预处理,生成 .i 的文件[预处理器cpp]，指令：-E</p></li><li><p>将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]，指令：-S</p></li><li><p>由汇编变为目标代码(机器代码)生成 .o 的文件[汇编器as]，指令：-c</p></li><li><p>连接目标代码, 生成可执行程序 [链接器ld]，指令：-o FILE</p></li></ul><p>在配合GDB时，gcc的指令选项有：</p><ul><li>-g（生成调试信息，GNU 调试器可利用该信息）</li><li>-ggdb（此选项将尽可能的生成 gdb 的可以使用的调试信息）</li></ul><h3 id="GDB中的基本调试命令"><a href="#GDB中的基本调试命令" class="headerlink" title="GDB中的基本调试命令"></a>GDB中的基本调试命令</h3><table><thead><tr><th><strong>命令</strong></th><th><strong>命令缩写</strong></th><th><strong>命令说明</strong></th></tr></thead><tbody><tr><td>set args</td><td></td><td>设置主程序的参数。例如：./test 1 2设置参数的方法是：gdb test(gdb) set args 1 2</td></tr><tr><td>break</td><td>b</td><td>设置断点，b 20 表示在第20行设置断点，可以设置多个断点。</td></tr><tr><td>run</td><td>r</td><td>开始运行程序, 程序运行到断点的位置会停下来，如果没有遇到断点，程序一直运行下去。</td></tr><tr><td>next</td><td>n</td><td>执行当前行语句，如果该语句为函数调用，不会进入函数内部执行。</td></tr><tr><td>step</td><td>s</td><td>执行当前行语句，如果该语句为函数调用，则进入函数执行其中的第一条语句。注意了，如果函数是库函数或第三方提供的函数，用s也是进不去的，因为没有源代码，如果是您自定义的函数，只要有源码就可以进去。</td></tr><tr><td>print</td><td>p</td><td>显示变量值，例如：p name表示显示变量name的值，print可以做运算。</td></tr><tr><td>continue</td><td>c</td><td>继续程序的运行，直到遇到下一个断点。</td></tr><tr><td>set var name=value</td><td></td><td>设置变量的值，假设程序有两个变量：int ii; char name[21];set var ii=10 把ii的值设置为10；set var name=”abc” 把name的值设置为”abc”，注意，不是strcpy。</td></tr><tr><td>quit</td><td>q</td><td>退出gdb环境。</td></tr></tbody></table><h3 id="进入GDB调试"><a href="#进入GDB调试" class="headerlink" title="进入GDB调试"></a>进入GDB调试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -g -o test</span><br><span class="line">gdb test # 进入gdb，指定test为可执行文件</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以只执行gdb，在gdb中用file命令指定可执行文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来就可以使用GDB的基本调试命令调试程序了</span></span><br></pre></td></tr></table></figure><h3 id="调试正在运行的程序"><a href="#调试正在运行的程序" class="headerlink" title="调试正在运行的程序"></a>调试正在运行的程序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过ps获取程序进程号</span></span><br><span class="line">gdb test -p [进程号]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入gdb后，程序会被暂停</span></span><br><span class="line">(gdb)bt # 使用bt查看程序的调用栈</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Print backtrace of all stack frames, or innermost COUNT frames.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出后，程序继续执行</span></span><br></pre></td></tr></table></figure><h3 id="调试多进程程序"><a href="#调试多进程程序" class="headerlink" title="调试多进程程序"></a>调试多进程程序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb)set follow-fork-mode [parent|child]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（缺省是parent）调试父|子进程，父|子进程不受影响</span></span><br><span class="line">(gdb)set datach-on-fork [on|off]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（缺省是on）on表示调试当前进程时，其他进程继续运行，off表示调试当前进程时，其他进程被GDB挂起</span></span><br><span class="line">(gdb)info inferiors # 查看调试的进程</span><br><span class="line">(gdb)inferior # 切换当前调试的进程，进程id是查看调试的进程返回的Num值</span><br></pre></td></tr></table></figure><h3 id="调试多线程程序"><a href="#调试多线程程序" class="headerlink" title="调试多线程程序"></a>调试多线程程序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep test # 查看当前运行的进程，查找符合&quot;test&quot;的字符串</span><br><span class="line">ps -aL|grep test # 查看当前运行的轻量级进程</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。</span></span><br><span class="line">pstree -p [主线程ID] # 查看主线程和新线程的关系</span><br><span class="line">(gdb)info threads # 查看线程</span><br><span class="line">(gdb)thread [线程ID] # 切换线程，线程ID是查看线程返回的Num值</span><br><span class="line">(gdb)set scheduler-locking [on|off] # on：只运行当前线程，off：运行全部的线程</span><br><span class="line">(gdb)thread apply [线程ID|all] [cmd] # 让某个|全部线程执行某GDB命令</span><br></pre></td></tr></table></figure><h3 id="服务程序运行日志"><a href="#服务程序运行日志" class="headerlink" title="服务程序运行日志"></a>服务程序运行日志</h3><p>设置断点或单步跟踪可能会严重干扰多进程、多线程之间的竞争状态，导致我们看到一个假象。一旦我们在某个线程设置了断点，该线程在断点处挺住了，只剩下另一个线程在跑。这时候，并发的场景已经完全被破坏了，通过调试器看到的只是一个和谐的场景（理想状态）。<strong>输出Log日志</strong>可以避免断点和单步跟踪所导致的副作用。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言内嵌汇编</title>
      <link href="/2022/02/25/220225-asmInC/"/>
      <url>/2022/02/25/220225-asmInC/</url>
      
        <content type="html"><![CDATA[<h2 id="今晨的日出"><a href="#今晨的日出" class="headerlink" title="今晨的日出"></a>今晨的日出</h2><p><img src="https://hao0527.gitee.io/220225-asmInC/220225-asmInC-1.jpg" alt="220225-asmInC-1.jpg"></p><p>早晨学习操作系统，看到系统调用实现时，遇到了C内嵌汇编，所以补了下相关知识。</p><h2 id="asm"><a href="#asm" class="headerlink" title="__asm__"></a>__asm__</h2><p>补充资料：<a href="https://dirtysalt.github.io/html/gcc-asm.html">https://dirtysalt.github.io/html/gcc-asm.html</a></p><p>在内嵌汇编中，可以将C语言表达式指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入哪个寄存器，以及如何将计算结果写回C 变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可，GCC会自动插入代码完成必要的操作。</p><p>完整的内嵌汇编格式：<code>__asm__ __volatile__(&quot;Instruction List&quot; : Output : Input : Clobber/Modify);</code></p><p>__asm__ 是GCC关键字asm的宏定义，asm用于声明这行代码是一个内嵌汇编表达式，任何内嵌的汇编表达式都以此关键字作为开头。</p><p>一个最简单的内嵌汇编：<code>__asm__(&quot;nop&quot;);</code> 括号里的是汇编指令，表示运行空指令，一个机器周期。Instruction List 是汇编指令序列，它可以是空的。可以有多条汇编指令，需要将所有指令放在多对引号中，两条指令必须用换行或分号分开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    ……</span></span><br><span class="line">    __asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl $buf\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl $0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;call tty_write\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;addl $8,%%esp\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">            ::<span class="string">&quot;r&quot;</span> (i):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line"><span class="comment">//    ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看上面<code>printk()</code>的例子，首先<code>push %fs</code>保存这个指向用户段的寄存器，在最后<code>pop %fs</code>将其恢复，<code>printk()</code>的核心是调用<code>tty_write()</code>。</p><p>Output Input 用来指定当前内联汇编语句的输出与输入，格式为形如“constraint”(variable)的列表（逗号分隔)，constraint是限制字符，下面表中列出几个常用限制字符作用，更多用法见：<a href="https://blog.csdn.net/qq_15974389/article/details/76416668">GCC内嵌汇编一些限制字符串</a>。</p><table><thead><tr><th>限制字符</th><th>作用</th></tr></thead><tbody><tr><td>a/b/c/d/s/d</td><td>将输入变量放入eax/ebx/ecx/edx/esi/edi</td></tr><tr><td>q</td><td>将输入变量放入eax,ebx,ecx,edx中的一个</td></tr><tr><td>r</td><td>输入变量放入通用寄存器，也就是eax,ebx,ecx,edx,esi,edi中的一个</td></tr><tr><td>=/+</td><td>操作数在指令中是只写/读写类型的（输出操作数）</td></tr></tbody></table><h2 id="volatile"><a href="#volatile" class="headerlink" title="__volatile__"></a>__volatile__</h2><p>__volatile__ 是GCC关键字volatile的宏定义，在内联汇编中，它是可选的。使用它会向GCC声明不允许对该内联汇编优化，否则当使用了优化选项(-O)进行编译时，GCC将会根据自己的判断决定是否将这个内联汇编表达式中的指令优化掉。</p><p>编译器优化常用的方法有：将内存变量缓存到寄存器；调整指令顺序充分利用CPU指令流水线，常见的是重新排序读写指令。对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由编译器优化或者硬件重新排序引起的问题的解决办法是在从硬件（或者其他处理器）的角度看必须以特定顺序执行的操作之间设置内存屏障（memory barrier），linux 提供了一个宏，<code>barrier()</code>，解决编译器的执行顺序问题，但对硬件无效。</p><p>有一种硬件级别的优化：内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入硬件高速缓存Cache，加速对内存的访问。在现代CPU中指令的执行并不一定严格按照顺序执行，没有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。</p><h2 id="Clobber-Modify"><a href="#Clobber-Modify" class="headerlink" title="Clobber/Modify"></a>Clobber/Modify</h2><p>有时候，你想通知GCC当前内联汇编语句可能会对某些寄存器或内存进行修改，希望GCC在编译时能够将这一点考虑进去。那么你就可以在Clobber/Modify域声明这些寄存器或内存。这种情况一般发生在一个寄存器出现在”Instruction List”，但却不是由Input/Output操作表达式所指定的，也不是在一些Input/Output操作表达式使用”r”约束时由GCC 为其选择的，同时此寄存器被”Instruction List”中的指令修改，而这个寄存器只是供当前内联汇编临时使用的情况。</p><p>例如：<code>__asm__ (&quot;mov R0, #0x34&quot; : : : &quot;R0&quot;);</code>寄存器R0出现在”Instruction List中”，并且被mov指令修改，但却未被任何Input/Output操作表达式指定，所以你需要在Clobber/Modify域指定”R0”，以让GCC知道这一点。</p><p>因为你在Input/Output操作表达式所指定的寄存器，或当你为一些Input/Output操作表达式使用”r”约束，让GCC为你选择一个寄存器时，GCC对这些寄存器是非常清楚的——它知道这些寄存器是被修改的，你根本不需要在Clobber/Modify域再声明它们。但除此之外， GCC对剩下的寄存器中哪些会被当前的内联汇编修改一无所知。所以如果你真的在当前内联汇编指令中修改了它们，那么就最好在Clobber/Modify 中声明它们，让GCC针对这些寄存器做相应的处理。否则有可能会造成寄存器的不一致，从而造成程序执行错误。</p><p>如果一个内联汇编语句的Clobber/Modify域存在”memory”，那么GCC会保证在此内联汇编之前，如果某个内存的内容被装入了寄存器，那么在这个内联汇编之后，如果需要使用这个内存处的内容，就会直接到这个内存处重新读取，而不是使用被存放在寄存器中的拷贝。因为这个 时候寄存器中的拷贝已经很可能和内存处的内容不一致了。</p><p>这只是使用”memory”时，GCC会保证做到的一点，但这并不是全部。因为使用”memory”是向GCC声明内存发生了变化，而内存发生变化带来的影响并不止这一点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> __argc, <span class="type">char</span>* __argv[])</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span>* __p = (<span class="type">int</span>*)__argc; </span><br><span class="line">    (*__p) = <span class="number">9999</span>; </span><br><span class="line">    __asm__(<span class="string">&quot;&quot;</span>:::<span class="string">&quot;memory&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span>((*__p) == <span class="number">9999</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>; </span><br><span class="line">    <span class="keyword">return</span> (*__p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中，如果没有那条内联汇编语句，那个if语句的判断条件就完全是一句废话。GCC在优化时会意识到这一点，而直接只生成return 5的汇编代码，而不会再生成if语句的相关代码，而不会生成return (*__p)的相关代码。但你加上了这条内联汇编语句，它除了声明内存变化之外，什么都没有做。但GCC此时就不能简单的认为它不需要判断都知道 (*__p)一定与9999相等，它只有老老实实生成这条if语句的汇编代码，一起相关的两个return语句相关代码。</p><p>linux内核中内存屏障也是基于它实现，<code>#define barrier() _asm__volatile_(&quot;&quot; : : : &quot;memory&quot;)</code>，主要是保证程序的执行遵循顺序一致性。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux实用工具</title>
      <link href="/2022/02/24/220224-Linux%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2022/02/24/220224-Linux%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-screen工具"><a href="#Linux-screen工具" class="headerlink" title="Linux screen工具"></a>Linux screen工具</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>Linux screen命令用于多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s &lt;shell&gt;][-S &lt;作业名称&gt;]</span><br></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li>-A 　将所有的视窗都调整为目前终端机的大小。</li><li>-d&lt;作业名称&gt; 　将指定的screen作业离线。</li><li>-h&lt;行数&gt; 　指定视窗的缓冲区行数。</li><li>-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。</li><li>-r&lt;作业名称&gt; 　恢复离线的screen作业。</li><li>-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。</li><li>-s<shell> 　指定建立新视窗时，所要执行的shell。</shell></li><li>-S&lt;作业名称&gt; 　指定screen作业的名称。</li><li>-v 　显示版本信息。</li><li>-x 　恢复之前离线的screen作业。</li><li>-ls或–list 　显示目前所有的screen作业。</li><li>-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">screen -ls  # 显示已创建的screen终端</span><br><span class="line">screen -S &lt;screen name&gt;  # 创建新的screen终端</span><br><span class="line">screen -r &lt;screen name&gt;  # 重连screen终端</span><br><span class="line">screen -d &lt;screen name&gt;  # 断开screen终端</span><br><span class="line">screen -S &lt;screen name&gt; -X quit  # 强制停止命令</span><br></pre></td></tr></table></figure><h3 id="screen快捷键"><a href="#screen快捷键" class="headerlink" title="screen快捷键"></a>screen快捷键</h3><ul><li>Ctrl -a c            创建新的视窗</li><li>Ctrl -a d            断开screen终端，任务还在运行</li><li>Ctrl -a k            删除当前视窗</li><li>Ctrl -a 空格      视窗切换</li><li>Ctrl -a ?           快捷键帮助</li><li>Ctrl -a :            命令模式，类似vi</li><li>Ctrl -a [            复制模式，可以移光标上去看上面的打印</li></ul><h3 id="screen配置"><a href="#screen配置" class="headerlink" title="screen配置"></a>screen配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/hao0527/hao0527.github.io/blob/main/others/screencfg -O ~/.screenrc  # 一个好用的screen配置文件</span><br></pre></td></tr></table></figure><p>上面这个配置指令有些问题，wget下载下来的是html，所以就手动复制下内容到~/.screenrc文件吧。</p><h2 id="Linux-vi-vim工具"><a href="#Linux-vi-vim工具" class="headerlink" title="Linux vi/vim工具"></a>Linux vi/vim工具</h2><h3 id="功能介绍-1"><a href="#功能介绍-1" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><h3 id="vi-vim使用"><a href="#vi-vim使用" class="headerlink" title="vi/vim使用"></a>vi/vim使用</h3><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。</p><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p><img src="https://hao0527.gitee.io/220224-Linux%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/220224-Linux%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7-1.jpg" alt="220224-Linux实用工具-1.jpg"></p><table><thead><tr><th>输入</th><th>作用</th></tr></thead><tbody><tr><td>yy</td><td>复制游标所在的那一行。(常用)</td></tr><tr><td>dd</td><td>剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。</td></tr><tr><td>p/P</td><td>p粘贴在光标行下面，P粘贴在光标行上面。</td></tr><tr><td>u</td><td>复原前一个动作。(常用)</td></tr><tr><td>[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr><tr><td>/word</td><td>向光标之下寻找一个名称为 word 的字符串。 (常用)</td></tr><tr><td>?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td>i, I</td><td>进入输入模式(Insert mode)</td></tr><tr><td>ZZ</td><td>如果修改过，保存当前文件，然后退出！效果等同于保存并退出</td></tr></tbody></table><p>常用的还有替换功能：</p><ul><li><code>:1,$s/word1/word2/g</code> 或 <code>:%s/word1/word2/g</code>，从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</li><li><code>:1,$s/word1/word2/gc</code> 或 <code>:%s/word1/word2/gc</code>，从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ，加了c表示取代前显示提示字符给用户确认 (confirm) 是否需要取代。</li></ul><h4 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h4><p>输入模式比较简单，可以使用键盘上的Home、End等功能键，按Esc退出输入模式到命令模式</p><h4 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h4><table><thead><tr><th>输入</th><th>作用</th></tr></thead><tbody><tr><td>:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td>:q</td><td>离开 vi (常用)</td></tr><tr><td>:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为『强制』离开不储存档案。</td></tr><tr><td>:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td>:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td>:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td>:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td>:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如<br>『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr><tr><td>:set nu/nonu</td><td>显示/取消行号</td></tr></tbody></table><h2 id="Linux-tldr工具"><a href="#Linux-tldr工具" class="headerlink" title="Linux tldr工具"></a>Linux tldr工具</h2><h3 id="功能介绍-2"><a href="#功能介绍-2" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>一个比 –help 和 man 好用的查指令手册的工具，<a href="https://github.com/tldr-pages/tldr">点我跳到tldr(too long don’t read)主页</a>。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我使用<code>sudo apt install tldr</code>安装，然后<code>mkdir -p ~/.tldr/tldr</code>，再更新字典<code>sudo git clone https://gitclone.com/github.com/tldr-pages/tldr.git ~/.tldr/tldr</code>，国内使用这个镜像快。</p><p>推荐：官网上说可以使用npm或pip3安装。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用方式极其简单，<code>tldr tldr</code>你就可以查到tldr的使用手册。</p><h2 id="Linux-Samba工具"><a href="#Linux-Samba工具" class="headerlink" title="Linux Samba工具"></a>Linux Samba工具</h2><h3 id="功能介绍-3"><a href="#功能介绍-3" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>samba 是基于SMB协议（ServerMessage Block，信息服务块）的开源软件，samba也可以是SMB协议的商标。SMB是一种Linux、UNIX系统上可用于共享文件和打印机等资源的协议，这种协议是基于Client\Server型的协议，Client端可以通过SMB访问到Server（服务器）上的共享资源。当Windows是 Client，Ubuntu是服务器时，通过Samba就可以实现window访问Linux的资源，实现两个系统间的数据交互。samba服务程序已经成为在Linux系统和Windows系统之间共享文件的最佳选择，当然在Linux系统与Linux系统之间的文件共享也选择samba。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>在Ubuntu中安装<code>sudo apt install samba</code>，会自动安装其依赖组件。</p><p>安装后可用<code>samba -V</code>查看samba版本号，以确认安装完成。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>配置文件目录在/etc/samba/smb.conf，配置以下内容可共享home目录下用户文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Un-comment the following (and tweak the other settings below to suit)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to <span class="built_in">enable</span> the default home directory shares. This will share each</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user<span class="string">&#x27;s home directory as \\server\username</span></span></span><br><span class="line">[homes]</span><br><span class="line">   comment = Home Directories</span><br><span class="line">   browseable = no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">By default, the home directories are exported read-only. Change the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">next parameter to &#x27;</span>no<span class="string">&#x27; if you want to be able to write to them.</span></span></span><br><span class="line">   read only = no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">File creation mask is set to 0700 for security reasons. If you want to</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">create files with group=rw permissions, set next parameter to 0775.</span></span></span><br><span class="line">   create mask = 0775</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Directory creation mask is set to 0700 for security reasons. If you want to</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">create dirs. with group=rw permissions, set next parameter to 0775.</span></span></span><br><span class="line">   directory mask = 0775</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">By default, \\server\username shares can be connected to by anyone</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">with access to the samba server.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Un-comment the following parameter to make sure that only &quot;username&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">can connect to \\server\username</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">This might need tweaking when using external authentication schemes</span></span></span><br><span class="line">   valid users = %S</span><br></pre></td></tr></table></figure><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>以上配置后需要重启samba服务生效，可以注销用户后重新登录。</p><p>通过<code>sudo smbpasswd -a userName</code>添加一个samba用户，不然直接windows远程访问会拒绝访问。</p><p>userName需要是系统已有的用户名，否则会<code>Failed to add entry for user userName</code>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="/2022/02/20/220220-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/02/20/220220-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="再次了解进程与线程"><a href="#再次了解进程与线程" class="headerlink" title="再次了解进程与线程"></a>再次了解进程与线程</h2><ul><li><a href="/2021/06/11/210611-python%E5%BC%82%E6%AD%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B/">Python异步与线程</a>：这是21年6月时对线程、进程、同步、异步的简单了解，最近在做毕设时又用到了，打算重新回顾一遍。</li></ul><h2 id="多线程与多进程的区别"><a href="#多线程与多进程的区别" class="headerlink" title="多线程与多进程的区别"></a>多线程与多进程的区别</h2><p><strong>多线程 threading：</strong> 一个人有与异性聊天和看剧两件事要做。单线程的她可以看完剧再去聊天，但这样子可能就没人陪她聊天了「哼，发消息不回」。我们把她看成一个CPU核心，为她开起多线程——先看一会剧，偶尔看看新消息，在两件事（线程）间来回切换。多线程：单个CPU核心可以同时做几件事，不至于卡在某一步傻等着。</p><p>用处：爬取网站信息（爬虫），等待多个用户输入</p><p><strong>多进程 processing：</strong> 一个人有很多砖需要搬，他领取手套、推车各种物资（向系统申请了资源）然后开始搬砖。然而他身边有很多人，我们让这些人去帮他！（一核有难，八核围观）。于是他们做了分工，砖很快就搬完了。多进程让多个CPU核心可以一起做事，不至于只有一人干活而其他人傻站着。</p><p>用处：进行高性能计算。只有多进程方案设计合理，才能加速计算。</p><h2 id="Python中应用多进程"><a href="#Python中应用多进程" class="headerlink" title="Python中应用多进程"></a>Python中应用多进程</h2><ul><li>毕设的上位机要接收显示图像，我在udp数据接收解码后，写入IO流，通过管道发给另一个进程，另一个进程做图像的处理与显示，这样就不会因为处理时间过长而阻塞下一次接收解码了。</li><li><a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html">multiprocessing — 基于进程的并行</a>：multiprocessing是Python自带的多进程库，这是Python官方的文档对multiprocessing库的介绍。</li><li>Python的线程是操作系统线程，因此要有Python全局解释器锁。一个python解释器进程内有一条<strong>主线程</strong>，以及多条用户程序的<strong>执行线程</strong>。即使在多核CPU平台上，由于GIL的存在，所以禁止多线程的并行执行。Python 3.6 才让multiprocessing逐渐发展成一个能用的Python内置多进程库，可以进行进程间的通信，以及有限的内存共享。</li></ul><h3 id="两种多进程创建方式"><a href="#两种多进程创建方式" class="headerlink" title="两种多进程创建方式"></a>两种多进程创建方式</h3><p>Python多进程可以选择两种创建进程的方式，spawn与fork，实际使用中可以根据子进程具体做什么来选取用fork还是spawn。</p><ol><li>fork：除了必要的启动资源外，其他变量，包，数据等都继承自父进程，并且是copy-on-write的，也就是共享了父进程的一些内存页，因此启动较快，但是由于大部分都用的父进程数据，所以是不安全的进程</li><li>spawn：从头构建一个子进程，父进程的数据等拷贝到子进程空间内，拥有自己的Python解释器，所以需要重新加载一遍父进程的包，因此启动较慢，由于数据都是自己的，安全性较高</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.set_start_method(<span class="string">&#x27;spawn&#x27;</span>)  <span class="comment"># default on WinOS or MacOS</span></span><br><span class="line">multiprocessing.set_start_method(<span class="string">&#x27;fork&#x27;</span>)   <span class="comment"># default on Linux (UnixOS)</span></span><br></pre></td></tr></table></figure><h3 id="四种进程间通信方式"><a href="#四种进程间通信方式" class="headerlink" title="四种进程间通信方式"></a>四种进程间通信方式</h3><p>Python中进程间通信可以采用进程池Pool、管道Pipe、队列Queue，在新版本Python中多了共享内存Manager的方式。</p><ol><li><a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#module-multiprocessing.pool">进程池Pool</a>：不怎么使用？通常使用另外两个方式通信</li><li><a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#pipes-and-queues">管道和队列</a>：Queue用于多个进程间实现通信，Pipe是两个进程的通信。Queue通过put和get方法插入读取队列，Pipe通过send和recv方法发送和接收信息，用法可以参考这篇文章：<a href="https://www.cnblogs.com/guguobao/p/9398653.html">python进程间通信</a>，如果追求运行更快，那么最好使用管道Pipe而队列Queue，详细查看<a href="https://www.raspberrypi.org/forums/viewtopic.php?t=141576">Python pipes and queues performance</a></li><li><a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html#sharing-state-between-processes">共享内存Manager</a>：Pipe Queue 把需要通信的信息从内存里深拷贝了一份给其他线程使用（需要分发的线程越多，其占用的内存越多）。而共享内存会由解释器负责维护一块共享内存（而不用深拷贝），这块内存每个进程都能读取到，读写的时候遵守管理（因此不要以为用了共享内存就一定变快）</li></ol><h3 id="编程中要注意"><a href="#编程中要注意" class="headerlink" title="编程中要注意"></a>编程中要注意</h3><p>为了避免自己调用自己时重复执行主进程，**多进程的主进程一定要写在程序入口if __name__ == ‘__main__’:，否则可能会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function1</span>(<span class="params"><span class="built_in">id</span></span>):  <span class="comment"># 这里是子进程</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;id <span class="subst">&#123;<span class="built_in">id</span>&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run__process</span>():  <span class="comment"># 这里是主进程</span></span><br><span class="line">    <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line">    process = [mp.Process(target=function1, args=(<span class="number">1</span>,)),</span><br><span class="line">               mp.Process(target=function1, args=(<span class="number">2</span>,)), ]</span><br><span class="line">    [p.start() <span class="keyword">for</span> p <span class="keyword">in</span> process]  <span class="comment"># 开启了两个进程</span></span><br><span class="line">    [p.join() <span class="keyword">for</span> p <span class="keyword">in</span> process]   <span class="comment"># 等待两个进程依次结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run__process()  # 主线程不建议写在 if外部。由于这里的例子很简单，你强行这么做可能不会报错</span></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run__process()  <span class="comment"># 正确做法：主线程只能写在 if内部</span></span><br></pre></td></tr></table></figure><p>设计高性能的多进程时，遵守以下规则：</p><ul><li>尽可能少传一点数据</li><li>尽可能减少主线程的负担</li><li>尽可能不让某个进程傻等着</li><li>尽可能减少进程间通信的频率</li></ul><h2 id="网上一些好的文档"><a href="#网上一些好的文档" class="headerlink" title="网上一些好的文档"></a>网上一些好的文档</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/340965963">Python程序入口 <strong>name</strong> == ‘<strong>main</strong>‘ 有重要功能（多线程）而非编程习惯</a>：这篇文章讲述了Python中程序入口的作用，Python用这个简单的方法来判断当前的模块是被直接运行还是被调用，这是很重要的功能。</li><li><a href="https://zhuanlan.zhihu.com/p/340657122">在Python中优雅地用多进程</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大学最后一个假期</title>
      <link href="/2022/01/19/220119-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%AF%92%E5%81%87/"/>
      <url>/2022/01/19/220119-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%AF%92%E5%81%87/</url>
      
        <content type="html"><![CDATA[<h1 id="大学回忆录"><a href="#大学回忆录" class="headerlink" title="大学回忆录"></a>大学回忆录</h1><h2 id="大一上学期"><a href="#大一上学期" class="headerlink" title="大一上学期"></a>大一上学期</h2><p>回忆从开学前几日的寝室生活开始，<strong>室友都非常的好相处</strong>，大家在一起能玩的很嗨。再到大一我参加了两个学生会的部门（学生会办公室&amp;党员之家实践部）和一个社团（单车俱乐部），自己在部门里认识了些不同班级不同专业的朋友，也<strong>交到了一位知心</strong>，大一上学期我天天晚上会和他去健身房，或是去钱塘江边散步，或是在寝室喝酒，元旦跨年我去了他家里，人生中第一次和别人跨年。参与了学生会的活动演出和演讲还有优秀干部的竞选；</p><h2 id="大一寒假"><a href="#大一寒假" class="headerlink" title="大一寒假"></a>大一寒假</h2><p>寒假里我一个人坐飞机去了山东蓬莱，找我高考结束后在华为上班认识的同事，蓬莱待了7天，青岛待了2天。独自旅行，去一个陌生的地方，享受孤独，思考人生，一个人狂欢。旅行结束回家后，我学习了郭天祥的<strong>十天学会51单片机</strong>，但并没有完全学会；</p><h2 id="大一下学期"><a href="#大一下学期" class="headerlink" title="大一下学期"></a>大一下学期</h2><p>大一下学期有我喜欢的课程模电，我通过教同学们解题来学习这门课程，因此也<strong>交到了陪伴我至今的女朋友</strong>。除了模电课我还选了一门电子课程设计也非常喜欢，老师授课讲了51单片机的知识，课程做了51数字钟（我在5月19日晚上写完，拍了个51开发版显示520倒计时的视频），最后的作业是51小车。这学期学生会部门成员积极性变差了，我最后没有选择留任执委，选择了留在电子创新实验室（一待就是三年）；</p><h2 id="大一暑假"><a href="#大一暑假" class="headerlink" title="大一暑假"></a>大一暑假</h2><p>暑假我留在实验室<strong>准备19年的全国大学生电子设计竞赛</strong>，暑假做了历年的题目（声音存储录放、风力摆、旋转倒立摆），那时候的我不知道熬夜会伤身体，每天白天调试，晚上在寝室看文档到凌晨2点。暑假里由于比较专注比赛，忘记关心女朋友，两人有过多次争执，女朋友不回消息，我直接去她家里了，就这样被她家人认识，至今我还常去她家蹭饭。这个暑假差一点点就分手了；</p><h2 id="大二上学期"><a href="#大二上学期" class="headerlink" title="大二上学期"></a>大二上学期</h2><p>大二上学期，一开学和徐高东学长参加了<strong>工程训练大赛</strong>，那次比赛后感觉之前所有学过的东西都能联会贯通了。比赛的时候出现了意外，没有取得好成绩，东哥说了句：比赛不就是这样。随后我参加了<strong>飞思卡尔智能车竞赛</strong>，在校内训练的时候感觉都良好，本来计划我和洪晨益写程序，由于硬件画的板子实在惨不忍睹，就自己动手把硬件做完了，我那写代码的队友也很强，一人能维护好代码，那年寒假前我们俩调车调到学校关门。这学期，我和我的女朋友分手了，但几个星期又复合了，我们相互都很缺时间在一起交流；</p><h2 id="大二寒假"><a href="#大二寒假" class="headerlink" title="大二寒假"></a>大二寒假</h2><p>那年是全世界肺炎流行的一年，寒假在家3个月，当然我也没闲着，趁家里无聊，打开电脑学了些东西，有<strong>python，tensorflow，sklearn，百度飞桨，git</strong>等，有潘利斌陪我一起学。疫情原因只能在家调飞卡，在家里把<strong>Altium Designer</strong>了一遍，画板子是没有问题了。3月在家网课，网课非常适合我，我可以不仅可以回放自己学校老师上课讲的，还能去B站慕课上找名校老师上课的视频；</p><h2 id="大二下学期"><a href="#大二下学期" class="headerlink" title="大二下学期"></a>大二下学期</h2><p>中国疫情控制的很厉害，4月中就能返校了。这学期在学校主要是准备电赛，准备飞卡，飞卡参加的是<strong>AI组别</strong>，通过机器学习，训练后部署到单片机，实现自主规划路线；</p><h2 id="大二暑假"><a href="#大二暑假" class="headerlink" title="大二暑假"></a>大二暑假</h2><p>暑假<strong>培训大一电赛新生</strong>，不过今年比赛延期了，暑假没有比赛。飞卡如期举行，离国赛就差0.02秒，怎么就这么可惜呀。电赛准备了很多模块，把模块间通信学的明明白白的，还有很多PCB上的设计规范也学了一遍，那年我们实验室都在看<strong>长江大学唐老师</strong>的教学视频。</p><h2 id="大三上学期"><a href="#大三上学期" class="headerlink" title="大三上学期"></a>大三上学期</h2><p>大三上学期开始在黄道麒<strong>公司实习</strong>，老板非常厉害，抓住了疫情这个风口，做红外热像仪体温枪这些生意。公司离学校很近，我每天上完课就去公司，那段时间进步非常快，学的东西也非常多非常杂。用了好多品牌的国产mcu，用QT写了上位机，学习了二元光学。十月份<strong>浙江省电子大赛</strong>，作品实物验收满分取得了省二等奖，队友配合的非常棒！这学期上了算法与数据结构和数字逻辑设计、51汇编，非常感兴趣，买了块FPGA开发板练手；</p><h2 id="大三寒假"><a href="#大三寒假" class="headerlink" title="大三寒假"></a>大三寒假</h2><p>寒假里我还在公司上班，老板让我住宾馆可以报销。寒假里我学习了<strong>linux应用开发</strong>，opencv，makefile，cmake，用树莓派做了个红外热像仪的demo。这个寒假我在公司借了很多书看，有linux的，opencv的，无线传感器网络的，感测技术的。在公司里和老板经常聊到很晚，我们谈未来的方向，谈生活时政等等，无所不谈，<strong>是一家有温度的公司</strong>；</p><h2 id="大三下学期"><a href="#大三下学期" class="headerlink" title="大三下学期"></a>大三下学期</h2><p>这学期了解了一些<strong>网络安全，开关电源设计，搭建了blog</strong>，仍然在公司实习。搞的东西太杂了容易忘记自己学过什么，写写博客记录下的话翻到还能有印象。公司里主要是把之前用树莓派跑的demo移到了m4的mcu，另一个项目是用高云fpga做了ov2640的串并转换到mcu处理，练习了fpga。5月份之前飞卡的软件队友提出来要再参加一次，让我做一下硬件，这次我非常熟练，PCB最多就设计了两版就完成了硬件设计；</p><h2 id="大三暑假"><a href="#大三暑假" class="headerlink" title="大三暑假"></a>大三暑假</h2><p>暑假去了一家做半导体芯片的公司实习，是属于系统集成部，公司平均年龄比较大，部门里同事都不怎么说话，公司氛围不太好，领导经常会骂别人很凶，我一看不对劲就溜溜球了。暑假在做wifi图传的项目，尝试用m4自己看数据手册写<strong>WiFi驱动</strong>，不过后来这事没成，换了<strong>esp32用idf</strong>开发。很早开始我就对网络感兴趣，可能未来也会多往这个方向发展；</p><h2 id="大四上学期"><a href="#大四上学期" class="headerlink" title="大四上学期"></a>大四上学期</h2><p>大四第一学期在世界五百强<strong>博世</strong>上班，公司的氛围特别好，领导都很有管理的能力，同事之间办公都非常的舒心，博世是个不加班的外企，但是工作效率挺高的，流程虽多，但处理速度很快。我在博世工作了4个月，学习了高压交流的PCB设计，直流无刷电机，永磁同步电机，把电力这一块学了一遍，也了解了电机的控制算法，最简单的六步换向，还有FOC。可以说这次实习经历相当难忘，每个牛的公司，都有一群好的团队管理者。这学期，还报名考研了，算是把大学的知识复习了一下，没考好，以后也不会再有考研的想法了；</p><h1 id="还有最后一个假期"><a href="#还有最后一个假期" class="headerlink" title="还有最后一个假期"></a>还有最后一个假期</h1><p>最后一个假期也没选择安逸，找了家做安防的公司实习，在这里我学到了<strong>linux驱动开发</strong>的知识，我的主管年龄挺大的技术很好，整个框架是他从头写出来的，我看git log一步步看他怎么写出来，太强了！面试的时候就被他的技术所吸引，这么强的人为人还非常谦虚，值得我去学习！在这里我重学了一年前了解过的<strong>makefile编写，shell脚本编程，C代码规范</strong>等等。看了主管写的几万行脚本代码，我再感叹到太强了！过年在家里自己系统的学了一遍计算机网络，本来还想学计算机组成原理和操作系统的，学操作系统的时候卡住了，看早期的linux源码也非常的费劲，只能推到我2月实习完回学校再学了；</p><h1 id="致青春：如果没有源自内心的冲动，怎么可能登峰造极呢？"><a href="#致青春：如果没有源自内心的冲动，怎么可能登峰造极呢？" class="headerlink" title="致青春：如果没有源自内心的冲动，怎么可能登峰造极呢？"></a>致青春：<strong>如果没有源自内心的冲动，怎么可能登峰造极呢？</strong></h1><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 这算什么 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FPGA之以太网学习</title>
      <link href="/2022/01/13/220113-fpga%E4%B9%8Beth/"/>
      <url>/2022/01/13/220113-fpga%E4%B9%8Beth/</url>
      
        <content type="html"><![CDATA[<h3 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h3><ul><li><a href="https://www.bilibili.com/video/BV194411f7GD?p=80">【正点原子】手把手教你学FPGA系列视频——以太网通信实验</a></li></ul><h3 id="以太网的介绍"><a href="#以太网的介绍" class="headerlink" title="以太网的介绍"></a>以太网的介绍</h3><h4 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h4><p><img src="https://hao0527.gitee.io/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-1.jpg" alt="220113-fpga之eth-1.jpg"></p><ul><li>物理层：在物理层上所传数据的单位是比特。发送方发送1(或0)时，接收方应当收到1(或0)而不是0 (或1)，因此物理层要考虑用多大的电压代表”1”或”0”，以及接收方如何识别出发送方所发送的比特。物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。当然，解释比特代表的意思，就不是物理层的任务。请注意，传递信息所利用的-些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面。</li><li>数据链路层：数据链路层常简称为链路层。我们知道，两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing)，在两个相邻结点间的链路上传送帧(frame)，每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结·束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在数据链路层传输时出现的差错(这就是说，数据链路层不仅要检错，而且要纠错)，那么就要采用可靠传输协议来纠正出现的差错。这种方法会使数据链路层的协议复杂些。</li><li>网络层、运输层、应用层见《计算机网络》书籍；fpga跑eth主要用到了phy层、数据链路mac层、网络层、udp传输层；</li></ul><h4 id="FPGA数据包内容"><a href="#FPGA数据包内容" class="headerlink" title="FPGA数据包内容"></a>FPGA数据包内容</h4><p>下面放出fpga发送的以太网数据包的组层图，图片来自《开拓者FPGA 开发指南V1.3》，相关介绍也可以查看PDF。</p><h5 id="以太网数据包格式"><a href="#以太网数据包格式" class="headerlink" title="以太网数据包格式"></a>以太网数据包格式</h5><p><img src="https://hao0527.gitee.io/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-2.jpg" alt="220113-fpga之eth-2.jpg"></p><h5 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h5><p><img src="https://hao0527.gitee.io/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-3.jpg" alt="220113-fpga之eth-3.jpg"></p><h5 id="IP数据包格式"><a href="#IP数据包格式" class="headerlink" title="IP数据包格式"></a>IP数据包格式</h5><p><img src="https://hao0527.gitee.io/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-4.jpg" alt="220113-fpga之eth-4.jpg"></p><h5 id="UDP数据格式"><a href="#UDP数据格式" class="headerlink" title="UDP数据格式"></a>UDP数据格式</h5><p><img src="https://hao0527.gitee.io/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-5.jpg" alt="220113-fpga之eth-5.jpg"></p><h4 id="千兆以太网物理层"><a href="#千兆以太网物理层" class="headerlink" title="千兆以太网物理层"></a>千兆以太网物理层</h4><ul><li>下面这个是我开发板图和板上的千兆以太网原理图，设计的非常好，板子上的IO基本上都是等长线。  </li></ul><p><img src="https://hao0527.gitee.io/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-6.jpg" alt="220113-fpga之eth-6.jpg"></p><p><img src="https://hao0527.gitee.io/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-7.jpg" alt="220113-fpga之eth-7.jpg"></p><ul><li>物理层的设计和学习还有个非常重要的学习资料就是《RTL8211数据手册》，这个手册上竟然写着不对外公布。</li></ul><h3 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h3><h4 id="例程修改"><a href="#例程修改" class="headerlink" title="例程修改"></a>例程修改</h4><ul><li>简易的修改了下例程，让udp每次数据包发送1472个字节数据，其中前4字节是包序列号，用于接收端检测是否掉包，其他的1468个字节数据为0x00-0xFF循环，从而更为精确的模仿正常传输时的内容。再通过每次发完控制idle时间来控制传输速率。</li></ul><h4 id="上位机编写"><a href="#上位机编写" class="headerlink" title="上位机编写"></a>上位机编写</h4><ul><li>上位机才用Python编写，在JupyterNotebook里实现。实现原理主要就是一直读udp，再去比较这次的包序列号是不是上一次+1，如果不是的话打印出来。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE = <span class="number">1472</span> * <span class="number">100</span></span><br><span class="line">ip_port = (<span class="string">&#x27;192.168.0.3&#x27;</span>, <span class="number">8080</span>)</span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  <span class="comment"># udp协议</span></span><br><span class="line">server.bind(ip_port)</span><br><span class="line">error = <span class="number">0</span></span><br><span class="line">recv_data_a = server.recvfrom(BUFSIZE)[<span class="number">0</span>][:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    recv_data_b = server.recvfrom(BUFSIZE)[<span class="number">0</span>][:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>.from_bytes(recv_data_b,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>) != \</span><br><span class="line">       <span class="built_in">int</span>.from_bytes(recv_data_a,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>) + <span class="number">1</span>):</span><br><span class="line">        error += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;error:%u, recv_data_a = %u, recv_data_b = %u&quot;</span> \</span><br><span class="line">              %(error, <span class="built_in">int</span>.from_bytes(recv_data_a,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>), \</span><br><span class="line">                <span class="built_in">int</span>.from_bytes(recv_data_b,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>)))</span><br><span class="line">    recv_data_a = server.recvfrom(BUFSIZE)[<span class="number">0</span>][:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>.from_bytes(recv_data_a,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>) != \</span><br><span class="line">       <span class="built_in">int</span>.from_bytes(recv_data_b,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>) + <span class="number">1</span>):</span><br><span class="line">        error += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;error:%u, recv_data_b = %u, recv_data_a = %u&quot;</span> \</span><br><span class="line">              %(error, <span class="built_in">int</span>.from_bytes(recv_data_b,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>), \</span><br><span class="line">                <span class="built_in">int</span>.from_bytes(recv_data_a,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>)))</span><br><span class="line">server.close()</span><br></pre></td></tr></table></figure><h4 id="掉包处理"><a href="#掉包处理" class="headerlink" title="掉包处理"></a>掉包处理</h4><ul><li>在100Mbps速率传输的时候，每65536帧传输后都会出现2帧的掉包，通过WireShark查看，能找到那2帧包，也就是说数据包被网卡接收但是在上位机处没有接收。通过WireShark查看整个以太网数据包内容后发现规律：只有在IP数据包的首部校验和为0xFFFF的时候才会出现掉包，百度上也有这样的案例，于是修改FPGA代码，让IP包首部标识位不每次+1，这样校验和就不会出现0XFFFF。</li></ul><h4 id="调试结果"><a href="#调试结果" class="headerlink" title="调试结果"></a>调试结果</h4><ul><li>经过简易测试，当传输速率为200Mbps的时候，不掉包；当传输速率为300Mbps的时候，出现掉包。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>本次调试，学习了网络5层模型的物理层和MAC层，通过亲自实践解决出现的问题，对网络的底层实现有了更清楚的认识，对日后学习Linux驱动开发的网络部分会有极大的帮助，以及我的毕设，udp传输图像只是其中的一小部分，如果有时间，我会做个更复杂题目，学习更多的网络知识（大学只学了物联网和网络相关，计网没学）。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动开发学习笔记</title>
      <link href="/2022/01/11/220111-LinuxComm/"/>
      <url>/2022/01/11/220111-LinuxComm/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-File（文件写入）"><a href="#Linux-File（文件写入）" class="headerlink" title="Linux-File（文件写入）"></a>Linux-File（文件写入）</h3><p>​    对于write函数，我们认为该函数一旦返回，数据便已经写到了文件中。但是这种概念只是宏观上的，一般情况下，对硬盘（或者其他持久存储设备）文件的write操作，更新的只是内存中的页缓存（page cache），而脏页不会立即更新到硬盘中，而是由操作系统统一调度，如flusher内核线程在满足一定条件时（一定时间间隔、内存中的脏页达到一定比例）将脏页面同步到硬盘上（放入设备的IO请求队列）。因为write调用不会等到硬盘IO完成之后才返回，设想如果操作系统在write调用之后、硬盘同步之前崩溃，则数据可能丢失。虽然这样的时间窗口很小，但是对于需要保证事务的持久化（durability）和一致性（consistency）的数据库程序来说，write()所提供的“松散的异步语义”是不够的，通常需要操作系统提供的同步IO（synchronized-IO）原语来保证：</p><p>​    Linux、unix在内核中设有缓冲区、高速缓冲或页面高速缓冲，大多数磁盘I/O都通过缓冲进行，采用延迟写技术。<br>sync：将所有修改过的快缓存区排入写队列，然后返回，并不等待实际写磁盘操作结束；<br>fsync：只对有文件描述符制定的单一文件起作用，并且等待些磁盘操作结束，然后返回；<br>fdatasync：类似fsync，但它只影响文件的数据部分。fsync还会同步更新文件的属性；<br>fflush：标准I/O函数（如：fread，fwrite）会在内存建立缓冲，该函数刷新内存缓冲，将内容写入内核缓冲，要想将其写入磁盘，还需要调用fsync。（先调用fflush后调用fsync，否则不起作用）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pFile = fopen(pFilePath, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pFile)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> FAILURE;</span><br><span class="line">&#125;</span><br><span class="line">res = fwrite(aValStr, <span class="number">1</span>, <span class="built_in">strlen</span>(aValStr), pFile); </span><br><span class="line"><span class="keyword">if</span>(res != <span class="built_in">strlen</span>(aValStr))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> FAILURE;</span><br><span class="line">&#125;</span><br><span class="line">fflush(pFile);          <span class="comment">//刷新缓冲区，强制缓冲区文件内容写入内核缓冲</span></span><br><span class="line">fsync(fileno(pFile));   <span class="comment">//同步内存中已修改的对应fd的文件数据到设备存储</span></span><br><span class="line">                        <span class="comment">//fileno()用于返回文件流对应的文件描述符fd</span></span><br><span class="line">fclose(pFile);</span><br></pre></td></tr></table></figure><h3 id="Linux-Net（五种IO模型）"><a href="#Linux-Net（五种IO模型）" class="headerlink" title="Linux-Net（五种IO模型）"></a>Linux-Net（五种IO模型）</h3><ul><li>搬运：<a href="https://blog.csdn.net/qq_34638435/article/details/81878301">阻塞IO与非阻塞IO</a>  </li></ul><h4 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h4><ul><li>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</li></ul><h4 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h4><ul><li>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。  </li><li>所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU，如果在while循环体中一直去询问内核数据是否就绪，就会导致CPU占用率非常高。</li></ul><h4 id="多路复用IO模型"><a href="#多路复用IO模型" class="headerlink" title="多路复用IO模型"></a>多路复用IO模型</h4><ul><li>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，<strong>只需要使用一个线程就可以管理多个socket</strong>，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且<strong>只有在真正有socket读写事件进行时，才会使用IO资源</strong>，所以它大大减少了资源占用。</li><li>也许有朋友会说，我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。</li><li>不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。<strong>（才用多线程或线程池的方式来轮询和处理时间可解决）</strong></li></ul><h4 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h4><ul><li>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</li></ul><h4 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h4><ul><li> 异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它收到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要知道实际的整个IO操作是如何进行的，只需要先发起一个请求，<strong>当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了</strong>。</li><li>也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。</li><li>前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FPGA之SDRAM学习</title>
      <link href="/2021/12/19/211219-fpga%E4%B9%8Bsdram/"/>
      <url>/2021/12/19/211219-fpga%E4%B9%8Bsdram/</url>
      
        <content type="html"><![CDATA[<h3 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h3><ul><li><a href="https://www.bilibili.com/video/BV194411f7GD?p=57">【正点原子】手把手教你学FPGA系列视频——SDRAM</a></li></ul><h3 id="SDRAM介绍"><a href="#SDRAM介绍" class="headerlink" title="SDRAM介绍"></a>SDRAM介绍</h3><ul><li><p><strong>同步动态随机存取内存</strong>（synchronous dynamic random-access memory，简称SDRAM）是有一个<a href="https://baike.baidu.com/item/%E5%90%8C%E6%AD%A5%E6%8E%A5%E5%8F%A3">同步接口</a>的<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%86%85%E5%AD%98/1681939">动态随机存取内存</a>（<a href="https://baike.baidu.com/item/DRAM">DRAM</a>）。通常DRAM是有一个异步接口的，这样它可以随时响应控制输入的变化。而SDRAM有一个同步接口，在响应控制<a href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5">输入</a>前会等待一个<a href="https://baike.baidu.com/item/%E6%97%B6%E9%92%9F%E4%BF%A1%E5%8F%B7">时钟信号</a>，这样就能和计算机的<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF">系统总线</a>同步。时钟被用来驱动一个<a href="https://baike.baidu.com/item/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/2081914">有限状态机</a>，对进入的指令进行<a href="https://baike.baidu.com/item/%E7%AE%A1%E7%BA%BF">管线</a>(Pipeline)操作。这使得SDRAM与没有同步接口的异步DRAM(asynchronous DRAM)相比，可以有一个更复杂的操作模式。</p></li><li><p>SDRAM从发展到现在已经经历了五代，分别是：第一代SDR SDRAM，第二代DDR SDRAM，第三代DDR2 SDRAM，第四代DDR3 SDRAM，第五代，DDR4 SDRAM。</p></li></ul><h3 id="SDRAM操作时序"><a href="#SDRAM操作时序" class="headerlink" title="SDRAM操作时序"></a>SDRAM操作时序</h3><ul><li>在对 SDRAM进行读写操作之前需要先对芯片进行初始化；SDRAM读写是一个较为复杂的控制流 程，其中包括行激活、列读写、预充电、刷新等一系列操作。</li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li><p>初始化流程如下<br><img src="https://hao0527.gitee.io/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-1.jpg" alt="211219-fpga之sdram-1.jpg"><br>SDRAM上电后要有200us的输入稳定期，在这个时间内不可以对SDRAM的接口做任何操作； 200us结束以后给所有L-Bank预充电，然后是连续8次刷新操作；最后设置模式寄存器。初始化 最关键的阶段就在于模式寄存器（MR，Mode Register）的设置，简称MRS（MR Set）。</p></li><li><p>模式寄存器如下<br><img src="https://hao0527.gitee.io/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-2.jpg" alt="211219-fpga之sdram-2.jpg"><br>如上图所示，用于配置模式寄存器的参数由地址线提供，地址线不同的位分别用于表示不 同的参数。SDRAM通过配置模式寄存器来确定芯片的工作方式，包括突发长度（Burst Length）、 潜伏期（CAS Latency）以及操作模式等。<br>需要注意的是，在模式寄存器设置指令发出之后，需要等待一段时间才能够向SDRAM发送 新的指令，这个时间我们称之为模式寄存器设置周期tRSC（Register Set Cycle）。</p></li></ul><h4 id="行激活"><a href="#行激活" class="headerlink" title="行激活"></a>行激活</h4><ul><li>行激活时序图<br><img src="https://hao0527.gitee.io/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-3.jpg" alt="211219-fpga之sdram-3.jpg"><br>初始化完成后，无论是读操作还是写操作，都要先激活（Active）SDRAM中的一行，使之 处于活动状态（又称行有效）。在此之前还要进行SDRAM芯片的片选和L-Bank的定址，不过它 们与行激活可以同时进行。<br>在片选CS#（#表示低电平有效）、L-Bank定址的同时，RAS（Row Address Strobe，行地址选通脉冲）也处于有效状态。此时An地址线则发送具体的行地址。如图中是A0-A11，共有12个地址线，由于是二进制表示法，所以共有4096个行（2^12=4096），A0-A11的不同数值就确定了具体的行地址。由于行激活的同时也是相应L-Bank有效，所以行激活也可称为L-Bank有效。</li></ul><h4 id="列读写"><a href="#列读写" class="headerlink" title="列读写"></a>列读写</h4><ul><li>列选通与读操作时序图<br><img src="https://hao0527.gitee.io/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-4.jpg" alt="211219-fpga之sdram-4.jpg"><br>由于在SDRAM中，地址线是行列共用的，因此列寻址时地址线仍然是A0-A11。在寻址时，利用RAS（Row Address Strobe，行地址选通脉冲）与CAS（Column Address Strobe，列地址选通脉冲）来区分行寻址与列寻址。</li><li>在发送列读写命令时必须要与行激活命令有一个时间间隔，这个间隔被定义为tRCD， 即RAS to CAS Delay（RAS至CAS延迟）。这是因为在行激活命令发出之后，芯片存储阵列电子 元件响应需要一定的时间。tRCD是SDRAM的一个重要时序参数，广义的tRCD以时钟周期（tCK， Clock Time）数为单位，比如tRCD=3，就代表RAS至CAS延迟为三个时钟周期，如图 33.1.8所 示。具体到确切的时间，则要根据时钟频率而定。</li></ul><h4 id="数据输出（读）"><a href="#数据输出（读）" class="headerlink" title="数据输出（读）"></a>数据输出（读）</h4><ul><li>在选定列地址后，就已经确定了具体的存储单元，剩下的事情就是数据通过数据I/O通道（DQ）输出到内存总线上了。但是在CAS发出之后，仍要经过一定的时间才能有数据输出，从CAS与读取命令发出到第一笔数据输出的这段时间，被定义为CL（CAS Latency，CAS潜伏期）。CL时间越短，读数据时SDRAM响应就越快。由于CL只在读取时出现，所以CL又被称为读取潜伏期（RL，Read Latency）。CL的单位与tRCD一样，为时钟周期数，具体耗时由时钟频率决定。</li></ul><h4 id="数据输出（写）"><a href="#数据输出（写）" class="headerlink" title="数据输出（写）"></a>数据输出（写）</h4><ul><li>数据写入时序图<br><img src="https://hao0527.gitee.io/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-5.jpg" alt="211219-fpga之sdram-5.jpg"><br>数据写入的操作也是在tRCD之后进行，但此时没有了CL（记住，CL只出现在读取操作中）， 行寻址与列寻址的时序图和上文一样，只是在列寻址时，WE#为有效状态。<br>数据与写指令同时发送。不过，数据并不是即时地写入存储单元，数据的 真正写入需要一定的周期。为了保证数据的可靠写入，都会留出足够的写入/校正时间（tWR， Write Recovery Time），这个操作也被称作写回（Write Back）。tWR至少占用一个时钟周期 或再多一点（时钟频率越高，tWR占用周期越多）。</li></ul><h4 id="此外"><a href="#此外" class="headerlink" title="此外"></a>此外</h4><ul><li>除上述操作之外，还有突发长度、预充电、刷新、数据掩码常用操作，具体可以查阅《开拓者FPGA开发指南》SDRAM读写测试实验。</li></ul><h3 id="实验仿真"><a href="#实验仿真" class="headerlink" title="实验仿真"></a>实验仿真</h3><p><img src="https://hao0527.gitee.io/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-6.jpg" alt="211219-fpga之sdram-6.jpg"><br><img src="https://hao0527.gitee.io/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-7.jpg" alt="211219-fpga之sdram-7.jpg"><br><img src="https://hao0527.gitee.io/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-8.jpg" alt="211219-fpga之sdram-8.jpg"><br><img src="https://hao0527.gitee.io/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-9.jpg" alt="211219-fpga之sdram-9.jpg"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LTE Cat.1模块和阿里云物联网平台使用</title>
      <link href="/2021/12/17/211217-ltecat1/"/>
      <url>/2021/12/17/211217-ltecat1/</url>
      
        <content type="html"><![CDATA[<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><ul><li><a href="https://help.aliyun.com/product/30520.html">阿里云物联网平台-产品文档</a></li></ul><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>在博世实习，同事想要远程调试，打印log到终端功能（代替出差去现场调试），于是我就决定用LTE Cat.1模块，配合阿里云物联网平台，使用MQTT传输日志文件。</li></ul><h3 id="阿里云物联网平台使用"><a href="#阿里云物联网平台使用" class="headerlink" title="阿里云物联网平台使用"></a>阿里云物联网平台使用</h3><ol><li><p>打开<a href="https://iot.console.aliyun.com/lk/summary/new">阿里云物联网平台</a>，使用公共实例，<a href="https://help.aliyun.com/document_detail/73728.html">创建产品</a>，数据格式选择<strong>（透传/自定义）</strong>，以便将上行的自定义格式的数据转换为Alink JSON格式，连网方式这里选择<strong>蜂窝（2G/3G/4G/5G）</strong>，所属品类选择<strong>自定义品类</strong>，其它配置默认即可。配置完在产品详情界面图如下：<img src="https://hao0527.gitee.io/211217-ltecat1/211217-ltecat1-1.jpg" alt="211217-ltecat1-1.jpg"></p></li><li><p><a href="https://help.aliyun.com/document_detail/89271.html">创建设备</a>，创建设备成功后，将自动弹出<strong>添加完成</strong>对话框。您可以查看、复制设备证书信息。设备证书由设备的ProductKey、DeviceName和DeviceSecret组成，是设备与物联网平台进行通信的重要身份认证，建议您妥善保管。配置完在设备详情界面图如下：<img src="https://hao0527.gitee.io/211217-ltecat1/211217-ltecat1-2.jpg" alt="211217-ltecat1-2.jpg"></p></li><li><p>接下来就是在产品详情界面中的功能定义，可以查看<a href="https://help.aliyun.com/document_detail/213906.html">物模型概述</a>，设置MQTT需要上传的变量。我设置了一些调试时用到的变量，如下图：<img src="https://hao0527.gitee.io/211217-ltecat1/211217-ltecat1-3.jpg" alt="211217-ltecat1-3.jpg"></p></li><li><p>在产品详情界面中的数据解析可以设置<a href="https://iot.console.aliyun.com/product/productDetail/gecgSxxbl6Q?current=4">物模型数据解析</a>，通过物模型数据解析我们可以将自定义帧结构的数据解析成Alink JSON格式，注意：产品的<strong>数据格式</strong>选择为<strong>透传/自定义</strong>（这个坑我一天，最后找阿里云客服解决）。写完数据解析后，选择模拟类型为<strong>设备上报数据</strong>，执行与提交。</p></li><li><p>接下来就是mcu使用LTE Cat.1模块给阿里云平台发数据了！在设备详情的物模型数据中可以看见，通过物模型数据上报的topic发送来的调试变量。我们也可以通过设备详情中的日志服务看见，阿里云上的数据收发记录和解析记录。</p></li><li><p>阿里云平台上还有很多其他功能，比如说把平台收到的数据再MQTT发给自己服务器做个数据处理与显示等，本次我没有用到，可以查看<a href="https://help.aliyun.com/product/30520.html">阿里云物联网平台-产品文档</a>了解更多功能。</p></li></ol><h3 id="LTE-Cat-1模块介绍"><a href="#LTE-Cat-1模块介绍" class="headerlink" title="LTE Cat.1模块介绍"></a>LTE Cat.1模块介绍</h3><ol><li><p>Luat Air724UG LTE Cat.1 模块，淘宝链接：<a href="https://item.taobao.com/item.htm?spm=a1z0d.6639537.1997196601.315.6b537484HESeeA&id=620804223790">Air724UG DTU透传4G模块Cat.1全网通TTL转LTE FS704UM阿里云MQTT</a></p></li><li><p>模块是串口输入，走4G网发送数据。模块可以一键配置阿里云MQTT服务，然后就能实现透传的功能。MCU也可以使用AT指令控制模块，可以有更丰富的操作。</p></li><li><p>连接阿里云流程可以看模块资料《Air724UG_软件设计手册V1.5》，连阿里云首先HTTP获取MQTT密码，然后连接MQTT，阿里云物联网会比较安全。</p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu使用Clash</title>
      <link href="/2021/10/07/211007-clashForLinux/"/>
      <url>/2021/10/07/211007-clashForLinux/</url>
      
        <content type="html"><![CDATA[<h2 id="安装运行clash"><a href="#安装运行clash" class="headerlink" title="安装运行clash"></a>安装运行clash</h2><ol><li><p>在<a href="https://github.com/Dreamacro/clash/releases">clash发布网站</a>下载对应的版本，我下载的是<strong>clash-linux-amd64-v1.7.1.gz</strong></p></li><li><p>将压缩包里的文件解压至**/opt/clash**，改名为clash，下载订阅链接文件到同个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O config.yaml [订阅链接]</span><br></pre></td></tr></table></figure></li><li><p>Country.mmdb为全球IP库，可以实现各个国家的IP信息解析和地理定位，没有这个文件clash是无法运行的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O Country.mmdb https://www.sub-speeder.com/client-download/Country.mmdb</span><br></pre></td></tr></table></figure></li><li><p>把clash权限改为可执行应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x clash</span><br></pre></td></tr></table></figure></li><li><p>执行clash，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./clash -d .</span><br></pre></td></tr></table></figure></li></ol><h2 id="修改系统代理"><a href="#修改系统代理" class="headerlink" title="修改系统代理"></a>修改系统代理</h2><ol><li>我使用的是ubuntu18.4，在设置里面修改。打开系统设置，点击网络代理右边的 ⚙ 按钮，选择手动，填写 HTTP 和 HTTPS 代理为 127.0.0.1:7890，填写 Socks 主机为 127.0.0.1:7891，即可启用系统代理</li></ol><h2 id="配置clash"><a href="#配置clash" class="headerlink" title="配置clash"></a>配置clash</h2><ol><li>在运行了clash后可以打开<a href="http://clash.razord.top/#/proxies">clash配置页面</a>进行配置，基本上就和windows中的clash图形化差不多了</li></ol><h2 id="设置为开机启动"><a href="#设置为开机启动" class="headerlink" title="设置为开机启动"></a>设置为开机启动</h2><ol><li><p>创建service文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /etc/systemd/system/clash.service</span><br></pre></td></tr></table></figure></li><li><p>编辑service文件，填入以下内容(注意修改clash文件夹路径)</p><blockquote><p>[Unit]<br>Description=clash daemon</p><p>[Service]<br>Type=simple<br>User=root<br>ExecStart=/opt/clash/clash -d /opt/clash/<br>Restart=on-failure</p><p>[Install]<br>WantedBy=multi-user.target</p></blockquote></li><li><p>重新加载systemctl daemon，<strong>systemctl daemon-reload</strong></p></li><li><p>启动Clash，<strong>systemctl start clash.service</strong></p></li><li><p>设置Clash开机自启动，<strong>systemctl enable clash.service</strong></p></li><li><p>systemctl的其他命令参考<a href="https://blog.csdn.net/skh2015java/article/details/94012643">linux中systemctl详细理解及常用命令</a></p></li></ol><h2 id="配置定时更新订阅"><a href="#配置定时更新订阅" class="headerlink" title="配置定时更新订阅"></a>配置定时更新订阅</h2><ol><li>可以设置个定时执行的任务，去下载新的配置文件，并重启clash服务</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电动工具电控设计</title>
      <link href="/2021/09/24/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86/"/>
      <url>/2021/09/24/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="电机位置反馈"><a href="#电机位置反馈" class="headerlink" title="电机位置反馈"></a>电机位置反馈</h1><h2 id="霍尔传感器"><a href="#霍尔传感器" class="headerlink" title="霍尔传感器"></a>霍尔传感器</h2><ul><li>马达轴上连有磁体，传感器为三个间隔60°的开关霍尔，霍尔会按照【001 - 101 - 100 - 110 - 010 - 011】六个状态变换，根据三相霍尔信号可以检测出电机转子位置所处的扇区，然后控制MOS或IGBT实现六步换向控制。</li><li>三路霍尔信号图<br><img src="https://hao0527.gitee.io/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86-1.jpg" alt="210924-电机控制部分-1.JPG"></li><li>120°霍尔换相真值表<br><img src="https://hao0527.gitee.io/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86-2.jpg" alt="210924-电机控制部分-2.JPG">  </li></ul><h2 id="无霍尔传感器"><a href="#无霍尔传感器" class="headerlink" title="无霍尔传感器"></a>无霍尔传感器</h2><ul><li>传感器很有用，但会增加成本，增加复杂性（由于需要附加绕组），并降低了可靠性（部分原因是传感器连接更容易受到灰尘和潮湿环境的污染），无传感器控制方式解决了这些不足。</li><li>无传感器利用电机反电动势确定转子角度，下图为三相反电动势波形和霍尔波形比较图<br><img src="https://hao0527.gitee.io/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86-3.jpg" alt="210924-电机控制部分-3.JPG"><br>可见，传统BLDC电机中单个霍尔传感器变化输出，与无传感器电机中单个线圈的反电动势零交叉点之间有一个30度的相位差。因此，在检测到零交叉点之后，我们会在无传感器电机电路的固件中内置一个30度相位延迟，然后再激活激励序列中的下一个动作。  </li></ul><h2 id="检测反电动势方法"><a href="#检测反电动势方法" class="headerlink" title="检测反电动势方法"></a>检测反电动势方法</h2><ol><li>最简单的方法就是用比较器将反电动势与一半的直流总线电压比较<br><img src="https://hao0527.gitee.io/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86-4.jpg" alt="210924-电机控制部分-4.JPG"><br>在此图中，线圈A正向激励，线圈C反向激励，而线圈B则开路。当实现此相位的激励序列时，反电动势就会上升和下降。这一简单比较器方法主要缺点就是三个绕组可能没有相同的特征，造成实际零交叉点的正负相移。电机仍可能在运转，但可能消耗过多电流。</li><li>上面问题解决方法就是通过使用与电机绕组并接的三个电阻网络来产生一个虚拟中性点，反电动势然后就会与虚拟中性点进行比较。<br><img src="https://hao0527.gitee.io/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86-5.jpg" alt="210924-电机控制部分-5.JPG"></li><li>第三种方法是采用模数转换器 (ADC)。为BLDC电机控制提供的许多MCU包括适合作此用途的高速ADC。采用这种方法后，反电动势就会衰减，以便可以直接馈送给MCU。信号被ADC采样后就会同与零点对应的数字值比较。当这两个值匹配时，线圈激励序列就会变址到下一步。这种技术具有一定优势，如允许使用数字滤波器来清除反电动势信号中的高频切换成份。<br><img src="https://hao0527.gitee.io/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86-6.jpg" alt="210924-电机控制部分-6.JPG">  </li></ol><h2 id="无感缺点"><a href="#无感缺点" class="headerlink" title="无感缺点"></a>无感缺点</h2><pre><code>无传感器BLDC电机控制有一大不足，就是当电机静止时，不会产生反电动势，这样MCU就无法知道定子和转子位置信息。  解决方法就是通过以预定序列激励线圈来启动处于开环配置的电机。当电机看似运转效率不高时，就会开始循环该序列。最终，速度将足以产生足够的反电动势，供控制系统切换到正常闭环运行状态（有效状态）。  由于反电机势与旋转速度成正比，因此在需要较低速度的应用中，无传感器BLDC电机可能不是一个好的选择。此时带有霍尔效应传感器的BLDC电机可能是更好的选择。  </code></pre><h2 id="示波器测霍尔角"><a href="#示波器测霍尔角" class="headerlink" title="示波器测霍尔角"></a>示波器测霍尔角</h2><p><img src="https://hao0527.gitee.io/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86-7.jpg" alt="210924-电机控制部分-7.JPG"></p><h2 id="FOC"><a href="#FOC" class="headerlink" title="FOC"></a>FOC</h2><p>​    <a href="https://zhuanlan.zhihu.com/p/147659820">【自制FOC驱动器】深入浅出讲解FOC算法与SVPWM技术</a></p><h1 id="MCU外围电路设计"><a href="#MCU外围电路设计" class="headerlink" title="MCU外围电路设计"></a>MCU外围电路设计</h1><h2 id="复位电路二极管"><a href="#复位电路二极管" class="headerlink" title="复位电路二极管"></a>复位电路二极管</h2><p>​    <a href="https://blog.csdn.net/cs_ing/article/details/9839661">复位电路为什么要加二极管</a>,断电后瞬间放掉电容的电荷，复位，使断电瞬间RC充分放电。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电动工具驱动部分设计</title>
      <link href="/2021/09/17/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/17/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h1><h2 id="单相逆变"><a href="#单相逆变" class="headerlink" title="单相逆变"></a>单相逆变</h2><ol><li>需要4个NMOS或者IGBT控制</li><li>正弦脉宽调制SPWM，在输出加电感电容滤波，电感电容值需要足够大（6mH 20uF）</li><li>在mos桥驱动中，用PNP三极管挂在MOS的GS上，作用是用三极管形成放电回路，否则GS电容的电过二极管往驱动芯片内部下管释放<br><img src="https://hao0527.gitee.io/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1-1.jpg" alt="210917-驱动部分设计-1.JPG"></li><li>在PCB布线时要注意让MOS开关部分的高频回流面积最小；功率地需要单点接地，高频开关环流路径不要铺地，以减小地干扰<br><img src="https://hao0527.gitee.io/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1-2.jpg" alt="210917-驱动部分设计-2.JPG"></li><li>反馈到单片机的信号需要隔离（电流电压互感器），低通或带通滤波</li><li>先直流升压再逆变的效率比先逆变再工频变压器升压的效率高很多</li></ol><h2 id="三相逆变"><a href="#三相逆变" class="headerlink" title="三相逆变"></a>三相逆变</h2><ol><li>需要6个NMOS或者IGBT控制</li><li>负载有星形负载和三角形负载<br><img src="https://hao0527.gitee.io/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1-3.jpg" alt="210917-驱动部分设计-3.JPG"></li><li>三相桥式逆变器可控器件导通顺序<br><img src="https://hao0527.gitee.io/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1-4.jpg" alt="210917-驱动部分设计-4.JPG"></li></ol><h1 id="驱动系统"><a href="#驱动系统" class="headerlink" title="驱动系统"></a>驱动系统</h1><h2 id="高铁"><a href="#高铁" class="headerlink" title="高铁"></a>高铁</h2><ol><li>接触网上传输高压交流电（25kV），通过变压器降压和四象限整流器转换成直流电，在经过逆变器降至六点转换成可调压调频的交流电，输入三相异步、同步牵引电动机，通过传动系统带动车轮运行</li><li>牵引变电所输入220kV三相交流电，通过三相变压器，低侧输出25kV三相交流电，一相往前方接触网，一相往后方接触网，另一项接铁轨</li><li>高铁趋势：整流 -&gt; 图腾柱PFC(无桥PFC)；IPM(IGBT) -&gt; SIC mostet(6个IGBT封装在一起)；三相异步电动机 -&gt; 永磁同步电动机(省电30%)</li><li><a href="https://blog.csdn.net/mahoon411/article/details/116980096">MOS管、IGBT、BJT的区别</a></li></ol><h1 id="PFC功率因数校正"><a href="#PFC功率因数校正" class="headerlink" title="PFC功率因数校正"></a>PFC功率因数校正</h1><h2 id="什么是PFC"><a href="#什么是PFC" class="headerlink" title="什么是PFC"></a>什么是PFC</h2><p>PFC的英文全称为”Power Factor Correction” ，意思是“功率因数校正”，功率因数指的是有效功率与总耗电量(视在功率)之间的关系，也就是有效功率除以总耗电量(视在功率)的比值。基本上功率因数可以衡量电力被有效利用的程度，当功率因数值越大，代表其电力利用率越高。功率因数是用来衡量用电设备用电效率的参数，低功率因数代表低电力效能。为了提高用电设备功率因数的技术就称为功率因数校正。（大于70瓦就必须使用功率因数校正PFC）</p><h2 id="被动式PFC"><a href="#被动式PFC" class="headerlink" title="被动式PFC"></a>被动式PFC</h2><p>被动式PFC一般分“电感补偿式”和“填谷电路式(Valley Fill Circuit)”<br>“电感补偿式”是使交流输入的基波电流与电压之间相位差减小来提高功率因数，“电感补偿式”包括静音式和非静音式。“电感补偿式”的功率因数只能达到0.7～0.8，它一般在高压滤波电容附近。<br>“填谷电路式”属于一种新型无源功率因数校正电路，其特点是利用整流桥后面的填谷电路来大幅度增加整流管的导通角，通过填平谷点，使输入电流从尖峰脉冲变为接近于正弦波的波形，将功率因数提高到0.9左右，显著降低总谐波失真。与传统的电感式无源功率因数校正电路相比，其优点是电路简单，功率因数补偿效果显著，并且在输入电路中不需要使用体积大重量沉的大电感器。</p><h2 id="主动式PFC"><a href="#主动式PFC" class="headerlink" title="主动式PFC"></a>主动式PFC</h2><p>主动式PFC则由电感电容及电子元器件组成，体积小、通过专用IC去调整电流的波形，对电流电压间的相位差进行补偿。主动式PFC可以达到较高的功率因数──通常可达98%以上，但成本也相对较高。此外，主动式PFC还可用作辅助电源，因此在使用主动式PFC电路中，往往不需要待机变压器，而且主动式PFC输出直流电压的纹波很小，这种电源不必采用很大容量的滤波电容。</p><h2 id="Boost-PFC变换器"><a href="#Boost-PFC变换器" class="headerlink" title="Boost PFC变换器"></a>Boost PFC变换器</h2><p><img src="https://hao0527.gitee.io/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1-5.jpg" alt="210917-驱动部分设计-5.JPG"></p><h2 id="PFC参考"><a href="#PFC参考" class="headerlink" title="PFC参考"></a>PFC参考</h2><ol><li><a href="https://www.sohu.com/a/436812131_100281310">一文搞懂PFC（功率因数校正）</a></li><li><a href="https://www.bilibili.com/video/BV1ko4y1C7km?spm_id_from=333.999.0.0">电赛必备之PFC电路，2006年B题功率因数监测与补偿系统</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电动工具电源部分设计</title>
      <link href="/2021/09/13/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/13/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="电源部分"><a href="#电源部分" class="headerlink" title="电源部分"></a>电源部分</h1><h2 id="AC-DC"><a href="#AC-DC" class="headerlink" title="AC/DC"></a>AC/DC</h2><p><img src="https://hao0527.gitee.io/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1-1.jpg" alt="210913-电源部分设计-1.JPG"></p><ol><li><a href="https://zhuanlan.zhihu.com/p/366532046">共模干扰和差模干扰</a></li><li>共模电感上流过共模电流时磁环中的磁通相互叠加，从而具有相当大的电感量，对共模电流起到抑制作用</li><li>X电容滤除差模干扰，利用其在高频时低阻抗的特性，短路掉差模干扰</li><li>压敏电阻是一种限压型保护器件，利用压敏电阻的非线性特性，当过电压出现在压敏电阻的两极间，压敏电阻可以将电压钳位到一个相对固定的电压值，从而实现对后级电路的保护</li><li>聚丙烯膜电容（CBB电容 MKP电容）做直流母线电容效果更好</li></ol><h2 id="Buck"><a href="#Buck" class="headerlink" title="Buck"></a>Buck</h2><p><img src="https://hao0527.gitee.io/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1-2.jpg" alt="210913-电源部分设计-2.JPG"></p><ol><li>AC-DC芯片采用MP174，SOURCE引脚是VCC和FB引脚的参考地</li><li>VCC供电电压是哪里来的？根据DataSheet，当Vout&lt;7V的时候，芯片空载功率较小，内部供电足够，当Vout&gt;7V时，需要添加外部辅助电源<br><img src="https://hao0527.gitee.io/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1-6.jpg" alt="210913-电源部分设计-6.JPG"></li><li><a href="https://www.bilibili.com/video/BV1ef4y1n7x1?spm_id_from=333.999.0.0">电源大师6——BUCK 降压电路降低EMI与EMC设计，开关电源PCB layout宝典</a></li><li>小信号地连一起（FB分压电阻，comp，ss）然后再与PGND单点相连，或者通过过孔连到背面</li><li>电感两个引脚间距京可能大，非一体成型电感底部不铺铜，让敏感电路（FB）和回路远离电感</li></ol><h2 id="LDO"><a href="#LDO" class="headerlink" title="LDO"></a>LDO</h2><p><img src="https://hao0527.gitee.io/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1-3.jpg" alt="210913-电源部分设计-3.JPG"></p><ol><li>LDO输入串阻，限流作用</li><li>LDO输出加TVS保护</li></ol><h1 id="采样部分"><a href="#采样部分" class="headerlink" title="采样部分"></a>采样部分</h1><h2 id="电压采样"><a href="#电压采样" class="headerlink" title="电压采样"></a>电压采样</h2><p><img src="https://hao0527.gitee.io/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1-4.jpg" alt="210913-电源部分设计-4.JPG"></p><ol><li>整流桥前和后的采样区别：整流桥前电压更稳定，一般采样用来测各种功率参数；整流桥后面的电压不稳定，会受到马达反冲等影响，整流桥后电压采样应用于过压和欠压保护</li></ol><h2 id="电流采样与过压保护"><a href="#电流采样与过压保护" class="headerlink" title="电流采样与过压保护"></a>电流采样与过压保护</h2><p><img src="https://hao0527.gitee.io/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1-5.jpg" alt="210913-电源部分设计-5.JPG"></p><ol><li>差分放大，迟滞比较器，电平反转，三极管自锁</li><li>在差分运放中电容并电阻微分作用，电容串电阻积分作用</li><li>对于电子电路：电阻的两端并联一个电容,为了减小对高频信号的阻抗，相当于微分，这样信号上升速度加快，用于提高响应速度；电容一端接电阻，一端接地，则相反，滤去高频，相当于积分，用于滤波。最典型的应用就是放大电路中的高低音频控制。<br>对于电力电路：不管RC串联还是并联，电容的作用都是一样的，电容的作用就是防止电压突变，吸收尖峰状态的过电压，串联的电阻起阻尼作用，电阻消耗过电压的能量，从而抑制电路的振荡。并联的电阻吸收电容的电能，防止电容的放电电流过大，避免对与之并联的器件（如晶闸管）造成损坏。最典型的应用就是防止操作过电压。</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>esp32开发板传输速率测试</title>
      <link href="/2021/08/31/210831-esp32%E4%BC%A0%E8%BE%93%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/08/31/210831-esp32%E4%BC%A0%E8%BE%93%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="程序框架和环境"><a href="#程序框架和环境" class="headerlink" title="程序框架和环境"></a>程序框架和环境</h3><ul><li>esp32的程序是通过esp-idf框架开发</li><li>esp32做Server，电脑做Client，手机热点AP</li><li>esp32使用外置天线更加稳定，但速率没有明显提升</li></ul><h3 id="TCP-Server"><a href="#TCP-Server" class="headerlink" title="TCP-Server"></a>TCP-Server</h3><ul><li>编译优化-O2，速率可从最高500KB/s提升到800KB/s</li><li>TCP传输错误会重传，有问题的时候速率会下降到100KB/s以下</li><li>应用在640*320分辨率的25帧JPEG图传不稳定</li></ul><h3 id="UDP-Server"><a href="#UDP-Server" class="headerlink" title="UDP-Server"></a>UDP-Server</h3><ul><li><p>速度可以达到1MB/s~2MB/s</p></li><li><p>UDP是个不稳定的传输，会有传输错误</p></li><li><p>不适合应用在JPEG图传</p></li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p><img src="https://hao0527.gitee.io/210831-esp32%E4%BC%A0%E8%BE%93%E6%B5%8B%E8%AF%95/210831-esp32%E4%BC%A0%E8%BE%93%E6%B5%8B%E8%AF%95-1.jpg" alt="210831-esp32传输测试-1.jpg"></p><ul><li><p>由于本人技术原因，无法达到官方测试的速率，大家使用需要亲自测试后才能做结论，可以参考iperf例程后再进行测试</p></li><li><p>参考：<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/index.html">ESP-IDF编程指南</a></p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> esp32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在Keil中重定向printf</title>
      <link href="/2021/08/21/210821-%E9%87%8D%E5%AE%9A%E5%90%91printf/"/>
      <url>/2021/08/21/210821-%E9%87%8D%E5%AE%9A%E5%90%91printf/</url>
      
        <content type="html"><![CDATA[<h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p>今天用STM32CubeMX生成了代码，使用printf函数后单片机程序运行异常，查出是STM32CubeMX生成的代码没有printf的重定向，百度查了两个方法后两个都行不通，最后参考正点原子例程解决。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p>错误参考：<a href="https://blog.csdn.net/xukao5671927/article/details/78485537">一知半解学CubeMX——UART：Printf实现</a></p></li><li><p>正确参考：正点原子例程SYSTEM文件夹下的usart.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入以下代码,支持printf函数,而不需要选择use MicroLIB</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> import(__use_no_semihosting)</span></span><br><span class="line"><span class="comment">//标准库需要的支持函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE __stdout;</span><br><span class="line"><span class="comment">//定义_sys_exit()以避免使用半主机模式</span></span><br><span class="line"><span class="type">void</span> _sys_exit(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重定义fputc函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//循环发送,直到发送完毕</span></span><br><span class="line">USART1-&gt;DR = (u8) ch;</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>要注意重定向的函数名是<code>int __io_putchar(int ch)</code>还是<code>int fputc(int ch, FILE *f)</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">  <span class="comment">/* With GCC/RAISONANCE, small printf (option LD Linker-&gt;Libraries-&gt;Small printf set to &#x27;Yes&#x27;) calls __io_putchar() */</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __GNUC__ */</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>CubeMX生成的代码没有勾选Use MicroLib，可能需要勾选，可以看<a href="https://www.cnblogs.com/zyqgold/p/6114637.html">Keil中的USE MicroLib说明</a>，MicroLib不支持操作系统函数。</p></li><li><p>Unix系统里，每行结尾只有“&lt;换行&gt;”，即”\n”；</p><p>Windows系统里面，每行结尾是“&lt;回车&gt;&lt;换行&gt;”，即“\r\n”；</p><p>Mac系统里，每行结尾是“&lt;回车&gt;”，即”\r”；</p><p>参考：<a href="https://blog.csdn.net/liewen_/article/details/89673402">\r,\n,\r\n的区别：回车与换行</a></p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《信号完整性与电源完整性分析》</title>
      <link href="/2021/08/09/210809-%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E4%B8%8E%E7%94%B5%E6%BA%90%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/"/>
      <url>/2021/08/09/210809-%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E4%B8%8E%E7%94%B5%E6%BA%90%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="书籍介绍"><a href="#书籍介绍" class="headerlink" title="书籍介绍"></a>书籍介绍</h3><p>作者: [美] Eric Bogatin<br>出版社: 电子工业出版社<br>原作名: Signal and Power Integrity：Simplified， Third Edition<br>译者: <a href="https://book.douban.com/search/%E6%9D%8E%E7%8E%89%E5%B1%B1">李玉山</a> / <a href="https://book.douban.com/search/%E5%88%98%E6%B4%8B">刘洋</a> / <a href="https://book.douban.com/search/%E5%88%9D%E7%A7%80%E7%90%B4">初秀琴</a> / <a href="https://book.douban.com/search/%E8%B7%AF%E5%BB%BA%E6%B0%91">路建民</a></p><h3 id="第一版前言"><a href="#第一版前言" class="headerlink" title="第一版前言"></a>第一版前言</h3><p>“一切都应该尽可能简单，而不只是简单一点。”        ——阿尔伯特·爱因斯坦</p><h3 id="信号完整性问题的10个基本原则"><a href="#信号完整性问题的10个基本原则" class="headerlink" title="信号完整性问题的10个基本原则"></a>信号完整性问题的10个基本原则</h3><ol><li><p>提高高速产品设计的关键是：充分利用分析工具实现准确的性能预估，使用测量手段验证设计过程，降低风险并提高所采用设计工具的可信度。</p></li><li><p>将问题的实质与表面现象剥离开的唯一可行途径是：采用经验法则，解析近似，数值仿真工具或测量工具获得数据，这是工程实践的本质要素。</p></li><li><p>任何一段互联，无论线长和形状，也无论信号的上升边如何，都是一个由信号路径和返回路径构成的传输线。一个信号在沿着互联前进的每一步，都会感受到一个瞬时阻抗。如果<strong>阻抗恒定</strong>为常数，比如具有均匀横截面传输线的情况，那么其信号质量将会获得奇迹般的改善。</p></li><li><p><strong>把“接地”这个术语忘掉</strong>，由于它所造成的问题比用它解决问题还要多。每一路都有返回路径。抓住“返回路径”，像对待信号路径一样去寻找并处理返回路径，这样有助于培养解决问题的直觉能力。</p></li><li><p>当电压变化时，电容器上就有电流流动。对于快速变化的前沿，即<strong>使印制电路板边沿和悬空导线之间的空气间隙形成的边缘线电容</strong>，都有可能拥有较低的阻抗。</p></li><li><p>电感与阻扰电流周围的磁力线匝数有本质的联系。只要电流与磁力线的匝数发生改变，在导线的两端就会产生电压。这一电压是导致反射噪声，串扰，开关噪声，地弹，轨道塌陷及电磁干扰的根源之一。</p></li><li><p>当流经地回路电感上的电流发生变化时，在接地回路导线上产生的电压称为是地弹。它是造成开关噪声和电磁干扰的内在机理。</p></li><li><p>以同频率的方法作为参照，信号带宽是指的有效正弦波分量的最高频率值。互联模型的带宽是指在这个最高的正弦频率上，模型仍然准确的预估互联的实际性能。在使用模型进行分析时，一定不要让信号的带宽超过模型的带宽。</p></li><li><p>除了少数情况之外，信号完整性公式中给出的是定义或者近似。在特别需要准确的场合就不使用近似。</p></li><li><p>有损传输线引起的问题是上升边退化。由于集肤深度和介质损耗，损耗随着频率的升高而增加。如果损耗随着频率的升高而保持不变，上升边就不会发生变化，这时的有损线只是增添了一些不便而已。</p></li></ol><h3 id="100条使信号完整性问题最小化的通用设计规则"><a href="#100条使信号完整性问题最小化的通用设计规则" class="headerlink" title="100条使信号完整性问题最小化的通用设计规则"></a>100条使信号完整性问题最小化的通用设计规则</h3><ul><li><a href="https://blog.csdn.net/qwertyuj/article/details/8460438">100条使信号完整性问题最小化的通用设计原则</a></li></ul><h3 id="100条估计信号完整性效应的经验法则"><a href="#100条估计信号完整性效应的经验法则" class="headerlink" title="100条估计信号完整性效应的经验法则"></a>100条估计信号完整性效应的经验法则</h3><ul><li><a href="https://blog.csdn.net/qwertyuj/article/details/8460440">100条估计信号完整性效应的经验法则</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fpga频率计设计</title>
      <link href="/2021/08/05/210805-fpga%E9%A2%91%E7%8E%87%E8%AE%A1/"/>
      <url>/2021/08/05/210805-fpga%E9%A2%91%E7%8E%87%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>开发板：<a href="https://item.taobao.com/item.htm?spm=a1z10.1-c.w4004-1816603213.25.3acf849bUh4GaW&id=592735846549">勤谋电子 Intel Altera Cyclone IV FPGA 开发板 EP4CE15 开发板</a></li><li>IDE：Quartus (Quartus Prime 18.0) Standard Edition</li><li>下载器：<a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.16.4d1e5dd8starCH&id=616077647019&ns=1&abbucket=9&skuId=4393547028324">USB Blaster下载器 ALTERA CPLD/FPGA下载线</a></li></ul><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><ul><li>实时频率测量</li><li>测量范围1Hz-50Mhz</li><li>测量误差0.0005%@20MHz</li><li>uart串口打印</li></ul><h3 id="不足思考"><a href="#不足思考" class="headerlink" title="不足思考"></a>不足思考</h3><ul><li>可以使用PLL提高sys_clk，使测量范围增到100MHz</li><li>程序逻辑复杂，还需简化</li><li>自适应闸门时间，在高频的时候提高实时测量的频率，低频的时候又可以准确测量，可使测量范围下限更小</li></ul><h3 id="Github发布"><a href="#Github发布" class="headerlink" title="Github发布"></a>Github发布</h3><ul><li><a href="https://github.com/hao0527/fpga-freq_measure_uart">https://github.com/hao0527/fpga-freq_measure_uart</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《FreeRTOS源码详解与应用开发——基于STM32》</title>
      <link href="/2021/07/29/210729-FreeRTOS%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2021/07/29/210729-FreeRTOS%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h3><ul><li><a href="https://www.bilibili.com/video/BV1a4411Q7X1">正点原子FreeRTOS手把手教学-基于STM32</a></li></ul><h3 id="思考与心得"><a href="#思考与心得" class="headerlink" title="思考与心得"></a>思考与心得</h3><ol><li><p>本书结构为：编码风格、<strong>系统移植</strong>、<strong>系统配置</strong>、任务函数、中断配置、临界区保护、多任务、列表结构、<strong>系统任务调度器</strong>、任务切换、时间管理、队列结构、信号量、<strong>软件定时器</strong>、事件标志组、任务通知、<strong>Tickless模式</strong>、空闲任务、<strong>内存管理</strong>。</p></li><li><p>跟今年2月份学的rtThread差不多，rtThread是参考<a href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/basic/basic">官方文档</a>学习的，学习了内核的一部分，和本次学习《FreeRTOS源码详解与应用开发》的内容差不多，也是借本书回忆一下之前学的实时系统。比较关心对接口的使用，本书的源码详解有一部分没有细看，日后需要的时候再啃源码，也可以自己手写一个实时系统来理解内核中核心的部分。</p></li><li><p>有些公司可能不想用实时系统，理由是影响速度，那么问题来了，<a href="https://www.zhihu.com/question/342441430">什么情况下需要采用嵌入式操作系统呢？</a>看过这个知乎的回答就知道，大型项目中裸奔会造成资源的浪费，特别是处理GUI、lwip、fatfs等，里面有大量的delay。在需要并行这些就需要用到rtos，使用os还可以实现应用层与底层硬件的隔离，可以方便分块开发、移植等。另外在资源数较少的mcu上不很适合使用rtos。</p></li><li><p>光看书没有用，我欠缺rtos的实践，最好是拿个项目练练手。</p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我画的第一块四层板</title>
      <link href="/2021/07/10/210710-%E7%AC%AC%E4%B8%80%E5%9D%97%E5%9B%9B%E5%B1%82%E6%9D%BF/"/>
      <url>/2021/07/10/210710-%E7%AC%AC%E4%B8%80%E5%9D%97%E5%9B%9B%E5%B1%82%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p><img src="https://hao0527.gitee.io/210710-%E7%AC%AC%E4%B8%80%E5%9D%97%E5%9B%9B%E5%B1%82%E6%9D%BF/210710-%E7%AC%AC%E4%B8%80%E5%9D%97%E5%9B%9B%E5%B1%82%E6%9D%BF-1.jpg" alt="210710-第一块四层板-1.jpg"></p><ul><li><p>第一次画四层板，嘉立创打板的时候出了点问题，嘉立创PCB解析和AD21.3.1版本的不兼容，导致内层存在空气间距</p></li><li><p>我还测试了下这个TVS和PTC防反接啥的，效果都蛮不错的</p></li><li><p>总体来说，感觉这块板子设计的蛮不错，目前没啥别的问题</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电路设计中各种GND之间的连接</title>
      <link href="/2021/06/28/210628-GND%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5/"/>
      <url>/2021/06/28/210628-GND%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/qlexcel/article/details/92728245">PCB的地与机壳（连接大地）为什么用阻容连接？</a></li><li><a href="https://www.bilibili.com/read/cv8008391/">电路设计中有几种地？各类GND的含义详解</a></li></ul><h3 id="GND可以分为几种"><a href="#GND可以分为几种" class="headerlink" title="GND可以分为几种"></a>GND可以分为几种</h3><ol><li><p>模拟地线AGND<br> 模拟信号是微弱信号，容易受到其他电路大电流的影响，大电流会在模拟电路中产生大的压降，会使得模拟信号失真。</p></li><li><p>数字地线DGND<br> 有按键检测电路、USB通信电路、单片机电路，在由0跳变到1的过程，电压产生了变化，根据麦克斯韦电磁理论，变化的电流周围会产生磁场，也就会形成EMC辐射，使用单独的DGND与其他电路隔离，防止辐射扩散。</p></li><li><p>功率地线PGND<br> 大电流会造成不同功能电路之间的地偏移现象。</p></li><li><p>电源地线GND<br> 是所有电路的0V电压参考点，是电源的地线GND。</p></li><li><p>交流地线CGND<br> 在AC-DC电源电路中，一个是交流地线，一个是直流地线，交流地线作为交流电路部分的0V参考点，直流地线作为直流电路部分的0V参考点。通常为了在电路中统一一个地线GND，工程师会将交流地线通过一个耦合电容或者电感与直流地线连接在一起。</p></li><li><p>大地地线EGND<br> 地线是在电系统或电子设备中，接大地、接外壳或接参考电位为零的导线。为了增强电路的安全系数，工程师一般在高压大电流的项目中使用大地的地线EGND，例如在家用电器电风扇、电冰箱、电视机等电路中。</p></li></ol><h3 id="不细分GND会导致的问题"><a href="#不细分GND会导致的问题" class="headerlink" title="不细分GND会导致的问题"></a>不细分GND会导致的问题</h3><ol><li><p>信号串扰<br> 假如将不同功能的地线GND直接连接在一起，大功率电路通过地线GND，会影响小功率电路的0V参考点GND，这样就产生了不同电路信号之间的串扰。</p></li><li><p>信号精度<br> 交流电源的地线CGND由于是正弦波，是周期性的上下波动变化，它的电压也是上下波动，不是像直流地线GND一样始终维持在一个0V上不变。将不同电路的地线GND连接在一起，周期性变化的交流地线CGND会带动模拟电路的地线AGND变化，这样就影响了模拟信号的电压精度值了。</p></li><li><p>EMC实验<br> 信号越弱，对外的电磁辐射EMC也就越弱；信号越强，对外的电磁辐射EMC也就越强。假如将不同电路的地线GND连接在一起，信号强电路的地线GND，直接干扰了信号弱电路的地线GND。</p></li><li><p>电路可靠性<br> 电路系统之间，信号连接的部分越少，电路独立运行的能力越强；信号连接的部分越多，电路独立运行的能力就越弱。</p></li></ol><h3 id="GND和机壳的连接"><a href="#GND和机壳的连接" class="headerlink" title="GND和机壳的连接"></a>GND和机壳的连接</h3><p>​    PCB板卡置于金属机壳中，机壳一般接大地，PCB的GND与机壳之间经常使用一个电容（1nF/1KV）并联一个电阻（1M）连接。</p><ol><li><p>电容是干啥用的<br>从EMS（电磁抗扰度）角度说，这个电容是在假设PE良好连接大地的前提下，降低可能存在的，以大地电平为参考的高频干扰型号对电路的影响，是为了抑制电路和干扰源之间瞬态共模压差的。其实GND直连PE是最好的，但是，直连可能不可操作或者不安全，例如，220V交流电过整流桥之后产生的GND是不可以连接PE的，所以就弄个低频过不去，高频能过去的路径。从EMI（电磁干扰）角度说，如果有与PE相连的金属外壳，有这个高频路径，也能够避免高频信号辐射出来。</p></li><li><p>一般在1nF左右比较合适<br>如果答主在变频器、伺服驱动器这样8~16kHz开关频率的工业设备上用这么大的电容值，那么，用户摸外壳会有触电的风险的。一般选到这么大，都是电路其他地方设计不合格，为了对付EMC测试，只好把这个电容加大的。<strong>最好是安规电容，GND和PE间选用Y电容</strong>。</p></li><li><p>1M电阻是干啥用的<br>这是对付ESD（静电放电）测试用的。因为这种用电容连接PE和GND的系统（浮地系统），在做ESD测试的时候，打入被测电路的电荷无处释放，会逐渐累积，抬升或降低GND相对与PE的电平，累积到一定程度，超过了PE和电路之间的绝缘最薄弱处所能耐受的电压范围，GND和PE之间就会放电，几个纳秒间，在PCB上的产生数十到数百安培的电流，这足以让任何电路因EMP（电磁脉冲）宕机，或者是让PE与电路之间绝缘最薄弱处所在信号连接的器件损坏。但是刚才说了，有时候又不能直接连接PE和GND，那么就用一个1-2M的电阻去慢慢释放这个电荷，以消除二者间的压差。当然1-2M这个数值是根据ESD测试标准选择的，因为IEC61000里面规定最高的重复次数只有10次/秒，如果你搞个1000次/秒的非标ESD放电，那么1~2M的电阻我觉得是不能释放掉累积的电荷的。1M电阻的高阻接地方式，往往是为了在<strong>提供EMC保护</strong>的同时或者说不影响防护效果的同时<strong>限制故障电流</strong>，印象中1M是根据人体模型得到的结果。比如内部挂了，GND连到高压上的故障，有这个1M，通过的电流不会伤害人体。</p></li><li><p>PE不可靠！因为很多国内的客户根本不会给你接上有效的PE，也就是说，你根本无法依靠PE来提升EMS或降低EMI的指标。其实这也不能全怪客户，是因为他们的车间、厂房、办公室根本就没按照电工标准来修，压根就是没有接地线的！所以，我明白PE不可靠以后，就使用一些技巧让电路能够硬抗过EMS测试。</p></li><li><p>PE（机壳）和GND直连是不行的。多见的系统是浮地，机壳连PE，PCBA不连PE，这样机壳就是个很好的法拉第笼，有效屏蔽外界。</p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FPGA驱动OV2640用SPI转发JPEG数据</title>
      <link href="/2021/06/23/210623-fpgaOV/"/>
      <url>/2021/06/23/210623-fpgaOV/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>FPGA采用的是<a href="http://www.gowinsemi.com.cn/prod_view.aspx?TypeId=10&FId=t3:10:3&Id=168">高云小蜜蜂家族</a>的GW1N-LV4QN88C6/I5</li><li>摄像头使用OV2640，可以配置数据为JPEG压缩后输出</li><li>采用DC-DC降压到3.6V再LDO降至3.3V与2.8V，OV内核和FPGA内核采用DC-DC降到1.2V使用</li></ul><h2 id="FPGA部分"><a href="#FPGA部分" class="headerlink" title="FPGA部分"></a>FPGA部分</h2><h3 id="编程流程图"><a href="#编程流程图" class="headerlink" title="编程流程图"></a>编程流程图</h3><ol><li>I2C驱动</li><li>FIFO配置</li><li>通过I2C配置OV2640寄存器</li><li>获取DCMI接口数据</li><li>JPEG找出帧头帧尾</li><li>把有效数据存入FIFO</li><li>SPI读FIFO数据输出</li></ol><h3 id="I2C驱动"><a href="#I2C驱动" class="headerlink" title="I2C驱动"></a>I2C驱动</h3><p>参考：正点原子OV5640驱动程序</p><h3 id="FIFO配置"><a href="#FIFO配置" class="headerlink" title="FIFO配置"></a>FIFO配置</h3><p>通过FIFO SC HS IP核向导生成（SC是同步的意思），在使用的时候需要查看IP核用户指南，重点要看时序部分</p><h3 id="SPI驱动"><a href="#SPI驱动" class="headerlink" title="SPI驱动"></a>SPI驱动</h3><p>参考：<a href="https://www.cnblogs.com/liujinggang/p/9609739.html">SPI总线的原理与Verilog实现</a></p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><p>本次FPGA实现读取OV2640并SPI发出来的小功能，解决了低端MCU没有DCMI外设，遇到了IP核不会使用的问题，要多看手册里的时序部分。还有就是有些数据处理的时候要缓冲，加延时，否则会造成信号的错位。后面我要加强流水线结构的设计，多用并行的思想发挥FPGA的优势。</p><h2 id="项目GitHub链接"><a href="#项目GitHub链接" class="headerlink" title="项目GitHub链接"></a>项目GitHub链接</h2><p><a href="https://github.com/hao0527/fpga-ov2640_fifo_spi">https://github.com/hao0527/fpga-ov2640_fifo_spi</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SRAM与DRAM</title>
      <link href="/2021/06/12/210612-RAM/"/>
      <url>/2021/06/12/210612-RAM/</url>
      
        <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/qq_21435127/article/details/79617714">浅谈关于SRAM与DRAM的区别</a></li></ul><h3 id="SRAM与DRAM的区别"><a href="#SRAM与DRAM的区别" class="headerlink" title="SRAM与DRAM的区别"></a>SRAM与DRAM的区别</h3><p>​        SRAM(Static RAM)与DRAM(Dynamic RAM)，从名字上看，SRAM与DRAM的区别只在于一个是静态一个是动态。由于SRAM不需要刷新电路就能够保存数据，所以具有静止存取数据的作用。而DRAM则需要不停地刷新电路，否则内部的数据将会消失。而且不停刷新电路的功耗是很高的，在我们的PC待机时消耗的电量有很大一部分都来自于对内存的刷新。那么为什么我们不用SRAM来作为内存呢？</p><p><strong>SRAM的基本单元结构图</strong> 和 <strong>DRAM的基本单元结构图</strong></p><p><img src="https://hao0527.gitee.io/210612-RAM/210612-RAM-1.jpg" alt="210612-RAM-1.jpg"></p><p>​        SRAM存储一位需要花6个晶体管，而DRAM只需要花一个电容和一个晶体管。cache（高速缓冲存储器）追求的是速度所以选择SRAM，而内存则追求容量所以选择能够在相同空间中存放更多内容并且造价相对低廉的DRAM。</p><p>​        我们姑且不去讨论关于SRAM是如何静态存储数据（触发器）的。为什么DRAM需要不断刷新呢？</p><p>​        DRAM的数据实际上是存在电容里的。而电容放久了，内部的电荷就会越来越少，对外就形成不了电位的变化。而且当对DRAM进行读操作的时候需要将电容与外界形成回路，通过检查是否有电荷流进或流出来判断该bit是1还是0。所以无论怎样，在读操作中我们都破坏了原来的数据。所以在读操作结束后需要将数据写回DRAM中。在整个读或者写操作的周期中，计算机都会进行DRAM的刷新，通常是刷新的周期是4ms-64ms。</p><p>​        关于SRAM和DRAM的寻址方式也有所不同。虽然通常我们都认为内存像一个长长的数组呈一维排列，但实际上内存是以一个二维数组的形式排列的，每个单元都有其行地址和列地址，当然cache也一样。而这两者的不同在于对于容量较小的SRAM，我们可以将行地址和列地址一次性传入到SRAM中，而如果我们对DRAM也这样做的话，则需要很多很多根地址线（容量越大，地址越长，地址位数越多）。所以我们选择分别传送行地址和列地址到DRAM中。先选中一整行，然后将整行数据存到一个锁存器中，等待列地址的传送然后选中所需要的数据。这也是为什么SRAM比DRAM快的原因之一。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python异步与线程</title>
      <link href="/2021/06/11/210611-python%E5%BC%82%E6%AD%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/06/11/210611-python%E5%BC%82%E6%AD%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h3><p>所谓多线程，就是系统可以同时运行多个任务，在操作系统中，每个任务就是一个线程。</p><p>Python 多线程可以成倍提高程序的运行速度。</p><p>进程是资源分配的最小单位，线程是程序执行的最小单位。</p><h3 id="python3多线程"><a href="#python3多线程" class="headerlink" title="python3多线程"></a>python3多线程</h3><p>参考：<a href="https://www.runoob.com/python3/python3-multithreading.html">Python3 多线程</a></p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h3><p><strong>同步</strong>是指完成事务的逻辑，先执行第一个事务，如果阻塞了，会一直等待，直到这个事务完成，再执行第二个事务，顺序执行。</p><p><strong>异步</strong>是和同步相对的，异步是指在处理调用这个事务的之后，不会等待这个事务的处理结果，直接处理第二个事务去了，通过状态、通知、回调来通知调用者处理结果。</p><h3 id="python3异步"><a href="#python3异步" class="headerlink" title="python3异步"></a>python3异步</h3><p>参考：<a href="https://docs.python.org/zh-cn/3/library/asyncio.html?highlight=asyncio#module-asyncio">asyncio — 异步 I/O</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛客网每日一练</title>
      <link href="/2021/06/07/210607-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83/"/>
      <url>/2021/06/07/210607-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<ol><li><p>（判断题）指针就是地址，因此一个变量的指针就是该变量的地址。<br>答案：错误；解释：指针是个变量，指针的值是个地址，地址是个常量。</p></li><li><p>char* s=”AAA”;<br>s[0]=’B’;    //错误，初始化指针时所创建的字符串常量被定义为只读，修改违法</p></li><li><p><code>char ch;int i;float f;double d;</code><br>表达式：<code>ch/i+(f*d-i)</code>的结果类型为<u>double</u></p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">MAX</span>(++a, b);</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">MAX</span>(++a, b + <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, a, b, c, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output： 8 0 7 10<br>解释：注意define，第一次调用MAX时，++a先执行了一次，此时a为6，由于满足宏定义中(a)&gt;(b)的条件，所以执行a，这个a就对应++a，所以a又自增了一次，变为7，由此得出c为7。 第二个MAX时a又自增了一次，此时为8，由于不满足条件，所以执行的是宏定义中的b，没有执行++a，所以a最终为8</p></li><li><p>关于fseek()    参考：<a href="https://www.runoob.com/cprogramming/c-function-fseek.html">C库函数 - fseek()</a></p></li><li><p>转义字符分三种，一般转义字符，八进制转义字符和十六进制转义字符 </p><p> <strong>一般转义字符</strong>，如‘\b’，由两个字符表示，其实代表一个字符，这个代表退格字符 </p><p> <strong>八进制转义字符</strong>，如‘\007’,三位数字是八进制的，ASCII码为7的表示响铃 </p><p> <strong>十六进制转义字符</strong>，如’\xfe’，同样后面数字是所表示意思的Ascii码的十六进制表示，注意一定要有x，大小写都行</p></li><li><p>在C程序中逗号运算符的优先级最低，赋值运算符其次；j++是属于赋值语句；sizeof()属于一元运算符；</p></li><li><p>C中&amp;&amp;（逻辑与）和&amp;（按位与）</p><ul><li>按位与运用二进制进行计算，逻辑与比较符号两边的真假输出逻辑值。</li><li>按位与对所有的表达式都要判断，逻辑与运算符第一个表达式不成立的话，后面的表达式不运算，直接返回。</li><li>按位与&amp;输出运算结果为不同的数值，逻辑与 &amp;&amp; 输出逻辑值true或者 false。</li></ul></li><li><p>两个指针变量不可以相加，因为指针变量相加没有意义。</p></li><li><p>scanf函数不能指定输入精度，可以指定长度，比如%m.nf是不允许的，但是可以%mf(m为整数)。<code>scanf(&quot;%7.2f&quot;,&amp;a);</code>不合法</p></li><li><p>多态类中的虚函数表建立在编译阶段。对类的编译，内存分布不太了解。</p></li><li><p><code>const int* p</code>是常量指针，<strong>p可以改变，*p不能改变</strong>；<code>int* const p = &amp;a</code>是指针常量，<strong>p不可以改变，*p能改变</strong>；记忆方法：const后面是p，p不能改变，const后面是*p，*p不能改变；还有一种<code>const int* const p = &amp;a</code>，p和*p都不能改变。</p></li><li><p>C++程序执行时，内存划分4个区域。不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程。代码区和全局区是在程序运行前划分，堆栈是在程序运行后划分。</p><ul><li>代码区：存放函数体和二进制代码，由操作系统负责管理（共享、只读）</li><li>全局区：存放全局变量和静态变量以及字符串，全局常量（程序结束后，由系统自动回收）</li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量，局部常量等</li><li>堆区：由程序员分配释放，若程序员不释放，程序结束时，由系统自动回收</li></ul></li><li><p>C++用new关键字请求内存，用delete释放内存，参考：<a href="https://www.runoob.com/cplusplus/cpp-dynamic-memory.html">C++ 动态内存</a></p></li><li><p>C没有引用，C++引用变量是一个别名，参考：<a href="https://www.runoob.com/cplusplus/cpp-references.htmlv">C++引用</a>；使用<a href="https://www.runoob.com/cplusplus/passing-parameters-by-references.html">引用传参</a>；使用<a href="https://www.runoob.com/cplusplus/returning-values-by-reference.html">引用作为函数返回值</a>；<a href="https://www.bilibili.com/video/BV1et411b73Z?p=93&spm_id_from=pageDriver">引用的本质</a>是指针常量；</p></li><li><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。<strong>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝析构时重复释放堆带来的问题</strong>。</p></li><li><p>类成员中有其他类对象，构造时先构造成员中的类对象，再构造自身；析构时相反。</p></li><li><p>静态成员变量：所有对象共享同一份数据；在编译阶段分配内存；类内声明，类外初始化；静态成员函数：所有对象共享同一个函数；静态成员函数只能访问静态成员变量；</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Class &amp;c)</span><br><span class="line">&#123;<span class="comment">// c++重载&lt;&lt;运算符</span></span><br><span class="line">    cout &lt;&lt; c.m_A;<span class="comment">// 打印成员变量</span></span><br><span class="line">    <span class="keyword">return</span> cout;<span class="comment">// 链式编程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电容的选型</title>
      <link href="/2021/05/23/210523-%E7%94%B5%E5%AE%B9%E9%80%89%E5%9E%8B/"/>
      <url>/2021/05/23/210523-%E7%94%B5%E5%AE%B9%E9%80%89%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://blog.csdn.net/yingxuexuan/article/details/6117023">LDO 输出电容</a></p></li><li><p><a href="https://blog.csdn.net/AirCity123/article/details/104186046">LDO输出端电容对其稳定性的影响</a></p></li></ul><h3 id="各种电容特性"><a href="#各种电容特性" class="headerlink" title="各种电容特性"></a>各种电容特性</h3><p><strong>多层陶瓷电容</strong></p><p>多层陶瓷电容(MLCC)不仅尺寸小，而且将低ESR、低ESL和宽工作温度范围特性融于一体，可以说是旁路电容的首选。不过，这类电容也并非完美无缺。根据电介质材料不同，电容值会随着温度、直流偏置和交流信号电压动态变化。另外，电介质材料的压电特性可将振动或机械冲击转换为交流噪声电压。大多数情况下，此类噪声往往以微伏计，但在极端情况下，机械力可以产生毫伏级噪声。</p><p>电压控制振荡器(VCO)、锁相环(PLL)、RF功率放大器(PA)和其它模拟电路都对供电轨上的噪声非常敏感。在VCO和PLL中，此类噪声表现为相位噪声；在RF PA中，表现为幅度调制；而在超声、CT扫描以及处理低电平模拟信号的其它应用中，则表现为显示伪像。尽管陶瓷电容存在上述缺陷，但由于尺寸小且成本低，因此几乎在每种电子器件中都会用到。不过，当调节器用在对噪声敏感的应用中时，设计人员必须仔细评估这些副作用。</p><p><strong>固态钽电解电容</strong></p><p>与陶瓷电容相比，固态钽电容对温度、偏置和振动效应的敏感度相对较低。新兴一种固态钽电容采用导电聚合物电解质，而非常见的二氧化锰电解质，其浪涌电流能力有所提高，而且无需电流限制电阻。此项技术的另一好处是ESR更低。固态钽电容的电容值可以相对于温度和偏置电压保持稳定，因此选择标准仅包括容差、工作温度范围内的降压情况以及最大ESR。</p><p>导电聚合物钽电容具有低ESR特性，成本高于陶瓷电容而且体积也略大，但对于不能忍受压电效应噪声的应用而言可能是唯一选择。不过，钽电容的漏电流要远远大于等值陶瓷电容，因此不适合一些低电流应用。</p><p>固态聚合物电解质技术的缺点是此类钽电容对无铅焊接过程中的高温更为敏感，因此制造商通常会规定电容在焊接时不得超过三个焊接周期。组装过程中若忽视此项要求，则可能导致长期稳定性问题。</p><p><strong>铝电解电容</strong></p><p>传统的铝电解电容往往体积较大、ESR和ESL较高、漏电流相对较高且使用寿命有限（以数千小时计）。而OS-CON电容则采用有机半导体电解质和铝箔阴极，以实现较低的ESR。这类电容虽然与固态聚合物钽电容相关，但实际上要比钽电容早10年或更久。由于不存在液态电解质逐渐变干的问题，OS-CON型电容的使用寿命要比传统的铝电解电容长。大多数电容的工作温度上限为105°C，但现在OS-CON型电容可以在最高125°C的温度范围内工作。</p><p>虽然OS-CON型电容的性能要优于传统的铝电解电容，但是与陶瓷电容或固态聚合物钽电容相比，往往体积更大且ESR更高。与固态聚合物钽电容一样，这类电容不受压电效应影响，因此适合低噪声应用。</p><p><strong>固态电容</strong></p><p>固态电容器的全名为固态铝质电解电容器，是目前电容器产品中最高阶的产品，固态电容的介电材料则为功能性导电高分子，能大幅提升产品的稳定度与安全性，它与液态铝质电解电容最大差别，在于所使用的介电材料，过去铝质电解电容所使用的介电材料是电解液，而固态电容则是导电性高分子材料，也因此导致成本相对较高。固态电容特点固态电容具备环保、低阻抗、高低温稳定、耐高纹波及高信赖度等优越特性，是目前电解电容产品中最高阶的产品。由于固态电容特性远优于液态铝电容，固态电容耐温达摄氏260度，且导电性、频率特性及寿命均佳，适用于低电压、高电流的应用。</p><h3 id="LDO负载电容"><a href="#LDO负载电容" class="headerlink" title="LDO负载电容"></a>LDO负载电容</h3><p>影响LDO稳定工作的外在因素是负载电容容值CL和ESR，以及LDO的输出电流，他们的关系是：</p><ol><li><p>容值小的CL，ESR往往较大，容值大的CL，ESR往往较小。无论哪种电容，都要保证ESR在合理的范围内，规格书往往会提供这个范围。</p></li><li><p>当LDO输出电流是额定电流的20%~50%时，容易发生不稳定状况。</p></li><li><p>低温时，CL的ESR会升高，并且容值也会发生变化。选型时要注意！</p></li><li><p>在ESR很低，LDO输出电流很小（≤1mA）时，容易发生不稳定状况。</p></li><li><p>同一温度下，LDO输出电流越小，保证LDO稳定性的ESR值越高。</p></li><li><p>同一输出电流下，温度越高，保证LDO稳定性的ESR越大。</p></li><li><p>在低输出电流时，LDO输出波形变成三角波，说明ESR过低；在中等输出电流时，如果LDO波形是正弦波，说明ESR过高。</p></li></ol><table><thead><tr><th><strong>电容技术</strong></th><th><strong>等效串联电阻</strong></th><th><strong>等效串联电感</strong></th><th><strong>电压稳定性</strong></th><th><strong>温度稳定性</strong></th><th><strong>振动敏感度</strong></th><th><strong>电容值/单位体积</strong></th></tr></thead><tbody><tr><td><strong>铝电解电容</strong></td><td>最高</td><td>最高</td><td>好</td><td>最低</td><td>低</td><td>低</td></tr><tr><td><strong>固态钽电容</strong></td><td>中等</td><td>中等</td><td>最佳</td><td>好</td><td>低</td><td>高</td></tr><tr><td><strong>聚合物固态铝电容</strong></td><td>低</td><td>低</td><td>最佳</td><td>好</td><td>低</td><td>高</td></tr><tr><td><strong>多层陶瓷电容</strong></td><td>最低</td><td>最低</td><td>差</td><td>好</td><td>高</td><td>中等</td></tr></tbody></table><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 智能车 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十六届智能车基础四轮方案</title>
      <link href="/2021/05/17/210517-%E9%A3%9E%E5%8D%A1/"/>
      <url>/2021/05/17/210517-%E9%A3%9E%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不会吧，不会吧，我又参加飞卡了？</p><h3 id="基础四轮组规则"><a href="#基础四轮组规则" class="headerlink" title="基础四轮组规则"></a>基础四轮组规则</h3><ul><li><p>车模：B车模，车模宽度不超过25厘米，高度不超过20厘米，长度没有限制，如果安装摄像头传感器，摄像头镜片中心的高度距离地面不超过10厘米</p></li><li><p>MCU：指定使用 Infineon系列单片机，允许使用各类电磁、红外光电、摄像头、激光、超声传感器</p></li><li><p>赛道元素：进出库、三岔路口（进出口120°，路口间直线距离&lt;3m）、环岛（R&lt;0.5m）、坡道（坡度&lt;=20°）、十字路口（需直行）、弯道（曲率半径&lt;0.5m）</p></li></ul><h3 id="电机驱动"><a href="#电机驱动" class="headerlink" title="电机驱动"></a>电机驱动</h3><p>IR2184老方案，B车电机比较猛，可能有11.7A，试一下加RDC释放电路来提高刹车性能</p><p><img src="https://hao0527.gitee.io/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-1.jpg" alt="210517-飞卡-1.jpg"></p><p><img src="https://hao0527.gitee.io/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-2.jpg" alt="210517-飞卡-2.jpg"></p><ul><li><input checked disabled type="checkbox"> 电机驱动加上ina240测电机电流(21.6.11前)</li></ul><p><img src="https://hao0527.gitee.io/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-7.jpg" alt="210517-飞卡-7.jpg"></p><p><img src="https://hao0527.gitee.io/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-8.jpg" alt="210517-飞卡-8.jpg"></p><p>（21.6.11）程序员通过电机反转来刹车，未加驱动死区时间，导致锂电池保护板保护。</p><h3 id="电磁运放"><a href="#电磁运放" class="headerlink" title="电磁运放"></a>电磁运放</h3><p>采用逐飞方案，opa4377，单端放大，检波，二极管使用了压降小的肖特基二极管</p><p><img src="https://hao0527.gitee.io/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-3.jpg" alt="210517-飞卡-3.jpg"></p><p><img src="https://hao0527.gitee.io/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-4.jpg" alt="210517-飞卡-4.jpg"></p><h3 id="tc377主控"><a href="#tc377主控" class="headerlink" title="tc377主控"></a>tc377主控</h3><p>考虑到DC-DC负载响应速率不如LDO，继续使用LM1084-ADJ给舵机供6.3v电<br><img src="https://hao0527.gitee.io/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-5.jpg" alt="210517-飞卡-5.jpg"><br><img src="https://hao0527.gitee.io/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-6.jpg" alt="210517-飞卡-6.jpg"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 智能车 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态顺序栈（C++）</title>
      <link href="/2021/05/14/210514-stack/"/>
      <url>/2021/05/14/210514-stack/</url>
      
        <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="http://c.biancheng.net/view/279.html">cin.getline()：C++读入一行字符串（整行数据）</a></p></li><li><p><a href="https://blog.csdn.net/dove1202ly/article/details/78542574">动态顺序栈的简单实现</a></p></li><li><p><a href="https://www.cnblogs.com/wkfvawl/p/10846851.html">C++ delete 和 delete []的区别</a></p></li><li><p><a href="https://www.cnblogs.com/lst601z815/p/5034576.html">c++数组自动扩容（动态数组）</a></p></li><li><p><a href="https://blog.csdn.net/manchengpiaoxue/article/details/83145476">c++动态数组</a></p></li><li><p><a href="https://codingdict.com/article/6233">C++ 类构造函数 &amp; 析构函数</a></p></li><li><p><a href="http://c.biancheng.net/view/2318.html">C++类模板5分钟入门教程</a></p></li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Stack</span>():_pData(<span class="keyword">new</span> T[<span class="number">1</span>]), _capacity(<span class="number">1</span>), _size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;creat stack successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Stack</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> [] _pData;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete stack successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">CheckCapacity</span>();</span><br><span class="line">_pData[_size++] = t;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;push &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T&amp; <span class="title">Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T&amp; t = _pData[_size<span class="number">-1</span>];</span><br><span class="line">_size--;</span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;pop return &quot; &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Capacity</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">Size</span>();</span><br><span class="line"><span class="type">size_t</span> capacity = <span class="built_in">Capacity</span>();</span><br><span class="line"><span class="type">size_t</span> newcapacity = <span class="number">2</span> * capacity;</span><br><span class="line"><span class="keyword">if</span> (size &gt;= capacity)</span><br><span class="line">&#123;</span><br><span class="line">_capacity = newcapacity;</span><br><span class="line">T* tmp = <span class="keyword">new</span> T[newcapacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp[i] = _pData[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] _pData;</span><br><span class="line">_pData = tmp;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;capacity add to &quot;</span> &lt;&lt; newcapacity &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _pData;</span><br><span class="line"><span class="type">size_t</span> _capacity;</span><br><span class="line"><span class="type">size_t</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line"><span class="type">char</span> strInput[<span class="number">100</span>]=<span class="string">&quot;test\0&quot;</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;input:&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(!cin.<span class="built_in">getline</span>(strInput,<span class="number">100</span>))</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error, input too long&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span>(strInput[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">Push</span>(strInput[i]);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;output:&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(strInput[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">Pop</span>();</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">creat stack successful</span><br><span class="line">input:i love tzy</span><br><span class="line">push i successful</span><br><span class="line">capacity add to 2</span><br><span class="line">push   successful</span><br><span class="line">capacity add to 4</span><br><span class="line">push l successful</span><br><span class="line">push o successful</span><br><span class="line">capacity add to 8</span><br><span class="line">push v successful</span><br><span class="line">push e successful</span><br><span class="line">push   successful</span><br><span class="line">push t successful</span><br><span class="line">capacity add to 16</span><br><span class="line">push z successful</span><br><span class="line">push y successful</span><br><span class="line">output:yzt evol i</span><br></pre></td></tr></table></figure><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><ol><li>Sublime里运行程序不能输入数据，只能输出数据（卡在cin）</li><li>参考：<strong>动态顺序栈的简单实现</strong> 中，数组扩容未改变_capacity</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>esp-idf开发esp32</title>
      <link href="/2021/05/11/210511-espidf/"/>
      <url>/2021/05/11/210511-espidf/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>安装Visual Studio Code（下面简称vscode）</li><li>安装python3.7.8（添加环境变量）、Git工具、CMake</li><li>vscode安装ESP-IDF Explorer插件，一键安装idf工具（国内速度慢）</li><li>通过这个插件安装esp-idf可能会失败，我当初用手机流量+梯子装的很快</li></ol><h2 id="使用idf"><a href="#使用idf" class="headerlink" title="使用idf"></a>使用idf</h2><p>Windows开发建议在vscode中使用esp-idf explorer插件</p><p>vscode还支持macOS和Linxu，未试过在其他操作系统使用该插件</p><h3 id="直接使用esp-idf"><a href="#直接使用esp-idf" class="headerlink" title="直接使用esp-idf"></a>直接使用esp-idf</h3><ol><li><p><code>%USERPROFILE%\esp\esp-idf</code>目录下examples文件夹内有例程</p></li><li><p>每次用idf工具，需要执行<code>%USERPROFILE%\esp\esp-idf</code>目录下的export添加环境变量，我是Windows，需要执行export.ps1，<strong>使用export.bat无效</strong>，ps1是Windows Power Shell脚本，需要电脑开启运行脚本权限，在管理员模式下Shell输入<code>set-executionpolicy remotesigned</code>开启权限，然后就可以运行export.ps1</p></li><li><p>在工程文件夹内使用<code>idf.py menuconfig</code>来配置工程</p></li><li><p>使用<code>idf.py build</code>来编译程序（首次编译或更改SDK后的速度慢）</p></li><li><p><code>idf.py -p PORT flash monitor</code>来下载程序</p></li></ol><h3 id="使用esp-idf-explorer插件"><a href="#使用esp-idf-explorer插件" class="headerlink" title="使用esp-idf explorer插件"></a>使用esp-idf explorer插件</h3><ul><li><p>这个工具非常好用，有GUI配SDK，在vscode用插件指令可以编译下载等</p></li><li><p>参考：<a href="https://www.bilibili.com/video/BV17p4y167uN?p=1">ESP-IDF VS Code 插件快速操作指南</a></p></li><li><p>vscode cmd <code>&gt;ESP-IDF:Show Examples Projects</code>基于例程新建工程</p></li><li><p>编译，下载，调试，设置sdk等功能点点左下角图标就可以</p></li></ul><h2 id="我的esp项目"><a href="#我的esp项目" class="headerlink" title="我的esp项目"></a>我的esp项目</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>通过esp32把红外热像Demo板的温度信号用TCP发到电脑上</p><h3 id="ESP和Demo板Uart通信"><a href="#ESP和Demo板Uart通信" class="headerlink" title="ESP和Demo板Uart通信"></a>ESP和Demo板Uart通信</h3><ul><li>参考esp例程：uart_events</li></ul><h3 id="ESP和电脑TCP通信"><a href="#ESP和电脑TCP通信" class="headerlink" title="ESP和电脑TCP通信"></a>ESP和电脑TCP通信</h3><ul><li>参考esp例程：tcp_client</li></ul><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ol><li>uart通信波特率设成921600时，接收会hw fifo overflow，esp没有DMA例程，通过降波特率解决</li><li>socket通信电脑端接收的时候不断更改<code>recv(new_fd, buff, BUFSIZ, 0)</code>buff指针会程序中断，未查出原因，通过把每次接收到的数据包写入文件解决</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> esp32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>卡片机项目进度</title>
      <link href="/2021/05/07/210507-%E5%8D%A1%E7%89%87%E6%9C%BA/"/>
      <url>/2021/05/07/210507-%E5%8D%A1%E7%89%87%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="室内-双光-配电柜卡片机"><a href="#室内-双光-配电柜卡片机" class="headerlink" title="室内 双光 配电柜卡片机"></a>室内 双光 配电柜卡片机</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ol><li>80*62 分辨率  预留160*120的空间和接口</li><li>200W 1920*1080  可见光分辨率</li><li>白光 LED 拍照照明</li><li>DC6-8.4V外部供电</li><li>低功耗</li><li>6-8pin航插，DC5V，uart 和SWD接口</li><li>无线图传电台：开阔地300米</li></ol><h3 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h3><ol><li><p>红外：80*62 的 3.3v spi接口上拉  160*120  fpc的 8Mbps UART ，DC5.0V降压 </p></li><li><p>可见光：OV2640 200W 24pin  考虑fpga作为DVP-spi接口 fpga时钟</p></li><li><p> 白光LED： DC3.4V 100-500mA</p></li><li><p>无线模块：24L01 2.4-2.52GHZ 250Kbps 500mW 27DB发射功率</p></li><li><p>电源：DC6V-8.4V 输入，加单向TVS和PTC保护  1uA低功耗LDO 接MCU ,带有EN使能脚的BUCK输出3.3V/5V</p></li><li><p>光敏  光电二极管加lmv321 放大 ADC</p></li><li><p>输出接口：SMA 无线  8pin 航插  RST，Vin ，rx/tx , SWD (ESD保护)</p></li><li><p>MCU：带RTC 32.768</p></li></ol><h3 id="调试阶段进度"><a href="#调试阶段进度" class="headerlink" title="调试阶段进度"></a>调试阶段进度</h3><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><ul><li><input checked disabled type="checkbox"> 绘制原理图</li><li><input checked disabled type="checkbox"> 绘制PCB（调试板）</li><li><input checked disabled type="checkbox"> 制板焊接（调试板）</li><li><input checked disabled type="checkbox"> 绘制产品的PCB</li></ul><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><ul><li><input checked disabled type="checkbox"> 调试80*60红外模块</li><li><input checked disabled type="checkbox"> 调试160*120红外模块</li><li><input checked disabled type="checkbox"> 调试FPGA-OV2640部分</li><li><input checked disabled type="checkbox"> 调试FPGA-MCU部分</li><li><input checked disabled type="checkbox"> 调试24L01模块</li><li><input checked disabled type="checkbox"> 调试电源管理部分</li><li><input disabled type="checkbox"> 调试其他功能</li></ul><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li><input checked disabled type="checkbox"> 红外模块板外形</li><li><input disabled type="checkbox"> ……</li></ul><h2 id="无线集抄器部分"><a href="#无线集抄器部分" class="headerlink" title="无线集抄器部分"></a>无线集抄器部分</h2><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><ol><li>可以支持500个从站</li><li>服务器端配置网络和从站设备</li><li>网口或者CAT1上传服务器</li><li>户外型  安装部署方便</li><li>DC12V 持续供电</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 工作日志 </category>
          
          <category> 卡片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BJT和FET相关知识总结</title>
      <link href="/2021/05/06/210506-bjt%E5%92%8Cfet/"/>
      <url>/2021/05/06/210506-bjt%E5%92%8Cfet/</url>
      
        <content type="html"><![CDATA[<h2 id="晶体三极管（BJT）"><a href="#晶体三极管（BJT）" class="headerlink" title="晶体三极管（BJT）"></a>晶体三极管（BJT）</h2><p>《模拟电子技术基础》（第五版）P24</p><h2 id="场效应管（FET）"><a href="#场效应管（FET）" class="headerlink" title="场效应管（FET）"></a>场效应管（FET）</h2><h3 id="结型场效应管（JFET）"><a href="#结型场效应管（JFET）" class="headerlink" title="结型场效应管（JFET）"></a>结型场效应管（JFET）</h3><p>《模拟电子技术基础》（第五版）P33</p><h3 id="绝缘栅型场效应管（IGFET）"><a href="#绝缘栅型场效应管（IGFET）" class="headerlink" title="绝缘栅型场效应管（IGFET）"></a>绝缘栅型场效应管（IGFET）</h3><ol><li>绝缘栅型场效应管的栅极与源极、漏极之间都采用SiO<sub>2</sub>绝缘层隔离，栅极为金属铝，又称MOS管</li><li>IGFET的G-S间内阻比JFET大得多，可达10<sup>10</sup>Ω以上</li><li>MOS分N沟道和P沟道两类，每一类分<strong>增强型</strong>和<strong>耗尽型</strong>两种，U<sub>GS</sub>=0时，I<sub>d</sub>=0为增强型，I<sub>d</sub>≠0为耗尽型</li><li>NMOS的U<sub>GS</sub> 越大，反型层越厚，导电沟道电阻越小</li><li>与JFET一样，MOS管有三个工作区：可变电阻区、恒流区、夹断区，当U<sub>DS</sub>增大到U<sub>GS(th)</sub>（即U<sub>DS</sub>=U<sub>GS</sub>-U<sub>GS(th)</sub>）时，沟道在漏极一侧出现加断点，进入恒流区，U<sub>DS</sub>增大的部分几乎全部用于克服预夹断区对漏极电流的阻力</li><li>U<sub>DS</sub>&gt;U<sub>GS</sub>-U<sub>GS(th)</sub>时，对应每一个U<sub>GS</sub>就有一个确定的I<sub>d</sub>，可将I<sub>d</sub>视为电压U<sub>GS</sub>控制的电流源</li></ol><h3 id="FET符号及特性"><a href="#FET符号及特性" class="headerlink" title="FET符号及特性"></a>FET符号及特性</h3><p><img src="https://hao0527.gitee.io/210506-bjt%E5%92%8Cfet/210506-bjt%E5%92%8Cfet-1.jpg" alt="210506-bjt和fet-1.jpg"><img src="https://hao0527.gitee.io/210506-bjt%E5%92%8Cfet/210506-bjt%E5%92%8Cfet-2.jpg" alt="210506-bjt和fet-2.jpg"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>喜提域名ihcode.cn（爱皓码）</title>
      <link href="/2021/05/04/210504-%E5%9F%9F%E5%90%8D/"/>
      <url>/2021/05/04/210504-%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h3><ol><li>在<a href="https://www.ename.cn/">易名官网</a>注册网站账号，实名认证（审核了半天）</li><li>选择好域名加入购物车，支付就可以，我的域名价格为35元一年</li></ol><h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><ol><li><p>注册完域名后进入后台-域名管理-我的域名</p></li><li><p>DNS使用的是<strong>易名DNS</strong>（免费版），网上听说易名DNS很烂，以后我再换一个DNS，易名DNS服务器是海外的，国内的DNS服务器需要备案，我的空间和服务器在本地，备案比较麻烦，就没备案</p></li><li><p>易名云解析中解析记录的一些配置如下</p><ul><li><p>主机记录就是域名前缀，常见用法有：</p><p>www：解析后的域名为 <code>www.ihcode.cn</code></p><p>@：直接解析主域名ihcode.cn</p><p>*：泛解析，匹配其他所有域名 *.ihcode.cn</p></li><li><p>要指向空间商提供的 IP 地址，选择「类型 A」，要指向一个域名，选择「类型 CNAME」</p></li><li><p>各类型的记录值一般是这样的：</p><p>A记录：填写您服务器 IP，如果您不知道，请咨询您的空间商</p><p>CNAME记录：填写空间商给您提供的域名</p></li><li><p>TTL(Time To Live)，缓存的生存时间。指地方dns缓存您域名记录信息的时间，缓存失效后会再次到获取记录值。</p><p>600（10分钟）：建议正常情况下使用600。</p><p>60（1分钟）：如果您经常修改IP，修改记录一分钟即可生效。长期使用60，解析速度会略受影响。</p><p>3600（1小时）：如果您IP极少变动（一年几次），建议选择3600，解析速度快。</p></li></ul></li><li><p>易名云解析中URL转发的一些配置如下</p><ul><li><p>域名，可以是 *.ihcode.cn 或者 <code>www.ihcode.cn</code></p></li><li><p>类型：显性或隐性</p><p>设置显性URL转发后，当用户访问域名会自动转向访问指定值，址栏显示指定值</p><p>设置隐性URL转发后，当用户访问域名会自动转向访问指定值，址栏仍旧显示之前域名</p></li><li><p>转发值：就是要跳转的域名链接http://，可以带端口号</p></li></ul></li></ol><h3 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h3><ol><li><p>解析记录的记录值只能是IP地址或者是指向的该IP的DDNS域名，不能加端口号</p><p>使用url转发可以带端口号，但是隐性类型转发后无法获取网页logo和名称，UI不正确等问题，使用显性类型转发可以</p></li><li><p>修改完解析记录后需要至少10分钟才能正常使用</p><p>清空DNS缓存即可，Windows管理员CMD输入<code>ipconfig /flushdns</code></p></li><li><p>Hexo 4000端口微信访问的时候会报非标准端口警告</p><p>考虑以后使用树莓派开一个web服务器，使用80端口映射到公网IP</p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OV2640初步调试记录</title>
      <link href="/2021/05/03/210503-ov2640/"/>
      <url>/2021/05/03/210503-ov2640/</url>
      
        <content type="html"><![CDATA[<h2 id="OV2640硬件"><a href="#OV2640硬件" class="headerlink" title="OV2640硬件"></a>OV2640硬件</h2><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p>参考：OV2640硬件开发手册</p><p>设计：Hao</p><p><img src="https://hao0527.gitee.io/210503-ov2640/210503-ov2640-1.jpg" alt="210503-ov2640-1.jpg"></p><h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p>layout：小张</p><h2 id="OV2640软件"><a href="#OV2640软件" class="headerlink" title="OV2640软件"></a>OV2640软件</h2><h3 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h3><ul><li>jpeg读取，24l01发送</li><li>光线暗打开闪光（未完成），通过读取曝光时间来判断光线强弱，决定是否打开闪光灯</li></ul><h3 id="程序开发"><a href="#程序开发" class="headerlink" title="程序开发"></a>程序开发</h3><ul><li><p>参考：<a href="https://www.bilibili.com/video/BV1Rx411R75t?p=79">正点原子ov2640实验视频</a>、OV2640数据手册、OV2640软件开发手册</p></li><li><p>接口：SCCB（类I2C）、DCMI（8bit并口）</p></li><li><p>传感器、传感器窗口、图像尺寸、图像窗口之间的关系如下图：<img src="https://hao0527.gitee.io/210503-ov2640/210503-ov2640-3.jpg" alt="210503-ov2640-3.jpg"></p></li><li><p>程序开发按照正点原子给的库很容易进行，但部分功能库里没有需要查阅软件开发手册和数据手册，对寄存器进行读写。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>DOVDD是IO的电平，给了3.3V，因为和它通讯的单片机使用的电压也是3.3V，如果这里用2.8V可以也是可以，会产生电流倒灌，增加了产品不稳定的因素</p></li><li><p>ov2640模组在上电的时候比较烫手，温度有55℃上下，不使用的时候将PWDN拉高，停止给电</p></li><li><p>为了节约成本，24Mhz时钟可以由单片机输出，代替有源晶振</p></li><li><p>如果单片机没有DCMI接口，软件模拟速度跟不上，需要使用带FIFO的摄像头（ov7550），才可以由软件模拟读取并口数据，模拟的还没有尝试过，可以参考原子哥M3例程，F103使用0V7550</p></li><li><p>由于大多数低成本国产单片机不带DCMI接口，可以由高云FPGA驱动ov2640，通过SPI发送给单片机，这是本人五一节后要做的事情</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 工作日志 </category>
          
          <category> 卡片机 </category>
          
          <category> OV2640 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>80*62红外热像Demo板调试记录</title>
      <link href="/2021/04/30/210430-at32/"/>
      <url>/2021/04/30/210430-at32/</url>
      
        <content type="html"><![CDATA[<h2 id="AT32（SPI）"><a href="#AT32（SPI）" class="headerlink" title="AT32（SPI）"></a>AT32（SPI）</h2><ul><li>暂时没有用DMA搬运，SPI3用于读取MI0801模组数据，SPI2用于驱LCD</li></ul><h3 id="SPI配置参数"><a href="#SPI配置参数" class="headerlink" title="SPI配置参数"></a>SPI配置参数</h3><ul><li><p>SPI配置需要注意的参数：极性CPOL和相位CPHA，<a href="https://www.cnblogs.com/shangdawei/p/4752476.html">详解SPI中的极性CPOL和相位CPHA</a></p></li><li><p>如何判断CPOL：SCLK的空闲时候的电压，是0还是1，决定了CPOL是0还是1</p></li><li><p>如何判断CPHA：数据采样时刻对应着的SCLK的电平，是第一个边沿还是第二个边沿，对应着CPHA为0还是1</p><p><img src="https://hao0527.gitee.io/210430-at32/210430-at32-1.jpg" alt="210430-at32-1.jpg"></p></li></ul><h3 id="驱动LCD问题"><a href="#驱动LCD问题" class="headerlink" title="驱动LCD问题"></a>驱动LCD问题</h3><ul><li>LCD用到了SPI和另外几个IO，写入命令过程中，要将DC拉低，0X2A、0X2B、0X2C是命令，但是DC拉低没有对上，通过程序加delay解决，当SPI速率上升后，可以不用delay就能使用LCD</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_REG</span><span class="params">(<span class="type">uint8_t</span> dat)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//  Delay_us(5);</span></span><br><span class="line">  <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TE) == RESET);</span><br><span class="line">  LCD_DC_Clr();<span class="comment">//写命令</span></span><br><span class="line">  LCD_Writ_Bus(dat);</span><br><span class="line">  <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TE) == RESET);</span><br><span class="line"><span class="comment">//  Delay_us(5);</span></span><br><span class="line">  LCD_DC_Set();<span class="comment">//写数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AT32在读写SPI前要等待上一次读写操作完成，否则会出现发送数据缺少，接收卡死</li></ul><h3 id="SPI-NSS上拉问题"><a href="#SPI-NSS上拉问题" class="headerlink" title="SPI NSS上拉问题"></a>SPI NSS上拉问题</h3><ul><li>at32单片机无法配置输出上拉或者下拉，SPI一开始调试的时候需要接着逻辑分析仪才可以，不接spi就接收不到数据，通过外加2k上拉电阻解决</li></ul><h2 id="AT32-SRAM"><a href="#AT32-SRAM" class="headerlink" title="AT32(SRAM)"></a>AT32(SRAM)</h2><h3 id="配置使用224KB-SRAM"><a href="#配置使用224KB-SRAM" class="headerlink" title="配置使用224KB SRAM"></a>配置使用224KB SRAM</h3><ul><li><p>要打开224KB SRAM《AT32F403A &amp; AT32F407入门使用指南》给了四种方法</p><p>1.2.3 AT32F403A_407零等待/非零等待Flash和内置SRAM大小选择配置大小选择配置说明</p><ul><li>使用 ICP/ISP 方式</li><li>使用脱机烧录器方式</li><li>客户也可以使用在 Bootloader program（IAP）内修改 SRAM 的大小，并调用它</li><li>启动文件中修改 AT32F403A_407 SRAM 为 224KB</li></ul></li><li><p>我用的是第三种方法，直接下一遍SRAM例程就开启了224KB SRAM</p></li></ul><h2 id="KEIL编译优化"><a href="#KEIL编译优化" class="headerlink" title="KEIL编译优化"></a>KEIL编译优化</h2><ul><li><strong>Keil编译优化等级从0提升到3，使图像帧率从2.5fps提升到了3.5fps</strong></li></ul><h3 id="不同编译优化等级区别"><a href="#不同编译优化等级区别" class="headerlink" title="不同编译优化等级区别"></a>不同编译优化等级区别</h3><ul><li><p>Level0：近乎不优化，用于调试代码。出现代码行不能设置断点可如此设置试试</p></li><li><p>Level1：部分优化。移除未调用的内联函数和静态函数，关闭debug窗口优化，此状态也能用于调试</p></li><li><p>Level2：默认优化等级。如果处于debug状态，<strong>部分代码行将不能被调试</strong>，具体做了什么优化好像没说</p></li><li><p>Level3：可能更牛的优化等级。会增加编译时间，可能会快，可能生成的文件大小会小，可能会暴毙</p></li><li><p>相关文档：<a href="https://blog.csdn.net/jiangchao3392/article/details/80267198">KEIL编译器【C语言编译选项优化等级说明】</a></p></li></ul><h2 id="实物"><a href="#实物" class="headerlink" title="实物"></a>实物</h2><h3 id="实物展示图"><a href="#实物展示图" class="headerlink" title="实物展示图"></a>实物展示图</h3><p><img src="https://hao0527.gitee.io/210430-at32/210430-at32-2.jpg" alt="210430-at32-2.jpg"></p><h3 id="四种图像显示模式"><a href="#四种图像显示模式" class="headerlink" title="四种图像显示模式"></a>四种图像显示模式</h3><p><img src="https://hao0527.gitee.io/210430-at32/210430-at32-3.jpg" alt="210430-at32-3.jpg"></p><h3 id="红外显示示范"><a href="#红外显示示范" class="headerlink" title="红外显示示范"></a>红外显示示范</h3><p><img src="https://hao0527.gitee.io/210430-at32/210430-at32-4.jpg" alt="210430-at32-4.jpg"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 工作日志 </category>
          
          <category> 卡片机 </category>
          
          <category> AT32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客框架在使用中遇到的问题</title>
      <link href="/2021/04/25/210425-hexo/"/>
      <url>/2021/04/25/210425-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="如何用Hexo搭建博客？"><a href="#如何用Hexo搭建博客？" class="headerlink" title="如何用Hexo搭建博客？"></a>如何用Hexo搭建博客？</h2><h3 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h3><ul><li><a href="https://www.bilibili.com/video/BV1Yb411a7ty">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></li></ul><h3 id="文档教程"><a href="#文档教程" class="headerlink" title="文档教程"></a>文档教程</h3><ul><li><a href="https://hexo.io/zh-cn/docs/">Hexo文档</a></li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="md插入图片网页上不显示"><a href="#md插入图片网页上不显示" class="headerlink" title="md插入图片网页上不显示"></a>md插入图片网页上不显示</h3><p>参考：<a href="https://blog.csdn.net/xjm850552586/article/details/84101345">hexo引用本地图片无法显示</a>、<a href="https://www.jianshu.com/p/3db6a61d3782">hexo使用markdown图片无法显示问题</a></p><ol><li>安装 <strong>hexo-asset-image</strong>插件</li><li>修改插件 <strong>_config.yml</strong>内容</li><li>图片放在 <strong>/source/_posts/xxx</strong>文件夹内，xxx与xxx.md同名</li><li>使用<code>![xxx](xxx/xxx.png)</code>直接插入图片（注意不能有差别，多个”/“都不行）</li></ol><h3 id="Markdown上下标"><a href="#Markdown上下标" class="headerlink" title="Markdown上下标"></a>Markdown上下标</h3><p>参考：<a href="https://www.jianshu.com/p/13b3366f0260">在markdown中如何加入上标、下标？</a></p><ul><li>SiO<sub>2</sub>写法为：<code>SiO&lt;sub&gt;2&lt;/sub&gt;</code></li><li>2<sup>10</sup>Ω写法为：<code>2&lt;sup&gt;10&lt;/sup&gt;Ω</code></li></ul><h3 id="Hexo-Github部署"><a href="#Hexo-Github部署" class="headerlink" title="Hexo Github部署"></a>Hexo Github部署</h3><ol><li>安装hexo-deployer-git插件 ‘cnpm install –save hexo-deployer-git’</li><li>git添加SSHKey</li><li>blog文件夹中_config.yml配置hexo-deployer-git插件<br> type: git<br> repo: <a href="mailto:&#x67;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;">&#x67;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;</a>:hao0527/hao0527.github.io.git<br> branch: main</li><li>hexo g 编译<br> hexo d 发布到Github</li><li>每次发布会GithubPages的Custom domain都会被删除，在本地source文件夹中添加CNAME文件，内容写自定义域名就行</li></ol><h3 id="Hexo-增加搜索功能"><a href="#Hexo-增加搜索功能" class="headerlink" title="Hexo 增加搜索功能"></a>Hexo 增加搜索功能</h3><p>参考：<a href="https://blog.csdn.net/xinyflove/article/details/108791970">Hexo博客添加搜索功能</a></p><p>参考：<a href="https://blog.csdn.net/Best_xiaogao/article/details/126471145">npm WARN config global –global, –local are deprecated. Use –location 的解决方法</a></p><hr><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
