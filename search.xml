<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>S32K344 Cache 调试记录</title>
      <link href="/2024/05/20/240520-cache/"/>
      <url>/2024/05/20/240520-cache/</url>
      
        <content type="html"><![CDATA[<h2 id="Cache概述"><a href="#Cache概述" class="headerlink" title="Cache概述"></a>Cache概述</h2><p>在嵌入式系统中，缓存（Cache）是一种重要的存储器，位于CPU和主存储器（如SRAM、DRAM）之间。它用于存储经常访问的数据和指令，以减少访问主存的时间，从而提高系统的整体性能。缓存可以显著减少CPU等待数据的时间，提高系统的响应速度和处理能力。</p><h2 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h2><p>缓存通过存储从主存储器中读取的常用数据或指令来加快访问速度。当CPU需要访问某个数据或指令时，会首先检查缓存。如果缓存中存在所需数据（称为缓存命中），则直接从缓存中读取。如果缓存中不存在（称为缓存未命中），则从主存储器中读取数据，并将其存储到缓存中，以备后续访问。</p><h2 id="S32K344-Cache资源情况"><a href="#S32K344-Cache资源情况" class="headerlink" title="S32K344 Cache资源情况"></a>S32K344 Cache资源情况</h2><p>NXP S32K344拥有8KB I-Cache 和 8KB D-Cache，从系统框图看这个芯片，对于锁步核的应用，两个核的Cache无法共用，而TCM内存是可以共用的，锁步情况下TCM内存容量是不锁步的2倍。在Memory table里还能看到存在672Bytes的I-Cache tag和800Bytes的D-Cache tag，缓存需要一种机制来管理哪些数据当前存储在缓存中，这就是tag的作用。S32K344的RAM和ROM都有ECC校验，Cache也包含了ECC校验，RAM和ROM每64位数据有8位是存ECC校验值，这意味着实际设计的Cache资源还要更大一些用于存ECC校验值。</p><h2 id="Cache维护"><a href="#Cache维护" class="headerlink" title="Cache维护"></a>Cache维护</h2><p>在缓存管理中，无效化（Invalidate）和清除（Clean）是两个不同的操作。这两个操作帮助维持缓存一致性，确保系统性能和数据正确性。</p><h3 id="无效化（Invalidate）"><a href="#无效化（Invalidate）" class="headerlink" title="无效化（Invalidate）"></a>无效化（Invalidate）</h3><p>作用：使缓存中的数据无效，但不写回主存。<br>使用场景：当你确定缓存中的数据已经过期或不再需要时，可以无效化缓存来避免使用陈旧数据。</p><h3 id="清除（Clean）"><a href="#清除（Clean）" class="headerlink" title="清除（Clean）"></a>清除（Clean）</h3><p>作用：将缓存中的数据写回主存，但不使数据无效。<br>使用场景：当需要确保缓存中的最新数据已经同步到主存时，可以进行清除操作，特别是在DMA操作前后。</p><h2 id="实际使用问题"><a href="#实际使用问题" class="headerlink" title="实际使用问题"></a>实际使用问题</h2><h3 id="开启Cache后Flash读写擦"><a href="#开启Cache后Flash读写擦" class="headerlink" title="开启Cache后Flash读写擦"></a>开启Cache后Flash读写擦</h3><p>S32K344，MCAL的INFLS代码可以配置开启<code>Mem Synchronize Cache</code>选项用于确保缓存与Flash存储之间的数据一致性。</p><p>功能：在每次Flash高电压操作（写入、擦除）后，通过调用MCL（Memory Control Layer）缓存API函数来无效化缓存，以确保缓存与修改后的Flash存储同步。但也存在缺点，如果要无效化的区域大于缓存的一半，则整个缓存会被无效化。</p><p><strong>在实际使用中如果开启Cache，没开这个选项部分代码擦写Flash不生效，写入异常</strong>。</p><h3 id="代码加载到RAM运行"><a href="#代码加载到RAM运行" class="headerlink" title="代码加载到RAM运行"></a>代码加载到RAM运行</h3><p>S32K344，MCAL的INFLS代码可以配置开启<code>Mem Clean Cache After Load Access Code</code>选项用于确保加载到RAM中的Access Code函数与缓存一致。</p><p>如果该选项启用，在将Access Code函数加载到RAM后，清除缓存，将缓存数据写入实际RAM内存。此操作可确保缓存和RAM之间的数据同步，避免缓存数据不一致的问题。<strong>在实际使用中遇到了开启这个选项但没开Cache功能，有概率会在加载RAM代码缓存操作时卡死问题</strong>。</p><h2 id="内存区域配置不使用Cache"><a href="#内存区域配置不使用Cache" class="headerlink" title="内存区域配置不使用Cache"></a>内存区域配置不使用Cache</h2><p>不同MCU实现不一样，有使用<strong>MPU（内存保护单元）</strong>，配置MPU区域属性，将指定内存区域设置为不可缓存，设置MPU的Region属性，使该区域不可缓存。也有配置<strong>MMU（内存管理单元）</strong>，如果使用MMU，可以通过设置页表条目属性将内存区域设置为不可缓存。或者是<strong>芯片特定的寄存器</strong>，参考芯片手册进行配置。</p><p>S32K344如何配置目前还没了解到，在链接脚本中看到有一块 SRAM 没有被缓存。顺着链接脚本中定义的变量应该能查到程序中哪里配置的不缓存，也有可能那块区域就是不缓存区域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MEMORY</span><br><span class="line">&#123;</span><br><span class="line">    int_pflash              : ORIGIN = 0x00440000, LENGTH = 0x00394000    /* 4096KB - 176KB (sBAF + HSE) - 256KB(boot) = 3664KB*/</span><br><span class="line">    int_dflash              : ORIGIN = 0x10000000, LENGTH = 0x00020000    /* 128KB */</span><br><span class="line">    int_itcm                : ORIGIN = 0x00000000, LENGTH = 0x00010000    /* 64KB */</span><br><span class="line">    int_dtcm                : ORIGIN = 0x20000000, LENGTH = 0x0001F000    /* 124KB */</span><br><span class="line">    int_stack_dtcm          : ORIGIN = 0x2001F000, LENGTH = 0x00001000    /* 4KB */</span><br><span class="line">    int_sram                : ORIGIN = 0x20400000, LENGTH = 0x0002FF00    /* 184KB, needs to include int_sram_fls_rsv */</span><br><span class="line">    int_sram_fls_rsv        : ORIGIN = 0x2042FF00, LENGTH = 0x00000100</span><br><span class="line">    int_sram_no_cacheable   : ORIGIN = 0x20430000, LENGTH = 0x0000FF00    /* 64KB, needs to include int_sram_results  */</span><br><span class="line">    int_sram_results        : ORIGIN = 0x2043FF00, LENGTH = 0x00000100</span><br><span class="line">    int_sram_shareable      : ORIGIN = 0x20440000, LENGTH = 0x00004000    /* 16KB */</span><br><span class="line">    ram_rsvd2               : ORIGIN = 0x20444000, LENGTH = 0             /* End of SRAM */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LVGL显示实时图像信息</title>
      <link href="/2024/04/03/240403-lvgl/"/>
      <url>/2024/04/03/240403-lvgl/</url>
      
        <content type="html"><![CDATA[<h2 id="LVGL介绍"><a href="#LVGL介绍" class="headerlink" title="LVGL介绍"></a><a href="https://lvgl.io/">LVGL</a>介绍</h2><p><strong>LVGL</strong> 是最流行的免费和开源嵌入式图形库，可为任何 MCU 和 MPU 显示类型创建漂亮的 UI。</p><h2 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h2><p>这是去年做的一个小项目，手持热像仪，需要LCD显示摄像头的实时图像。之前做过直接用LCD驱动显示图片效率会高些，这一次需要加一下UI给用户选配置等功能，所以选择使用LVGL。做UI是小问题，主要是如何显示实时图像，本文将介绍使用图像解码器的方法。</p><h2 id="Image-decoder（图像解码器）"><a href="#Image-decoder（图像解码器）" class="headerlink" title="Image decoder（图像解码器）"></a><a href="https://lvgl.100ask.net/master/overview/image.html#image-decoder">Image decoder（图像解码器）</a></h2><p>图像解码器原本被用来解码通用图像格式，如 PNG 或 JPG。我把摄像头读来数据通过图像解码器封装了一下，当做自定义格式去解码，解码器接口如下，最后注册到LVGL，主要实现了 get_info 和 read_line 这两个接口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint16_t</span> img_ram[MY_IMG_H][MY_IMG_W];<span class="comment">// 摄像机读来的图像数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">lv_res_t</span> <span class="title function_">my_decoder_get_info</span><span class="params">(<span class="type">lv_img_decoder_t</span>* decoder, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">lv_img_header_t</span>* header)</span></span><br><span class="line">&#123;</span><br><span class="line">    LV_UNUSED(decoder);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(<span class="string">&quot;use my_decoder&quot;</span>, src))</span><br><span class="line">    &#123;<span class="comment">// 如果src 不等于 &quot;use my_decoder&quot;，不使用此解码器</span></span><br><span class="line">        <span class="keyword">return</span> LV_RES_INV;</span><br><span class="line">    &#125;</span><br><span class="line">    header-&gt;w = MY_IMG_W;</span><br><span class="line">    header-&gt;h = MY_IMG_H;</span><br><span class="line">    header-&gt;always_zero = <span class="number">0</span>;</span><br><span class="line">    header-&gt;cf = LV_IMG_CF_TRUE_COLOR;  <span class="comment">// 使用lv_conf.h 中 LV_COLOR_DEPTH 配置的颜色</span></span><br><span class="line">    <span class="keyword">return</span> LV_RES_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">lv_res_t</span> <span class="title function_">my_decoder_open</span><span class="params">(<span class="type">lv_img_decoder_t</span>* decoder, <span class="type">lv_img_decoder_dsc_t</span>* dsc)</span></span><br><span class="line">&#123;</span><br><span class="line">    LV_UNUSED(decoder);</span><br><span class="line">    LV_UNUSED(dsc);</span><br><span class="line">    <span class="keyword">return</span> LV_RES_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">lv_res_t</span> <span class="title function_">my_decoder_read_line</span><span class="params">(<span class="type">lv_img_decoder_t</span>* decoder, <span class="type">lv_img_decoder_dsc_t</span>* dsc, <span class="type">lv_coord_t</span> x, <span class="type">lv_coord_t</span> y, <span class="type">lv_coord_t</span> len, <span class="type">uint8_t</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    LV_UNUSED(decoder);</span><br><span class="line">    LV_UNUSED(dsc);</span><br><span class="line">    <span class="type">uint16_t</span>* destBuff = (<span class="type">uint16_t</span>*)buf;</span><br><span class="line">    <span class="type">uint16_t</span>* srcBuff = (<span class="type">uint16_t</span>*)img_ram;</span><br><span class="line">    <span class="type">uint32_t</span> offset = x + y * MY_IMG_W;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        destBuff[i] = srcBuff[offset + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LV_RES_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_decoder_close</span><span class="params">(<span class="type">lv_img_decoder_t</span>* decoder, <span class="type">lv_img_decoder_dsc_t</span>* dsc)</span></span><br><span class="line">&#123;</span><br><span class="line">    LV_UNUSED(decoder);</span><br><span class="line">    LV_UNUSED(dsc);</span><br><span class="line">    <span class="keyword">return</span> LV_RES_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建一个解码器，将自定义解码器的接口注册到此解码器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_decoder_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">lv_img_decoder_t</span>* dec = lv_img_decoder_create();</span><br><span class="line">    lv_img_decoder_set_close_cb(dec, my_decoder_close);</span><br><span class="line">    lv_img_decoder_set_info_cb(dec, my_decoder_get_info);</span><br><span class="line">    lv_img_decoder_set_open_cb(dec, my_decoder_open);</span><br><span class="line">    lv_img_decoder_set_read_line_cb(dec, my_decoder_read_line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时刷新和 main 函数代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_timer</span><span class="params">(<span class="type">lv_timer_t</span> * timer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">lv_obj_t</span> * img = timer-&gt;user_data;  <span class="comment">// 取出定时器的userdata</span></span><br><span class="line">    <span class="comment">// 这里需实现更新摄像机的图像数据到 img_ram 数组的代码</span></span><br><span class="line">    lv_obj_invalidate(img); <span class="comment">// 将img对象标记为无效以重新绘制其区域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_show_img</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">lv_obj_t</span> * img = lv_img_create(lv_scr_act());</span><br><span class="line">    lv_img_set_src(img, <span class="string">&quot;use my_decoder&quot;</span>);</span><br><span class="line">    lv_obj_align(img, LV_ALIGN_CENTER, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    lv_obj_set_size(img, MY_IMG_W, MY_IMG_H);</span><br><span class="line">    lv_timer_create(my_timer, <span class="number">100</span>, (<span class="type">void</span>*)img); <span class="comment">// 创建定时器，周期100ms，定时器userdata设为img对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> APIENTRY <span class="title function_">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR szCmdLine, <span class="type">int</span> nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Initialize LittlevGL*/</span></span><br><span class="line">    lv_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Initialize the HAL for LittlevGL*/</span></span><br><span class="line">    lv_win32_init(hInstance, SW_SHOWNORMAL, <span class="number">800</span>, <span class="number">480</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Output prompt information to the console, you can also use printf() to print directly*/</span></span><br><span class="line">    LV_LOG_USER(<span class="string">&quot;LVGL initialization completed!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Run the demo*/</span></span><br><span class="line">    my_decoder_init();</span><br><span class="line">    my_show_img();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!lv_win32_quit_signal) &#123;</span><br><span class="line">        <span class="comment">/* Periodically call the lv_task handler.</span></span><br><span class="line"><span class="comment">         * It could be done in a timer interrupt or an OS task too.*/</span></span><br><span class="line">        lv_task_handler();</span><br><span class="line">        usleep(<span class="number">10000</span>);       <span class="comment">/*Just to let the system breath*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p><a href="https://lvgl.100ask.net/master/widgets/canvas.html">Canvas（画布）(lv_canvas)</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows CMD 脚本学习，实现 Markdown Table 解析</title>
      <link href="/2024/01/26/240126-wincmd/"/>
      <url>/2024/01/26/240126-wincmd/</url>
      
        <content type="html"><![CDATA[<h2 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h2><p>命令提示符是在操作系统中，提示进行命令输入的一种工作提示符。在不同的操作系统环境下，命令提示符各不相同。在windows环境下，命令行程序为cmd.exe，是一个32位的命令行程序（在64位系统中 cmd.exe 也存在于 SysWOW64 目录，WOW64 是 x86 模拟器，允许基于 Windows 的 32 位应用程序在 64 位 Windows 上运行），微软Windows系统基于Windows上的命令解释程序，类似于微软的<a href="https://zh.wikipedia.org/wiki/DOS">DOS操作系统</a>（可惜，我这个年代的人都没见过DOS~）。</p><h2 id="批处理文件"><a href="#批处理文件" class="headerlink" title="批处理文件"></a>批处理文件</h2><p>批处理文件是无格式的文本文件，它包含一条或多条命令。它的文件扩展名为 .bat 或 .cmd。在命令提示下输入批处理文件的名称，或者双击该批处理文件，系统就会调用 cmd.exe 按照该文件中各个命令出现的顺序来逐个运行它们。使用批处理文件（也被称为批处理程序或脚本），可以简化日常或重复性任务。</p><h2 id="BAT实现些小功能"><a href="#BAT实现些小功能" class="headerlink" title="BAT实现些小功能"></a>BAT实现些小功能</h2><h3 id="echo-和"><a href="#echo-和" class="headerlink" title="echo 和 @"></a>echo 和 @</h3><p>Cmd中的echo命令通过<code>echo /?</code>可以看介绍。</p><p>用于显示消息：<code>ECHO [message]</code>，（注意：echo不会去message引号）<br>启用或关闭命令回显：<code>ECHO [ON | OFF]</code>，（提一句：Cmd命令不区分大小写）</p><p>还有个关回显的方式：<code>@</code>表示本条命令不回显，仅在本条命令生效，优先级高于echo off。</p><h3 id="设变量"><a href="#设变量" class="headerlink" title="设变量"></a>设变量</h3><p>和Shell不同，Cmd中设变量需要加set，如<code>set VariableName=100</code>，等号两边不应有空格。设好变量后可用<code>echo %VariableName%</code>来打印刚才设置的变量。</p><p>如果要看系统所有的环境变量可以在Cmd中输入<code>set</code>就会打印到终端里，如果要保存到文件中可以<code>set &gt; Variable.txt</code>，<code>&gt;</code>和Shell一样，可以将左边命令输出重定向到指定文件，用<code>&gt;&gt;</code>就是追加写入。</p><p>系统中有很多自带的环境变量，下面几个是我感觉可能会用到的：</p><ul><li>%CD% 本地 返回当前目录字符串。</li><li>%USERNAME% 本地 返回当前登录的用户的名称。</li><li>%DATE% 系统 返回当前日期。使用与 date /t 命令相同的格式。</li><li>%ERRORLEVEL% 系统 返回上一条命令的错误代码。（通常用非零值表示错误）</li><li>%PATH% 系统 指定可执行文件的搜索路径。（有多个版本Gcc工具链可以通过设这个环境变量再指定，越在前优先级越高，可以把要用的加在前面）</li><li>%WINDIR% 系统 返回操作系统目录的位置。</li></ul><p>值得思考：变量来自哪里？不同地方定义的环境变量哪个优先级高？</p><h3 id="发现异常"><a href="#发现异常" class="headerlink" title="发现异常"></a>发现异常</h3><p>用上面提到的ERRORLEVEL环境变量可以知道上一次命令的返回结果，成功为0（默认值），失败非0。可以根据这个变量去做命令执行失败的处理。</p><h3 id="变长参数解析"><a href="#变长参数解析" class="headerlink" title="变长参数解析"></a>变长参数解析</h3><p>配合shift命令，将参数一个个解析。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> Usage: build.bat [--relese ^&lt;LOG_FILE^&gt;] [make target ...]</span><br><span class="line">:parse-args</span><br><span class="line"><span class="comment">rem 检测到没有下个参数，跳到编译</span></span><br><span class="line"><span class="keyword">if</span> &quot;%<span class="number">1</span>&quot;==&quot;&quot; ( <span class="keyword">goto</span> pre-build1 )</span><br><span class="line"><span class="keyword">if</span> &quot;%<span class="number">1</span>&quot;==&quot;--release&quot; (</span><br><span class="line"><span class="comment">    rem 解析到--release，还需再读一个后面跟的文件地址</span></span><br><span class="line">    <span class="built_in">set</span> RELEASE_FLAG=<span class="number">1</span></span><br><span class="line"><span class="built_in">set</span> SVN_LOG_FILE=<span class="variable">%RUN_PATH%</span>\%<span class="number">2</span></span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line"><span class="comment">    rem 其他参数都归自定义make参数</span></span><br><span class="line">    <span class="built_in">set</span> CUSTOM_MAKE_ARGS=<span class="variable">%CUSTOM_MAKE_ARGS%</span> %<span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">rem shift更改参数的位置</span></span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="keyword">goto</span> parse-args</span><br></pre></td></tr></table></figure><h3 id="传地址参数"><a href="#传地址参数" class="headerlink" title="传地址参数"></a>传地址参数</h3><p>脚本经常会遇到传地址参数，比如我的–release参数后面就要跟一个LOG_FILE的参数，需要传递文件路径。</p><p>传进来的相对参数正常是基于脚本启动路径，脚本里如果有切换执行路径，在使用地址参数时要加这个路径偏移。可以在执行脚本刚开始记录启动路径（绝对路径）<code>set RUN_PATH=%cd%</code>，后面在解析文件参数时加上启动路径<code>set SVN_LOG_FILE=%RUN_PATH%\%2</code>。</p><p>这样可以解决相对路径的传参问题，但是绝对路径无法解决，Cmd脚本如何识别传入的路径是相对or绝对？</p><p>在Windows中，绝对路径组成有：<code>驱动器号:\目录名\目录名\...\文件名</code>，可以通过识别有无<code>:</code>来判断是否为绝对路径。</p><h3 id="丢弃异常输出"><a href="#丢弃异常输出" class="headerlink" title="丢弃异常输出"></a>丢弃异常输出</h3><p>在Windows命令行脚本中，<code>&gt; nul</code> 是一种将命令输出重定向到空设备的方式。这通常用于抑制命令的输出，使其不显示在命令行窗口中。通常在删除时不报找不到文件错可以加，让异常输出不显示使用 <code>2 &gt; nul</code>。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> FILE_PATH=%<span class="number">1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%FILE_PATH%</span> | <span class="built_in">find</span> &quot;:&quot; &gt; <span class="built_in">nul</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">errorlevel</span> <span class="number">1</span> (</span><br><span class="line">    <span class="built_in">echo</span> 传入的路径为相对路径</span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">echo</span> 传入的路径为绝对路径</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="延迟拓展"><a href="#延迟拓展" class="headerlink" title="延迟拓展"></a>延迟拓展</h3><p>在cmd执行命令前会对脚本进行预处理，其中有一个过程是变量识别过程，在这个过程中，如果有两个%括起来的如<code>%value%</code>类似这样的变量，就会对其进行识别，并且查找这个变量对应的值，再而将值替换掉这个变量，这个替换值的过程，就叫做<strong>变量扩展</strong>，然后再执行命令。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"><span class="built_in">set</span> a=<span class="number">4</span></span><br><span class="line"><span class="built_in">set</span> a=<span class="number">5</span>&amp; <span class="built_in">echo</span> <span class="variable">%a%</span></span><br></pre></td></tr></table></figure><p>Cmd脚本会逐行预处理（用到括号会被当成一行，开<code>@echo on</code>可以看到），上面脚本在预处理时第三行会被变量拓展为<code>set a=5&amp; echo 4</code>，所以就算设置了a=5，打印内容已经被拓展了还是4。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> on</span><br><span class="line"><span class="built_in">setlocal</span> enabledelayedexpansion</span><br><span class="line"><span class="built_in">set</span> a=<span class="number">4</span></span><br><span class="line"><span class="built_in">set</span> a=<span class="number">5</span>&amp; <span class="built_in">echo</span> <span class="variable">!a!</span></span><br></pre></td></tr></table></figure><p>设置本地开启延时拓展：<code>setlocal enabledelayedexpansion</code>，设置本地关闭延时拓展：<code>setlocal disabledelayedexpansion</code>。这两个也相当于命令，<strong>需要运行到才会起作用</strong>。如果不开启延时拓展，使用到的延时拓展变量不会被拓展echo的内容为<code>!a!</code>。</p><p>开启延时拓展后，要被延时拓展的变量要用一对叹号<code>!value!</code>括起来，上面脚本在预处理后为<code>set a=5&amp;echo !a!</code>，在执行echo时才会解析变量a，打印的内容是5。</p><p>小技巧：可以开启延时拓展后使用<code>echo %value% !value!</code>看是否一致，如果一致可以不使用延时拓展该变量（最好还是理解原理）。</p><h3 id="调子程序"><a href="#调子程序" class="headerlink" title="调子程序"></a>调子程序</h3><p>子程序写法：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:getSum</span><br><span class="line"><span class="built_in">set</span> /a sum+=%<span class="number">1</span></span><br><span class="line"><span class="built_in">shift</span> /<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> &quot;%<span class="number">1</span>&quot;==&quot;&quot; <span class="keyword">goto</span> getSum</span><br><span class="line"><span class="keyword">goto</span> :eof</span><br></pre></td></tr></table></figure><p>调用方法：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> sum=<span class="number">0</span></span><br><span class="line"><span class="function">call:<span class="title">getSum</span> 1 2 3</span></span><br><span class="line"><span class="function"><span class="title">echo</span> %<span class="title">sum</span>%</span></span><br></pre></td></tr></table></figure><p>输出：<code>6</code></p><p>脚本不用像C一样先声明后使用，子程序可以写在调用的下方。</p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>语法格式：<code>if [not] &lt;条件&gt; (执行语句)</code>，注意：执行语句如果用括号，左括号和条件间必须有个空格。</p><p>多个条件与：<code>if [not] &lt;条件&gt; [if [not] &lt;条件&gt; ...] (执行语句)</code></p><p>多个条件或（写法比较不优雅）：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [<span class="keyword">not</span>] &lt;条件&gt; <span class="keyword">goto</span> <span class="keyword">do</span>-something</span><br><span class="line"><span class="keyword">if</span> [<span class="keyword">not</span>] &lt;条件&gt; <span class="keyword">goto</span> <span class="keyword">do</span>-something</span><br><span class="line">...</span><br><span class="line">:<span class="keyword">do</span>-something</span><br><span class="line">执行语句</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>Windows bat脚本的for语句基本形态如下：<br>在cmd窗口中：<code>for %I in (command1) do command2</code><br>在批处理文件中：<code>for %%I in (command1) do command2</code></p><p>for、in、do是for语句的关键字，它们三个缺一不可。%%I是for语句中对形式变量的引用，即使变量I在do后的语句中没有参与语句的执行，也是必须出现的。in之后，do之前的括号不能省略。command1表示字符串或变量，command2表示字符串、变量或命令语句。具体使用可以看下面的BAT解析 MarkdownTable。</p><h3 id="脱引号（转载）"><a href="#脱引号（转载）" class="headerlink" title="脱引号（转载）"></a>脱引号（<a href="https://www.cnblogs.com/dongzhiquan/p/3594614.html">转载</a>）</h3><p>很多情况下，我们需要脱除一个字符串中可能会存在的引号，然后在加上自己的引号使其中的特殊字符（命令连接符&amp; 、| 、&amp;&amp;、||，命令行参数界定符Space 、tab 、 ; 、= ，字符化转义符^ 、” ，变量化转义符%等）字符化，失去特定的作用，而作为普通的字符成为字符串的一个组成部分。</p><p>如果字符串存在于命令行参数<code>%1</code>中，可以使用<code>%~1</code>脱去第一对外侧引号，如果没有外侧引号则字符串不变。</p><p>如果字符串存在于for替代变量<code>%%i</code>中，可以使用<code>%%~i</code>脱去第一对外侧引号，如果没有外侧引号则字符串不变。</p><p>如果字符串存在于环境变量<code>%temp%</code>中，可以使用<code>%temp:&quot;=%</code>脱去其中所有的引号，如果没有引号则字符串不变。</p><h2 id="BAT解析-MarkdownTable"><a href="#BAT解析-MarkdownTable" class="headerlink" title="BAT解析 MarkdownTable"></a>BAT解析 MarkdownTable</h2><p>解析 MarkdownTable 子程序：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">::==============================Parse Markdown Function============================</span><br><span class="line"><span class="comment">rem 定位Markdown中相应标题所在起始行和结束行</span></span><br><span class="line">:locateMarkdownTitleFunc</span><br><span class="line"><span class="built_in">echo</span> Entering Function %<span class="number">0</span></span><br><span class="line"><span class="built_in">echo</span> inFileName %<span class="number">1</span></span><br><span class="line"><span class="comment">rem titleName需加引号</span></span><br><span class="line"><span class="built_in">echo</span> titleName %<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> startLineNum=</span><br><span class="line"><span class="built_in">set</span> endLineNum=</span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rem 查找所有#开头的标题行</span></span><br><span class="line"><span class="keyword">for</span> /F &quot;tokens=*&quot; <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;<span class="built_in">findstr</span> /i /n &quot;^#&quot; %<span class="number">1</span>&#x27;) <span class="keyword">do</span> (</span><br><span class="line"><span class="built_in">set</span> &quot;line=<span class="variable">%%i</span>&quot;</span><br><span class="line"><span class="comment">rem 解析标题行的行号和内容</span></span><br><span class="line"><span class="keyword">for</span> /F &quot;tokens=<span class="number">1</span>* delims=:&quot; <span class="variable">%%j</span> <span class="keyword">in</span> (&quot;<span class="variable">!line!</span>&quot;) <span class="keyword">do</span> (</span><br><span class="line"><span class="built_in">set</span> linenum=<span class="variable">%%j</span></span><br><span class="line"><span class="built_in">set</span> &quot;linestr=<span class="variable">%%k</span>&quot;</span><br><span class="line"><span class="comment">rem 已有起始行 没有结束行，设置结束行</span></span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">!startLineNum!</span>&quot; <span class="keyword">neq</span> &quot;&quot; <span class="keyword">if</span> &quot;<span class="variable">!endLineNum!</span>&quot; <span class="keyword">equ</span> &quot;&quot; (</span><br><span class="line"><span class="built_in">set</span> endLineNum=<span class="variable">!linenum!</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">rem 去标题内容首部#和空格</span></span><br><span class="line"><span class="keyword">for</span> /F &quot;tokens=* delims=#&quot; <span class="variable">%%a</span> <span class="keyword">in</span> (&quot;<span class="variable">!linestr!</span>&quot;) <span class="keyword">do</span> <span class="built_in">set</span> &quot;linestr=<span class="variable">%%a</span>&quot;</span><br><span class="line"><span class="keyword">for</span> /F &quot;tokens=* delims= &quot; <span class="variable">%%a</span> <span class="keyword">in</span> (&quot;<span class="variable">!linestr!</span>&quot;) <span class="keyword">do</span> <span class="built_in">set</span> &quot;linestr=<span class="variable">%%a</span>&quot;</span><br><span class="line"><span class="comment">rem 标题名匹配 没有起始行，设置起始行（多个匹配使用第一个）</span></span><br><span class="line"><span class="keyword">if</span> /i &quot;<span class="variable">!linestr!</span>&quot; <span class="keyword">equ</span> %<span class="number">2</span> <span class="keyword">if</span> &quot;<span class="variable">!startLineNum!</span>&quot; <span class="keyword">equ</span> &quot;&quot; (</span><br><span class="line"><span class="built_in">set</span> startLineNum=<span class="variable">!linenum!</span></span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line"><span class="comment">rem 有起始行没有结束行则取文件总行数+1作为结束行</span></span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%startLineNum%</span>&quot; <span class="keyword">neq</span> &quot;&quot; <span class="keyword">if</span> &quot;<span class="variable">!endLineNum!</span>&quot; <span class="keyword">equ</span> &quot;&quot; (</span><br><span class="line"><span class="keyword">for</span> /F <span class="variable">%%a</span> <span class="keyword">in</span> (&#x27;<span class="built_in">find</span> /c /v &quot;&quot; ^&lt; %<span class="number">1</span>&#x27;) <span class="keyword">do</span> <span class="built_in">set</span> /a endLineNum=<span class="variable">%%a</span>+<span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">echo</span> Leaving Function %<span class="number">0</span></span><br><span class="line"><span class="function">goto:<span class="title">eof</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 解析README中的Repo Link表格，设环境变量</span></span></span><br><span class="line"><span class="function">:<span class="title">parseRepoLinkFunc</span></span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">Entering</span> <span class="title">Function</span> %0</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">inFileName</span> %1</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">argsSuffix</span> %2</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 定位Markdown中Repo Link标题所在起始行和结束行</span></span></span><br><span class="line"><span class="function"><span class="title">call:locateMarkdownTitleFunc</span> %1 &quot;<span class="title">Repo</span> <span class="title">link</span>&quot;</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">RepoLinkStartLineNum</span>=%<span class="title">startLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">RepoLinkEndLineNum</span>=%<span class="title">endLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">RepoLinkStartLineNum</span>=%<span class="title">RepoLinkStartLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">RepoLinkEndLineNum</span>=%<span class="title">RepoLinkEndLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 解析svn配置行</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1,2,3,4 <span class="title">delims</span>=^| &quot; %%<span class="title">i</span> <span class="title">in</span> (&#x27;<span class="title">findstr</span> /<span class="title">i</span> /<span class="title">n</span> &quot;<span class="title">svn</span>.*<span class="title">http</span>&quot; %1&#x27;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function"><span class="comment">rem 解析行号</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1* <span class="title">delims</span>=:&quot; %%<span class="title">a</span> <span class="title">in</span> (&quot;%%<span class="title">i</span>&quot;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">linenum</span>=%%<span class="title">a</span></span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"><span class="comment">rem 行号大于标题开始行 且 小于标题结束行 则解析，设环境变量</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> !<span class="title">linenum</span>! <span class="title">gtr</span> %<span class="title">RepoLinkStartLineNum</span>% <span class="title">if</span> !<span class="title">linenum</span>! <span class="title">lss</span> %<span class="title">RepoLinkEndLineNum</span>% (</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">SvnUrlMd_</span>%2=%%<span class="title">l</span></span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 解析git配置行</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1,2,3,4 <span class="title">delims</span>=^| &quot; %%<span class="title">i</span> <span class="title">in</span> (&#x27;<span class="title">findstr</span> /<span class="title">i</span> /<span class="title">n</span> &quot;<span class="title">git</span>.*<span class="title">http</span>&quot; %1&#x27;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function"><span class="comment">rem 解析行号</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1* <span class="title">delims</span>=:&quot; %%<span class="title">a</span> <span class="title">in</span> (&quot;%%<span class="title">i</span>&quot;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">linenum</span>=%%<span class="title">a</span></span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"><span class="comment">rem 行号大于标题开始行 且 小于标题结束行 则解析，设环境变量</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> !<span class="title">linenum</span>! <span class="title">gtr</span> %<span class="title">RepoLinkStartLineNum</span>% <span class="title">if</span> !<span class="title">linenum</span>! <span class="title">lss</span> %<span class="title">RepoLinkEndLineNum</span>% (</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">GitUrlMd_</span>%2=%%<span class="title">l</span></span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">BranchMd_</span>%2=%%<span class="title">k</span></span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">Leaving</span> <span class="title">Function</span> %0</span></span><br><span class="line"><span class="function"><span class="title">goto:eof</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 解析README中的Config表格，输出到文件</span></span></span><br><span class="line"><span class="function">:<span class="title">parseConfigFunc</span></span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">Entering</span> <span class="title">Function</span> %0</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">inFileName</span> %1</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">outFileName</span> %2</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 清空outFile</span></span></span><br><span class="line"><span class="function"><span class="title">del</span> %2 2&gt;<span class="title">nul</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 定位Markdown中Config标题所在起始行和结束行</span></span></span><br><span class="line"><span class="function"><span class="title">call:locateMarkdownTitleFunc</span> %1 &quot;<span class="title">Config</span>&quot;</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">ConfigStartLineNum</span>=%<span class="title">startLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">ConfigEndLineNum</span>=%<span class="title">endLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">ConfigStartLineNum</span>=%<span class="title">ConfigStartLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">ConfigEndLineNum</span>=%<span class="title">ConfigEndLineNum</span>%</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 查找Config标题中Config Name所在行</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=*&quot; %%<span class="title">i</span> <span class="title">in</span> (&#x27;<span class="title">findstr</span> /<span class="title">i</span> /<span class="title">n</span> /<span class="title">c</span>:&quot;<span class="title">Config</span> <span class="title">Name</span>&quot; %1&#x27;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function"><span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1* <span class="title">delims</span>=:&quot; %%<span class="title">a</span> <span class="title">in</span> (&quot;%%<span class="title">i</span>&quot;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">linenum</span>=%%<span class="title">a</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> !<span class="title">linenum</span>! <span class="title">gtr</span> %<span class="title">ConfigStartLineNum</span>% <span class="title">if</span> !<span class="title">linenum</span>! <span class="title">lss</span> %<span class="title">ConfigEndLineNum</span>% (</span></span><br><span class="line"><span class="function"><span class="comment">rem 设置Config Table内容开始行</span></span></span><br><span class="line"><span class="function"><span class="title">set</span> /<span class="title">a</span> <span class="title">tableStart</span>=!<span class="title">linenum</span>!+2</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem 逐行遍历Markdown文件</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1,2,3,4 <span class="title">delims</span>=^| &quot; %%<span class="title">i</span> <span class="title">in</span> (&#x27;<span class="title">findstr</span> /<span class="title">i</span> /<span class="title">n</span> &quot;^&quot; %1&#x27;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function"><span class="comment">rem 解析行号</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> /<span class="title">F</span> &quot;<span class="title">tokens</span>=1* <span class="title">delims</span>=:&quot; %%<span class="title">a</span> <span class="title">in</span> (&quot;%%<span class="title">i</span>&quot;) <span class="title">do</span> (</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">linenum</span>=%%<span class="title">a</span></span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function"><span class="comment">rem 行号大于等于表格内容开始行则解析</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> !<span class="title">linenum</span>! <span class="title">geq</span> %<span class="title">tableStart</span>% (</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">configName</span>=%%<span class="title">j</span></span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">configValue</span>=%%<span class="title">k</span></span></span><br><span class="line"><span class="function"><span class="comment">rem 检测为空判定为表格结束，退出函数</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> &quot;!<span class="title">configName</span>!&quot; <span class="title">equ</span> &quot;&quot; ( <span class="title">goto</span> <span class="title">leaveParseConfig</span> )</span></span><br><span class="line"><span class="function"><span class="title">if</span> &quot;!<span class="title">configValue</span>!&quot; <span class="title">equ</span> &quot;&quot; ( <span class="title">goto</span> <span class="title">leaveParseConfig</span> )</span></span><br><span class="line"><span class="function"><span class="comment">rem 存到输出文件</span></span></span><br><span class="line"><span class="function"><span class="title">echo</span> !<span class="title">configName</span>!=!<span class="title">configValue</span>!&gt;&gt;%2</span></span><br><span class="line"><span class="function"><span class="title">echo</span> !<span class="title">configName</span>!=!<span class="title">configValue</span>!</span></span><br><span class="line"><span class="function"><span class="comment">rem 是PostSyncJob 则 设环境变量</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> &quot;!<span class="title">configName</span>!&quot; <span class="title">equ</span> &quot;<span class="title">PostSyncJob</span>&quot; (</span></span><br><span class="line"><span class="function"><span class="title">set</span> <span class="title">PostSyncJob</span>=!<span class="title">configValue</span>!</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function">:<span class="title">leaveParseConfig</span></span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">Leaving</span> <span class="title">Function</span> %0</span></span><br><span class="line"><span class="function"><span class="title">goto:eof</span></span></span><br><span class="line"><span class="function">::=================================================================================</span></span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 进入git仓库, 解析README.<span class="built_in">md</span>文件</span><br><span class="line"><span class="function">call:<span class="title">parseRepoLinkFunc</span> <span class="title">repo</span>\<span class="title">repo_git</span>\<span class="title">README.md</span> <span class="title">Git</span></span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">GitRepo</span> <span class="title">README.md</span> <span class="title">Info</span>:</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">SvnUrlMd_Git</span> = %<span class="title">SvnUrlMd_Git</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">GitUrlMd_Git</span> = %<span class="title">GitUrlMd_Git</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">BranchMd_Git</span> = %<span class="title">BranchMd_Git</span>%</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">echo</span> 进入<span class="title">svn</span>仓库, 解析<span class="title">README.md</span>文件</span></span><br><span class="line"><span class="function"><span class="title">call:parseRepoLinkFunc</span> <span class="title">repo</span>\<span class="title">repo_svn</span>\<span class="title">README.md</span> <span class="title">Svn</span></span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">SvnRepo</span> <span class="title">README.md</span> <span class="title">Info</span>:</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">SvnUrlMd_Svn</span> = %<span class="title">SvnUrlMd_Svn</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">GitUrlMd_Svn</span> = %<span class="title">GitUrlMd_Svn</span>%</span></span><br><span class="line"><span class="function"><span class="title">echo</span> <span class="title">BranchMd_Svn</span> = %<span class="title">BranchMd_Svn</span>%</span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="comment"><span class="function">rem Config写入README_Config.txt</span></span></span><br><span class="line"><span class="function"><span class="title">call:parseConfigFunc</span> <span class="title">repo</span>\<span class="title">repo_git</span>\<span class="title">README.md</span> <span class="title">README_Config.txt</span></span></span><br></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>这几天边写边学BAT脚本，刚接触BAT感觉和Python比起来不够可读和易用，和Shell比起来命令功能不强大。BAT的编程能力与C语言等编程语句比起来是十分有限的，也是十分不规范的。批处理的程序语句就是一条条的DOS命令（包括内部命令和外部命令），而批处理的能力主要取决于你所使用的命令，但在Windows平台上命令确实不如Linux上的好用，在Windows上装MinGW使用Linux上的命令又涉及到了字符转义和编码不同，bat中调Linux下的命令会非常乱，不推荐我这种菜鸡使用，不如直接全部上Linux。</p><h2 id="好东西"><a href="#好东西" class="headerlink" title="好东西"></a>好东西</h2><p>Linux下命令有很多，不常用或者首次用比较陌生，好在可以使用tldr这个命令做提示，比命令自带的帮助文档精简。发现一个网页版的tldr，数据库还经常更新，<a href="https://tldr.inbrowser.app/">tldr-inbrowser</a>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 脚本 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言传递的参数还能这样解析</title>
      <link href="/2023/12/27/231227-argv/"/>
      <url>/2023/12/27/231227-argv/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以前写脚本的时候用到过传参：python最简单，直接<code>import argparse</code>。shell中使用<code>$#</code>表示传递到脚本的参数个数，用<code>$*</code>表示以一个单字符串显示所有向脚本传递的参数，如”$*“用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。bat脚本传参和shell类似，<code>%#</code>表示传递到脚本的参数个数，<code>%*</code>表示参数字符串，*可以是数字。在C语言中可以使用<code>getopt</code>，它是一个标准的C库函数，用于解析命令行参数。它可以帮助你处理短选项（-h）和长选项（–help）。</p><p>今天学习 <a href="https://github.com/dbry/adpcm-xq">adpcm-xq</a> 看到一个C代码直接用指针操作argv，如*++*argv，能差不多看懂，现在回家再来理一下。</p><h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(argc, argv)</span> <span class="type">int</span> argc; <span class="type">char</span> **argv;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lookahead = <span class="number">3</span>, flags = ADPCM_FLAG_NOISE_SHAPING, blocksize_pow2 = <span class="number">0</span>, overwrite = <span class="number">0</span>, asked_help = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *infilename = <span class="literal">NULL</span>, *outfilename = <span class="literal">NULL</span>;</span><br><span class="line">    FILE *outfile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if the name of the executable ends in &quot;encoder&quot; or &quot;decoder&quot;, just do that function</span></span><br><span class="line">    encode_only = argc &amp;&amp; <span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;encoder&quot;</span>) &amp;&amp; <span class="built_in">strlen</span> (<span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;encoder&quot;</span>)) == <span class="built_in">strlen</span> (<span class="string">&quot;encoder&quot;</span>);</span><br><span class="line">    decode_only = argc &amp;&amp; <span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;decoder&quot;</span>) &amp;&amp; <span class="built_in">strlen</span> (<span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;decoder&quot;</span>)) == <span class="built_in">strlen</span> (<span class="string">&quot;decoder&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loop through command-line arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (_WIN32)</span></span><br><span class="line">        <span class="keyword">if</span> ((**++argv == <span class="string">&#x27;-&#x27;</span> || **argv == <span class="string">&#x27;/&#x27;</span>) &amp;&amp; (*argv)[<span class="number">1</span>])</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> ((**++argv == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (*argv)[<span class="number">1</span>])</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">while</span> (*++*argv)</span><br><span class="line">                <span class="keyword">switch</span> (**argv) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">                        lookahead = **argv - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                        blocksize_pow2 = strtol (++*argv, argv, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (blocksize_pow2 &lt; <span class="number">8</span> || blocksize_pow2 &gt; <span class="number">15</span>) &#123;</span><br><span class="line">                            <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nblock size power must be 8 to 15!\n&quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        --*argv;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">                        decode_only = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                        encode_only = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">                        flags &amp;= ~ADPCM_FLAG_NOISE_SHAPING;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                        asked_help = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">                        verbosity = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">                        flags |= ADPCM_FLAG_RAW_OUTPUT;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                        verbosity = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>:</span><br><span class="line">                        overwrite = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nillegal option: %c !\n&quot;</span>, **argv);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!infilename) &#123;</span><br><span class="line">            infilename = <span class="built_in">malloc</span> (<span class="built_in">strlen</span> (*argv) + <span class="number">10</span>);</span><br><span class="line">            <span class="built_in">strcpy</span> (infilename, *argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!outfilename) &#123;</span><br><span class="line">            outfilename = <span class="built_in">malloc</span> (<span class="built_in">strlen</span> (*argv) + <span class="number">10</span>);</span><br><span class="line">            <span class="built_in">strcpy</span> (outfilename, *argv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nextra unknown argument: %s !\n&quot;</span>, *argv);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verbosity &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;%s&quot;</span>, sign_on);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!outfilename || asked_help) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%s&quot;</span>, usage);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span> (infilename, outfilename)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;can&#x27;t overwrite input file (specify different/new output file name)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!overwrite &amp;&amp; (outfile = fopen (outfilename, <span class="string">&quot;r&quot;</span>))) &#123;</span><br><span class="line">        fclose (outfile);</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;output file \&quot;%s\&quot; exists (use -y to overwrite)\n&quot;</span>, outfilename);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> adpcm_converter (infilename, outfilename, flags, blocksize_pow2, lookahead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="argc-argv-知识"><a href="#argc-argv-知识" class="headerlink" title="argc argv 知识"></a>argc argv 知识</h2><p>C语言中的<code>argc</code>和<code>argv</code>通常用于处理命令行参数。在C程序中，<code>main</code>函数可以接受两个参数，分别是<code>argc</code>（参数计数）和<code>argv</code>（参数向量）。</p><ul><li><code>argc</code> 表示命令行参数的数量（包含命令），它是一个整数。</li><li><code>argv</code> 是一个指向字符指针数组的指针，每个指针指向一个字符串，这些字符串是命令行参数的实际内容。<code>argv[0]</code>通常是程序的名称，而<code>argv[1]</code>、<code>argv[2]</code>等则是传递给程序的参数。</li></ul><p>下面是一个简单的例子，展示了如何在C语言中使用<code>argc</code>和<code>argv</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of arguments: %d\n&quot;</span>, argc);</span><br><span class="line">    <span class="comment">// 输出所有命令行参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Argument %d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设你将上述代码保存在一个名为 <code>example.c</code> 的文件中，然后通过命令行编译并运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc example.c -o example</span><br><span class="line">./example arg1 arg2 arg3</span><br></pre></td></tr></table></figure><p>这将输出：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CopyNumber of arguments:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">Argument 0:</span> <span class="string">./example</span></span><br><span class="line"><span class="attr">Argument 1:</span> <span class="string">arg1</span></span><br><span class="line"><span class="attr">Argument 2:</span> <span class="string">arg2</span></span><br><span class="line"><span class="attr">Argument 3:</span> <span class="string">arg3</span></span><br></pre></td></tr></table></figure><p>这里，<code>argc</code>是4，因为有四个参数（包括程序的名称），而<code>argv</code>包含这四个参数的字符串。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>接下来我将对代码片段中的argc argv相关代码的逐行分析：</p><h3 id="片段1"><a href="#片段1" class="headerlink" title="片段1"></a>片段1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if the name of the executable ends in &quot;encoder&quot; or &quot;decoder&quot;, just do that function</span></span><br><span class="line">encode_only = argc &amp;&amp; <span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;encoder&quot;</span>) &amp;&amp; <span class="built_in">strlen</span> (<span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;encoder&quot;</span>)) == <span class="built_in">strlen</span> (<span class="string">&quot;encoder&quot;</span>);</span><br><span class="line">decode_only = argc &amp;&amp; <span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;decoder&quot;</span>) &amp;&amp; <span class="built_in">strlen</span> (<span class="built_in">strstr</span> (argv [<span class="number">0</span>], <span class="string">&quot;decoder&quot;</span>)) == <span class="built_in">strlen</span> (<span class="string">&quot;decoder&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>argc</code>：传递给程序的命令行参数数量；<code>argv[0]</code>：可执行文件的名称（第一个命令行参数）。</p><p><code>char *strstr(const char *haystack, const char *needle);</code> 返回一个指向第一次出现 <code>needle</code> 的指针，如果未找到，则返回 <code>NULL</code>。</p><p><code>strlen</code>用于计算字符串的长度，即字符串中字符的个数，不包括字符串末尾的 null 终止符。</p><p>这段代码用于检查可执行文件的名称（从命令行参数 <code>argv[0]</code> 获取）是否以 “encoder” 或 “decoder” 结尾（出现字符通过<code>strstr</code>保证，结尾通过<code>strlen</code>保证）。它根据这些条件设置两个布尔变量 <code>encode_only</code> 和 <code>decode_only</code>。</p><h3 id="片段2"><a href="#片段2" class="headerlink" title="片段2"></a>片段2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 循环了 argc - 1 次，遍历完所有命令参数</span></span><br><span class="line">    <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (_WIN32)</span></span><br><span class="line">        <span class="comment">// argv首先自增，即指向下一个字符串，**argv是字符串的第一个字符，比较是否为&#x27;-&#x27;或&#x27;/&#x27;，</span></span><br><span class="line">        <span class="comment">// &amp;&amp; (*argv)[1]，且这个字符串存在第二个字符</span></span><br><span class="line">        <span class="keyword">if</span> ((**++argv == <span class="string">&#x27;-&#x27;</span> || **argv == <span class="string">&#x27;/&#x27;</span>) &amp;&amp; (*argv)[<span class="number">1</span>])</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">// argv首先自增，即指向下一个字符串，**argv是字符串的第一个字符，比较是否为&#x27;-&#x27;，</span></span><br><span class="line">        <span class="comment">// &amp;&amp; (*argv)[1]，且这个字符串存在第二个字符</span></span><br><span class="line">        <span class="keyword">if</span> ((**++argv == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (*argv)[<span class="number">1</span>])</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="comment">// argv是指针数组，*argv是指向的字符串，++*argv是增加偏移1字节，指向字符串下一个字符，</span></span><br><span class="line">            <span class="comment">// *++*argv就是下个字符，while (*++*argv)意思就是当下个字符不为结束符&#x27;\0&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> (*++*argv)</span><br><span class="line">                <span class="comment">// **argv是字符串中的一个字符，上一行用++让字符串*argv的指向+1，**argv就是当前指向的字符串字符</span></span><br><span class="line">                <span class="keyword">switch</span> (**argv) &#123;</span><br></pre></td></tr></table></figure><h3 id="片段3"><a href="#片段3" class="headerlink" title="片段3"></a>片段3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;5&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;6&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;7&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;8&#x27;</span>:</span><br><span class="line">    lookahead = **argv - <span class="string">&#x27;0&#x27;</span>;<span class="comment">// lookahead为数值，字符串转数值</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="片段4"><a href="#片段4" class="headerlink" title="片段4"></a>片段4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">    <span class="comment">// long strtol(const char *str, char **endptr, int base);</span></span><br><span class="line">    <span class="comment">// strtol 用于将字符串转换为长整型数（long）返回，str是要转换的字符串，base 10表示十进制，</span></span><br><span class="line">    <span class="comment">// endptr 如果不是 NULL，则它存储一个指向第一个无法转换的字符的指针，或者如果字符串为空，则指向 str 的开始，</span></span><br><span class="line">    <span class="comment">// 感觉这行代码endptr把 argv 传进去有风险，如果++*argv无法转换成long，argv则会被写</span></span><br><span class="line">    blocksize_pow2 = strtol (++*argv, argv, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (blocksize_pow2 &lt; <span class="number">8</span> || blocksize_pow2 &gt; <span class="number">15</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nblock size power must be 8 to 15!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 感觉这行可有可无，都要break了，接下来就是检查下个字符串了</span></span><br><span class="line">    --*argv;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h3 id="片段5"><a href="#片段5" class="headerlink" title="片段5"></a>片段5</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!infilename) &#123;</span><br><span class="line">    <span class="comment">// 先是把非&#x27;-&#x27;开头的参数赋给输入文件名字</span></span><br><span class="line">    infilename = <span class="built_in">malloc</span> (<span class="built_in">strlen</span> (*argv) + <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span> (infilename, *argv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!outfilename) &#123;</span><br><span class="line">    <span class="comment">// 再是把非&#x27;-&#x27;开头的参数赋给输出文件名字</span></span><br><span class="line">    outfilename = <span class="built_in">malloc</span> (<span class="built_in">strlen</span> (*argv) + <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span> (outfilename, *argv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果参数有问题就输出stderr，打印出是哪个参数错误</span></span><br><span class="line">    <span class="built_in">fprintf</span> (<span class="built_in">stderr</span>, <span class="string">&quot;\nextra unknown argument: %s !\n&quot;</span>, *argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有用解析命令参数库的情况下，竟然可以这样实现一些常见的命令选项功能，佩服！</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>QAC代码静态分析软件使用记录</title>
      <link href="/2023/12/20/231220-qac%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/12/20/231220-qac%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><ol><li>安装<code>RepriseLicenseManager-15.0-Win-64Bit.exe</code>，授权服务器。</li><li>安装<code>Helix-QAC-2023.3-3943-Win.exe</code>，QAC软件。</li><li>安装<code>M3CM-5.3.0-Win.exe</code>、<code>ASCM-4.3.0-Win.exe</code>，规则包。</li><li><code>Helix-QAC-Dashboard-2023.3-Win.exe</code>，暂时还未使用过。</li></ol><h2 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h2><ol><li>RLM授权服务器，双击打开<code>rlm.exe</code>即可使用。</li><li>QAC首次打开需配置授权服务器地址和端口，我本机开的授权服务器，选择127.0.0.1:5055。</li><li>创建新工程（规则配置.rcf文件、分析配置.acf文件、编译器兼容模板.cct文件）。</li><li>同步，使用监控编译监测的方式同步用到的.c和.h文件。</li><li>工程属性-&gt;分析配置-&gt;分析工具<code>qac 11.3.0</code>的<code>-i</code>选项需要增加编译工具链中的头文件路径。</li><li>分析，没有Hard Error就成功了，有则说明配置还有问题。</li><li>生成报告，可以选择不同的报告生成，代码分析报告，MISRA报告等。</li></ol><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="示例工程分析问题"><a href="#示例工程分析问题" class="headerlink" title="示例工程分析问题"></a>示例工程分析问题</h3><p>问题现象：分析报错Parse Error，所有.c都有这个问题，看报错好像是解析乱码，错误指向代码的第一行。<br>解决措施：IT解密策略更新。</p><p>问题现象：分析报错CIP file invalid or missing，所有.cpp文件有这个问题。<br>解决措施：找QAC技术解决，回复：QAC未能自动执行脚本生成CIP文件，让我执行一个Python脚本手动生成CIP。<br>命令：<code>python -E &quot;%localappdata%\Perforce\Helix-QAC-2023.3\samples\sample_cgicc_diff-2023.3\prqa\configs\Initial\config\DATA\Helix_Generic_C++\Script\Helix_Generic_C++.py&quot; &quot;%localappdata%\Perforce\Helix-QAC-2023.3\samples\sample_cgicc_diff-2023.3\prqa\configs\Initial\config\Helix_Generic_C++.cct&quot;</code></p><h3 id="自己建工程同步问题"><a href="#自己建工程同步问题" class="headerlink" title="自己建工程同步问题"></a>自己建工程同步问题</h3><p>问题现象：同步时qac监控编译进程，执行.bat脚本调用make报错。<br>解决措施：找QAC技术解决，一顿尝试最后回复：make进程不在cct自动生成列表中，让我脚本直接调用编译器编译。<br>原本在工程Debug目录下执行make命令就可以编译程序，现在需要手动调编译器，这自己写脚本不写死人？最后把make的日志信息保存，写个Python脚本将<code>arm-none-eabi-</code>开头的行提取了出来，作为bat脚本编译工程，在bat脚本的开头设环境变量选择编译工具链，<code>Path C:\Yuntu\YuntuIDE\tools\bin;%Path%</code>。</p><p>问题现象：同步时勾选自动生成cct，报错。<br>解决措施：找QAC技术解决，回复：gcc属于开源编译器，无法自动生成cct，然后给我一个。</p><h3 id="自己建工程分析问题"><a href="#自己建工程分析问题" class="headerlink" title="自己建工程分析问题"></a>自己建工程分析问题</h3><p>问题现象：分析的时候报错，没有生成cct。<br>解决措施：将编译器兼容模块cct文件不要选择Auto_generate_C/C++，注意有两个C和C++的都不能选择自动生成。<br>C选择QAC技术给的arm-none-eabi-gcc_6.3.1的cct，C++技术没有给cct，要选择通用的Helix_Generic_C++的cct。</p><p>问题现象：分析的时候报错Parse Error，我还以为又是有啥IT解密策略不对，一看报错好像缺libc的头文件。<br>解决措施：工程属性-&gt;分析配置-&gt;分析工具<code>qac 11.3.0</code>的<code>-i</code>选项需要增加编译工具链中的头文件路径。<br>C:/Yuntu/YuntuIDE/tools/arm-none-eabi/include<br>C:/Yuntu/YuntuIDE/tools/lib/gcc/arm-none-eabi/10.3.1/include<br>C:/Yuntu/YuntuIDE/tools/lib/gcc/arm-none-eabi/10.3.1/include-fixed<br>添加以上三个路径后问题解决。</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>这种商业软件网上资料不多，出了问题要找技术支持，有些配置自己配不来，需要联系技术直接要个配好的包。售后技术支持每年还要交钱，换个平台、工具链可能必须要找技术支持，得交钱。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AUTOSAR Wdg Stack 架构</title>
      <link href="/2023/10/31/231031-wdg/"/>
      <url>/2023/10/31/231031-wdg/</url>
      
        <content type="html"><![CDATA[<h2 id="Wdg-功能"><a href="#Wdg-功能" class="headerlink" title="Wdg 功能"></a>Wdg 功能</h2><p>看门狗/Wdg模块是一个独立的定时器，它的作用是提供安全功能以确保软件按计划执行，并且CPU不会陷入无限循环或执行意外的代码。如果Wdg模块在一定时间内未被触发/刷新/喂狗，它将复位MCU。</p><p>看门狗功能对于关键安全系统是必须的，对于非关键安全系统也是很有必要的。</p><p>对于汽车上使用的诸多零部件，鉴于汽车环境的恶劣，各类ECU中的软件均有可能遭受如外部电磁干扰，高温等环境因素的影响，从而导致程序“跑飞”或者“死机”现象，此时如果有看门狗的存在，便可以主动触发系统复位机制保证能够再次正常使用。</p><h2 id="硬件看门狗"><a href="#硬件看门狗" class="headerlink" title="硬件看门狗"></a>硬件看门狗</h2><p>硬件看门狗依赖自身定时器来完成看门狗功能，俗称“硬狗”。常见的硬件看门狗比如MCU内部自带的看门狗、外部的独立看门狗。至于选用何种的硬件看门狗，取决于自身系统设计需要。</p><p>在使用硬件看门狗的时候需要特别考虑以下：</p><ul><li>该硬件看门狗的最大超时时间能否满足系统设计需求，如果该超时时间过小，就会导致整个系统的不稳定性，误触发看门狗。</li><li>该硬件看门狗是否可以进行关闭，对于关键安全系统，一般都要求看门狗一旦打开将不允许被关闭。</li><li>该硬件看门狗系统上电后默认处于开狗还是关狗状态，如果是默认开狗，那么对于软件而言，需考虑芯片上电后便要进行喂狗或者重置看门狗行为，同时设计一种在刷软件或者调试软件前的物理关狗动作。</li><li>该硬件看门狗是采用哪种方式进行喂狗，如通过GPIO，IIC或SPI等通讯方式来喂狗。</li></ul><p>UJA1078A手册：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/231031-wdg/sbc-ds1-en.png" alt="img"></p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/231031-wdg/sbc-ds1-cn.png" alt="img"></p><h2 id="软件看门狗"><a href="#软件看门狗" class="headerlink" title="软件看门狗"></a>软件看门狗</h2><p>属于通过软件定时器的方式来实现看门狗功能，俗称“软狗”。软件看门狗的时基本质上也需要依赖硬件定时器。</p><p>比如常见的用systick作时基，通过一个task运行软狗监控的定时器不断递减，其他task程序则是重置软狗定时器，如果软狗监控的某个定时器归零，那么此时可以便可以判断其他task并没有被正常的执行，此时便可以通过主动复位的方式来实现看门狗功能。</p><p>以上可实现软狗对<strong>多个task</strong>的监控，这是硬狗没有的功能。软狗除了实现硬狗timeout和window的两种模式，还可以实现其他模式，取决于软件，监控的花样更多。</p><p>一般而言，运行软狗的主任务的优先级不应设置比被监控的任务优先级低，所以软狗无法检测Hardfault中卡死的问题。<strong>软狗跟硬狗搭配在一起使用</strong>，可以解决硬狗监控模式单一、软狗执行优先级没被监控任务高的问题。</p><h2 id="AUTOSAR-Wdg-架构"><a href="#AUTOSAR-Wdg-架构" class="headerlink" title="AUTOSAR Wdg 架构"></a>AUTOSAR Wdg 架构</h2><h3 id="内部分层"><a href="#内部分层" class="headerlink" title="内部分层"></a>内部分层</h3><p><img src="https://gitee.com/hao0527/hao0527/raw/img/231031-wdg/wdg-stack.png" alt="img"></p><p>Watchdog Driver：用于实现针对硬件看门狗的寄存器操作与控制，可以分为MCU内部看门狗(Internal Watchdog)与外部看门狗(External Watchdog)，该外部看门狗可以通过GPIO、IIC或SPI来实现喂狗。</p><p>Watchdog Interface：其主要功能则是为了实现上层Watchdog Manager与底层Watchdog Driver的连接，当然其连接的底层Watchdog Driver可以存在多个。</p><p>Watchdog Manager：作为整个看门狗协议栈中的服务层，主体功能就是为了负责整个程序执行的正确性，并触发相应的硬件看门狗的喂狗动作，扮演了整个监控的核心角色。</p><h3 id="WdgM-依赖"><a href="#WdgM-依赖" class="headerlink" title="WdgM 依赖"></a>WdgM 依赖</h3><p><img src="https://gitee.com/hao0527/hao0527/raw/img/231031-wdg/wdgM-dep-en.png" alt="img"></p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/231031-wdg/wdgM-dep-cn.png" alt="img"></p><h2 id="AUTOSAR-Wdg-基础知识"><a href="#AUTOSAR-Wdg-基础知识" class="headerlink" title="AUTOSAR Wdg 基础知识"></a>AUTOSAR Wdg 基础知识</h2><h3 id="三种模式"><a href="#三种模式" class="headerlink" title="三种模式"></a>三种模式</h3><p>在AUTOSAR架构中，针对Watchdog Driver而言，定义了看门狗控制模式存在如下三种模式：</p><ul><li>Off Mode：表示看门狗关闭状态，对于关键安全系统，一般不能将其切换至Off状态，即一旦打开，将不能被关闭。</li><li>Slow Mode：表示看门狗的一个长时间喂狗窗口，该模式一般用于系统启动初始化过程中。</li><li>Fast Mode：表示看门狗的正常喂狗模式，该模式运用在系统正常运行的过程中。</li></ul><h2 id="AUTOSAR-Wdg-各层功能"><a href="#AUTOSAR-Wdg-各层功能" class="headerlink" title="AUTOSAR Wdg 各层功能"></a>AUTOSAR Wdg 各层功能</h2><h3 id="Wdg"><a href="#Wdg" class="headerlink" title="Wdg"></a>Wdg</h3><p>Wdg通常有两种，一种是芯片内部自带的片内看门狗；还有一种是在芯片外部通过SPI这种接口连接的片外看门狗。MCAL只负责第一种片内看门狗，片内看门狗的特点是Wdg模块是直接访问相关硬件寄存器。片外看门狗属于板级设备抽象层负责，通常需要使用MCAL提供的其他模块（比如SPI等）来访问/控制外扩看门狗芯片，这种不能直接访问硬件寄存器。</p><p>部分flash不能在写的时候读取，所以该模块代码可以在RAM里面运行。比如在刷写Flash时，Wdg模块可能作为二进制文件里面的一部分在RAM上运行。（到底哪些部分需要放RAM？）</p><h4 id="Wdg-API"><a href="#Wdg-API" class="headerlink" title="Wdg API"></a>Wdg API</h4><p>Wdg 驱动层，主要接口就三个，调用方式如下图：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/231031-wdg/wdg-1.png" alt="img"></p><ul><li>wdg初始化：通过EcuM模块调用函数Wdg_Init来完成Watchdog的初始化配置。</li><li>触发wdg喂狗：通过WdgM模块调用WdgIf模块提供的函数WdgIf_SetTriggerCondition来触发底层驱动进行喂狗（不是wdg真正的喂狗操作），并设置下次看门狗timeout时间。</li><li>改变wdg模式：通过WdgM模块调用WdgIf模块提供的函数WdgIf_SetMode来实现看门狗模式的改变。</li></ul><h4 id="喂狗"><a href="#喂狗" class="headerlink" title="喂狗"></a>喂狗</h4><p>在AUTOSAR之前的版本中，看门狗服务是<strong>由上层软件来调用</strong>，会导致一些问题：</p><ol><li>很难保证针对窗口式看门狗严格的时间约束。新版对这部分做了优化，优化的基本思想是将<strong>用于维护看门狗硬件时序的服务与逻辑控制分开</strong>，触发看门狗的时基可以通过系统时钟（systick）来提供，而控制看门狗硬件的程序可直接在硬件定时器的中断函数里面实现，这样可确保满足窗口式看门狗的喂狗时间准确。</li><li>很难处理了快和慢两种模式。Wdg模块3种模式其中两种是Slow，Fast模式。很多时候应用层可能并不需要那么严格的时间监控，可能秒级的周期即可。但由于喂狗周期都是固定的且比较短，应用层不断去喂狗会导致性能下降，而且需要到处穿插喂狗函数。</li><li>应用软件频繁修改硬狗寄存器不安全。现在AUTOSAR实现方式，应用层调用喂狗函数（Wdg_SetTriggerCondition）并不是直接去操作硬件看门狗寄存器的，而是去喂软狗。<strong>真正喂硬狗靠硬件定时器</strong>，在定时器中断回调中判断软狗没问题才去操作硬狗寄存器。</li></ol><p>看门狗驱动程序和硬狗操作之间的调用方式如下图：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/231031-wdg/wdg-2.png" alt="img"></p><h3 id="WdgIf"><a href="#WdgIf" class="headerlink" title="WdgIf"></a>WdgIf</h3><p>和NvM下的MemIf功能相同，可以通过DeviceIndex区分要调用哪个Wdg Driver，可以用宏或函数实现，接口如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Std_ReturnType <span class="title function_">WdgIf_SetMode</span><span class="params">(uint8 DeviceIndex, WdgIf_ModeType WdgMode)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">WdgIf_SetTriggerCondition</span><span class="params">(uint8 DeviceIndex, uint16 Timeout)</span>;</span><br></pre></td></tr></table></figure><h3 id="WdgM"><a href="#WdgM" class="headerlink" title="WdgM"></a>WdgM</h3><p>Watchdog Manager可以理解为一种应用层软狗机制，该软件机制监控的对象被称为<strong>监控实体</strong>（SupervisedEntity, SE），通过在每个监控实体中打上对应的<strong>检查点</strong>（Checkpoint, CP）监控程序是否正常。</p><p>WdgM中可以创建一个或多个SE，每个SE都有对应的SEID。<br>每个SE可以创建一个或多个CP，每个CP都有对应的CheckpointID。<br>每个SE可以选择一个<strong>监控方式</strong>，这个取决于具体的需求，监控方式可以分为如下三种：</p><ol><li>Alive Supervision: 用于监控周期性任务是否周期性运行。</li><li>Deadline Supervision：用于监控事件型任务的运行时间是否超时。</li><li>Logical Supervision: 用于监控任务的执行逻辑/时序是否正确。</li></ol><p>每一个监控实体可以基于上述三种监控方式计算得出监控结果，被称为<strong>Local Status</strong>。<br>当每一个监控实体的状态得到确定，那么整个MCU的监控结果便可以最终确定，这个最终确定的状态被称为<strong>Global Status</strong>。</p><h4 id="WdgM-API"><a href="#WdgM-API" class="headerlink" title="WdgM API"></a>WdgM API</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">WdgM_Init</span><span class="params">(<span class="type">const</span> WdgM_ConfigType *ConfigPtr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WdgM_DeInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (WDGM_VERSION_INFO_API == STD_ON)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WdgM_GetVersionInfo(_vi) STD_GET_VERSION_INFO(_vi,WDGM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_SetMode</span><span class="params">(WdgM_ModeType Mode)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_GetMode</span><span class="params">(WdgM_ModeType *Mode)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_CheckpointReached</span><span class="params">(WdgM_SupervisedEntityIdType SEID, WdgM_CheckpointIdType CheckpointID)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_GetLocalStatus</span><span class="params">(WdgM_SupervisedEntityIdType SEID, WdgM_LocalStatusType *Status)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_GetGlobalStatus</span><span class="params">(WdgM_GlobalStatusType *Status)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WdgM_PerformReset</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">Std_ReturnType <span class="title function_">WdgM_GetFirstExpiredSEID</span><span class="params">(WdgM_SupervisedEntityIdType *SEID)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">WdgM_MainFunction</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h4><p>Figure 2: Local Supervision Status:</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/231031-wdg/wdgM-1.png" alt="img"></p><p>在从其他状态切换至WDGM_LOCAL_STATUS_EXPIRED状态时，Watchdog Manager提供一定的时间保留机制能够允许做一些特别的操作，如设置看门狗模式或者写入NvM数据，复位原因等。</p><p>Figure 3: Global Supervision Status:</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/231031-wdg/wdgM-2.png" alt="img"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> AUTOSAR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Memory Stack 开发总结</title>
      <link href="/2023/10/20/231020-MemoryStack/"/>
      <url>/2023/10/20/231020-MemoryStack/</url>
      
        <content type="html"><![CDATA[<h2 id="Memory-Stack-开发总结"><a href="#Memory-Stack-开发总结" class="headerlink" title="Memory Stack 开发总结"></a>Memory Stack 开发总结</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>截止目前，已经完成了 FlashDriver、Fls、Fee、MemIf、NvM 的开发。开发的 Memory Stack 只是借鉴了 AUTOSAR Memory Stack 架构，并非完全相同，为了兼容旧版软件，也有部分不符合 AUTOSAR 规范的地方。为了解决一些特殊需求，也有一些创新之处。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>AUTOSAR 官方资料</li><li><a href="https://www.embeddedtutor.com/search/label/Autosar">https://www.embeddedtutor.com/search/label/Autosar</a></li></ol><h3 id="设计方式"><a href="#设计方式" class="headerlink" title="设计方式"></a>设计方式</h3><h4 id="FlashDriver"><a href="#FlashDriver" class="headerlink" title="FlashDriver"></a>FlashDriver</h4><p>Flash驱动层，这一层AUTOSAR中是没有的，我的理解是，AUTOSAR的Fls是Fee代码组件是由芯片厂家提供，那么mcu厂家提供的代码不会兼容其他厂家的外部Flash。代码我只看了云途配置工具生成的Fls代码和NXP官网上的一些芯片的BSW库，并没有见到过有外部Flash厂家提供的Fls代码。为了解决这个问题，我对Fls做了抽象，将不同Flash相关的代码和Fls分开，故有FlashDriver层。不同Flash有共性同时也有特性，为保留特性，借鉴了Linux中对各种外设共有属性和私有属性的思想，这个我是在看《嵌入式C语言自我修养——从芯片、编译器到操作系统》里学的。</p><p>Flash驱动层对上层Fls通过一个成员全是函数指针的结构体提供接口，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">void</span> (*Flash_Init)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr);</span><br><span class="line">MemIf_JobResultType (*Flash_Erase)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType TargetAddress);</span><br><span class="line">MemIf_JobResultType (*Flash_Write)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType TargetAddress, <span class="type">const</span> uint8 *SourceAddressPtr, Fls_LengthType Length);</span><br><span class="line">MemIf_JobResultType (*Flash_Read)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType SourceAddress, uint8 *TargetAddressPtr, Fls_LengthType Length);</span><br><span class="line">MemIf_JobResultType (*Flash_Compare)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr, Fls_AddressType SourceAddress, <span class="type">const</span> uint8 *TargetAddressPtr, Fls_LengthType Length);</span><br><span class="line">MemIf_JobResultType (*Flash_GetStatus)(<span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr);</span><br><span class="line">&#125; Fls_DriverFunType;</span><br></pre></td></tr></table></figure><p>此结构体在每个FlashDriver中有定义，并且是对外的全局变量。用户在配置Fls时，可以配置此结构体指针，这样Fls就可以使用不同的Flash驱动了。</p><h5 id="保留特性"><a href="#保留特性" class="headerlink" title="保留特性"></a>保留特性</h5><p>每种Flash驱动对应一份FlashDriver代码，目前已完成两种FlashDriver开发，一个是mcu内部Flash，另一个是spi通信的外部Flash。每个Flash共有的属性有起始地址、扇区大小（最小擦除量）、扇区个数、页大小（最大写入量），特性有不同的通信方式。如外部Flash SPI通信，需要配置其SPI ID，这是在有MCAL（mcu硬件抽象层）的基础上，如果没有MCAL FlashDriver这一层需要把SPI配置都用用户配置的方式实现，方便封库。</p><p>为保留特性，FlashDriver每个接口都由上层传递了<code>FlsPrivateConfigPtr</code>，接口定义里这是个void指针，在每个FlashDriver的接口实现里将其转成了自己特性配置的结构体指针类型。特性配置结构体类型声明在每个FlashDriver的头文件中，由用户在Fls用户代码中定义配置，再配置进Fls层，上层Fls只是做了传递这个配置给FlashDriver，Fls无法解析这个配置。</p><p>像mcu内部Flash好像并不需要什么特性配置，读写方式都是定死的。不需要<code>FlsPrivateConfigPtr</code>可以在配置Fls时将这个指针配成NULL。</p><h5 id="阻塞在哪"><a href="#阻塞在哪" class="headerlink" title="阻塞在哪"></a>阻塞在哪</h5><p>阻塞在哪里也是个问题，在开发Fls时才想到，一开始我都是阻塞在FlashDriver，因为实现方便，写入和擦除操作可以直接查Flash状态阻塞到完成。后来Fls想做同时支持同步也支持异步的方式，还有需求是Fls超时结束任务，这就需要有Fls去控制是否还要继续阻塞。故FlashDriver中就不阻塞，新增一个读状态接口<code>Flash_GetStatus</code>，阻塞在Fls层。</p><p>但阻塞在FlashDriver这个配置也保留了，可以通过宏选择是否阻塞在驱动。为什么留？写入、擦除出现问题时，改这个成阻塞也不管超时，可以判断下是不是异步导致的问题，调试也能更好的定位问题（阻塞在有问题的地方，可以分析函数调用栈）。 目前Flash底层驱动可以提供阻塞或非阻塞的接口让Fls调用，甚至可以通过私有配置实现部分地址使用阻塞，部分地址使用非阻塞的方式。</p><h5 id="其余问题"><a href="#其余问题" class="headerlink" title="其余问题"></a>其余问题</h5><p>其余问题是云途这个Flash驱动的问题，如果不严格按例程操作寄存器写，只按手册命令方式写的话坑比较多，可能开发的时候能用，测试也没问题，但集成到整个项目工程里时有玄学问题。</p><h4 id="Fls"><a href="#Fls" class="headerlink" title="Fls"></a>Fls</h4><p>按AUTOSAR手册，Fls主要是Flash驱动的功能，对上层提供各种异步读写擦的功能，支持查询任务状态、运行结果。Fls可以将不同地址统一成一个从零开始的线性地址，这个有什么用？假如我想使用两个不连续的Flash扇区，Fls做个地址映射到这两个扇区，对上层来说地址是连续的，上层无需管Flash物理地址，操作的都是逻辑地址，方便上层的使用。</p><p>Fls把FlashDriver抽象出来，增加一种flash需编写一份Flash底层驱动，无需修改Fls代码，可在Flash底层驱动里实现不同Flash的私有配置。Fls会传递正确的物理地址和长度等参数给FlashDriver，因此FlashDriver可不用重复检查参数。Fls可以配置多个实例，支持多个实例用同一份FlashDriver，也支持同时有多种不同的Fls实例，他们共用一份Fls代码（增加复用性）。</p><h5 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h5><p>为什么使用异步？同步阻塞时间过大，影响其他任务运行，异步可以将一个大任务打散成多个小任务多次执行。Fls要实现异步方式调用，任务会在Fls_main里执行，用户可配每次Fls_main执行任务最大的读写量，防止一次main阻塞时间过长。</p><p>异步除了在实现的时候会比同步复杂些，用户在调用的时候也会比同步复杂，有os支持下还好，当任务异步调用Fls后可以挂起，定时查询状态或回调的方式，当Fls任务结束后继续执行原任务，假如没有os支持的话，没有挂起接口，用户每次异步调完Fls后需要记录下当前运行的位置，周期调度下次继续执行。异步能让io(flash)操作阻塞时mcu去干别的事，更好的利用处理器性能，但也增加了查询、任务切换等开销。Fls异步写入时，将写入任务拆成一个个异步的页写入任务，执行后内部挂起，等下次执行查状态。像云途的Flash页大小就8字节，岂不是写256字节要分成30多次子任务，这进出函数的开销和利用阻塞的时间，异步到底有没有优化性能呢？</p><p>擦除任务异步挺有意义的每次阻塞的时间长，也不用把任务打的很散增大函数出入的开销。GD的外部Flash页有256字节，每次写入阻塞时间较长，这种也适用异步写，车规芯片的SPI速度较低最大4M，需要SPI中断或DMA的支持。</p><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>为何保留同步？通过一个参数来决定是同步执行还是异步执行，同步的好处使用户方便使用。</p><p>同步如何实现？其实异步实现了，同步自然就实现了。同步就是一直调用Fls内部的main直到任务执行完毕。</p><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>Fls需要配置哪些参数？凡是在Fls配置的都是Flash的共有属性，配置较多：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Fls_JobType FlsJobDoing;              <span class="comment">// 正在执行的任务</span></span><br><span class="line">MemIf_StatusType FlsJobStatus;        <span class="comment">// 任务状态</span></span><br><span class="line">MemIf_JobResultType FlsJobResult;     <span class="comment">// 任务返回值</span></span><br><span class="line">Fls_AddressType FlsJobAddr;           <span class="comment">// 任务目前执行到的地址</span></span><br><span class="line">Fls_LengthType FlsJobLength;          <span class="comment">// 任务目前执行剩余长度</span></span><br><span class="line"><span class="type">const</span> uint8 *FlsJobDataSrcPtr;        <span class="comment">// 用于传递Write、Compare地址指针参数</span></span><br><span class="line">uint8 *FlsJobDataDestPtr;             <span class="comment">// 用于传递Read地址指针参数</span></span><br><span class="line">MemIf_ModeType FlsJobMode;            <span class="comment">// 快速模式或者慢速模式对应的每周期操作的字节数不同</span></span><br><span class="line">Fls_LengthType FlsPendingEraseLen;    <span class="comment">// 挂起的擦除字节长度（异步擦除用）</span></span><br><span class="line">Fls_LengthType FlsTotalSize;          <span class="comment">// 此Fls实例的空间总大小</span></span><br><span class="line">&#125; Fls_JobInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">uint16 FlsNumberOfSectors;                <span class="comment">// 扇区个数</span></span><br><span class="line">uint16 FlsWriteAlignSize;                 <span class="comment">// 写入对齐大小</span></span><br><span class="line">uint16 FlsReadAlignSize;                  <span class="comment">// 读取对齐大小</span></span><br><span class="line">Fls_LengthType FlsSectorSize;             <span class="comment">// 单个扇区字节数</span></span><br><span class="line">Fls_LengthType FlsPageSize;               <span class="comment">// 单个页字节数</span></span><br><span class="line">Fls_AddressType FlsSectorStartaddress;    <span class="comment">// 第一个扇区起始地址</span></span><br><span class="line">&#125; Fls_SectorType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">const</span> Fls_DriverFunType *FlsDriverFunPtr;    <span class="comment">// 驱动函数指针结构体地址</span></span><br><span class="line"><span class="type">const</span> Fls_SectorType *FlsSectorListPtr;      <span class="comment">// 扇区列表地址</span></span><br><span class="line">uint8 FlsSectorListNum;                      <span class="comment">// Flash（扇区列表）个数</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span> *FlsPrivateConfigPtr;             <span class="comment">// 不同种类Flash私有属性配置地址</span></span><br><span class="line">uint32 FlsMaxBlockingTime;                   <span class="comment">// Fls最大阻塞时间（ms），0表示不开启阻塞超时监测</span></span><br><span class="line">uint8 FlsEnableNonBlockingErase;             <span class="comment">// 开启Fls非阻塞擦除的功能</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Fls_LengthType FlsMaxReadFastMode;       <span class="comment">// 在快速模式下，一个周期内Read、Compare的最大字节数</span></span><br><span class="line">Fls_LengthType FlsMaxReadNormalMode;     <span class="comment">// 在正常模式下，一个周期内Read、Compare的最大字节数</span></span><br><span class="line">Fls_LengthType FlsMaxWriteFastMode;      <span class="comment">// 在快速模式下，一个周期内Write的最大字节数</span></span><br><span class="line">Fls_LengthType FlsMaxWriteNormalMode;    <span class="comment">// 在正常模式下，一个周期内Write的最大字节数</span></span><br><span class="line">MemIf_ModeType FlsDefaultJobMode;        <span class="comment">// 初始化后的JobMode</span></span><br><span class="line">&#125; FlsModeConfig;                             <span class="comment">// 配置不同模式参数</span></span><br><span class="line">&#125; Fls_InstanceConfigType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">void</span> (*FlsBlockingCallbackPtr)(<span class="type">void</span>);                      <span class="comment">// 阻塞回调函数</span></span><br><span class="line">Fls_JobInfoType *FlsJobInfoListPtr;                        <span class="comment">// 任务管理空间地址</span></span><br><span class="line"><span class="type">const</span> Fls_InstanceConfigType *FlsInstanceConfigListPtr;    <span class="comment">// Fls实例配置指针</span></span><br><span class="line">uint8 FlsInstanceNum;                                      <span class="comment">// 总实例数量</span></span><br><span class="line">&#125; Fls_ConfigType;</span><br></pre></td></tr></table></figure><p>由于要封模块，并且要做成可重入，所以需要由用户在配置代码中定义每个实例的管理ram，并配置到config常量中。</p><h5 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h5><p>从零开始的线性地址如何实现？看了上面的<code>Fls_SectorType</code>配置可以想到，Flash的地址映射关系就是映射到的“扇区列表配置”中。当时有个问题，假如有多个Flash，是不是映射成一个从零开始的地址？这样的话上层调用无需体现实例号的，因为根据地址映射关系就能找到要操作的Flash。后来想想还是不行，需要每个Flash的地址都分开从零开始，因为不同Flash的扇区大小等不同，上层不好只通过地址分辨是哪个Flash然后操作。</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/231020-MemoryStack/231020-MemoryStack-3.png" alt="img"></p><h5 id="多实例同时运行"><a href="#多实例同时运行" class="headerlink" title="多实例同时运行"></a>多实例同时运行</h5><p>这个特性也是需要支持的，不能让一个Flash阻塞的时候另一个Flash无法使用。如何实现这个特性呢？为每个Fls实例开一个<code>Fls_JobInfoType</code>管理实例的运行状态，每次Fls_main都把不同实例都执行一遍。这里有个可改善点，每次Fls_main只执行一个实例，让Fls_main的周期短一些，可以把多个Fls实例执行的阻塞时间打散一些，整个系统的最大阻塞时间会缩短。</p><h5 id="对外接口"><a href="#对外接口" class="headerlink" title="对外接口"></a>对外接口</h5><p>对外接口大致遵循AUTOSAR规范，增加了实例号和是否同步的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Fls_Init</span><span class="params">(<span class="type">const</span> Fls_ConfigType *ConfigPtr, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Erase</span><span class="params">(Fls_AddressType TargetAddress, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Write</span><span class="params">(Fls_AddressType TargetAddress, <span class="type">const</span> uint8 *SourceAddressPtr, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Read</span><span class="params">(Fls_AddressType SourceAddress, uint8 *TargetAddressPtr, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_Compare</span><span class="params">(Fls_AddressType SourceAddress, <span class="type">const</span> uint8 *TargetAddressPtr, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line">Std_ReturnType <span class="title function_">Fls_BlankCheck</span><span class="params">(Fls_AddressType TargetAddress, Fls_LengthType Length, uint8 FlsInstanceId, boolean IsSync)</span>;</span><br><span class="line"></span><br><span class="line">MemIf_StatusType <span class="title function_">Fls_GetStatus</span><span class="params">(uint8 FlsInstanceId)</span>;</span><br><span class="line">MemIf_JobResultType <span class="title function_">Fls_GetJobResult</span><span class="params">(uint8 FlsInstanceId)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Fls_SetMode</span><span class="params">(MemIf_ModeType Mode, uint8 FlsInstanceId)</span>;</span><br><span class="line">uint64 <span class="title function_">Fls_GetErrorCode</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Fls_MainFunction</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="Fee"><a href="#Fee" class="headerlink" title="Fee"></a>Fee</h4><p>AUTOSAR NvM中的Fee(Flash EEPROM Emulation)主要做Flash模拟EEPROM的功能。使用EEPROM，软件可以在任意字节读写，也无需管擦除的事情。使用Flash需要考虑每次写入是否对齐、擦除一整个扇区的时候会不会有其他的数据被擦除，总不能每次写就擦除一整个扇区，一个扇区里就放一点点要存的内容吧。不管是Flash还是EEP通常都有磨损均衡的算法，提高Flash的寿命与利用率。Fee就是干这个事情的，并且要留出和Ea(EEPROM Abstraction Layer)一样的接口供上层MemIf(Memory Abstraction Interface)调用，在NvM操作MemIf，无需关心是Fee还是Ea。这也体现了AUTOSAR Memory Stack的高扇入低扇出思想，对外统一接口，内部可以操作不同的非易失存储器。</p><p>Fee是我在实现AUTOSAR Memory Stack中，最复杂的一个模块，先介绍一个基础概念：在内存协议栈中，每个要读写的数据为一个Block数据块，NvM会调用MemIf读写Block，MemIf会调用相应的子设备如Fee。</p><h5 id="均衡算法与Cluster概念"><a href="#均衡算法与Cluster概念" class="headerlink" title="均衡算法与Cluster概念"></a>均衡算法与Cluster概念</h5><p>均衡算法参考了AUTOSAR的多Cluster与多Cluster Group，也加入了自己的均衡磨损管理算法，最终可以实现安全可靠的Block存储。</p><p>在Fee中，一个Flash被划分成1个或多个Cluster Group，每个Cluster Group中可以管理不同的Block；一个Cluster Group中有2个或多个Cluster，用来均衡磨损，每次写入Block都会在所属的Cluster Group中的一个活跃的Cluster上写入，当所有Cluster被写满时，最老的一个Cluster会被擦除，然后此Cluster待写入。</p><p>每个Cluster Group都可以由用户配置，并且都有自己运行时的一份变量空间，一下是Cluster Group的配置与变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Fls_AddressType ClusterFreeSpaceAddr;    <span class="comment">// 指向当前Cluster的空闲空间地址，又表示当前cluster已使用的空间大小</span></span><br><span class="line">uint16 ActiveClusterId;                  <span class="comment">// 当前ACTIVE的Cluster Id</span></span><br><span class="line">uint16 ScanStartClusterId;               <span class="comment">// scanBlock从哪块Cluster开始，0xffff为不执行scanBlock</span></span><br><span class="line">uint32 CycleTimes;                       <span class="comment">// Cluster擦除的周期计数</span></span><br><span class="line">boolean NeedSwap;                        <span class="comment">// 此clusterGroup是否需要swap</span></span><br><span class="line">&#125; Fee_ClusterGroupInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">uint32 CycleTimes;               <span class="comment">// Cluster擦写次数</span></span><br><span class="line">Fee_ClusterStatusType Status;    <span class="comment">// Cluster状态</span></span><br><span class="line">uint8 ClrInfoVerify;             <span class="comment">// ClrId ClrGroup ClusterSize信息 1:正确 0:不正确</span></span><br><span class="line">&#125; Fee_ClusterInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Fls_AddressType ClrStartAddr;          <span class="comment">// Cluster Group起始的Fls地址</span></span><br><span class="line">Fls_LengthType ClrSize;                <span class="comment">// 每个Cluster的字节数</span></span><br><span class="line">uint8 ClrGroup;                        <span class="comment">// Cluster Group ID</span></span><br><span class="line">uint16 NumberOfClr;                    <span class="comment">// Cluster Group中的Cluster数量</span></span><br><span class="line">Fee_ClusterInfoType *FeeClrInfoPtr;    <span class="comment">// 簇信息管理空间地址（用户需要提供数组大小要与NumberOfClr一致）</span></span><br><span class="line">&#125; Fee_ClusterGroupConfigType;</span><br></pre></td></tr></table></figure><p>每个Cluster有它的管理数据结构，Cluster Header中包含了所属哪个Cluster Group、Cluster Id、Cluster Size、擦除次数、状态等信息。初始化会检查这些Cluster头，避免Flash中的Cluster配置与代码不一致造成的数据问题，还可以通过擦除次数看Flash的使用次数，评估其寿命，异常时做云平台上报。</p><h5 id="查找最新的Block"><a href="#查找最新的Block" class="headerlink" title="查找最新的Block"></a>查找最新的Block</h5><p>每次上电初始化要做的事就是从Flash中读取Block，那存在Cluster中的哪个Block是最新的呢？首先要知道一个Cluster Group中哪个Cluster是最新的。Cluster Header中会有Cluster的状态，一般情况下最新的Cluster有个活跃的状态，便可知最老的那个Cluster，从最老的Cluster上遍历查找每个Block，记录每个Block最新地址，这么一轮遍历结束就可以知道各个Block最新的数据存在哪个位置啦。</p><p>内部接口：<code>static Std_ReturnType Fee_ScanBlock(uint8 FeeInstanceId, uint8 ClusterGroup, uint16 ScanStartClusterId)</code></p><p>索引是从指定Cluster搜索有效的block，取最新的block信息保存至FeeBlockInfo。考虑Cluster中会有损坏的Block和之前写Block中断电的情况，Scan需要能跳过坏Block，按以下流程scan每个有效的Cluster：</p><ol><li>每个Cluster开始索引的地址为ClusterHeader后开始存放Block的地址。</li><li>开始检查对应地址的Block状态。</li><li><ol><li>为空，跳出此Cluster的索引。</li></ol></li><li><ol start="2"><li>DataValid有效，Block正常，将Block地址存储在BlockInfo（hash表）中，根据此Block长度跳地址，继续索引（步骤2）。</li></ol></li><li><ol start="3"><li>NumLenValid（BlockInfo）有效，Block数据段无效，数据段无法保证全为空, 跳过BlockHeader+BlockLen长度继续索引。</li></ol></li><li><ol start="4"><li>NumLen和Data都无效，BlockHeader不为空正常情况下数据区还没被写，跳过一个BlockHeader长度继续索引。</li></ol></li></ol><p>每个Block在Fee中都有其对应的配置与RAM空间，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Fls_AddressType BlockAddr;     <span class="comment">// Block头所在的Fls地址</span></span><br><span class="line">uint16 ClusterId;              <span class="comment">// Block所在的Cluster Id</span></span><br><span class="line">uint16 BlockNumber;            <span class="comment">// Block Number</span></span><br><span class="line">uint16 BlockLen;               <span class="comment">// Block Len</span></span><br><span class="line">Fee_BlockStatusType Status;    <span class="comment">// Block头的状态</span></span><br><span class="line">&#125; Fee_BlockInfoType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">uint16 BlockNumber;    <span class="comment">// 配置Block Number</span></span><br><span class="line">uint16 BlockLen;       <span class="comment">// 配置Block Len</span></span><br><span class="line">uint8 ClusterGroup;    <span class="comment">// 配置Block属于那个BlockGroup</span></span><br><span class="line">&#125; Fee_BlockConfigType;</span><br></pre></td></tr></table></figure><p>每个Block也像Cluster一样有Header，在Block Header中记录BlockId、BlockSize、各种标志位信息。可以通过这些标志位，判断当时存的时候有没有异常下电，Block数据是否完整可信，在Fee中不是通过CRC的方式判断数据是否可信，因为在初始化遍历读取Block的时候，给每个Block做CRC如果Flash很大那需要很长一段时间。</p><h5 id="交换Cluster"><a href="#交换Cluster" class="headerlink" title="交换Cluster"></a>交换Cluster</h5><p>内部接口：<code>static Std_ReturnType Fee_SwapCluster(uint8 FeeInstanceId, uint8 ClusterGroup, uint16 FromClusterId, uint16 ToClusterId)</code></p><p>将旧Cluster上的有效Block搬到新Cluster。</p><ol><li>遍历所有的BlockInfo，如果Block的ClusterGroup匹配，且有效数据在老的Cluster上，就将整个Block读取到函数栈空间，然后写入新Cluster的地址，在SWAPPING的时候无需考虑写BlockHeader标志位的顺序，因为SWAPPING时掉电，下次初始化时会擦除此Cluster重新SWAP。</li></ol><p>详细描述：当Cluster总数-1的Cluster被写完的情况下就需要触发Cluster交换任务了，目的是将最老Cluster上有效的Block（没有更新的数据）转移到那块空白的Cluster上，我称这个操作叫换页。换页时会给Cluster写上换页的标志位，换页过程中异常下电下次能识别到触发重新换页任务。上面说过每个Block都有ram空间，管理这其最新Block的地址（在哪个Cluster上和偏移地址），因此很容易知道最老的Cluster有哪些有效Block和其地址，可以简单的使用memcpy将其复制到最新的Cluster上，因为Block Header不用发生更改，并且写入Block时无需防止异常下电。换页结束后需改变Cluster的状态，将原先最新的那个从活跃设置为满状态，将新的那个Cluster从空设为活跃状态。</p><h5 id="维护任务"><a href="#维护任务" class="headerlink" title="维护任务"></a>维护任务</h5><p>内部接口：<code>static Std_ReturnType Fee_MaintainJob(uint8 FeeInstanceId)</code></p><p>维护任务，需要检查是否需要执行交换和擦除任务。考虑减少运行时阻塞，正常情况维护中擦除Cluster采用异步非阻塞的方式。正常情况维护操作流程如下：（非正常情况处理较复杂不写）</p><ol><li>当前操作的Cluster状态为ACTIVE，检查下个Cluster状态是否为VERIFIED，若不是，异步擦除下个Cluster。</li><li>当前操作的Cluster状态为ACTIVE，下个Cluster状态为VERIFIED，检查当前Cluster空闲空间是否充足，若不足，将当前Cluster写FULL标志位，2个Cluster和2个以上Cluster写入标志位顺序有差异。</li><li>当前操作的Cluster状态为FULL，执行SWAP任务，将最老的Cluster上有效的Block搬到新的Cluster上，SWAP成功后将当前操作的Cluster改为新的Cluster，新Cluster状态设为ACTIVE。</li></ol><p><strong>Cluster 状态转移图如下</strong>：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/231020-MemoryStack/231020-MemoryStack-2.png" alt="img"></p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>对外接口：<code>void Fee_Init(const Fee_ConfigType* ConfigPtr, boolean IsSync)</code><br>内部初始化Job接口：<code>static Std_ReturnType Fee_InitJob(uint8 FeeInstanceId)</code></p><p>初始化Job中需要处理各种不同的Cluster状态，查找ACTIVE状态的Cluster和最老的Cluster，从最老的Cluster开始索引Block。</p><p>考虑在换页时断电和Cluster损坏的可能性，初始化处理Cluster状态有如下几种情况：（每种情况处理方式不描述了）</p><ol><li>只有1个ACTIVE状态的cluster。</li><li>没有ACTIVE状态的cluster，只有1个SWAPPING状态的cluster。</li><li>总共只有2个Cluster，没有cluster状态为ACTIVE和SWAPPING，只有1个cluster状态为FULL。</li><li>没有ACTIVE和SWAPPING状态的Cluster，只有FULL状态的Cluster。</li><li>其他。<br>原则上，大于2个Cluster只要有1个ACTIVE或1个SWAPPING状态的Cluster都能被成功初始化，如果存储在Flash中的数据受干扰异常导致无法识别ACTIVE和SWAPPING状态的Cluster，会导致初始化失败，会重新初始化Cluster，历史数据丢失。</li></ol><h5 id="写入Block"><a href="#写入Block" class="headerlink" title="写入Block"></a>写入Block</h5><p>对外接口：<code>Std_ReturnType Fee_Write(uint8 FeeInstanceId, uint16 BlockNumber, const uint8 *DataBufferPtr, boolean IsSync)</code><br>内部接口：<code>MemIf_JobResultType Fee_WriteJob(uint16 BlockIndex, const uint8* DataBufferPtr, uint8 FeeInstanceId)</code></p><p>上层调用Fee写入Block数据，支持异步。</p><p>在Fee_WriteJob()需考虑写入时Flash空间不为空的情况，若不为空应该找到空白区域，使下次可正常写入，具体写入流程如下：</p><ol><li>每次写入前都会检查要写入BlockHeader的地址空间是否为空白，如果不空白，解析BlockHeader。</li><li><ol><li>为空，跳出检查。</li></ol></li><li><ol start="2"><li>DataValid或NumLenValid有效，根据此Block长度跳地址，继续检查下个地址空间是否空白（步骤1）。</li></ol></li><li><ol start="3"><li>NumLen和Data都无效，跳过一个BlockHeader长度继续检查（步骤1）。</li></ol></li><li>写入BlockHeader中的INFO（BlockNumber、BlockLen），写入BlockHeader中的NUMLEN有效标志位。</li><li>检查要写入数据的区域是否为空，不为空则退出。</li><li>写入BlockData，写入Data有效标志位。</li><li>数据写入Flash成功，更新BlockInfo，指向最新的Block地址。</li></ol><h5 id="读取Block"><a href="#读取Block" class="headerlink" title="读取Block"></a>读取Block</h5><p>对外接口：<code>Std_ReturnType Fee_Read(uint8 FeeInstanceId, uint16 BlockNumber, uint16 BlockOffset, uint8 *DataBufferPtr, uint16 Length, boolean IsSync)</code><br>内部接口：<code>MemIf_JobResultType Fee_ReadJob(uint16 BlockIndex, uint16 BlockOffset, uint8* DataBufferPtr, uint16 Length, uint8 FeeInstanceId)</code></p><p>上层调用Fee读取数据，支持异步，读取通过偏移和长度参数，读取Block中的部分数据内容。</p><p>Block读取较为简单，判断参数正确未越界即可直接读取Flash中的数据到内存，如果Flash中未保存此数据返回MEMIF_BLOCK_INVALID。</p><h5 id="同异步、多实例"><a href="#同异步、多实例" class="headerlink" title="同异步、多实例"></a>同异步、多实例</h5><p>Fee和Fls都支持同步和异步的调用方式，为了实现异步调用，需要有一个管理任务的内存空间，Fee和Fls都使用JobInfo结构体来管理。每个实例都有独立的ram空间，所以多实例问题也很好解决。</p><p>Fee对外接口中，读Block、写Block、失效Block三个接口支持异步的方式，Fls对外接口中，读Flash、写、擦、比较、空校验这些接口支持异步方式调用。</p><ul><li>异步调用Fee对外接口，接口函数会检测参数正确性，无误后将任务参数写入JobInfo，Fee状态变为Busy，然后接口return，在Fee_main中执行Job。</li><li>同步调用Fee读写接口和异步方式相同，写入JobInfo后会在对外接口函数内调用执行Job函数，直到状态变为IDLE。</li></ul><h4 id="MemIf"><a href="#MemIf" class="headerlink" title="MemIf"></a>MemIf</h4><p>内存抽象接口（MemIf）模块提供对底层Fee或Ea模块的抽象，由NvM调用传入形参实例号（DeviceIndex），MemIf根据实例号区分该调用Fee或是Ea模块。</p><p>MemIf也做成了可配置的形式，可通过配置将需要用的子模块链接到程序中，不用的模块不链接，实现整套协议栈功能可裁剪。</p><h4 id="NvM"><a href="#NvM" class="headerlink" title="NvM"></a>NvM</h4><p>NvM模块包含：下电写入、周期写入、事件触发写入、Block标定、Block清除（恢复默认值）、Block读取写入、Block结构体变更处理、Block校验失败处理、Block数据和RTE同步功能。</p><p>NvM是基于原本EPara模块重构的，使用MemIf的接口，对上提供原EPara有的那些服务接口，如标定、同步这些AUTOSAR中没有的功能。其余读写Block，接口改的与AUTOSAR一致，一些AUTOSAR中有的但用不到的接口部分也没有实现。</p><p>初始化接口：<code>void NvM_Init( const NvM_ConfigType* ConfigPtr )</code><br>流程：校验config参数，读取所有Block，创建NvM周期任务。</p><p>读取Block任务接口：<code>static void NvM_ReadBlock(uint16 BlockId)</code><br>流程：读取NvM Block Header，根据头中的Block Len读取相应长度的数据段，做CRC16校验。CRC校验失败恢复默认值，版本不一致恢复默认值。原数据长度小于配置的Block长度，继承原先长度的Block数据，超过原先长度的部分从默认值获取。原数据长度大于等于配置的Block长度，保留Block所配置长度的数据段。</p><p>写入Block任务接口：<code>static void NvM_WriteBlockJob(uint16 BlockId)</code><br>流程：读取Block，比较不一致再写入，写入成功或比较一致清除Block写入标志位。</p><p>写入Block接口：<code>void NvM_WriteAll(boolean IsSync)</code> <code>void NvM_WriteBlock(uint16 BlockId, boolean IsSync)</code><br>流程：这两个写入Block接口会将Block写入标志位置写入标志位，如果IsSync = TRUE，会在函数内部调用<code>NvM_ExecuteJob()</code>，执行写入任务。</p><p>周期写入接口：<code>static void NvM_CycleWrite(void)</code><br>流程：写入周期到，会对所有配置了周期写入的Block置写入标志位。</p><p>下电写入接口：<code>static void NvM_PoweroffWrite(void)</code><br>流程：检测到预下电RTE信号上升沿，会对所有配置了周期写入的Block置写入标志位。</p><p>事件触发写入接口：<code>static void NvM_EventWrite(void)</code><br>流程：检测到对应Block事件触发信号上升沿，会对此Block置写入标志位。</p><p>执行任务接口：<code>static void NvM_ExecuteJob(void)</code><br>流程：执行写入任务，调用一次ExecuteJob，最多只会写入1个Block。</p><h5 id="NvM存储各层数据结构"><a href="#NvM存储各层数据结构" class="headerlink" title="NvM存储各层数据结构"></a>NvM存储各层数据结构</h5><p><img src="https://gitee.com/hao0527/hao0527/raw/img/231020-MemoryStack/231020-MemoryStack-1.png" alt="img"></p><h3 id="待改进点"><a href="#待改进点" class="headerlink" title="待改进点"></a>待改进点</h3><ol><li>Fls写入使用异步非阻塞，每写入一个页挂起，需要os支持。</li><li>Fee异常时的擦除也可以挂起，减少阻塞时处理器性能浪费。</li><li>MemIf下可以挂除Fee和Ea外的设备，支持S32K的EEP，因为S32EEP不需要均衡磨损，本身就是用Flash模拟的，所以不适合挂在Ea和Fee。为什么不直接用Flash，然后挂Fee上？因为想让用S32Eep的老项目支持这套内存协议栈。</li><li>NvM作为协议栈的上层，可以实现更多的功能。</li></ol><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>整套协议栈自己实现相比直接用AUTOSAR的组件有很多的优点，有哪些自己特殊的需求加到协议栈里比较方便。比如使用之前的均衡磨损算法、NvM支持数据不同版本继承、Fee对数据继承的支持、有同步接口的需求、外部Flash也想使用Fee等等。</p><p>调试的过程中云途的mcu擦flash也有坑，这么多个模块开发下来，其中感觉最为复杂的是Fee，完成一个能经得住随机下电，下次上电能自恢复的Fee是很有成就感的。这里要感谢我领导对我的支持与帮助，给我时间让我自我发挥，遇到我解决问题可以一同调试。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> AUTOSAR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>蓝牙BLE调试记录</title>
      <link href="/2023/09/23/230923-ble/"/>
      <url>/2023/09/23/230923-ble/</url>
      
        <content type="html"><![CDATA[<h2 id="蓝牙SOC芯片"><a href="#蓝牙SOC芯片" class="headerlink" title="蓝牙SOC芯片"></a>蓝牙SOC芯片</h2><p>国产芯片PAN1020，M0带蓝牙收发器的SOC只要2.5r/pcs，可以用来做一些低成本的小产品，带上蓝牙控制的功能。参考资料：<a href="https://bbs.panchip.com/forum.php?mod=viewthread&tid=7480&extra=page=1">PAN1020_Public_SDK_V2.0.8</a>。</p><ul><li>RF<br>- 2.4GHz 射频收发机（兼容 BLE4.2）<br>- 接收灵敏度：-90 dBm@1Mbps<br>- 最大接收信号：0 dBm<br>- 可编程发射输出功率：最大为 13 dBm，一般为 8 dBm<br>- 单线天线：无需 RF 匹配或 RX/TX 切换</li><li>内核<br>- MCU 内核运行速度高达 26 MHz<br>- 一个 24 位系统定时器<br>- 支持低功耗空闲模式<br>- 单周期 32 位硬件乘法器<br>- 支持串行线调试（SWD）接口和两个观察点/四个断点</li><li>内存<br>- 256 KB 闪存用于程序存储器<br>- 16 KB SRAM</li></ul><p><strong>低功耗说明</strong>：</p><table><thead><tr><th>NO</th><th>Mode</th><th>Interval</th><th>Average Current</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td>Advertising</td><td>100ms</td><td>545uA</td><td>32K RC</td></tr><tr><td>2</td><td>Advertising</td><td>1000ms</td><td>66uA</td><td>32K RC</td></tr><tr><td>3</td><td>Connected</td><td>100ms</td><td>301uA</td><td>32K RC</td></tr><tr><td>4</td><td>Connected</td><td>1000ms</td><td>55uA</td><td>32K RC</td></tr><tr><td>5</td><td>Advertising</td><td>100ms</td><td>400uA</td><td>32K XO</td></tr><tr><td>6</td><td>Connected</td><td>100ms</td><td>230uA</td><td>32K XO</td></tr></tbody></table><h2 id="产品需求"><a href="#产品需求" class="headerlink" title="产品需求"></a>产品需求</h2><p>蓝牙温度计，能记录历史数据，手机app显示温度波形，40mah纽扣电池供电，使用5天。</p><h2 id="软件开发记录"><a href="#软件开发记录" class="headerlink" title="软件开发记录"></a>软件开发记录</h2><p>代码已上传 GIthub：<a href="https://github.com/hao0527/BLE_APP">BLE_APP 源码</a></p><h3 id="启用中断回调"><a href="#启用中断回调" class="headerlink" title="启用中断回调"></a>启用中断回调</h3><p>我配置了 ADC 并开启中断，测试程序会卡死，最后发现与 ADC 中断是否开启相关。在 BLE 协议栈接口那发现了注册中断的接口。</p><p>使用如下代码将 <code>ADC_IRQ</code> 的中断回调 <code>mcu_adc_isr</code> 注册到协议栈后，问题解决。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册中断处理函数到协议栈，否则中断会卡死。</span></span><br><span class="line">((interrupt_register_handler)SVC_interrupt_register)(ADC_IRQ, mcu_adc_isr);</span><br></pre></td></tr></table></figure><h3 id="开启低功耗模式"><a href="#开启低功耗模式" class="headerlink" title="开启低功耗模式"></a>开启低功耗模式</h3><p>如需开启低功耗模式，只需在 <code>panip_config.h</code> 中 <code>#define SLEEP_EN (1)</code>。</p><p>PAN1020 SDK 定义的全局变量在使用前都必须要在函数中初始化，如果定义的时候就初始化，当前初始化的值是不生效的。</p><p>因为<strong>开启低功耗模式需配置编译器将 RAM 设置为 NoInit</strong>，如图所示：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/230923-ble/230923-ble-1.jpg" alt="img"></p><p>设为 NoInit 后，全局变量定义后的值为随机值，没有被初始化，需要自己手动初始化。此处是为了在 PAN1020 休眠唤醒后 RAM 不被重新初始化，唤醒后的 RAM 值依旧保持为休眠前的值。</p><h3 id="配置软件定时器"><a href="#配置软件定时器" class="headerlink" title="配置软件定时器"></a>配置软件定时器</h3><p>按照 SDK 用户手册配置软件定时器后遇到奇怪的问题，但测试发现解决方法，如下注释说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_proj_template_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(&amp;app_proj_template_env, <span class="number">0</span>, <span class="keyword">sizeof</span>(app_proj_template_env));</span><br><span class="line"></span><br><span class="line">temper_resetInit();</span><br><span class="line"><span class="comment">/* 注意：配置定时器放在此函数里没问题，放在appm_init()外部有问题，会导致无法进定时回调！</span></span><br><span class="line"><span class="comment">函数调用关系：ble_normal_reset_init() -&gt; user_code_start() -&gt; appm_init() -&gt; app_init_ind_func()</span></span><br><span class="line"><span class="comment">设置定时器放在appm_init()内部没问题，但是放在appm_init()外部就不行，</span></span><br><span class="line"><span class="comment">甚至把设置定时器放在appm_init()内部的最后一行可以，放在appm_init()执行完出来的下一行不行！*/</span></span><br><span class="line">((ke_timer_set_handler)SVC_ke_timer_set)(APP_SAMPLE_TEMPER_TIMER, TASK_APP, <span class="number">60</span>*<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置ATT数据库"><a href="#配置ATT数据库" class="headerlink" title="配置ATT数据库"></a>配置ATT数据库</h3><p>配置att数据库后发现只有数据库的前13条配置生效，后面的att没有生效，在配置att的接口调试发现有条件为满足导致的后面一些att数据库配置没配置进协议栈，一层层向上查后是以下代码，<code>db_cfg-&gt;features = 0x1fff;</code> 导致的，如下配置为 <code>db_cfg-&gt;features = 0xffffffff;</code> 后问题解决。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_proj_template_add_server</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proj_template_server_db_cfg</span>* <span class="title">db_cfg</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate the BASS_CREATE_DB_REQ</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">gapm_profile_task_add_cmd</span> *<span class="title">req</span> =</span> KE_MSG_ALLOC_DYN(GAPM_PROFILE_TASK_ADD_CMD,</span><br><span class="line">TASK_GAPM, TASK_APP,</span><br><span class="line">gapm_profile_task_add_cmd,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> proj_template_server_db_cfg));</span><br><span class="line"><span class="comment">// Fill message</span></span><br><span class="line">req-&gt;operation = GAPM_PROFILE_TASK_ADD;</span><br><span class="line">req-&gt;sec_lvl = (PERM(SVC_AUTH, DISABLE)| PERM(SVC_UUID_LEN, UUID_16)| PERM(SVC_EKS, DISABLE)|PERM(SVC_DIS, DISABLE));</span><br><span class="line"></span><br><span class="line">req-&gt;prf_task_id = TASK_ID_PROJ_TEMPLATE_SERVER;</span><br><span class="line">req-&gt;app_task = TASK_APP;</span><br><span class="line">req-&gt;start_hdl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set parameters</span></span><br><span class="line">db_cfg = (<span class="keyword">struct</span> proj_template_server_db_cfg* ) req-&gt;param;</span><br><span class="line">db_cfg-&gt;features = <span class="number">0xffffffff</span>;<span class="comment">// 注意：配置了gatt数据库，要配置这个掩码使能，32位都是1可以使能32个数据库配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Send the message</span></span><br><span class="line">((ke_msg_send_handler)SVC_ke_msg_send)(req);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="电池输出电流不足不问"><a href="#电池输出电流不足不问" class="headerlink" title="电池输出电流不足不问"></a>电池输出电流不足不问</h3><p>电池40mah，放点倍率0.1C，输出电流最大就4ma，射频瞬间最大电流有30多ma，adc采集会开启ldo和运放，最大电流有90ma。</p><p>adc采集的时候电流过大会将电压拉低导致单片机复位，正在通过加电容解决。</p><p>射频需求只需要5m范围内，所以射频的功率也可以配置低一些。</p><p>后面测试解决完这个问题更新……</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32 CMake 构建工程</title>
      <link href="/2023/09/14/230914-stm32cmake/"/>
      <url>/2023/09/14/230914-stm32cmake/</url>
      
        <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://github.com/rxdu/stm32_cmake">STM32 CMake Project Template</a></li><li><a href="https://github.com/skb666/stm32l4_demo/tree/dev">stm32l4_demo - skb666</a></li></ol><h3 id="为什么使用-CMake？"><a href="#为什么使用-CMake？" class="headerlink" title="为什么使用 CMake？"></a>为什么使用 CMake？</h3><p>很早就想过用 CMake 来代替 eclipse 构建工程，优点是可以使用 VsCode 编译工程进行开发。另外还方便在 Jenkins 上使用脚本构建工程，目前使用 eclipse 构建工程，需要把生成的 Makefile 和多个 .arg 文件传 SVN，Jenkins 上通过 eclipse 生成的 Makefile 脚本编译工程，需要管控很多 Make 相关的文件，而且工程文件目录调整后，需要重新用 eclipse 生成一份 Makefile 供 Jenkins 使用。</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>一开始使用 CMake 遇到很多问题，主要还是我在使用 Windows 开发环境，有些地方需要注意。我后来使用 WSL 使用CMake 的时候还是很顺利的，而且 Linux 中的包管理器很好用，准备开发环境非常方便，确实比 Windows 开发优秀很多。如果可以的话，我也想拥有一台电脑装 Linux 操作系统做日常软件开发。</p><p>现在改了 CMake 脚本，在 Windows 下也可以完成构建和编译了！，主要是加了 <code>set(CMAKE_SYSTEM_NAME Generic)</code>，<code>CMAKE_SYSTEM_NAME</code> 变量用于指定项目的目标操作系统名称，”Generic” 通常表示你不是针对特定的操作系统进行构建，而是希望以更通用或跨平台的方式构建项目，这通常用于编写可以在多个不同平台上编译和运行的代码。否则链接时会出现以下报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[  2%] Linking C executable C:/Users/33110/Projects/stm32l4_demo/output/stm32l4_demo.elf.exe</span><br><span class="line">c:/program files (x86)/gcc-arm-none-eabi-10.3-2021.10/bin/../lib/gcc/arm-none-eabi/10.3.1/../../../../arm-none-eabi/bin/ld.exe: unrecognized option &#x27;--major-image-version&#x27;</span><br><span class="line">c:/program files (x86)/gcc-arm-none-eabi-10.3-2021.10/bin/../lib/gcc/arm-none-eabi/10.3.1/../../../../arm-none-eabi/bin/ld.exe: use the --help option for usage information</span><br><span class="line">collect2.exe: error: ld returned 1 exit status</span><br><span class="line">make[2]: *** [CMakeFiles/stm32l4_demo.elf.dir/build.make:764：C:/Users/33110/Projects/stm32l4_demo/output/stm32l4_demo.elf.exe] 错误 1</span><br><span class="line">make[1]: *** [CMakeFiles/Makefile2:83：CMakeFiles/stm32l4_demo.elf.dir/all] 错误 2</span><br><span class="line">make: *** [Makefile:91：all] 错误 2</span><br></pre></td></tr></table></figure><h3 id="CMake-脚本"><a href="#CMake-脚本" class="headerlink" title="CMake 脚本"></a>CMake 脚本</h3><p>CMake 脚本分为两个，将不同平台编译工具链相关的抽离出来，在一份 CMake 工程可以编译出不同平台的结果。脚本内容如下：</p><h4 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义工程名的变量</span></span><br><span class="line"><span class="keyword">set</span>(PROJECT_NAME <span class="string">&quot;my_ytm32_prj&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> LANGUAGES C CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更详细的编译信息</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_VERBOSE_MAKEFILE <span class="keyword">on</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;PROJECT_NAME: &quot;</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;CMAKE_TOOLCHAIN_FILE: &quot;</span> <span class="variable">$&#123;CMAKE_TOOLCHAIN_FILE&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;MCU: &quot;</span> <span class="variable">$&#123;MCU&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;LD_SCRIPT: &quot;</span> <span class="variable">$&#123;LD_SCRIPT&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;ASM_SOURCES: &quot;</span> <span class="variable">$&#123;ASM_SOURCES&#125;</span>)</span><br><span class="line"><span class="keyword">MESSAGE</span>(STATUS <span class="string">&quot;MAP_FILE: &quot;</span> <span class="variable">$&#123;MAP_FILE&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加编译参数</span></span><br><span class="line"><span class="keyword">add_compile_options</span>(-O2 -fmessage-length=<span class="number">0</span> -fsigned-char -ffunction-sections -fdata-sections -fno-strict-aliasing)</span><br><span class="line"><span class="keyword">add_link_options</span>(-T<span class="variable">$&#123;LD_SCRIPT&#125;</span> -Xlinker --gc-sections -Wl,-Map=<span class="variable">$&#123;MAP_FILE&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归调用子文件的 CMakeLists.txt</span></span><br><span class="line"><span class="comment"># add_subdirectory(lib)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 汇编文件配置编译选项</span></span><br><span class="line"><span class="keyword">set_property</span>(SOURCE <span class="variable">$&#123;ASM_SOURCES&#125;</span> PROPERTY LANGUAGE C)</span><br><span class="line"><span class="keyword">set_source_files_properties</span>(<span class="variable">$&#123;ASM_SOURCES&#125;</span> PROPERTIES COMPILE_FLAGS <span class="string">&quot;-x assembler-with-cpp -DSTART_FROM_FLASH&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用file命令的GLOB_RECURSE选项递归搜索所有C文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE SOURCE_FILES <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/source/*.c&quot;</span> <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/Project_Settings/Startup_Code/*.c&quot;</span>)</span><br><span class="line"><span class="comment"># MESSAGE(STATUS &quot;SOURCE_FILES: &quot; $&#123;SOURCE_FILES&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标所需的源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="variable">$&#123;SOURCE_FILES&#125;</span> <span class="variable">$&#123;ASM_SOURCES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标所需宏定义</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf PUBLIC</span><br><span class="line">    CPU_YTM32B1ME0</span><br><span class="line">    YTM32B1ME0</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标所需的库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf PUBLIC m)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标所需的头文件路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf PUBLIC</span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/Project_Settings/Startup_Code&quot;</span></span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/Project_Settings/Startup_Code/CMSIS/Core/Include&quot;</span></span><br><span class="line">    <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/source/inc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加预编译目标</span></span><br><span class="line"><span class="keyword">add_custom_target</span>(</span><br><span class="line">    PRE_BUILD_DUMMY ALL</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 目标编译前自定义指令</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    <span class="keyword">TARGET</span> PRE_BUILD_DUMMY PRE_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../Bin/generate_version.sh</span><br><span class="line">    WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_OUTPUT_DIRECTORY&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 将预编译步骤作为主目标依赖</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf PRE_BUILD_DUMMY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标编译后自定义指令</span></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">    <span class="keyword">TARGET</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf POST_BUILD</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../Bin/BuildTools/PostBuild.bat <span class="variable">$&#123;PROJECT_NAME&#125;</span> <span class="variable">$&#123;TOOLCHAINS_PATH&#125;</span> <span class="variable">$&#123;TOOLCHAINS_PREFIX&#125;</span></span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;TOOLCHAINS_PATH&#125;</span>/<span class="variable">$&#123;TOOLCHAINS_PREFIX&#125;</span>objcopy -O binary -S <span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="variable">$&#123;PROJECT_NAME&#125;</span>.bin</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;TOOLCHAINS_PATH&#125;</span>/<span class="variable">$&#123;TOOLCHAINS_PREFIX&#125;</span>objcopy -O binary -S <span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="variable">$&#123;PROJECT_NAME&#125;</span>.srec</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;TOOLCHAINS_PATH&#125;</span>/<span class="variable">$&#123;TOOLCHAINS_PREFIX&#125;</span>objcopy -O binary -S <span class="variable">$&#123;PROJECT_NAME&#125;</span>.elf <span class="variable">$&#123;PROJECT_NAME&#125;</span>.hex</span><br><span class="line">    WORKING_DIRECTORY <span class="variable">$&#123;CMAKE_OUTPUT_DIRECTORY&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="toolchains-cmake"><a href="#toolchains-cmake" class="headerlink" title="toolchains.cmake"></a>toolchains.cmake</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_SYSTEM_NAME Generic)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SYSTEM_PROCESSOR ARM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择编译版本（可以通过 vscode 指定）</span></span><br><span class="line"><span class="comment"># set(CMAKE_BUILD_TYPE Release)</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE Debug)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(TOOLCHAINS_PATH <span class="string">&quot;C:/Yuntu/YuntuIDE/tools/bin&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(TOOLCHAINS_PREFIX <span class="string">&quot;arm-none-eabi-&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉编译器（可以通过 vscode 指定）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER <span class="string">&quot;$&#123;TOOLCHAINS_PATH&#125;/$&#123;TOOLCHAINS_PREFIX&#125;gcc.exe&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;$&#123;TOOLCHAINS_PATH&#125;/$&#123;TOOLCHAINS_PREFIX&#125;g++.exe&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳过编译器检查</span></span><br><span class="line"><span class="comment"># set(CMAKE_C_COMPILER_WORKS 1)</span></span><br><span class="line"><span class="comment"># set(CMAKE_CXX_COMPILER_WORKS 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成目标的存放目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_OUTPUT_DIRECTORY <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/Debug)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_OUTPUT_DIRECTORY&#125;</span>)</span><br><span class="line"><span class="comment"># 默认存放静态库的文件夹位置</span></span><br><span class="line"><span class="comment"># set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY $&#123;CMAKE_OUTPUT_DIRECTORY&#125;/archive)</span></span><br><span class="line"><span class="comment"># 默认存放动态库的文件夹位置</span></span><br><span class="line"><span class="comment"># set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_OUTPUT_DIRECTORY&#125;/library)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CPU <span class="string">&quot;-mcpu=cortex-m33&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(FPU <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(FLOAT-ABI <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(MCU <span class="string">&quot;$&#123;CPU&#125; -mthumb $&#123;FPU&#125; $&#123;FLOAT-ABI&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;$&#123;MCU&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS_DEBUG <span class="string">&quot;-g3&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS_RELEASE <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果CMAKE_CXX_STANDARD_REQUIRED设置为ON则必须使用CMAKE_CXX_STANDARD指定的版本</span></span><br><span class="line"><span class="comment"># 如果CMAKE_CXX_STANDARD_REQUIRED设置为OFF则CMAKE_CXX_STANDARD指定版本的为首选版本如果没有会使用上一版本</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;MCU&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;-g3&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(LD_SCRIPT <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/Project_Settings/Linker_Files/flash.ld&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(ASM_SOURCES <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/Project_Settings/Startup_Code/YTM32B1ME0_startup_gcc.S&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(MAP_FILE <span class="string">&quot;$&#123;CMAKE_OUTPUT_DIRECTORY&#125;/$&#123;PROJECT_NAME&#125;.map&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXE_LINKER_FLAGS <span class="string">&quot;--specs=nosys.specs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)</span><br></pre></td></tr></table></figure><h3 id="构建及编译指令"><a href="#构建及编译指令" class="headerlink" title="构建及编译指令"></a>构建及编译指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd Project</span><br><span class="line">cmake -G &quot;Unix Makefiles&quot; -S. -BDebug -DCMAKE_TOOLCHAIN_FILE=toolchains.cmake</span><br><span class="line">cmake --build Debug --target all -- -j8</span><br></pre></td></tr></table></figure><h3 id="写cmake脚本时遇到的问题"><a href="#写cmake脚本时遇到的问题" class="headerlink" title="写cmake脚本时遇到的问题"></a>写cmake脚本时遇到的问题</h3><ol><li>vscode生成cmake时需要加入指定工具链的命令<code>-DCMAKE_TOOLCHAIN_FILE=toolchains.cmake</code>，这个需在vscode cmake拓展设置中配置。</li><li>vscode生成cmake可以选择是Debug还是Release，还可选择工具链，既然我通过上面一个方案传入工具链的cmake，vscode配置工具链成未指定就可以了。</li><li>cmake生成时会有检查工具链，有些工具链可能会报错，gcc10.5需要加<code>set(CMAKE_EXE_LINKER_FLAGS &quot;--specs=nosys.specs&quot;)</code>。</li><li>gcc4.9就不支持<code>--specs=nosys.specs</code>这个选项，跳过编译器检查需要加 <code>set(CMAKE_C_COMPILER_WORKS 1) set(CMAKE_CXX_COMPILER_WORKS 1)</code>。</li><li>跨平台的编译需要加<code>set(CMAKE_SYSTEM_NAME Generic) set(CMAKE_SYSTEM_PROCESSOR ARM)</code>，否则会链接错误。</li><li>更详细的编译信息<code>set(CMAKE_VERBOSE_MAKEFILE on)</code>需要加在<code>project($&#123;PROJECT_NAME&#125; LANGUAGES C CXX)</code>后面，否则不起作用。</li><li><code>set(CMAKE_SYSTEM_NAME Generic)</code>需要加在<code>project($&#123;PROJECT_NAME&#125; LANGUAGES C CXX)</code>前面，否则不起作用，这类问题还没搞清楚为什么有的需要在project前有的需要在后，解决方法是由于未起作用试出来的。</li></ol><h3 id="待优化"><a href="#待优化" class="headerlink" title="待优化"></a>待优化</h3><ol><li>现在链接顺序和 eclipse 编译出来的不一致，导致二进制不同（经测试，手动改变链接顺序，改成与 eclipse 一致，编译结果 bin 一致）。</li><li>没根据系统选择不同的cmake脚本，linux 下可能不兼容。</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AUTOSAR Memory Stack 架构</title>
      <link href="/2023/08/24/230824-AutoSarNVRAM/"/>
      <url>/2023/08/24/230824-AutoSarNVRAM/</url>
      
        <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://www.fer.unizg.hr/_download/repository/3._Vjestine_AUTOSAR_MemStack._v3.pdf">AUTOSAR Memory Stack(MemStack)</a></li><li><a href="https://www.autosar.org/fileadmin/standards/R20-11/CP/AUTOSAR_SWS_NVRAMManager.pdf">Specification of NVRAM Manager</a></li><li><a href="https://www.autosar.org/fileadmin/standards/R21-11/CP/AUTOSAR_EXP_NVDataHandling.pdf">NV Data Handling Guideline</a></li></ol><h3 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h3><p>为了管理汽车领域中的非易失性存储器(NV Memory)，在AUTOSAR环境中使用了内存协议栈(MemStack)。</p><p>AUTOSAR中的MemStack主要有以下功能：</p><ol><li>数据检索：以结构化方式存储数据</li><li>数据存储：对NV Memory的读取与写入</li><li>抽象层：对不同的内部或外部NV Memory提供抽象</li><li>耐久性管理：管理内存写入周期</li><li>错误处理和纠正：管理NV Memory的纠错和错误检测机制</li><li>内存块管理：管理内存块(Memory Block)</li><li>地址映射：虚拟地址到物理地址的映射</li></ol><p>AUTOSAR的内存协议栈为应用层和基础软件(BSW)模块提供访问非易失性存储器的服务（例如读写）。使用AUTOSAR MemStack API，应用层中的软件组件(SWC)和BSW模块可以从NV Memory读取数据并将数据写入NV Memory，例如诊断事件管理器(DEM)使用MemStack服务将冻结帧数据写入NV Memory。</p><h3 id="存储协议栈架构"><a href="#存储协议栈架构" class="headerlink" title="存储协议栈架构"></a>存储协议栈架构</h3><p><img src="https://gitee.com/hao0527/hao0527/raw/img/230824-AutoSarNVRAM/230824-AutoSarNVRAM-1.jpg" alt="img"></p><p>NvM访问内存抽象接口(MemIf)，该接口抽象了Flash模拟Eep模块(Fee)和EEPROM抽象模块(Ea)。因此，NvM是硬件无关的。</p><p>应用程序通常不直接访问BSW模块的服务。它们通过RTE和BSW模块提供的服务端口进行连接。应用程序SWC或NV SWC可以从NV Memory读取或写入数据。NvM将调用传递给MemIf，调用将传递给内存驱动模块，驱动模块将数据写入NV Memory。如果是外部Flash（通过SPI连接）的情况下，将使用SPI驱动程序。</p><h4 id="NvM（NVRAM-Manager）"><a href="#NvM（NVRAM-Manager）" class="headerlink" title="NvM（NVRAM Manager）"></a>NvM（NVRAM Manager）</h4><p>NvM模块提供了数据存储和数据维护的服务。NvM模块位于AUTOSAR堆栈的服务层中，并向用户（即SWC）提供从NV Memory读取数据或写入数据的服务。NvM是访问NV Memory的唯一方式，或者我们可以说NvM是SWC访问NV Memory的网关。</p><p>NvM执行存储器的初始化、NV Block的错误更正和错误检测。</p><h4 id="MemIf-Fee-Ea（Memory-Abstraction-Interface）"><a href="#MemIf-Fee-Ea（Memory-Abstraction-Interface）" class="headerlink" title="MemIf/Fee/Ea（Memory Abstraction Interface）"></a>MemIf/Fee/Ea（Memory Abstraction Interface）</h4><p>MemIf提供了对底层Fee或Ea模块的抽象，因此上层模块（例如NVRAM管理器）会请求MemIf模块进行读/写操作，然后MemIf模块将请求传递给底层的Fee或Ea模块。</p><p>Fee和Ea提供虚拟32位地址空间，并抽象出设备特定的寻址方案。Fee和Ea将虚拟地址转换为物理地址。</p><h4 id="Fls-EEP（Memory-Driver）"><a href="#Fls-EEP（Memory-Driver）" class="headerlink" title="Fls/EEP（Memory Driver）"></a>Fls/EEP（Memory Driver）</h4><p>存储器驱动程序用于访问mcu的内部flash或外部存储器。存储器驱动程序提供从EEPROM或Flash存储器读取、写入和擦除的功能。Fls驱动程序与Flash存储器相关联，EEP驱动程序与EEPROM存储器相关联。</p><p>用于外部EEPROM的驱动程序使用处理程序（在大多数情况下为SPI）或驱动程序来访问外部EEPROM设备，它位于ECU抽象层中。</p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>今年的一项PBC：仿照AUTOSAR的存储器协议栈，开发一套适合自己公司使用的存储器协议栈。经过大半年零散的、自下而上的开发与测试，我的软件终于上量产车使用了，这几天整理下资料和回顾下开发过程，后续再写些文章。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> AUTOSAR </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言源码保护技术</title>
      <link href="/2023/08/22/230822-sourceProtect/"/>
      <url>/2023/08/22/230822-sourceProtect/</url>
      
        <content type="html"><![CDATA[<h2 id="源码保护技术"><a href="#源码保护技术" class="headerlink" title="源码保护技术"></a>源码保护技术</h2><p>对于一些大软件工程，可能有一部分模块代码是从第三方获取来的，并且可能是不开源的。前段时间给别的部门软件组提供了一份快充协议栈的模块，使用静态库的方式提供，提供头文件给用户调用协议栈中的函数及读取全局变量，快充协议栈的输入也是有模块内部调用用户提供的指定函数，或指定的全局变量实现，在工程最后链接的时候会将静态库中未链接的符号链接到外部代码的地址。</p><p>今天在看PAN1020的SDK，一款蓝牙SOC，它里面的协议栈是不开源的，厂家提供hex文件，于是在想用户需如何集成hex到自己工程，用户代码要如何与协议栈不开源的代码建立联系。自己的猜想基本是对的，厂家还会提供一份头文件，里面有用户需要调用的函数或全局变量，和静态库不同的是，头文件中不是变量和函数的声明，而是需要让用户知道，所需的全局变量与函数在这份hex文件中的哪个位置。</p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>厂家提供的hex文件需要链接到指定地址，以下是PAN1020未开源模块所提供的头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_FUN_ADDR0x00016600</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//app fun register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_dbg_sys_write_register (*(volatile uint32_t *)(STACK_FUN_ADDR))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*dbg_sys_write_register_handler)</span><span class="params">(<span class="type">void</span> (*call)(<span class="type">uint16_t</span> address, <span class="type">uint16_t</span> data))</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_appm_init_register (*(volatile uint32_t *)(STACK_FUN_ADDR + 4))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*appm_init_register_handler)</span><span class="params">(<span class="type">void</span> (*call)(<span class="type">void</span>))</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_hci_init_register  (*(volatile uint32_t *)(STACK_FUN_ADDR + 8))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*hci_init_register_handler)</span><span class="params">(<span class="type">void</span> (*call)(<span class="type">bool</span> reset))</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_hci_send_2_controller_register (*(volatile uint32_t *)(STACK_FUN_ADDR + 12))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*hci_send_2_controller_register_handler)</span><span class="params">(<span class="type">void</span> (*call)(<span class="type">void</span> *param))</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_attm_svc_create_db_register (*(volatile uint32_t *)(STACK_FUN_ADDR + 16))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*attm_svc_create_db_register_handler)</span><span class="params">(<span class="type">uint8_t</span> (*call)(<span class="type">uint16_t</span> *shdl, <span class="type">uint16_t</span> uuid, <span class="type">uint8_t</span> *cfg_flag, <span class="type">uint8_t</span> max_nb_att,</span></span><br><span class="line"><span class="params">                           <span class="type">uint8_t</span> *att_tbl, <span class="type">ke_task_id_t</span> <span class="type">const</span> dest_id,<span class="type">const</span> <span class="keyword">struct</span> attm_desc *att_db, <span class="type">uint8_t</span> svc_perm))</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SVC_gattc_con_enable_register (*(volatile uint32_t *)(STACK_FUN_ADDR + 20))</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*gattc_con_enable_register_handler)</span><span class="params">(<span class="type">void</span> (*call)(<span class="type">uint8_t</span> conidx))</span>;</span><br></pre></td></tr></table></figure><p>一开始，我以为是要将hex链接到0x00016600地址，头文件中给出的是函数在hex中的偏移地址。hex文件是带地址的，我用jflash一看后才明白，hex的起始地址是0，0x00016600地址上存放的是一个网表，用来存放函数的真实地址，网表其实就是函数指针类型的数组。</p><p>代码中的<code>(STACK_FUN_ADDR + offset)</code>其实就是函数指针的地址，所以<code>(*(volatile uint32_t *)(STACK_FUN_ADDR + offset))</code>就是取出函数指针的值，这个是函数真实所在的地址。头文件中还有函数指针的typedef，可以通过函数指针类型知道每个函数的形参和返回值。</p><p>有了函数地址与函数类型，用户就可以通过以下方式去调用库中的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">app_fun_resgister</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">((appm_init_register_handler)SVC_appm_init_register)(appm_init);</span><br><span class="line">((hci_init_register_handler)SVC_hci_init_register)(hci_init);</span><br><span class="line">((hci_send_2_controller_register_handler)SVC_hci_send_2_controller_register)(hci_send_2_controller);</span><br><span class="line">((attm_svc_create_db_register_handler)SVC_attm_svc_create_db_register)(attm_svc_create_db);</span><br><span class="line">((gattc_con_enable_register_handler)SVC_gattc_con_enable_register)(gattc_con_enable);</span><br><span class="line">((gattm_cleanup_register_handler)SVC_gattm_cleanup_register)(gattm_cleanup);</span><br><span class="line">((gattm_create_register_handler)SVC_gattm_create_register)(gattm_create);</span><br><span class="line">((prf_cleanup_register_handler)SVC_prf_cleanup_register)(prf_cleanup);</span><br><span class="line">((prf_create_register_handler)SVC_prf_create_register)(prf_create);</span><br><span class="line">((prf_get_id_from_task_register_handler)SVC_prf_get_id_from_task_register)(prf_get_id_from_task);</span><br><span class="line">((prf_get_task_from_id_register_handler)SVC_prf_get_task_from_id_register)(prf_get_task_from_id);</span><br><span class="line">((prf_init_register_handler)SVC_prf_init_register)(prf_init);</span><br><span class="line">((attm_att_update_perm_register_handler)SVC_attm_att_update_perm_register)(attm_att_update_perm);</span><br><span class="line">((gattm_init_attr_register_handler)SVC_gattm_init_attr_register)(gattm_init_attr);</span><br><span class="line">((hci_basic_cmd_send_2_controller_register_handler)SVC_hci_basic_cmd_send_2_controller_register)(hci_basic_cmd_send_2_controller);</span><br><span class="line">((prf_add_profile_register_handler)SVC_prf_add_profile_register)(prf_add_profile);</span><br><span class="line">((gattc_get_mtu_register_handler)SVC_gattc_get_mtu_register)(gattc_get_mtu);</span><br><span class="line">((attm_init_register_handler)SVC_attm_init_register)(attm_init);</span><br><span class="line">((gattm_init_register_handler)SVC_gattm_init_register)(gattm_init);</span><br><span class="line">((hci_send_2_host_register_handler)SVC_hci_send_2_host_register)(hci_send_2_host);</span><br><span class="line">((attmdb_destroy_register_handler)SVC_attmdb_destroy_register)(attmdb_destroy);</span><br><span class="line">((sleep_handler_register)SVC_sleep_handler_register)(sleep_handler);</span><br><span class="line">((ble_event_handler_register)SVC_ble_event_handler_register)(ble_event_handler);</span><br><span class="line">((rf_init_handler_register)SVC_rf_init_handler_register)(rf_init_handler);</span><br><span class="line">((ble_rx_handler_register)SVC_ble_rx_handler_register)(ble_rx_handler);</span><br><span class="line">((rf_dev_cal_init_handler_register)SVC_rf_dev_cal_init_handler_register)(rf_dev_cal_init_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码为初始化模块中，用户将模块所需要的一些函数注册到模块中。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>PAN1020这种方式保护源码，让用户不可见源码，相比我之前封静态库的方式有以下优势：</p><ol><li>编译模块的时候不需要其他模块的头文件声明，通过模块对外提供注册函数的方式，获取外部函数地址后调用。我之前静态库的方式就需要在编译模块的时候提供其他模块的函数声明头文件，而且如果链接的时候找不到还会链接失败。</li><li>这种由外部注册函数的方式，模块所依赖其他模块的函数名可以关心，如果用静态库方式就外部函数的函数名就必须与声明的一致。</li><li>提供给用户hex，比静态库文件的信息更少，静态库中有网表信息，hex中只有二进制文件和地址。</li></ol><p>是否可以将一个工程的各模块分开独立，编译成各个hex后再集成？优点：可以使公司的源码不易泄露，每个人都维护自己的模块。</p><p>让各个模块编译完hex后的地址都为0开始，hex中网表的前两个为模块init和模块main。用户将所有的hex链接到指定flash地址，配置给os各模块网表起始地址，网表大小，模块调度周期。因为网表的前两个是init和main，所以os可以轻松创建好任务。模块与模块之间调用，由模块向os请求获取特定模块特定网表index的函数地址。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内核代码风格</title>
      <link href="/2023/06/25/230625-Linux%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
      <url>/2023/06/25/230625-Linux%E5%86%85%E6%A0%B8%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p>Chinese translated version of Documentation/process/coding-style.rst</p><p>If you have any comment or update to the content, please post to LKML directly. However, if you have problem communicating in English you can also ask the Chinese maintainer for help. Contact the Chinese maintainer, if this translation is outdated or there is problem with translation.</p><p>Chinese maintainer: Zhang Le &lt;<a href="mailto:r0bertz@gentoo.org">r0bertz@gentoo.org</a>&gt;</p><hr><p>Documentation/process/coding-style.rst 的中文翻译</p><p>如果想评论或更新本文的内容，请直接发信到LKML。如果你使用英文交流有困难的话， 也可以向中文版维护者求助。如果本翻译更新不及时或者翻译存在问题，请联系中文版 维护者:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">中文版维护者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</span><br><span class="line">中文版翻译者： 张乐 Zhang Le &lt;r0bertz@gentoo.org&gt;</span><br><span class="line">中文版校译者： 王聪 Wang Cong &lt;xiyou.wangcong@gmail.com&gt;</span><br><span class="line">               wheelz &lt;kernel.zeng@gmail.com&gt;</span><br><span class="line">               管旭东 Xudong Guan &lt;xudong.guan@gmail.com&gt;</span><br><span class="line">               Li Zefan &lt;lizf@cn.fujitsu.com&gt;</span><br><span class="line">               Wang Chen &lt;wangchen@cn.fujitsu.com&gt;</span><br></pre></td></tr></table></figure><p>以下为正文</p><hr><h1 id="Linux-内核代码风格"><a href="#Linux-内核代码风格" class="headerlink" title="Linux 内核代码风格"></a>Linux 内核代码风格</h1><p>这是一个简短的文档，描述了 linux 内核的首选代码风格。代码风格是因人而异的， 而且我不愿意把自己的观点强加给任何人，但这就像我去做任何事情都必须遵循的原则 那样，我也希望在绝大多数事上保持这种的态度。请 (在写代码时) 至少考虑一下这里 的代码风格。</p><p>首先，我建议你打印一份 GNU 代码规范，然后不要读。烧了它，这是一个具有重大象征性意义的动作。</p><p>不管怎样，现在我们开始：</p><h2 id="1-缩进"><a href="#1-缩进" class="headerlink" title="1) 缩进"></a>1) 缩进</h2><p>制表符是 8 个字符，所以缩进也是 8 个字符。有些异端运动试图将缩进变为 4 (甚至 2！) 字符深，这几乎相当于尝试将圆周率的值定义为 3。</p><p>理由：缩进的全部意义就在于清楚的定义一个控制块起止于何处。尤其是当你盯着你的 屏幕连续看了 20 小时之后，你将会发现大一点的缩进会使你更容易分辨缩进。</p><p>现在，有些人会抱怨 8 个字符的缩进会使代码向右边移动的太远，在 80 个字符的终端屏幕上就很难读这样的代码。这个问题的答案是，如果你需要 3 级以上的缩进，不管用 何种方式你的代码已经有问题了，应该修正你的程序。</p><p>简而言之，<u>8 个字符的缩进可以让代码更容易阅读，还有一个好处是当你的函数嵌套太深的时候可以给你警告。留心这个警告</u>。</p><p>在 switch 语句中消除多级缩进的首选的方式是让 <code>switch</code> 和从属于它的 <code>case</code> 标签对齐于同一列，而不要 <code>两次缩进</code> <code>case</code> 标签。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (suffix) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">        mem &lt;&lt;= <span class="number">30</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">        mem &lt;&lt;= <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;k&#x27;</span>:</span><br><span class="line">        mem &lt;&lt;= <span class="number">10</span>;</span><br><span class="line">        <span class="comment">/* fall through */</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要把多个语句放在一行里，除非你有什么东西要隐藏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) do_this;</span><br><span class="line">  do_something_everytime;</span><br></pre></td></tr></table></figure><p>也不要在一行里放多个赋值语句。内核代码风格超级简单。就是避免可能导致别人误读 的表达式。</p><p>除了注释、文档和 Kconfig 之外，不要使用空格来缩进，前面的例子是例外，是有意为 之。</p><p>选用一个好的编辑器，不要在行尾留空格。</p><h2 id="2-把长的行和字符串打散"><a href="#2-把长的行和字符串打散" class="headerlink" title="2) 把长的行和字符串打散"></a>2) 把长的行和字符串打散</h2><p>代码风格的意义就在于使用平常使用的工具来维持代码的可读性和可维护性。</p><p>每一行的长度的限制是 80 列，我们强烈建议您遵守这个惯例。</p><p>长于 80 列的语句要打散成有意义的片段。除非超过 80 列能显著增加可读性，并且不 会隐藏信息。子片段要明显短于母片段，并明显靠右。这同样适用于有着很长参数列表 的函数头。然而，绝对不要打散对用户可见的字符串，例如 printk 信息，因为这样就 很难对它们 grep。</p><h2 id="3-大括号和空格的放置"><a href="#3-大括号和空格的放置" class="headerlink" title="3) 大括号和空格的放置"></a>3) 大括号和空格的放置</h2><p>C 语言风格中另外一个常见问题是大括号的放置。和缩进大小不同，选择或弃用某种放置策略并没有多少技术上的原因，不过首选的方式，就像 Kernighan 和 Ritchie 展示 给我们的，是把起始大括号放在行尾，而把结束大括号放在行首，所以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (x is true) &#123;</span><br><span class="line">        we do y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这适用于所有的非函数语句块 (if, switch, for, while, do)。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (action) &#123;</span><br><span class="line">case KOBJ_ADD:</span><br><span class="line">        return &quot;add&quot;;</span><br><span class="line">case KOBJ_REMOVE:</span><br><span class="line">        return &quot;remove&quot;;</span><br><span class="line">case KOBJ_CHANGE:</span><br><span class="line">        return &quot;change&quot;;</span><br><span class="line">default:</span><br><span class="line">        return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，有一个例外，那就是函数：函数的起始大括号放置于下一行的开头，所以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int function(int x)</span><br><span class="line">&#123;</span><br><span class="line">        body of function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全世界的异端可能会抱怨这个不一致性是… 呃… 不一致的，不过所有思维健全的人 都知道 (a) K&amp;R 是 <strong>正确的</strong> 并且 (b) K&amp;R 是正确的。此外，不管怎样函数都是特 殊的 (C 函数是不能嵌套的)。</p><p>注意结束大括号独自占据一行，除非它后面跟着同一个语句的剩余部分，也就是 do 语 句中的 “while” 或者 if 语句中的 “else”，像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">        body of do-loop</span><br><span class="line">&#125; while (condition);</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (x == y) &#123;</span><br><span class="line">        ..</span><br><span class="line">&#125; else if (x &gt; y) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理由：K&amp;R。</p><p>也请注意这种大括号的放置方式也能使空 (或者差不多空的) 行的数量最小化，同时不失可读性。因此，由于你的屏幕上的新行是不可再生资源 (想想 25 行的终端屏幕)，你 将会有更多的空行来放置注释。</p><p>当只有一个单独的语句的时候，不用加不必要的大括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">        action();</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">        do_this();</span><br><span class="line">else</span><br><span class="line">        do_that();</span><br></pre></td></tr></table></figure><p>这并不适用于只有一个条件分支是单语句的情况；这时所有分支都要使用大括号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">        do_this();</span><br><span class="line">        do_that();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        otherwise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-空格"><a href="#3-1-空格" class="headerlink" title="3.1) 空格"></a>3.1) 空格</h3><p>Linux 内核的空格使用方式 (主要) 取决于它是用于函数还是关键字。(大多数) 关键字后要加一个空格。值得注意的例外是 sizeof, typeof, alignof 和 __attribute__，这 些关键字某些程度上看起来更像函数 (它们在 Linux 里也常常伴随小括号而使用，尽管 在 C 里这样的小括号不是必需的，就像 <code>struct fileinfo info;</code> 声明过后的 <code>sizeof info</code>)。</p><p>所以在这些关键字之后放一个空格:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if, switch, case, for, do, while</span><br></pre></td></tr></table></figure><p>但是不要在 sizeof, typeof, alignof 或者 <strong>attribute</strong> 这些关键字之后放空格。 例如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = sizeof(struct file);</span><br></pre></td></tr></table></figure><p>不要在小括号里的表达式两侧加空格。这是一个 <strong>反例</strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = sizeof( struct file );</span><br></pre></td></tr></table></figure><p><u>当声明指针类型或者返回指针类型的函数时， <code>*</code> 的首选使用方式是使之靠近变量名或者函数名，而不是靠近类型名</u>。例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *linux_banner;</span><br><span class="line">unsigned long long memparse(char *ptr, char **retptr);</span><br><span class="line">char *match_strdup(substring_t *s);</span><br></pre></td></tr></table></figure><p><u>在大多数二元和三元操作符两侧使用一个空格</u>，例如下面所有这些操作符:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=  +  -  &lt;  &gt;  *  /  %  |  &amp;  ^  &lt;=  &gt;=  ==  !=  ?  :</span><br></pre></td></tr></table></figure><p><u>但是一元操作符后不要加空格</u>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined</span><br></pre></td></tr></table></figure><p>后缀自加和自减一元操作符前不加空格:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++  --</span><br></pre></td></tr></table></figure><p>前缀自加和自减一元操作符后不加空格:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++  --</span><br></pre></td></tr></table></figure><p><code>.</code> 和 <code>-&gt;</code> 结构体成员操作符前后不加空格。</p><p>不要在行尾留空白。有些可以自动缩进的编辑器会在新行的行首加入适量的空白，然后 你就可以直接在那一行输入代码。不过假如你最后没有在那一行输入代码，有些编辑器 就不会移除已经加入的空白，就像你故意留下一个只有空白的行。包含行尾空白的行就 这样产生了。</p><p>当 git 发现补丁包含了行尾空白的时候会警告你，并且可以应你的要求去掉行尾空白； 不过如果你是正在打一系列补丁，这样做会导致后面的补丁失败，因为你改变了补丁的上下文。</p><h2 id="4-命名"><a href="#4-命名" class="headerlink" title="4) 命名"></a>4) 命名</h2><p>C 是一个简朴的语言，你的命名也应该这样。和 Modula-2 和 Pascal 程序员不同， C 程序员不使用类似 ThisVariableIsATemporaryCounter 这样华丽的名字。C 程序员会 称那个变量为 <code>tmp</code> ，这样写起来会更容易，而且至少不会令其难于理解。</p><p>不过，虽然混用大小写的名字是不提倡使用的，但是全局变量还是需要一个具描述性的名字。称一个全局函数为 <code>foo</code> 是一个难以饶恕的错误。</p><p>全局变量 (只有当你 <strong>真正</strong> 需要它们的时候再用它) 需要有一个具描述性的名字，就像全局函数。如果你有一个可以计算活动用户数量的函数，你应该叫它 <code>count_active_users()</code> 或者类似的名字，你不应该叫它 <code>cntuser()</code> 。</p><p>在函数名中包含函数类型 (所谓的匈牙利命名法) 是脑子出了问题——编译器知道那些类 型而且能够检查那些类型，这样做只能把程序员弄糊涂了。难怪微软总是制造出有问题的程序。</p><p>本地变量名应该简短，而且能够表达相关的含义。如果你有一些随机的整数型的循环计数器，它应该被称为 <code>i</code> 。叫它 <code>loop_counter</code> 并无益处，如果它没有被误解的可能的话。类似的， <code>tmp</code> 可以用来称呼任意类型的临时变量。</p><p>如果你怕混淆了你的本地变量名，你就遇到另一个问题了，叫做函数增长荷尔蒙失衡综合症。请看第六章 (函数)。</p><h2 id="5-Typedef"><a href="#5-Typedef" class="headerlink" title="5) Typedef"></a>5) Typedef</h2><p>不要使用类似 <code>vps_t</code> 之类的东西。</p><p>对结构体和指针使用 typedef 是一个 <strong>错误</strong> 。当你在代码里看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vps_t a;</span><br></pre></td></tr></table></figure><p>这代表什么意思呢？</p><p>相反，如果是这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct virtual_container *a;</span><br></pre></td></tr></table></figure><p>你就知道 <code>a</code> 是什么了。</p><p>很多人认为 typedef <code>能提高可读性</code> 。实际不是这样的。它们只在下列情况下有用：</p><blockquote><ol><li><p>完全不透明的对象 (这种情况下要主动使用 typedef 来 <strong>隐藏</strong> 这个对象实际上是什么)。</p><p>例如： <code>pte_t</code> 等不透明对象，你只能用合适的访问函数来访问它们。</p><p>Note：不透明性和 “访问函数” 本身是不好的。我们使用 pte_t 等类型的原因在于真的是完全没有任何共用的可访问信息。</p></li><li><p>清楚的整数类型，如此，这层抽象就可以 <strong>帮助</strong> 消除到底是 <code>int</code> 还是 <code>long</code> 的混淆。</p><p>u8/u16/u32 是完全没有问题的 typedef，不过它们更符合类别 (d) 而不是这里。</p><p>Note：要这样做，必须事出有因。如果某个变量是 <code>unsigned long</code> ，那么没有必要 typedef unsigned long myflags_t;</p><p>不过如果有一个明确的原因，比如它在某种情况下可能会是一个 <code>unsigned int</code> 而在其他情况下可能为 <code>unsigned long</code> ，那么就不要犹豫，请务必使用 typedef。</p></li><li><p>当你使用 sparse 按字面的创建一个 <strong>新</strong> 类型来做类型检查的时候。</p></li><li><p>和标准 C99 类型相同的类型，在某些例外的情况下。</p><p>虽然让眼睛和脑筋来适应新的标准类型比如 <code>uint32_t</code> 不需要花很多时间，可是有些人仍然拒绝使用它们。</p><p>因此，Linux 特有的等同于标准类型的 <code>u8/u16/u32/u64</code> 类型和它们的有符号类型是被允许的——尽管在你自己的新代码中，它们不是强制要求要使用的。</p><p>当编辑已经使用了某个类型集的已有代码时，你应该遵循那些代码中已经做出的选择。</p></li><li><p>可以在用户空间安全使用的类型。</p><p>在某些用户空间可见的结构体里，我们不能要求 C99 类型而且不能用上面提到的 <code>u32</code> 类型。因此，我们在与用户空间共享的所有结构体中使用 __u32 和类似 的类型。</p></li></ol></blockquote><p>可能还有其他的情况，不过基本的规则是 <strong>永远不要</strong> 使用 typedef，除非你可以明确的应用上述某个规则中的一个。</p><p>总的来说，如果一个指针或者一个结构体里的元素可以合理的被直接访问到，那么它们就不应该是一个 typedef。</p><h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6) 函数"></a>6) 函数</h2><p><u>函数应该简短而漂亮，并且只完成一件事情</u>。函数应该可以一屏或者两屏显示完 (我们 都知道 ISO/ANSI 屏幕大小是 80x24)，只做一件事情，而且把它做好。</p><p>一个函数的最大长度是和该函数的复杂度和缩进级数成反比的。所以，如果你有一个理论上很简单的只有一个很长 (但是简单) 的 case 语句的函数，而且你需要在每个 case 里做很多很小的事情，这样的函数尽管很长，但也是可以的。</p><p>不过，如果你有一个复杂的函数，而且你怀疑一个天分不是很高的高中一年级学生可能甚至搞不清楚这个函数的目的，你应该严格遵守前面提到的长度限制。使用辅助函数， 并为之取个具描述性的名字 (如果你觉得它们的性能很重要的话，可以让编译器内联它们，这样的效果往往会比你写一个复杂函数的效果要好。)</p><p>函数的另外一个衡量标准是本地变量的数量。此数量不应超过 5－10 个，否则你的函数 就有问题了。重新考虑一下你的函数，把它分拆成更小的函数。人的大脑一般可以轻松的同时跟踪 7 个不同的事物，如果再增多的话，就会糊涂了。即便你聪颖过人，你也可能会记不清你 2 个星期前做过的事情。</p><p>在源文件里，使用空行隔开不同的函数。如果该函数需要被导出，它的 <strong>EXPORT</strong> 宏 应该紧贴在它的结束大括号之下。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int system_is_up(void)</span><br><span class="line">&#123;</span><br><span class="line">        return system_state == SYSTEM_RUNNING;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(system_is_up);</span><br></pre></td></tr></table></figure><p>在函数原型中，包含函数名和它们的数据类型。虽然 C 语言里没有这样的要求，在 Linux 里这是提倡的做法，因为这样可以很简单的给读者提供更多的有价值的信息。</p><h2 id="7-集中的函数退出途径"><a href="#7-集中的函数退出途径" class="headerlink" title="7) 集中的函数退出途径"></a>7) 集中的函数退出途径</h2><p>虽然被某些人声称已经过时，但是 goto 语句的等价物还是经常被编译器所使用，具体形式是无条件跳转指令。</p><p>当一个函数从多个位置退出，并且需要做一些类似清理的常见操作时，goto 语句就很方便了。如果并不需要清理操作，那么直接 return 即可。</p><p>选择一个能够说明 goto 行为或它为何存在的标签名。如果 goto 要释放 <code>buffer</code>, 一个不错的名字可以是 <code>out_free_buffer:</code> 。别去使用像 <code>err1:</code> 和 <code>err2:</code> 这样的GW_BASIC 名称，因为一旦你添加或删除了 (函数的) 退出路径，你就必须对它们重新编号，这样会难以去检验正确性。</p><p>使用 goto 的理由是：</p><ul><li>无条件语句容易理解和跟踪</li><li>嵌套程度减小</li><li>可以避免由于修改时忘记更新个别的退出点而导致错误</li><li>让编译器省去删除冗余代码的工作 ;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int fun(int a)</span><br><span class="line">&#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        char *buffer;</span><br><span class="line"></span><br><span class="line">        buffer = kmalloc(SIZE, GFP_KERNEL);</span><br><span class="line">        if (!buffer)</span><br><span class="line">                return -ENOMEM;</span><br><span class="line"></span><br><span class="line">        if (condition1) &#123;</span><br><span class="line">                while (loop1) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                &#125;</span><br><span class="line">                result = 1;</span><br><span class="line">                goto out_free_buffer;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">out_free_buffer:</span><br><span class="line">        kfree(buffer);</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个需要注意的常见错误是 <code>一个 err 错误</code> ，就像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err:</span><br><span class="line">        kfree(foo-&gt;bar);</span><br><span class="line">        kfree(foo);</span><br><span class="line">        return ret;</span><br></pre></td></tr></table></figure><p>这段代码的错误是，在某些退出路径上 <code>foo</code> 是 NULL。通常情况下，通过把它分离 成两个错误标签 <code>err_free_bar:</code> 和 <code>err_free_foo:</code> 来修复这个错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">err_free_bar:</span><br><span class="line">       kfree(foo-&gt;bar);</span><br><span class="line">err_free_foo:</span><br><span class="line">       kfree(foo);</span><br><span class="line">       return ret;</span><br></pre></td></tr></table></figure><p>理想情况下，你应该模拟错误来测试所有退出路径。</p><h2 id="8-注释"><a href="#8-注释" class="headerlink" title="8) 注释"></a>8) 注释</h2><p>注释是好的，不过有过度注释的危险。永远不要在注释里解释你的代码是如何运作的： 更好的做法是让别人一看你的代码就可以明白，<u>解释写的很差的代码是浪费时间</u>。</p><p>一般的，你想要你的注释告诉别人你的代码做了什么，而不是怎么做的。也请你不要把注释放在一个函数体内部：如果函数复杂到你需要独立的注释其中的一部分，你很可能需要回到第六章看一看。你可以做一些小注释来注明或警告某些很聪明 (或者槽糕) 的做法，但不要加太多。你应该做的，是把注释放在函数的头部，告诉人们它做了什么， 也可以加上它做这些事情的原因。</p><p>当注释内核 API 函数时，请使用 kernel-doc 格式。请看 Documentation/doc-guide/ 和 scripts/kernel-doc 以获得详细信息。</p><p>长 (多行) 注释的首选风格是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This is the preferred style for multi-line</span><br><span class="line"> * comments in the Linux kernel source code.</span><br><span class="line"> * Please use it consistently.</span><br><span class="line"> *</span><br><span class="line"> * Description:  A column of asterisks on the left side,</span><br><span class="line"> * with beginning and ending almost-blank lines.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>对于在 net/ 和 drivers/net/ 的文件，首选的长 (多行) 注释风格有些不同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* The preferred comment style for files in net/ and drivers/net</span><br><span class="line"> * looks like this.</span><br><span class="line"> *</span><br><span class="line"> * It is nearly the same as the generally preferred comment style,</span><br><span class="line"> * but there is no initial almost-blank line.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>注释数据也是很重要的，不管是基本类型还是衍生类型。为了方便实现这一点，每一行 应只声明一个数据 (不要使用逗号来一次声明多个数据)。这样你就有空间来为每个数据 写一段小注释来解释它们的用途了。</p><h2 id="9-你已经把事情弄糟了"><a href="#9-你已经把事情弄糟了" class="headerlink" title="9) 你已经把事情弄糟了"></a>9) 你已经把事情弄糟了</h2><p>这没什么，我们都是这样。可能你的使用了很长时间 Unix 的朋友已经告诉你 <code>GNU emacs</code> 能自动帮你格式化 C 源代码，而且你也注意到了，确实是这样，不过它 所使用的默认值和我们想要的相去甚远 (实际上，甚至比随机打的还要差——无数个猴子 在 GNU emacs 里打字永远不会创造出一个好程序) (译注：Infinite Monkey Theorem)</p><p>所以你要么放弃 GNU emacs，要么改变它让它使用更合理的设定。要采用后一个方案， 你可以把下面这段粘贴到你的 .emacs 文件里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(defun c-lineup-arglist-tabs-only (ignored)</span><br><span class="line">  &quot;Line up argument lists by tabs, not spaces&quot;</span><br><span class="line">  (let* ((anchor (c-langelem-pos c-syntactic-element))</span><br><span class="line">         (column (c-langelem-2nd-pos c-syntactic-element))</span><br><span class="line">         (offset (- (1+ column) anchor))</span><br><span class="line">         (steps (floor offset c-basic-offset)))</span><br><span class="line">    (* (max steps 1)</span><br><span class="line">       c-basic-offset)))</span><br><span class="line"></span><br><span class="line">(add-hook &#x27;c-mode-common-hook</span><br><span class="line">          (lambda ()</span><br><span class="line">            ;; Add kernel style</span><br><span class="line">            (c-add-style</span><br><span class="line">             &quot;linux-tabs-only&quot;</span><br><span class="line">             &#x27;(&quot;linux&quot; (c-offsets-alist</span><br><span class="line">                        (arglist-cont-nonempty</span><br><span class="line">                         c-lineup-gcc-asm-reg</span><br><span class="line">                         c-lineup-arglist-tabs-only))))))</span><br><span class="line"></span><br><span class="line">(add-hook &#x27;c-mode-hook</span><br><span class="line">          (lambda ()</span><br><span class="line">            (let ((filename (buffer-file-name)))</span><br><span class="line">              ;; Enable kernel mode for the appropriate files</span><br><span class="line">              (when (and filename</span><br><span class="line">                         (string-match (expand-file-name &quot;~/src/linux-trees&quot;)</span><br><span class="line">                                       filename))</span><br><span class="line">                (setq indent-tabs-mode t)</span><br><span class="line">                (setq show-trailing-whitespace t)</span><br><span class="line">                (c-set-style &quot;linux-tabs-only&quot;)))))</span><br></pre></td></tr></table></figure><p>这会让 emacs 在 <code>~/src/linux-trees</code> 下的 C 源文件获得更好的内核代码风格。</p><p>不过就算你尝试让 emacs 正确的格式化代码失败了，也并不意味着你失去了一切：还可以用 <code>indent</code> 。</p><p>不过，GNU indent 也有和 GNU emacs 一样有问题的设定，所以你需要给它一些命令选项。不过，这还不算太糟糕，因为就算是 GNU indent 的作者也认同 K&amp;R 的权威性 (GNU 的人并不是坏人，他们只是在这个问题上被严重的误导了)，所以你只要给 indent 指定选项 <code>-kr -i8</code> (代表 <code>K&amp;R，8 字符缩进</code>)，或使用 <code>scripts/Lindent</code> 这样就可以以最时髦的方式缩进源代码。</p><p><code>indent</code> 有很多选项，特别是重新格式化注释的时候，你可能需要看一下它的手册。 不过记住： <code>indent</code> 不能修正坏的编程习惯。</p><h2 id="10-Kconfig-配置文件"><a href="#10-Kconfig-配置文件" class="headerlink" title="10) Kconfig 配置文件"></a>10) Kconfig 配置文件</h2><p>对于遍布源码树的所有 Kconfig* 配置文件来说，它们缩进方式有所不同。紧挨着 <code>config</code> 定义的行，用一个制表符缩进，然而 help 信息的缩进则额外增加 2 个空格。举个例子:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config AUDIT</span><br><span class="line">      bool &quot;Auditing support&quot;</span><br><span class="line">      depends on NET</span><br><span class="line">      help</span><br><span class="line">        Enable auditing infrastructure that can be used with another</span><br><span class="line">        kernel subsystem, such as SELinux (which requires this for</span><br><span class="line">        logging of avc messages output).  Does not do system-call</span><br><span class="line">        auditing without CONFIG_AUDITSYSCALL.</span><br></pre></td></tr></table></figure><p>而那些危险的功能 (比如某些文件系统的写支持) 应该在它们的提示字符串里显著的声 明这一点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config ADFS_FS_RW</span><br><span class="line">      bool &quot;ADFS write support (DANGEROUS)&quot;</span><br><span class="line">      depends on ADFS_FS</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure><p>要查看配置文件的完整文档，请看 Documentation/kbuild/kconfig-language.txt。</p><h2 id="11-数据结构"><a href="#11-数据结构" class="headerlink" title="11) 数据结构"></a>11) 数据结构</h2><p>如果一个数据结构，在创建和销毁它的单线执行环境之外可见，那么它必须要有一个引用计数器。内核里没有垃圾收集 (并且内核之外的垃圾收集慢且效率低下)，这意味着你绝对需要记录你对这种数据结构的使用情况。</p><p>引用计数意味着你能够避免上锁，并且允许多个用户并行访问这个数据结构——而不需要担心这个数据结构仅仅因为暂时不被使用就消失了，那些用户可能不过是沉睡了一阵或者做了一些其他事情而已。</p><p>注意上锁 <strong>不能</strong> 取代引用计数。上锁是为了保持数据结构的一致性，而引用计数是一个内存管理技巧。通常二者都需要，不要把两个搞混了。</p><p>很多数据结构实际上有 2 级引用计数，它们通常有不同 <code>类</code> 的用户。子类计数器统计子类用户的数量，每当子类计数器减至零时，全局计数器减一。</p><p>这种 <code>多级引用计数</code> 的例子可以在内存管理 (<code>struct mm_struct</code>: mm_users 和 mm_count)，和文件系统 (<code>struct super_block</code>: s_count 和 s_active) 中找到。</p><p>记住：如果另一个执行线索可以找到你的数据结构，但这个数据结构没有引用计数器， 这里几乎肯定是一个 bug。</p><h2 id="12-宏，枚举和RTL"><a href="#12-宏，枚举和RTL" class="headerlink" title="12) 宏，枚举和RTL"></a>12) 宏，枚举和RTL</h2><p>用于定义常量的宏的名字及枚举里的标签需要大写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define CONSTANT 0x12345</span><br></pre></td></tr></table></figure><p>在定义几个相关的常量时，最好用枚举。</p><p>宏的名字请用大写字母，不过形如函数的宏的名字可以用小写字母。</p><p>一般的，如果能写成内联函数就不要写成像函数的宏。</p><p>含有多个语句的宏应该被包含在一个 do-while 代码块里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define macrofun(a, b, c)                       \</span><br><span class="line">        do &#123;                                    \</span><br><span class="line">                if (a == 5)                     \</span><br><span class="line">                        do_this(b, c);          \</span><br><span class="line">        &#125; while (0)</span><br></pre></td></tr></table></figure><p>使用宏的时候应避免的事情：</p><ol><li>影响控制流程的宏：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define FOO(x)                                  \</span><br><span class="line">        do &#123;                                    \</span><br><span class="line">                if (blah(x) &lt; 0)                \</span><br><span class="line">                        return -EBUGGERED;      \</span><br><span class="line">        &#125; while (0)</span><br></pre></td></tr></table></figure><p><strong>非常</strong> 不好。它看起来像一个函数，不过却能导致 <code>调用</code> 它的函数退出；不要打 乱读者大脑里的语法分析器。</p><ol><li>依赖于一个固定名字的本地变量的宏：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define FOO(val) bar(index, val)</span><br></pre></td></tr></table></figure><p>可能看起来像是个不错的东西，不过它非常容易把读代码的人搞糊涂，而且容易导致看起来不相关的改动带来错误。</p><ol><li>作为左值的带参数的宏： FOO(x) = y；如果有人把 FOO 变成一个内联函数的话，这 种用法就会出错了。</li><li>忘记了优先级：使用表达式定义常量的宏必须将表达式置于一对小括号之内。带参数 的宏也要注意此类问题。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define CONSTANT 0x4000</span><br><span class="line">#define CONSTEXP (CONSTANT | 3)</span><br></pre></td></tr></table></figure><ol><li>在宏里定义类似函数的本地变量时命名冲突：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define FOO(x)                          \</span><br><span class="line">(&#123;                                      \</span><br><span class="line">        typeof(x) ret;                  \</span><br><span class="line">        ret = calc_ret(x);              \</span><br><span class="line">        (ret);                          \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><u>ret 是本地变量的通用名字 - __foo_ret 更不容易与一个已存在的变量冲突。</u></p><p>cpp 手册对宏的讲解很详细。gcc internals 手册也详细讲解了 RTL，内核里的汇编语言经常用到它。</p><h2 id="13-打印内核消息"><a href="#13-打印内核消息" class="headerlink" title="13) 打印内核消息"></a>13) 打印内核消息</h2><p>内核开发者应该是受过良好教育的。请一定注意内核信息的拼写，以给人以好的印象。 不要用不规范的单词比如 <code>dont</code>，而要用 <code>do not</code> 或者 <code>don&#39;t</code> 。保证这些信息简单明了，无歧义。</p><p>内核信息不必以英文句号结束。</p><p>在小括号里打印数字 (%d) 没有任何价值，应该避免这样做。</p><p>&lt;linux/device.h&gt; 里有一些驱动模型诊断宏，你应该使用它们，以确保信息对应于正确的设备和驱动，并且被标记了正确的消息级别。这些宏有：dev_err(), dev_warn(), dev_info() 等等。对于那些不和某个特定设备相关连的信息，&lt;linux/printk.h&gt; 定义了 pr_notice(), pr_info(), pr_warn(), pr_err() 和其他。</p><p>写出好的调试信息可以是一个很大的挑战；一旦你写出后，这些信息在远程出错时能提供极大的帮助。然而打印调试信息的处理方式同打印非调试信息不同。其他 pr_XXX() 函数能无条件地打印，pr_debug() 却不；默认情况下它不会被编译，除非定义了 DEBUG 或设定了 CONFIG_DYNAMIC_DEBUG。实际这同样是为了 dev_dbg()，一个相关约定是在一个已经开启了 DEBUG 时，使用 VERBOSE_DEBUG 来添加 dev_vdbg()。</p><p>许多子系统拥有 Kconfig 调试选项来开启 -DDEBUG 在对应的 Makefile 里面；在其他情况下，特殊文件使用 #define DEBUG。当一条调试信息需要被无条件打印时，例如，如果已经包含一个调试相关的 #ifdef 条件，printk(KERN_DEBUG …) 就可被使用。</p><h2 id="14-分配内存"><a href="#14-分配内存" class="headerlink" title="14) 分配内存"></a>14) 分配内存</h2><p>内核提供了下面的一般用途的内存分配函数： kmalloc(), kzalloc(), kmalloc_array(), kcalloc(), vmalloc() 和 vzalloc()。 请参考 API 文档以获取有关它们的详细信息。</p><p>传递结构体大小的首选形式是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = kmalloc(sizeof(*p), ...);</span><br></pre></td></tr></table></figure><p>另外一种传递方式中，sizeof 的操作数是结构体的名字，这样会降低可读性，并且可能会引入 bug。有可能指针变量类型被改变时，而对应的传递给内存分配函数的 sizeof 的结果不变。</p><p>强制转换一个 void 指针返回值是多余的。C 语言本身保证了从 void 指针到其他任何指针类型的转换是没有问题的。</p><p>分配一个数组的首选形式是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = kmalloc_array(n, sizeof(...), ...);</span><br></pre></td></tr></table></figure><p>分配一个零长数组的首选形式是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = kcalloc(n, sizeof(...), ...);</span><br></pre></td></tr></table></figure><p>两种形式检查分配大小 n * sizeof(…) 的溢出，如果溢出返回 NULL。</p><h2 id="15-内联弊病"><a href="#15-内联弊病" class="headerlink" title="15) 内联弊病"></a>15) 内联弊病</h2><p>有一个常见的误解是 <code>内联</code> 是 gcc 提供的可以让代码运行更快的一个选项。虽然使 用内联函数有时候是恰当的 (比如作为一种替代宏的方式，请看第十二章)，不过很多情况下不是这样。inline 的过度使用会使内核变大，从而使整个系统运行速度变慢。 <u>因为体积大内核会占用更多的指令高速缓存</u>，而且会导致 pagecache 的可用内存减少。 想象一下，一次 pagecache 未命中就会导致一次磁盘寻址，将耗时 5 毫秒。5 毫秒的 时间内 CPU 能执行很多很多指令。</p><p><u>一个基本的原则是如果一个函数有 3 行以上，就不要把它变成内联函数</u>。这个原则的一个例外是，如果你知道某个参数是一个编译时常量，而且因为这个常量你确定编译器在编译时能优化掉你的函数的大部分代码，那仍然可以给它加上 inline 关键字。 kmalloc() 内联函数就是一个很好的例子。</p><p>人们经常主张给 static 的而且只用了一次的函数加上 inline，如此不会有任何损失， 因为没有什么好权衡的。虽然从技术上说这是正确的，但是实际上这种情况下即使不加 inline gcc 也可以自动使其内联。而且其他用户可能会要求移除 inline，由此而来的争论会抵消 inline 自身的潜在价值，得不偿失。</p><h2 id="16-函数返回值及命名"><a href="#16-函数返回值及命名" class="headerlink" title="16) 函数返回值及命名"></a>16) 函数返回值及命名</h2><p>函数可以返回多种不同类型的值，最常见的一种是表明函数执行成功或者失败的值。这样 的一个值可以表示为一个错误代码整数 (-Exxx＝失败，0＝成功) 或者一个 <code>成功</code> 布尔值 (0＝失败，非0＝成功)。</p><p>混合使用这两种表达方式是难于发现的 bug 的来源。如果 C 语言本身严格区分整形和布尔型变量，那么编译器就能够帮我们发现这些错误… 不过 C 语言不区分。为了避免 产生这种 bug，请遵循下面的惯例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果函数的名字是一个动作或者强制性的命令，那么这个函数应该返回错误代</span><br><span class="line">码整数。如果是一个判断，那么函数应该返回一个 &quot;成功&quot; 布尔值。</span><br></pre></td></tr></table></figure><p>比如， <code>add work</code> 是一个命令，所以 add_work() 在成功时返回 0，在失败时返回 -EBUSY。类似的，因为 <code>PCI device present</code> 是一个判断，所以 pci_dev_present() 在成功找到一个匹配的设备时应该返回 1，如果找不到时应该返回 0。</p><p>所有 EXPORTed 函数都必须遵守这个惯例，所有的公共函数也都应该如此。私有 (static) 函数不需要如此，但是我们也推荐这样做。</p><p>返回值是实际计算结果而不是计算是否成功的标志的函数不受此惯例的限制。一般的， 他们通过返回一些正常值范围之外的结果来表示出错。典型的例子是返回指针的函数， 他们使用 NULL 或者 ERR_PTR 机制来报告错误。</p><h2 id="17-不要重新发明内核宏"><a href="#17-不要重新发明内核宏" class="headerlink" title="17) 不要重新发明内核宏"></a>17) 不要重新发明内核宏</h2><p>头文件 include/linux/kernel.h 包含了一些宏，你应该使用它们，而不要自己写一些它们的变种。比如，如果你需要计算一个数组的长度，使用这个宏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))</span><br></pre></td></tr></table></figure><p>类似的，如果你要计算某结构体成员的大小，使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define FIELD_SIZEOF(t, f) (sizeof(((t*)0)-&gt;f))</span><br></pre></td></tr></table></figure><p>还有可以做严格的类型检查的 min() 和 max() 宏，如果你需要可以使用它们。你可以自己看看那个头文件里还定义了什么你可以拿来用的东西，如果有定义的话，你就不应在你的代码里自己重新定义。</p><h2 id="18-编辑器模式行和其他需要罗嗦的事情"><a href="#18-编辑器模式行和其他需要罗嗦的事情" class="headerlink" title="18) 编辑器模式行和其他需要罗嗦的事情"></a>18) 编辑器模式行和其他需要罗嗦的事情</h2><p>有一些编辑器可以解释嵌入在源文件里的由一些特殊标记标明的配置信息。比如，emacs 能够解释被标记成这样的行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-*- mode: c -*-</span><br></pre></td></tr></table></figure><p>或者这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Local Variables:</span><br><span class="line">compile-command: &quot;gcc -DMAGIC_DEBUG_FLAG foo.c&quot;</span><br><span class="line">End:</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>Vim 能够解释这样的标记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* vim:set sw=8 noet */</span><br></pre></td></tr></table></figure><p>不要在源代码中包含任何这样的内容。每个人都有他自己的编辑器配置，你的源文件不应该覆盖别人的配置。这包括有关缩进和模式配置的标记。人们可以使用他们自己定制的模式，或者使用其他可以产生正确的缩进的巧妙方法。</p><h2 id="19-内联汇编"><a href="#19-内联汇编" class="headerlink" title="19) 内联汇编"></a>19) 内联汇编</h2><p>在特定架构的代码中，你可能需要内联汇编与 CPU 和平台相关功能连接。需要这么做时就不要犹豫。然而，当 C 可以完成工作时，不要平白无故地使用内联汇编。在可能的情况下，你可以并且应该用 C 和硬件沟通。</p><p>请考虑去写捆绑通用位元 (wrap common bits) 的内联汇编的简单辅助函数，别去重复地写下只有细微差异内联汇编。记住内联汇编可以使用 C 参数。</p><p>大型，有一定复杂度的汇编函数应该放在 .S 文件内，用相应的 C 原型定义在 C 头文 件中。汇编函数的 C 原型应该使用 <code>asmlinkage</code> 。</p><p>你可能需要把汇编语句标记为 volatile，用来阻止 GCC 在没发现任何副作用后就把它 移除了。你不必总是这样做，尽管，这不必要的举动会限制优化。</p><p>在写一个包含多条指令的单个内联汇编语句时，把每条指令用引号分割而且各占一行， 除了最后一条指令外，在每个指令结尾加上 nt，让汇编输出时可以正确地缩进下一条 指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">asm (&quot;magic %reg1, #42\n\t&quot;</span><br><span class="line">     &quot;more_magic %reg2, %reg3&quot;</span><br><span class="line">     : /* outputs */ : /* inputs */ : /* clobbers */);</span><br></pre></td></tr></table></figure><h2 id="20-条件编译"><a href="#20-条件编译" class="headerlink" title="20) 条件编译"></a>20) 条件编译</h2><p>只要可能，就不要在 .c 文件里面使用预处理条件 (#if, #ifdef)；这样做让代码更难阅读并且更难去跟踪逻辑。替代方案是，<u>在头文件中用预处理条件提供给那些 .c 文件使用，再给 #else 提供一个空桩 (no-op stub) 版本</u>，然后在 .c 文件内无条件地调用 那些 (定义在头文件内的) 函数。这样做，编译器会避免为桩函数 (stub) 的调用生成任何代码，产生的结果是相同的，但逻辑将更加清晰。</p><p>最好倾向于编译整个函数，而不是函数的一部分或表达式的一部分。与其放一个 ifdef 在表达式内，不如分解出部分或全部表达式，放进一个单独的辅助函数，并应用预处理 条件到这个辅助函数内。</p><p>如果你有一个在特定配置中，可能变成未使用的函数或变量，编译器会警告它定义了但未使用，把它标记为 __maybe_unused 而不是将它包含在一个预处理条件中。(然而，如果一个函数或变量总是未使用，就直接删除它。)</p><p>在代码中，尽可能地使用 IS_ENABLED 宏来转化某个 Kconfig 标记为 C 的布尔 表达式，并在一般的 C 条件中使用它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (IS_ENABLED(CONFIG_SOMETHING)) &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会做常量折叠，然后就像使用 #ifdef 那样去包含或排除代码块，所以这不会带来任何运行时开销。然而，这种方法依旧允许 C 编译器查看块内的代码，并检查它的正确性 (语法，类型，符号引用，等等)。因此，如果条件不满足，代码块内的引用符号就不存在时，你还是必须去用 #ifdef。</p><p>在任何有意义的 #if 或 #ifdef 块的末尾 (超过几行的)，在 #endif 同一行的后面写下注解，注释这个条件表达式。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifdef CONFIG_SOMETHING</span><br><span class="line">...</span><br><span class="line">#endif /* CONFIG_SOMETHING */</span><br></pre></td></tr></table></figure><h2 id="附录-I-参考"><a href="#附录-I-参考" class="headerlink" title="附录 I) 参考"></a>附录 I) 参考</h2><p>The C Programming Language, 第二版 作者：Brian W. Kernighan 和 Denni M. Ritchie. Prentice Hall, Inc., 1988. ISBN 0-13-110362-8 (软皮), 0-13-110370-9 (硬皮).</p><p>The Practice of Programming 作者：Brian W. Kernighan 和 Rob Pike. Addison-Wesley, Inc., 1999. ISBN 0-201-61586-X.</p><p>GNU 手册 - 遵循 K&amp;R 标准和此文本 - cpp, gcc, gcc internals and indent, 都可以从 <a href="http://www.gnu.org/manual/">http://www.gnu.org/manual/</a> 找到</p><p>WG14 是 C 语言的国际标准化工作组，URL: <a href="http://www.open-std.org/JTC1/SC22/WG14/">http://www.open-std.org/JTC1/SC22/WG14/</a></p><p>Kernel process/coding-style.rst，作者 <a href="mailto:greg@kroah.com">greg@kroah.com</a> 发表于 OLS 2002： <a href="http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/">http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何从Git仓库中将模块分离成独立仓库并保留其提交历史？</title>
      <link href="/2023/05/15/230515-gitSubTree/"/>
      <url>/2023/05/15/230515-gitSubTree/</url>
      
        <content type="html"><![CDATA[<h2 id="如何从Git仓库中将模块分离成独立仓库并保留其提交历史？"><a href="#如何从Git仓库中将模块分离成独立仓库并保留其提交历史？" class="headerlink" title="如何从Git仓库中将模块分离成独立仓库并保留其提交历史？"></a>如何从Git仓库中将模块分离成独立仓库并保留其提交历史？</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><ul><li>部门代码管理使用的SVN，由于Git可以提交至本地，自己在本地又使用Git管理代码，使用Git管理了一整个工程，在开发不同模块时切到不同分支，一开始没把模块独立放到一个Git仓库，现在想独立模块，又想保留其提交历史，故有此文。</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://shantanoo-desai.github.io/posts/technology/git_subtree/">subtrees in Git: How to split Directories into individual standalone repositories</a></li><li><a href="https://stackoverflow.com/questions/25559260/assertion-failed-errors-when-trying-to-git-subtree-split">assertion failed errors when trying to git subtree split</a></li><li><a href="https://stackoverflow.com/questions/74486167/git-clone-recurse-submodules-throws-error-on-macos-transmission-type-file-n">Git clone –recurse-submodules throws error on MacOs: Transmission type ‘file’ not allowed</a></li><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">Git 工具 - 子模块</a></li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol><li>将子目录拆分独立库：<code>git subtree split -P &lt;name-of-folder&gt; -b &lt;name-of-new-branch&gt;</code>，注意此行命令需要在Git仓库toplevel目录执行，<code>&lt;name-of-folder&gt;</code>需要避免在前面加<code>./</code>，避免使用反斜杠，否则会产生assertion failed errors，解决方案就是改掉就行，参考：<a href="https://stackoverflow.com/questions/25559260/assertion-failed-errors-when-trying-to-git-subtree-split">assertion failed errors when trying to git subtree split</a></li><li>拆分独立库后此仓库在<code>&lt;name-of-new-branch&gt;</code>分支中会保存模块代码和提交记录，然后<code>mkdir &lt;name-of-new-branch&gt; &amp;&amp; cd &lt;name-of-new-branch&gt; &amp;&amp; git</code>，我参考别人的操作使用<code>git pull &lt;/path/to/big-repo&gt; &lt;name-of-new-branch&gt;</code>拉取上级目录的指定分支到一个新的文件夹好像不太行，网上暂时没查到<code>/path/to</code>的用法。我使用的方式是将老仓库<code>&lt;name-of-new-branch&gt;</code>分支代码push，然后使用<code>git pull &lt;repo-path.git&gt; &lt;name-of-new-branch&gt;</code>拉来的代码。</li><li>上一步操作后就已经将代码和历史提交记录全部拉到了一个新仓库，后续就可以将新仓库Push。</li></ol><h3 id="如何在工程的Git仓库中引用模块仓库？"><a href="#如何在工程的Git仓库中引用模块仓库？" class="headerlink" title="如何在工程的Git仓库中引用模块仓库？"></a>如何在工程的Git仓库中引用模块仓库？</h3><ol><li><p>参考Git文档：<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97">Git 工具 - 子模块</a></p><blockquote><p>我们首先将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。 你可以通过在 git submodule add 命令后面加上想要跟踪的项目的相对或绝对 URL 来添加新的子模块。 在本例中，我们将会添加一个名为 “DbConnector” 的库。<br>$ git submodule add <a href="https://github.com/chaconinc/DbConnector">https://github.com/chaconinc/DbConnector</a><br>Cloning into ‘DbConnector’…<br>remote: Counting objects: 11, done.<br>remote: Compressing objects: 100% (10/10), done.<br>remote: Total 11 (delta 0), reused 11 (delta 0)<br>Unpacking objects: 100% (11/11), done.<br>Checking connectivity… done.<br>默认情况下，子模块会将子项目放到一个与仓库同名的目录中，本例中是 “DbConnector”。 如果你想要放到其他地方，那么可以在命令结尾添加一个不同的路径。</p></blockquote></li><li><p>如果一个分支有子模块，另一个分支没有，直接 checkout 后会造成子模块的文件在另一个分支未被删除，可以在 checkout 前使用<code>git submodule deinit --all</code>命令来卸载当前分支已安装的所有子模块，在 checkout 后，如果另一个分支也有子模块，可以使用<code>git submodule init</code>命令注册子模块，再使用<code>git submodule update</code>从子模块库中取出文件。</p></li><li><p>我使用的子模块库是本地的Git仓库，在拉库的时候首次会报<code>Transmission type &#39;file&#39; not allowed</code>的错误，需通过<code>git config --global protocol.file.allow always</code>配置Git，参考：<a href="https://stackoverflow.com/questions/74486167/git-clone-recurse-submodules-throws-error-on-macos-transmission-type-file-n">Git clone –recurse-submodules throws error on MacOs: Transmission type ‘file’ not allowed</a></p></li></ol><h3 id="Git子模块和子树区别"><a href="#Git子模块和子树区别" class="headerlink" title="Git子模块和子树区别"></a>Git子模块和子树区别</h3><p>Git子模块（submodule）和子树（subtree）都是Git中用于将外部仓库包含到自己的仓库中的机制。虽然它们的目的相似，但在功能和使用方式上有一些区别。</p><h4 id="Git子模块："><a href="#Git子模块：" class="headerlink" title="Git子模块："></a>Git子模块：</h4><ul><li>子模块是对外部仓库中特定提交的引用。</li><li>当你将一个子模块添加到你的仓库时，你在自己的仓库中包含了指向另一个仓库的链接，它作为一个子目录存在。</li><li>子模块维护着独立的Git历史，被视为独立的仓库。它们有自己的分支、标签和提交历史。</li><li>每个子模块引用指向外部仓库中的特定提交。你可以通过显式地拉取变更来更新子模块到新的提交。</li><li>子模块通常用于在你的仓库中包含另一个项目作为依赖项，但希望保持两个代码库的分离。</li></ul><h4 id="Git子树："><a href="#Git子树：" class="headerlink" title="Git子树："></a>Git子树：</h4><ul><li>子树允许你直接将外部仓库的内容嵌入到自己仓库的子目录中。</li><li>当你向你的仓库添加子树时，你将另一个仓库的文件导入并合并到你的仓库的子目录中。导入的文件成为你的仓库历史的一部分。</li><li>子树不维护独立的Git历史。相反，外部仓库的提交会合并到你的仓库的历史中。</li><li>子树允许你在你的仓库中直接对导入的代码进行修改。如果你有写入权限，你也可以将修改的内容推送回原始仓库。</li><li>子树通常用于将另一个项目的代码作为你仓库的一部分，并将其视为你代码库的一个组成部分。</li></ul><p>总结而言，子模块提供了一种将外部仓库作为独立实体包含在你的仓库中的方式，而子树允许你将外部仓库的内容合并到你的仓库历史中。选择使用子模块还是子树取决于你的具体需求和工作流程。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 版本管控 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言 宏的高级用法</title>
      <link href="/2023/03/10/230310-macro/"/>
      <url>/2023/03/10/230310-macro/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串转换符"><a href="#字符串转换符" class="headerlink" title="字符串转换符"></a>字符串转换符</h3><p>使用<code>#</code>运算符可以将宏参数替换为一个字符串，并用双引号括起来，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT_STR(x) printf(<span class="string">&quot;The string is: %s\n&quot;</span>, #x)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    PRINT_STR(Hello World);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例程序中，定义了一个宏PRINT_STR，它的参数x通过#运算符被转换为一个字符串，并被传递给printf函数进行输出。运行这个程序会输出：<code>The string is: Hello World</code></p><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>在C语言中，宏定义可以使用##运算符进行字符串拼接，称为连接运算符（Token Pasting Operator）。<code>##</code>运算符可以将两个标记（Token）连接成一个标记，从而实现字符串拼接的功能。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONCAT(x, y) x##y</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> xy = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, CONCAT(x, y));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例程序中，定义了一个宏CONCAT，它使用<code>##</code>运算符将两个参数x和y连接成一个标记。在main函数中定义了一个变量xy，并将连接后的标记xy作为参数传递给printf函数进行输出。输出结果是：<code>10</code></p><h3 id="变长参数宏"><a href="#变长参数宏" class="headerlink" title="变长参数宏"></a>变长参数宏</h3><p>C语言中的变长参数宏（Variadic Macro）可以接受可变数量的参数。变长参数宏是通过使用特殊的预处理符号<code>__VA_ARGS__</code>来实现的，它表示可变参数的列表。下面是一个简单的示例，展示了如何使用变长参数宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF(...) printf(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    PRINTF(<span class="string">&quot;x = %d, str = %s\n&quot;</span>, x, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例程序中，定义了一个宏PRINTF，它使用printf函数打印可变数量的参数。使用<code>__VA_ARGS__</code>表示可变参数的列表。在main函数中，PRINTF宏被调用，传递了三个参数，包括一个整数和一个字符串。输出结果是：<code>x = 10, str = hello</code></p><h3 id="宏：取最大值"><a href="#宏：取最大值" class="headerlink" title="宏：取最大值"></a>宏：取最大值</h3><p>一种方式：<code>#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))</code><br>这种方式需要注意参数如果有自增运算，需要在传参的时候加括号，否则自增运算会重复两次。<br>正确调用方法如：<code>z = MAX((x++), (y++));</code></p><p>使用下面一种方式可以避免此类问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) (&#123; \</span></span><br><span class="line"><span class="meta">    typeof(a) _a = (a); \</span></span><br><span class="line"><span class="meta">    typeof(b) _b = (b); \</span></span><br><span class="line"><span class="meta">    (void)(&amp;_a == &amp;_b); \</span></span><br><span class="line"><span class="meta">    _a &gt; _b ? _a : _b; \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p><code>typeof</code>是GNU C编译器内置的一种类型描述符，用于表示表达式的类型。在编译时，编译器会根据<code>typeof(x)</code>对象的类型生成一个类型的值，并将其插入到代码中。</p><p>比较难理解的是<code>(void)(&amp;_a == &amp;_b);</code>，看起来很多余，仔细分析一下，你会发现这条语句很有意思。它的作用有两个： </p><ol><li>用来给用户提示一个警告，对于不同类型的指针比较，编译器会发出一个警告， 提示两种数据的类型不同。<code>warning: comparison of distinct pointer types lacks a cast.</code></li><li>两个数进行比较运算，运算的结果却没有用到，有些编译器可能会给出一个warning，加一个<code>(void)</code>后，就可以消除这个警告。</li></ol><h3 id="宏：offsetof"><a href="#宏：offsetof" class="headerlink" title="宏：offsetof"></a>宏：offsetof</h3><p><code>offsetof</code>是一个宏，用于获取结构体中成员的偏移量。实现是使用指针运算来计算结构体成员的偏移量。具体实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(type, member) ((size_t) &amp;((type *)0)-&gt;member)</span></span><br></pre></td></tr></table></figure><p>其中，type表示结构体类型，member表示结构体成员。在宏展开时，(type *)0将一个空指针强制转换为结构体指针类型，然后通过指针运算获取成员的地址。由于空指针的地址为0，因此可以确保这个地址不会指向任何实际的内存位置，避免了访问非法内存的风险。最后，将成员的地址转换为size_t类型的偏移量，并返回。</p><p>需要注意的是，offsetof宏只能用于标准布局的结构体，即结构体中的成员按照其定义顺序依次存储，没有嵌套、位域、虚函数等。对于非标准布局的结构体，offsetof可能无法正确计算成员的偏移量。</p><h3 id="宏：container-of"><a href="#宏：container-of" class="headerlink" title="宏：container_of"></a>宏：container_of</h3><p><code>container_of</code>是一个宏，用于从结构体的成员指针计算出结构体的地址。其实现通常基于<code>offsetof</code>宏和指针运算。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    ((type *)((char *)(ptr) - offsetof(type, member)))</span></span><br></pre></td></tr></table></figure><p>其中，ptr表示结构体成员的指针，type表示结构体类型，member表示结构体成员名。offsetof(type, member)用于计算结构体成员在结构体中的偏移量，(char *)(ptr)将成员指针转换为char类型指针，以便进行指针运算。通过成员指针的地址减去成员在结构体中的偏移量，可以得到结构体的地址。最后，将地址转换为type类型的指针，并返回。</p><p>container_of宏常用于实现Linux内核中的数据结构，如链表、哈希表等。它可以方便地从链表节点或哈希桶中获取对应的数据结构。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言 复合字面量(Compound Literals)</title>
      <link href="/2023/03/09/230309-CompoundLiterals/"/>
      <url>/2023/03/09/230309-CompoundLiterals/</url>
      
        <content type="html"><![CDATA[<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Compound-Literals.html">https://gcc.gnu.org/onlinedocs/gcc/Compound-Literals.html</a></li></ul><h3 id="复合字面量介绍"><a href="#复合字面量介绍" class="headerlink" title="复合字面量介绍"></a>复合字面量介绍</h3><p>假设给带int类型的形参函数传递一个值，可以传递int类型的变量，也可以传递int类型常量，但是对于带数组形参的函数则不一样，可以传递数组，但是不支持传递数组常量，由此C99新增了复合字面量的用法，字面量是指除符号常量外的常量。</p><p>例如：10是int的类型的字面量，10.24是double类型的字面量，”abc”是字符串的字面量等，如果有数组或者结构体的字面量，这样使用起来会更方便。</p><h3 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h3><p>数组的复合字面量和数组初始化列表差不多，前面使用括号括起来的类型名。<br>例如，这是个数组定义：<code>int age[2] = [19, 20];</code><br>使用复合字面量创建一个匿名数组：<code>(int [2])&#123;19, 20&#125;;</code><br>可见去掉定义中的数组名，留下的int[2]就是复合字面量的类型名，整个就是数组字面量。<br>使用数组字面量时可以像定义数组一样省略数组大小，也可以应用于二维或多维数组。<br>还可构造一个字符串数组，将复合字面量强制转换为指向其第一个元素的指针，如：<code>char **foo = (char *[]) &#123; &quot;x&quot;, &quot;y&quot;, &quot;z&quot; &#125;;</code></p><h3 id="结构体字面量"><a href="#结构体字面量" class="headerlink" title="结构体字面量"></a>结构体字面量</h3><p>结构体的复合字面量的指定类型是一个结构体。<br>假设，struct foo 和 structure 声明如：<code>struct foo &#123;int a; char b[2];&#125; structure;</code><br>使用复合字面量构造 struct foo 的示例：<code>structure = ((struct foo) &#123;x + y, &#39;a&#39;, 0&#125;);</code><br>这等效于：<code>&#123;   struct foo temp = &#123;x + y, &#39;a&#39;, 0&#125;;   structure = temp; &#125;</code></p><h3 id="复合字面量生命周期"><a href="#复合字面量生命周期" class="headerlink" title="复合字面量生命周期"></a>复合字面量生命周期</h3><p>在 C 语言中，复合字面量指定具有静态或自动存储持续时间的未命名对象。在 C++ 中，复合字面量指定一个临时对象，该对象仅在其完整表达式结束之前存在。因此，采用复合字面量的子对象地址的定义良好的 C 代码在 C++ 中可以是未定义的，因此 G++ 拒绝将临时数组转换为指针。例如，如果上面的数组复合字面量示例出现在函数内部，则在 C++ 中对 foo 的任何后续使用都会产生未定义的行为，因为数组的生命周期在 foo 的声明之后结束。</p><p>作为一种优化，G++ 有时会为数组复合字面量提供更长的生命周期：当数组出现在函数外部或具有 const 限定类型时。如果 foo 及其初始值设定项具有 char *const 而不是 char * 类型的元素，或者如果 foo 是全局变量，则数组将具有静态存储持续时间。但是，避免在 C++ 代码中使用数组复合字面量可能是最安全的。</p><h3 id="复合字面量应用"><a href="#复合字面量应用" class="headerlink" title="复合字面量应用"></a>复合字面量应用</h3><ol><li>函数参数是结构体、数组，用复合字面量传参。</li><li>程序运行中想给char数组赋字符串。</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分析c语言函数调用时的汇编代码，进出函数时CPU做了什么？</title>
      <link href="/2023/03/07/230307-cAsm/"/>
      <url>/2023/03/07/230307-cAsm/</url>
      
        <content type="html"><![CDATA[<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span><span class="type">int</span> a; <span class="type">int</span> b; <span class="type">int</span> c; <span class="type">int</span> d; <span class="type">int</span> e;&#125; g_stTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">struct</span> foo <span class="title function_">testFun2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">stTest</span>;</span></span><br><span class="line">    stTest.a = a;</span><br><span class="line">    stTest.b = b;</span><br><span class="line">    stTest.c = c;</span><br><span class="line">    stTest.d = d;</span><br><span class="line">    stTest.e = e;</span><br><span class="line">    <span class="keyword">return</span> stTest;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">void</span> <span class="title function_">testFun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_stTest = testFun2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p>用gcc工具链编译s32k144平台的代码，通过ozone分析elf得到反汇编如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">void</span> <span class="title function_">testFun1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 0002C74C   PUSH           &#123;R4-R5, R7, LR&#125;</span></span><br><span class="line"><span class="comment">// 0002C74E   SUB            SP, SP, #32</span></span><br><span class="line"><span class="comment">// 0002C750   ADD            R7, SP, #8</span></span><br><span class="line">    g_stTest = testFun2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 0002C752   LDR            R4, =g_stTest                 ; [PC, #40] [0x0002C77C] =0x20002318</span></span><br><span class="line">    <span class="comment">// 0002C754   MOV            R2, R7</span></span><br><span class="line">    <span class="comment">// 0002C756   MOVS           R3, #4</span></span><br><span class="line">    <span class="comment">// 0002C758   STR            R3, [SP, #0]</span></span><br><span class="line">    <span class="comment">// 0002C75A   MOVS           R3, #5</span></span><br><span class="line">    <span class="comment">// 0002C75C   STR            R3, [SP, #4]</span></span><br><span class="line">    <span class="comment">// 0002C75E   MOV            R0, R2</span></span><br><span class="line">    <span class="comment">// 0002C760   MOVS           R1, #1</span></span><br><span class="line">    <span class="comment">// 0002C762   MOVS           R2, #2</span></span><br><span class="line">    <span class="comment">// 0002C764   MOVS           R3, #3</span></span><br><span class="line">    <span class="comment">// 0002C766   BL             testFun2                      ; 0x0002C710</span></span><br><span class="line">    <span class="comment">// 0002C76A   MOV            R5, R4</span></span><br><span class="line">    <span class="comment">// 0002C76C   MOV            R4, R7</span></span><br><span class="line">    <span class="comment">// 0002C76E   LDM            R4!, &#123;R0-R3&#125;</span></span><br><span class="line">    <span class="comment">// 0002C770   STM            R5!, &#123;R0-R3&#125;</span></span><br><span class="line">    <span class="comment">// 0002C772   LDR            R3, [R4]</span></span><br><span class="line">    <span class="comment">// 0002C774   STR            R3, [R5]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0002C776   ADDS           R7, #24</span></span><br><span class="line"><span class="comment">// 0002C778   MOV            SP, R7</span></span><br><span class="line"><span class="comment">// 0002C77A   POP            &#123;R4-R5, R7, PC&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">struct</span> foo <span class="title function_">testFun2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 0002C710   PUSH           &#123;R4-R5, R7&#125;</span></span><br><span class="line"><span class="comment">// 0002C712   SUB            SP, SP, #44</span></span><br><span class="line"><span class="comment">// 0002C714   ADD            R7, SP, #0</span></span><br><span class="line"><span class="comment">// 0002C716   STR            R0, [R7, #12]</span></span><br><span class="line"><span class="comment">// 0002C718   STR            R1, [R7, #8]</span></span><br><span class="line"><span class="comment">// 0002C71A   STR            R2, [R7, #4]</span></span><br><span class="line"><span class="comment">// 0002C71C   STR            R3, [R7]</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">stTest</span>;</span></span><br><span class="line">    stTest.a = a;</span><br><span class="line">    <span class="comment">// 0002C71E   LDR            R3, [R7, #8]</span></span><br><span class="line">    <span class="comment">// 0002C720   STR            R3, [R7, #20]</span></span><br><span class="line">    stTest.b = b;</span><br><span class="line">    <span class="comment">// 0002C722   LDR            R3, [R7, #4]</span></span><br><span class="line">    <span class="comment">// 0002C724   STR            R3, [R7, #24]</span></span><br><span class="line">    stTest.c = c;</span><br><span class="line">    <span class="comment">// 0002C726   LDR            R3, [R7]</span></span><br><span class="line">    <span class="comment">// 0002C728   STR            R3, [R7, #28]</span></span><br><span class="line">    stTest.d = d;</span><br><span class="line">    <span class="comment">// 0002C72A   LDR            R3, [R7, #56]</span></span><br><span class="line">    <span class="comment">// 0002C72C   STR            R3, [R7, #32]</span></span><br><span class="line">    stTest.e = e;</span><br><span class="line">    <span class="comment">// 0002C72E   LDR            R3, [R7, #60]</span></span><br><span class="line">    <span class="comment">// 0002C730   STR            R3, [R7, #36]</span></span><br><span class="line">    <span class="keyword">return</span> stTest;</span><br><span class="line">    <span class="comment">// 0002C732   LDR            R3, [R7, #12]</span></span><br><span class="line">    <span class="comment">// 0002C734   MOV            R5, R3</span></span><br><span class="line">    <span class="comment">// 0002C736   ADD.W          R4, R7, #20</span></span><br><span class="line">    <span class="comment">// 0002C73A   LDM            R4!, &#123;R0-R3&#125;</span></span><br><span class="line">    <span class="comment">// 0002C73C   STM            R5!, &#123;R0-R3&#125;</span></span><br><span class="line">    <span class="comment">// 0002C73E   LDR            R3, [R4]</span></span><br><span class="line">    <span class="comment">// 0002C740   STR            R3, [R5]</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 0002C742   LDR            R0, [R7, #12]</span></span><br><span class="line"><span class="comment">// 0002C744   ADDS           R7, #44</span></span><br><span class="line"><span class="comment">// 0002C746   MOV            SP, R7</span></span><br><span class="line"><span class="comment">// 0002C748   POP            &#123;R4-R5, R7&#125;</span></span><br><span class="line"><span class="comment">// 0002C74A   BX             LR</span></span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol><li>在进入函数后，首先会将R4, R5, R7寄存器压栈，使用PUSH指令后SP会自动减去压栈空间的大小。</li><li>然后是SP减去一个直接数，是在给局部变量、形参和参数传递开辟栈区空间。</li><li>R7 = SP + 偏移，R7是局部变量所在栈区的地址，偏移的大小是函数内调用函数时，参数传递所需要的空间大小。</li><li><code>g_stTest = testFun2(1, 2, 3, 4, 5);</code>反汇编中，参数4, 5通过栈传递，参数1, 2, 3通过R1~R3寄存器传递。</li><li>在<code>testFun2</code>函数进入后，<code>STR R0, [R7, #12]</code>等指令，会将R0~R3寄存器传递的参数存入（局部变量）栈中，为什么传参的还有R0？</li><li>重新分析<code>g_stTest = testFun2(1, 2, 3, 4, 5);</code>反汇编，R0传入的是R7（局部变量地址），在<code>testFun2</code>函数<code>return stTest;</code>时，将stTest写入R0传入的地址区域。</li><li>在退出函数时，如果函数有return参数，会将return参数写入R0，若大于4字节会将进入函数时R0传入的地址返回。</li><li>在退出函数时，会将SP改回进入函数前的SP，并使用POP指令出栈（POP指令会增加SP），最后跳转出函数（还可以直接POP取出PC跳转）。</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分享一个学习Git的网站，记录Git一些用法</title>
      <link href="/2023/02/15/230215-git/"/>
      <url>/2023/02/15/230215-git/</url>
      
        <content type="html"><![CDATA[<h2 id="网站：Learn-Git-Branching"><a href="#网站：Learn-Git-Branching" class="headerlink" title="网站：Learn Git Branching"></a>网站：<a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></h2><h3 id="分离HEAD"><a href="#分离HEAD" class="headerlink" title="分离HEAD"></a>分离HEAD</h3><p><strong>HEAD 是一个对当前检出记录的符号引用</strong>，也就是指向你正在其基础上进行工作的提交记录。HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git 命令都是从改变 HEAD 的指向开始的。HEAD 通常情况下是指向分支名的。在你提交时，改变了分支的状态，这一变化通过 HEAD 变得可见。<br>如果想看 HEAD 指向，可以通过 cat .git/HEAD 查看， 如果 HEAD 指向的是一个引用，还可以用 git symbolic-ref HEAD 查看它的指向。 </p><h3 id="相对引用"><a href="#相对引用" class="headerlink" title="相对引用"></a>相对引用</h3><p>切换至上个版本<code>git checkout HEAD^</code><br>切换至上上上版本<code>git checkout HEAD~3</code></p><h3 id="强制修改分支位置"><a href="#强制修改分支位置" class="headerlink" title="强制修改分支位置"></a>强制修改分支位置</h3><p>我使用相对引用最多的就是移动分支。可以直接使用 -f 选项让分支指向另一个提交。例如:<code>git branch -f main HEAD~3</code>，命令会将 main 分支强制指向 HEAD 的第 3 级父提交。</p><h3 id="撤销变更"><a href="#撤销变更" class="headerlink" title="撤销变更"></a>撤销变更</h3><p><code>git reset</code> 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。<code>git reset</code> 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。<br>为了撤销更改并分享给别人，我们需要使用 <code>git revert</code>，在我们要撤销的提交记录后面居然多了一个新提交，此次提交是用来撤销上一次提交的，此次提交与上上一次提交状态相同。</p><h3 id="Git-Cherry-pick"><a href="#Git-Cherry-pick" class="headerlink" title="Git Cherry-pick"></a>Git Cherry-pick</h3><p>如果你想<strong>将一些提交复制到当前所在的位置（HEAD）下面</strong>的话， Cherry-pick 是最直接的方式了。命令形式为：<code>git cherry-pick &lt;提交号&gt;...</code></p><h3 id="交互式的-Rebase"><a href="#交互式的-Rebase" class="headerlink" title="交互式的 Rebase"></a>交互式的 Rebase</h3><p>交互式 rebase 指的是使用带参数 –interactive 的 rebase 命令, 简写为 -i。<br>如果你在命令后增加了这个选项, Git 会打开一个 UI 界面并列出将要被复制到目标分支的备选提交记录，它还会显示每个提交记录的哈希值和提交说明，提交说明有助于你理解这个提交进行了哪些更改。Git会自动打开默认的文本编辑器，比如在我本地使用的是vim。在文本编辑器的开始几行会列出所有满足条件的提交记录，每个提交记录对应一行，每行开头单词代表要对这条提交记录实施的操作。</p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>pick</td><td>采用该提交（默认行为）</td></tr><tr><td>reword</td><td>采用该提交，但要求修改提交记录的备注</td></tr><tr><td>edit</td><td>采用该提交，但要求修改提交记录的信息，如：作者名称，邮箱地址等</td></tr><tr><td>squash</td><td>采用该提交，但它会被并入前一条提交</td></tr><tr><td>fixup</td><td>类似“squash”，但是会丢弃这条提交记录的日志信息</td></tr><tr><td>exec</td><td>执行指定的shell脚本或命令</td></tr><tr><td>drop</td><td>丢弃该提交</td></tr></tbody></table><h3 id="Git-Describe"><a href="#Git-Describe" class="headerlink" title="Git Describe"></a>Git Describe</h3><p>git describe 的​​语法是：<code>git describe &lt;ref&gt;</code><br><code>&lt;ref&gt;</code> 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）。<br>它输出的结果：<code>&lt;tag&gt;_&lt;numCommits&gt;_g&lt;hash&gt;</code><br>tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。当 ref 提交记录上有某个标签时，则只输出标签名称。</p><h3 id="Git-Pull"><a href="#Git-Pull" class="headerlink" title="Git Pull"></a>Git Pull</h3><p>git pull 就是 git fetch 和 git merge 的缩写！</p><h3 id="rebase和merge区别【阅读原文】"><a href="#rebase和merge区别【阅读原文】" class="headerlink" title="rebase和merge区别【阅读原文】"></a>rebase和merge区别【<a href="https://joyohub.com/2020/04/06/git-rebase/">阅读原文</a>】</h3><p>使用git merge 命令将 master 分支合并到 feature分支中：<code>git merge feature master</code>，git merge 会在 feature 分支中新增一个新的 merge commit，然后将两个分支的历史联系在一起。</p><ul><li>使用 merge 是很好的方式，因为它是一种非破坏性的操作，对现有分支不会以任何方式被更改。</li><li>另一方面，这也意味着 feature 分支每次需要合并上游更改时，它都将产生一个额外的合并提交。</li><li>如果master 提交非常活跃，这可能会严重污染你的 feature 分支历史记录。不过这个问题可以使用高级选项 git log 来缓解。</li></ul><p>使用git rebase 命令将 master 分支合并到 feature分支中：<code>git rebase feature master</code></p><ul><li>rebase 会将整个 feature 分支移动到 master 分支的顶端，从而有效地整合了所有 master 分支上的提交。</li><li>但是，与 merge 提交方式不同，rebase 通过为原始分支中的每个提交创建全新的 commits 来重写项目历史记录,特点是仍然会在feature分支上形成线性提交。</li><li>rebase 的主要好处是可以获得更清晰的项目历史。首先，它消除了 git merge 所需的不必要的合并提交；其次，正如你在上图中所看到的，rebase 会产生完美线性的项目历史记录，你可以在 feature分支上没有任何分叉的情况下一直追寻到项目的初始提交。</li></ul><h3 id="Pull-Request"><a href="#Pull-Request" class="headerlink" title="Pull Request"></a>Pull Request</h3><p>如果你是在一个大的合作团队中工作, 很可能是main被锁定了, 需要一些Pull Request流程来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:<br><code>! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</code></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 版本管控 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Github静态博客访问速度慢，部署图片资源到其他服务器</title>
      <link href="/2023/02/01/230201-gitee/"/>
      <url>/2023/02/01/230201-gitee/</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>用Github部署静态站访问国内速度慢，主要表现有2个，一是首次请求页面打开慢，二是打开后图片加载慢。问题一原因是域名解析需要访问多个海外的DNS服务器，且Github静态站服务器也在海外，首次请求国内或本地没有缓存。问题二也是访问Github静态站服务器速度受限，图片和文本并发访问，文本比图片数据量小先加载完成显示。</p><p>本想将博客全部移到Gitee上，尝试部署又遇到三个问题，一是不能使用自己的域名解析，二是部署Gitee静态站服务它竟说我有文章不合规，三是每次上传Gitee后不会自动更新静态页面，每次要重新发布审核。</p><p>本人使用的解决办法是将图片上传到gitee，github静态博客上的图片都使用gitee的链接，<a href="https://gitee.com/xxx/xxx/tree/img/">Gitee/blog仓库img分支</a>上传了本博客用到的图片。</p><h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><p>参考：<a href="https://gitee.com/help/articles/4136#article-header0">Gitee Pages</a></p><p>在Gitee中创建仓库，开然后将博客用到的图片上传到Gitee中，开通仓库的Pages服务更新分支。审核成功后就可以通过Gitee提供的域名，加上图片在仓库中的路径访问了。例如我的静态页面网址是：<code>https://xxx.gitee.io/</code>，要访问仓库<code>210430-at32</code>文件夹中的<code>210430-at32-1.jpg</code>，访问网址为：<code>https://xxx.gitee.io/210430-at32/210430-at32-1.jpg</code>。</p><h3 id="使用域名转发"><a href="#使用域名转发" class="headerlink" title="使用域名转发"></a>使用域名转发</h3><p>加入以后我的图床地址变了，但我又不想重新修改每个文章里的图片网址怎么办？</p><p>使用域名转发可以解决此问题，我使用的是易名注册的域名和易名免费的域名解析服务，开启URL隐性转发，转发值为你的静态页面网址，这样就可以通过自己的域名访问了，以后想换个图床的话只需要转发地址更改下就可以了。使用易名域名解析转发到我的静态页面会审核不通过，这是因为静态页面没有内容，只需要加个index.html骗骗审核就行了，审核结束就可以删除。</p><p>遇到一个问题，使用域名转发通过http访问可以，通过https访问不行，暂且文章里的图片网址用http访问吧。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阿里云物联网平台数据解析与物模型显示</title>
      <link href="/2023/01/21/230121-iot/"/>
      <url>/2023/01/21/230121-iot/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章是对之前文章【<a href="2021/12/17/211217-ltecat1/">LTE Cat.1模块和阿里云物联网平台使用</a>】的一个补充。之前只介绍了阿里云物联网平台如何创建产品、添加设备、添加物模型概述，缺少对消息解析、物模型展示的使用介绍，导致我这次用阿里云物联网平台时花了将近半天的时间在做之前做过又忘记怎么做的事情。本文就来介绍下<strong>消息解析</strong>、<strong>物模型展示</strong>的功能。</p><p>另外阿里云免费的物联网平台公共实例的资源包将于2023年2月20日下线，我看企业版的最便宜的也要700元/月，我这种添加一个设备调试用的不能白嫖了，到时候需要的话只能包一台服务器自己搭个MQTT划算点了，或者看看其他云服务商那能不能白嫖😂。</p><h3 id="添加物模型"><a href="#添加物模型" class="headerlink" title="添加物模型"></a>添加物模型</h3><p>在<strong>设备管理-&gt;产品-&gt;对应产品名称-&gt;功能定义-&gt;编辑草稿</strong>中添加物模型数据，功能类型有<strong>属性、服务、事件</strong>，我目前只使用到了属性类型，编辑完成后发布上线即可，下面是我这次调试模块用到的物模型功能定义：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/230121-iot/230121-iot-1.jpg" alt="img"></p><h3 id="消息解析"><a href="#消息解析" class="headerlink" title="消息解析"></a>消息解析</h3><p>在<strong>设备管理-&gt;产品-&gt;对应产品名称-&gt;消息解析-&gt;编辑草稿</strong>中编写消息解析的脚本代码，有<strong>js、Python、php</strong>三种语言可供选择，我选择的是Python。消息解析有<a href="https://help.aliyun.com/document_detail/149962.html">自定义Topic消息解析</a>和<a href="https://help.aliyun.com/document_detail/66640.html">物模型消息解析</a>两种，创建产品时数据格式选择<strong>透传/自定义</strong>，消息解析里才有设备上报数据和设备接收数据，数据格式选ICA 标准数据格式(Alink JSON)，消息解析里只有自定义Topic消息解析。通过看模拟输入中模拟类型有哪些，可以知道是否支持某种消息类型的数据解析。</p><h4 id="自定义Topic消息解析"><a href="#自定义Topic消息解析" class="headerlink" title="自定义Topic消息解析"></a>自定义Topic消息解析</h4><p>设备通过携带解析标记<code>?_sn=default</code>的自定义Topic上报自定义格式消息时，物联网平台收到消息数据后，需调用消息解析脚本将自定义格式数据转换为JSON结构体，再流转给后续业务系统。例如，设备发送到Topic <code>/$&#123;productKey&#125;/$&#123;deviceName&#125;/user/update</code>的消息需要解析为JSON格式，在开发设备端时，就需配置该Topic为：<code>/$&#123;productKey&#125;/$&#123;deviceName&#125;/user/update?_sn=default</code>。</p><p>在Python脚本中，自定义Topic消息解析的接口函数名为<code>transform_payload(topic, rawData)</code>，可以根据不同的topic选择不同的解析方式。</p><h4 id="物模型消息解析"><a href="#物模型消息解析" class="headerlink" title="物模型消息解析"></a>物模型消息解析</h4><p>数据格式为<strong>ICA标准数据格式</strong>，设备按照物联网平台定义的标准数据格式生成消息上报，标准Alink JSON数据格式说明，请参见<a href="https://help.aliyun.com/document_detail/89301.htm#concept-mvc-4tw-y2b">设备属性、事件、服务</a>。</p><p>数据格式为<strong>透传/自定义</strong>，设备通信时，需要物联网平台调用您提交的消息解析脚本，将上行物模型消息解析为物联网平台定义的标准格式（Alink JSON），将下行物模型消息据解析为设备的自定义数据格式。</p><p>在Python脚本中，设备自定义数据格式转Alink JSON格式数据的函数（上行通信）为<code>raw_data_to_protocol</code>，Alink JSON格式数据转为设备自定义数据格式的函数（下行通信）为<code>protocol_to_raw_data</code>，要注意的是<code>raw_data_to_protocol</code>函数需要将rawData输入转为标准的Alink JSON，参考标准Alink JSON数据格式说明。下面是我这次用到的脚本解析代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ALINK_PROP_REPORT_METHOD = <span class="string">&#x27;thing.event.property.post&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">raw_data_to_protocol</span>(<span class="params">rawData</span>):</span><br><span class="line">    uint8Array = []</span><br><span class="line">    <span class="keyword">for</span> byteValue <span class="keyword">in</span> rawData:</span><br><span class="line">        uint8Array.append(byteValue &amp; <span class="number">0xff</span>)</span><br><span class="line">    </span><br><span class="line">    jsonMap = &#123;&#125;</span><br><span class="line">    params = &#123;&#125;</span><br><span class="line">    params[<span class="string">&#x27;status&#x27;</span>] = uint8Array[<span class="number">0</span>]</span><br><span class="line">    params[<span class="string">&#x27;error&#x27;</span>] = uint8Array[<span class="number">1</span>]</span><br><span class="line">    params[<span class="string">&#x27;validIDNum&#x27;</span>] = uint8Array[<span class="number">2</span>]</span><br><span class="line">    params[<span class="string">&#x27;errorSlave&#x27;</span>] = uint8Array[<span class="number">3</span>]</span><br><span class="line">    params[<span class="string">&#x27;idallocTimes&#x27;</span>] = uint8Array[<span class="number">4</span>]</span><br><span class="line">    params[<span class="string">&#x27;costTime&#x27;</span>] = (uint8Array[<span class="number">6</span>]|(uint8Array[<span class="number">7</span>]&lt;&lt;<span class="number">8</span>))<span class="comment"># 非单字节变量注意大小端</span></span><br><span class="line">    params[<span class="string">&#x27;successCnt&#x27;</span>] = (uint8Array[<span class="number">8</span>]|(uint8Array[<span class="number">9</span>]&lt;&lt;<span class="number">8</span>)|(uint8Array[<span class="number">10</span>]&lt;&lt;<span class="number">16</span>)|(uint8Array[<span class="number">11</span>]&lt;&lt;<span class="number">24</span>))</span><br><span class="line">    params[<span class="string">&#x27;errorCnt&#x27;</span>] = (uint8Array[<span class="number">12</span>]|(uint8Array[<span class="number">13</span>]&lt;&lt;<span class="number">8</span>)|(uint8Array[<span class="number">14</span>]&lt;&lt;<span class="number">16</span>)|(uint8Array[<span class="number">15</span>]&lt;&lt;<span class="number">24</span>))</span><br><span class="line">    jsonMap[<span class="string">&#x27;params&#x27;</span>] = params<span class="comment"># 物模型中的属性添加到params中，再加到jsonMap</span></span><br><span class="line">    jsonMap[<span class="string">&#x27;method&#x27;</span>] = ALINK_PROP_REPORT_METHOD<span class="comment"># 标准的Alink JSON必须要加method</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonMap</span><br></pre></td></tr></table></figure><h3 id="物模型显示效果"><a href="#物模型显示效果" class="headerlink" title="物模型显示效果"></a>物模型显示效果</h3><p>这次应用是有软件模块过年放假期间需要测试，我用4G Cat.1模块传到阿里云物联网平台记录数据，最终物模型显示效果如下图：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/230121-iot/230121-iot-2.jpg" alt="img"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言printf变长参数如何实现</title>
      <link href="/2023/01/20/230120-printf/"/>
      <url>/2023/01/20/230120-printf/</url>
      
        <content type="html"><![CDATA[<h3 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h3><p>函数原型：<code>int printf(const char *format, ...)</code><br>调用格式为：<code>printf(&quot;&lt;格式化字符串&gt;&quot;, &lt;参量表&gt;);</code><br>功能：发送格式化输出到标准输出 stdout</p><h3 id="变长参数实现思路"><a href="#变长参数实现思路" class="headerlink" title="变长参数实现思路"></a>变长参数实现思路</h3><p>C语言支持变长参数函数(Variable Argument Functions)，即参数的个数可以是不定个，在函数定义的时候用<code>...</code>表示。采用这种形式定义的变长参数函数，<strong>至少需要一个普通的形参</strong>，且<code>...</code>需要放在最后一个参数，比如printf函数中的<code>*format</code>后面的<code>...</code>是函数原型的一部分。</p><p>变长参数的实现得益于C语言默认的<em><strong>cdecl</strong></em>调用惯例，其参数是<strong>从右向左</strong>压入栈的，第一个参数位于栈顶。这样printf函数实现的时候，就无需关心调用他的函数会传递几个参数过来，而只要关心自己用到几个，将全部参数压入栈，函数处理时从栈中取即可。</p><h3 id="自己实现一个变长参数的函数"><a href="#自己实现一个变长参数的函数" class="headerlink" title="自己实现一个变长参数的函数"></a>自己实现一个变长参数的函数</h3><p>Ｃ已经有现成可用的一些东西来帮我们实现变长参数，它主要通过<code>stdarg.h</code>头文件定义的一个变量类型（va_list）和三个宏（va_start、va_arg、va_end）来实现。</p><p>实现一个可变长参数的sum函数，第一个参数<code>num</code>传递变长参数中有参数的数量，紧接着后面会传递<code>num</code>个整型变量，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, val = <span class="number">0</span>;</span><br><span class="line">    va_list ap;<span class="comment">//定义一个具有va_list型的变量，这个变量是指向参数的指针</span></span><br><span class="line">    va_start(ap, num);<span class="comment">//始化变量刚定义的va_list变量,使其指向第一个可变参数的地址,地址自动增加</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        val += va_arg(ap, <span class="type">int</span>);<span class="comment">//va_arg返回va_list中的参数，并增加指针偏移</span></span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);<span class="comment">//结束可变参数列表</span></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;16+38+53=%d\n&quot;</span>, sum(<span class="number">3</span>, <span class="number">16</span>, <span class="number">38</span>, <span class="number">53</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变长参数实现原理"><a href="#变长参数实现原理" class="headerlink" title="变长参数实现原理"></a>变长参数实现原理</h3><p>上面的sum函数也可以不使用va_list等宏，通过其他方法实现。<br>当我们调用：<code>int n = sum(3, 16, 38, 53);</code><br>参数在栈上会形成如下布局：<br><img src="https://gitee.com/hao0527/hao0527/raw/img/230120-printf/230120-printf-1.jpg" alt="img"></p><p>在函数内部，函数可以使用变量<code>num</code>来访问数字3，但无法使用任何名称访问其他的几个不定参数。但此时由于栈上其他的几个参数实际恰好依序排列在参数<code>num</code>的高地址方向，因此可以很简单地通过<code>num</code>的地址计算出其他参数的地址，sum函数的另一种实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> num, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* p = &amp;num + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(num--)</span><br><span class="line">        ret += *p++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p>printf的不定参数比sum要复杂得多，因为printf的参数不仅数量不定，而且<strong>类型</strong>也不定。所以printf需要在格式字符串中注明参数的类型，例如用<code>%d</code>表明是一个整数。printf里的格式字符串如果将类型描述错误，因为不同参数的大小不同，不仅可能导致这个参数的输出错误，还有可能导致其后的一系列参数错误。[摘自《程序员的自我修养——链接、封装、库》P338]</p><p><code>printf(&quot;%lf\t%d\t%c\n&quot;, 1, 666, &#39;a&#39;);</code> 在这行函数里，printf的第一个输出参数是一个int(4 字节)，而我们告诉printf它是一个double(8字节)，因此printf的输出会错误，由于printf在读取double的时候实际造成了越界，因此后面几个参数的输出也会失败。该程序的实际输出为：<code>0.000000 97</code>（根据实际编译器和环境可能不同）</p><h3 id="va-list等宏如何实现"><a href="#va-list等宏如何实现" class="headerlink" title="va_list等宏如何实现"></a>va_list等宏如何实现</h3><p><strong>va_list</strong> 实际是一个指针，用来指向各个不定参数。由于类型不明，因此这个 va_list 以 void* 或 char*  为最佳选择。<br><strong>va_start</strong> 将 va_list 定义的指针指向函数的最后一个参数后面的位置，这个位置就是第一个不定参数。<br><strong>va_arg</strong> 获取当前不定参数的值，并根据当前不定参数的大小将指针移向下一个参数。<br><strong>va_end</strong> 将指针清 0。<br>按照以上思路，va_list等宏的一个<strong>最简单的实现</strong>就可以得到了，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> va_list char*</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_start(ap, arg) (ap=(va_list)&amp;arg+sizeof(arg))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_arg(ap, t) (*(t*)((ap+=sizeof(t))-sizeof(t)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> va_end(ap) (ap=(va_list)0)</span></span><br></pre></td></tr></table></figure><p>注意：实际代码中还套了很多宏，不同编译器，不同架构都有可能使用不同的代码实现，但具体实现思想一致，有些x64条件编译时va_list会是一个结构体，里面会记录可变参数开始地址、结束地址、参数数量等信息。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DDR关键参数介绍</title>
      <link href="/2022/12/17/221217-ddr/"/>
      <url>/2022/12/17/221217-ddr/</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>在学习FPGA时使用了DDR3，最近学ARM处理器也用到了DDR3的外设，在FPGA是使用 MIG(Memory Interface Generators)IP核驱动DDR3，ARM处理器是通过配置MMDC(Multi Mode DDR Controller)模块驱动DDR3，这编博客将会介绍使用DDR需配置的几个关键参数。</p><p>SRAM操作流程、时序图可以浏览我之前的文章，<a href="/2021/12/19/211219-fpga%E4%B9%8Bsdram/">FPGA之SDRAM学习</a>。</p><h3 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h3><h4 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h4><p>传输速率的单位是MT/s(Mega Transfer Per Second)，即每秒传输的百万次数，常见DDR3有800MT/s、1066MT/s、1333MT/s、1600MT/s等，这是首先需要考虑的，该参数决定了DDR的最高数据传输速率。</p><h4 id="tRCD-参数"><a href="#tRCD-参数" class="headerlink" title="tRCD 参数"></a>tRCD 参数</h4><p>tRCD 全称是 RAS-to-CAS Delay，也就是<strong>行寻址到列寻址之间的延迟</strong>。 DDR 的寻址流程是先指定 BANK 地址，然后在指定行地址，最后指定列地址确定最终要寻址的单元。 BANK 地址和行地址是同时发出的，这个命令叫做<strong>行激活</strong>(Row Active)。行激活以后就发送列地址和具体的操作命令(读还是写)，这两个是同时发出的，因此一般也用<strong>读/写命令</strong>表示<strong>列寻址</strong>。在行有效(行激活)到读/写命令发出的这段时间间隔叫做 tRCD。</p><h4 id="CL-参数"><a href="#CL-参数" class="headerlink" title="CL 参数"></a>CL 参数</h4><p>当列地址发出以后就会触发数据传输，但是从数据从存储单元到内存芯片 IO 接口上还需要一段时间，这段时间就是非常著名的 CL(CAS Latency)，也就是<strong>列地址选通潜伏期</strong>。</p><h4 id="AL-参数"><a href="#AL-参数" class="headerlink" title="AL 参数"></a>AL 参数</h4><p>在 DDR 的发展中，提出了一个前置 CAS 的概念，目的是为了解决 DDR 中的指令冲突，它允许 CAS 信号紧随着 RAS 发送，相当于将 DDR 中的 CAS 前置了。但是读/写操作并没有因此提前，依旧要保证足够的延迟/潜伏期，为此引入了 AL(Additive Latency)，单位也是时钟周期数。 AL+CL 组成了 RL(Read Latency)，从 DDR2 开始还引入了写潜伏期 WL(Write Latency)，WL 表示写命令发出以后到第一笔数据写入的潜伏期。</p><h4 id="tRAS-参数"><a href="#tRAS-参数" class="headerlink" title="tRAS 参数"></a>tRAS 参数</h4><p>RAS active time，也指Active to Precharge Delay，行有效至行预充电时间。是指从收到一个请求后到初始化RAS(行地址选通脉冲)真正开始接受数据的间隔时间，tRAS 是 ACTIVE 命令到 PRECHARGE 命令之间的最小时间，tRAS=tRCD+tWR。</p><h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><h4 id="tRP-参数"><a href="#tRP-参数" class="headerlink" title="tRP 参数"></a>tRP 参数</h4><p>在发出预充电命令之后，要经过一段时间才能允许发送RAS行有效命令打开新的工作行，这个间隔被称为tRP（RAS Precharge time，预充电有效时间）。</p><h4 id="tRC-参数"><a href="#tRC-参数" class="headerlink" title="tRC 参数"></a>tRC 参数</h4><p>tRC(Row Cycle Time)，表示“SDRAM行周期时间”，它是包括行单元预充电到激活在内的整个过程所需要的最小的时钟周期数，是两个 ACTIVE 命令或者 ACTIVE 命令到 REFRESH 命令之间的周期。tRC=tRAS+tRP。如果tRC的时间过长，会因在完成整个时钟周期后激活新的地址而等待无谓的延时，而降低性能。然而如果该值设置过小，在被激活的行单元被充分充电之前，新的周期就可以被初始化，也会导致数据丢失和损坏。</p><h4 id="tWR-参数"><a href="#tWR-参数" class="headerlink" title="tWR 参数"></a>tWR 参数</h4><p>由于数据信号由控制端发出，输入时芯片无需做任何调校，只需直接传到数据输入寄存器中，然后再由写入驱动器进行对存储电容的充电操作，因此数据可以与CAS同时发送，也就是说写入延迟为0。不过，数据并不是即时地写入存储电容，因为选通三极管（就如读取时一样）与电容的充电必须要有一段时间，所以数据的真正写入需要一定的周期。为了保证数据的可靠写入，都会留出足够的写入/校正时间（tWR，Write Recovery Time），这个操作也被称作写回（Write Back）。tWR至少占用一个时钟周期或再多一点（时钟频率越高，tWR占用周期越多）。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于CAN2.0的J1939协议</title>
      <link href="/2022/11/29/221129-j1939/"/>
      <url>/2022/11/29/221129-j1939/</url>
      
        <content type="html"><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>这几天在做ID自分配协议栈，使用的是J1939协议，汽车中还有其他的EOL协议、快充协议也都是使用的J1939协议。</p><h3 id="SAE-J1939与CAN2-0的关系"><a href="#SAE-J1939与CAN2-0的关系" class="headerlink" title="SAE-J1939与CAN2.0的关系"></a>SAE-J1939与CAN2.0的关系</h3><p>CAN2.0是一种总线规范，是数据链路层的技术。J1939是SAE（美国汽车协会）基于CAN总线定义的的规范，主要用于解决不同发动机厂商、不同ECU厂商之间的兼容性问题。J1939定义了一系列的PGN和SPN，这些PGN包含了发动机、变速器、车轴等汽车上各部件的信息；对参数的表示方法（状态和值）又定义了SLOT（Scaling—比例、Limit—界限、Offset—偏移、Transfer—传送）。ECU厂商开发设备时都应该遵循这个规范。ECU模块的功能不同，厂商不同，在J1939的基础上，又表现出其多样性：支持或者不支持某些PGN、SPN和SLOT；新增了某些J1939未定义的PGN和SPN。</p><h3 id="SAE-J1939消息帧格式"><a href="#SAE-J1939消息帧格式" class="headerlink" title="SAE-J1939消息帧格式"></a>SAE-J1939消息帧格式</h3><p>CAN2.0规范包括CAN2.0A（标准帧格式），CAN2.0B（扩展帧格式），二者使用不同的帧格式位码。J1939是在CAN2.0B的基础上进一步封装，对仲裁场部分的29位ID的重新定义。SAE-J1939中只为扩展帧格式定义了标准化的通信，因此，<strong>SAE-1939设备必须使用扩展帧格式</strong>。</p><h3 id="SAE-J1939数据帧结构"><a href="#SAE-J1939数据帧结构" class="headerlink" title="SAE-J1939数据帧结构"></a>SAE-J1939数据帧结构</h3><p>SAE-J1939将每个协议数据单元（PDU）融合进一个CAN2.0B数据帧中，其结构如下：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/221129-j1939/221129-j1939-1.png" alt="img"></p><p>参数群编号（PGN）对于制定基于SAE-J1939的CAN协议来说十分重要，很多ECU厂商规定在接受CAN报文时识别的就是PGN而不是整个报文的ID。参数群编号是由24位组成的（其实是18位），主要包括下面几个部分：保留位（R，1bit，默认为：0），数据页位（DP，1bit，多数情况下为：0），PDU格式（PF，8bit）和特定PDU（PS，8bit，目标地址是否群扩展）。当PF值为：0~239之前时PGN的低字节将被设置为：0；当PF值为240~254之时，PGN的低字节为PS的值。PGN结构如下：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/221129-j1939/221129-j1939-2.png" alt="img"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>I.MX6U Assembly LED Driver</title>
      <link href="/2022/11/13/221113-asmLed/"/>
      <url>/2022/11/13/221113-asmLed/</url>
      
        <content type="html"><![CDATA[<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><h3 id="点灯流程"><a href="#点灯流程" class="headerlink" title="点灯流程"></a>点灯流程</h3><ol><li>使能指定 GPIO 的时钟</li><li>设置 IO 的复用功能</li><li>配置 GPIO 输出功能、上拉、速度等等</li><li>设置 GPIO 输出高电平或低电平</li></ol><h3 id="点灯汇编代码"><a href="#点灯汇编代码" class="headerlink" title="点灯汇编代码"></a>点灯汇编代码</h3><p>代码中的地址参考《i.MX 6ULL Applications Processor Reference Manual》</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.global _start@ global symbol</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">ldr r1, =0xffffffff</span><br><span class="line">mov r2, #6</span><br><span class="line">ldr r0, =0x020c4080@ CCM_CCGR6</span><br><span class="line">ldr r2, =0x020c4068@ CCM_CCGR0</span><br><span class="line"></span><br><span class="line">CCGR_loop_init:</span><br><span class="line">str r1, [r0]</span><br><span class="line">sub r0, #4</span><br><span class="line">cmp r2, r0</span><br><span class="line">ble CCGR_loop_init</span><br><span class="line"></span><br><span class="line">ldr r0, =0x020e0068@ IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03</span><br><span class="line">ldr r1, =0x5</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =0x020e02f4@ IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03</span><br><span class="line">ldr r1, =0x10b0</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =0x0209c004@ GPIO1_GDIR</span><br><span class="line">ldr r1, =0x8</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">ldr r0, =0x0209c000@ GPIO1_DR</span><br><span class="line">ldr r1, =0x0</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =0x1f78a400@ 528M</span><br><span class="line">ldr r1, =0xfbc5200@ 264M</span><br><span class="line">delay1:</span><br><span class="line">sub r0, #100</span><br><span class="line">cmp r0, r1</span><br><span class="line">bge delay1</span><br><span class="line"></span><br><span class="line">ldr r0, =0x0209c000@ GPIO1_DR</span><br><span class="line">ldr r1, =0x8</span><br><span class="line">str r1, [r0]</span><br><span class="line"></span><br><span class="line">ldr r0, =0x1f78a400@ 528M</span><br><span class="line">ldr r1, =0xfbc5200@ 264M</span><br><span class="line">delay2:</span><br><span class="line">sub r0, #100</span><br><span class="line">cmp r0, r1</span><br><span class="line">bge delay2</span><br><span class="line"></span><br><span class="line">b loop</span><br></pre></td></tr></table></figure><h2 id="程序编译"><a href="#程序编译" class="headerlink" title="程序编译"></a>程序编译</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><code>arm-linux-gnueabihf-gcc -g -c led.s -o led.o</code></p><p>上述命令就是将 led.s 编译为 led.o，其中“-g”选项是产生调试信息，GDB 能够使用这些调试信息进行代码调试。“-c”选项是编译源文件，但是不链接。“-o”选项是指定编译产生的文件名字。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><code>arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf</code></p><p>上述命令中-Ttext 就是指定链接地址，“-o”选项指定链接生成的 elf 文件名，这里命名为 led.elf。</p><h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><p><code>arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin</code></p><p>烧录要用到bin文件，上述命令中，“-O”选项指定以什么格式输出，后面的“binary”表示以二进制格式输出，选项“-S”表示不要复制源文件中的重定位信息和符号信息，“-g”表示不复制源文件中的调试信息。</p><h3 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h3><p><code>arm-linux-gnueabihf-objdump -D led.elf &gt; led.dis</code></p><p>有时候需要查看其汇编代码来调试代码，因此就需要进行反汇编，一般可以将 elf 文件反汇编，上述代码中的“-D”选项表示反汇编所有的段。</p><h2 id="Makefile脚本"><a href="#Makefile脚本" class="headerlink" title="Makefile脚本"></a>Makefile脚本</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">led.bin:led.s</span></span><br><span class="line">arm-linux-gnueabihf-gcc -g -c led.s -o led.o</span><br><span class="line">arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf</span><br><span class="line">arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin</span><br><span class="line">arm-linux-gnueabihf-objdump -D led.elf &gt; led.dis</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf *.o led.bin led.elf led.dis</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：每一个命令行必须以 注意：每一个命令行必须以[Tab]字符开始，不能是空格开始，[Tab] 字符告诉 make 此行是一个命令行，make 按照命令完成相应的动作。这也是书写按照命令完成相应的动作，这也是书写 Makefile 中容易产生，而且比较隐蔽的错误。报错信息：<code>Makefile:2: *** 遗漏分隔符 (null)。 停止。</code></p><h2 id="反汇编-1"><a href="#反汇编-1" class="headerlink" title="反汇编"></a>反汇编</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">87800000 &lt;_start&gt;:</span><br><span class="line">87800000:e3e01000 mvnr1, #0</span><br><span class="line">87800004:e3a02006 movr2, #6</span><br><span class="line">87800008:e59f0078 ldrr0, [pc, #120]; 87800088 &lt;delay2+0x10&gt;</span><br><span class="line">8780000c:e59f2078 ldrr2, [pc, #120]; 8780008c &lt;delay2+0x14&gt;</span><br><span class="line"></span><br><span class="line">87800010 &lt;CCGR_loop_init&gt;:</span><br><span class="line">87800010:e5801000 strr1, [r0]</span><br><span class="line">87800014:e2400004 subr0, r0, #4</span><br><span class="line">87800018:e1520000 cmpr2, r0</span><br><span class="line">8780001c:dafffffb ble87800010 &lt;CCGR_loop_init&gt;</span><br><span class="line">87800020:e59f0068 ldrr0, [pc, #104]; 87800090 &lt;delay2+0x18&gt;</span><br><span class="line">87800024:e3a01005 movr1, #5</span><br><span class="line">87800028:e5801000 strr1, [r0]</span><br><span class="line">8780002c:e59f0060 ldrr0, [pc, #96]; 87800094 &lt;delay2+0x1c&gt;</span><br><span class="line">87800030:e59f1060 ldrr1, [pc, #96]; 87800098 &lt;delay2+0x20&gt;</span><br><span class="line">87800034:e5801000 strr1, [r0]</span><br><span class="line">87800038:e59f005c ldrr0, [pc, #92]; 8780009c &lt;delay2+0x24&gt;</span><br><span class="line">8780003c:e3a01008 movr1, #8</span><br><span class="line">87800040:e5801000 strr1, [r0]</span><br><span class="line"></span><br><span class="line">87800044 &lt;loop&gt;:</span><br><span class="line">87800044:e59f0054 ldrr0, [pc, #84]; 878000a0 &lt;delay2+0x28&gt;</span><br><span class="line">87800048:e3a01000 movr1, #0</span><br><span class="line">8780004c:e5801000 strr1, [r0]</span><br><span class="line">87800050:e59f004c ldrr0, [pc, #76]; 878000a4 &lt;delay2+0x2c&gt;</span><br><span class="line">87800054:e59f104c ldrr1, [pc, #76]; 878000a8 &lt;delay2+0x30&gt;</span><br><span class="line"></span><br><span class="line">87800058 &lt;delay1&gt;:</span><br><span class="line">87800058:e2400064 subr0, r0, #100; 0x64</span><br><span class="line">8780005c:e1500001 cmpr0, r1</span><br><span class="line">87800060:aafffffc bge87800058 &lt;delay1&gt;</span><br><span class="line">87800064:e59f0034 ldrr0, [pc, #52]; 878000a0 &lt;delay2+0x28&gt;</span><br><span class="line">87800068:e3a01008 movr1, #8</span><br><span class="line">8780006c:e5801000 strr1, [r0]</span><br><span class="line">87800070:e59f002c ldrr0, [pc, #44]; 878000a4 &lt;delay2+0x2c&gt;</span><br><span class="line">87800074:e59f102c ldrr1, [pc, #44]; 878000a8 &lt;delay2+0x30&gt;</span><br><span class="line"></span><br><span class="line">87800078 &lt;delay2&gt;:</span><br><span class="line">87800078:e2400064 subr0, r0, #100; 0x64</span><br><span class="line">8780007c:e1500001 cmpr0, r1</span><br><span class="line">87800080:aafffffc bge87800078 &lt;delay2&gt;</span><br><span class="line">87800084:eaffffee b87800044 &lt;loop&gt;</span><br><span class="line">87800088:020c4080 andeqr4, ip, #128; 0x80</span><br><span class="line">8780008c:020c4068 andeqr4, ip, #104; 0x68</span><br><span class="line">87800090:020e0068 andeqr0, lr, #104; 0x68</span><br><span class="line">87800094:020e02f4 andeqr0, lr, #244, 4; 0x4000000f</span><br><span class="line">87800098:000010b0 strheqr1, [r0], -r0</span><br><span class="line">8780009c:0209c004 andeqip, r9, #4</span><br><span class="line">878000a0:0209c000 andeqip, r9, #0</span><br><span class="line">878000a4:1f78a400 svcne0x0078a400</span><br><span class="line">878000a8:0fbc5200 svceq0x00bc5200</span><br></pre></td></tr></table></figure><p>和我写的汇编代码都是一一对应的，只是把直接数放在了代码段的最后，ldr通过pc+offset来取。</p><p>从反汇编来看还把ldr一些短的直接数改成了mov指令。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MCU startup.s</title>
      <link href="/2022/11/03/221103-mcustartup/"/>
      <url>/2022/11/03/221103-mcustartup/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>云途MCU内存有ECC(Error Correcting Code)功能，需要在startup.s中初始化所有内存（既赋值0），所以软复位后从startup.s中reset_handle运行，会重新初始化内存，原本内存的值会被清0，无法使用内存OTA升级程序，需要用到Flash来保存OTA信息。</p><p>这篇文章来讲下汇编启动程序做了什么，单片机启动过程，ld链接脚本中定义的变量在汇编程序中的引用，不同编译器汇编程序的区别。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol><li>正点原子《I.MX6U  嵌入式 x Linux  驱动开发指南 V1.6 6》——第七章 ARM  汇编基础</li><li><a href="https://developer.arm.com/zh-TW/">ARM开发人员网站</a>，可以直接搜索指令</li><li><a href="https://www.arm.com/zh-TW/resource-library">ARM资源图书馆</a>，可以下载白皮书、ARM编程手册</li><li><a href="https://sourceware.org/binutils/docs/">Documentation for binutils</a>，binutils工具链(ld, as…)的官方文档</li></ol><h2 id="启动程序和启动过程"><a href="#启动程序和启动过程" class="headerlink" title="启动程序和启动过程"></a>启动程序和启动过程</h2><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><p><img src="https://https//gitee.com/hao0527/hao0527/raw/img/mcustartup/2020032320502673.png" alt="启动文件使用的 ARM 汇编指令汇总"></p><h3 id="startup-stm32f40-41xxx-s-代码分析"><a href="#startup-stm32f40-41xxx-s-代码分析" class="headerlink" title="startup_stm32f40_41xxx.s 代码分析"></a>startup_stm32f40_41xxx.s 代码分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stack_Size      EQU     0x00000400</span><br><span class="line">                AREA    STACK, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">Stack_Mem       SPACE   Stack_Size</span><br><span class="line">__initial_sp</span><br><span class="line"></span><br><span class="line">Heap_Size       EQU     0x00000200</span><br><span class="line">                AREA    HEAP, NOINIT, READWRITE, ALIGN=3</span><br><span class="line">__heap_base</span><br><span class="line">Heap_Mem        SPACE   Heap_Size</span><br><span class="line">__heap_limit</span><br></pre></td></tr></table></figure><p>第1行：EQU 是表示宏定义的伪指令，类似于 C 语言中的#define。伪指令的意思是指这个“指令”并不会生成二进制程序代码，也不会引起变量空间分配。0x00000400 表示栈大小，字节为单位。0x00000400 =1024字节=1KB。</p><p>第2行：开辟一段数据空间可读可写，段名 STACK，按照8字节对齐。ARER 伪指令表示下面将开始定义一个代码段或者数据段。此处是定义数据段。ARER 后面的关键字表示这个段的属性。</p><ul><li>STACK ：表示这个段的名字，可以任意命名。</li><li>NOINIT：表示此数据段不需要填入初始数据。</li><li>READWRITE：表示此段可读可写。</li><li>ALIGN=3 ：表示首地址按照 2 的 3 次方对齐，也就是按照 8 字节对齐(地址对 8 求余数等于0)。</li></ul><p>第3行：SPACE 这行指令告诉汇编器给STACK段分配 0x00000400 字节的连续内存空间。</p><p>第4行：__initial_sp 紧接着SPACE语句放置，表示了栈顶地址。__initial_sp 只是一个标号，标号主要用于表示一片内存空间的某个位置，等价于 C 语言中的“地址”概念。地址仅仅表示存储空间的一个位置，从 C 语言的角度来看，变量的地址，数组的地址或是函数的入口地址在本质上并无区别。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                PRESERVE8   ; 指定当前文件保持堆栈8字节对齐</span><br><span class="line">                THUMB       ; 表示后面的指令是THUMB指令集</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">; Vector Table Mapped to Address 0 at Reset</span><br><span class="line">                AREA    RESET, DATA, READONLY</span><br><span class="line">                EXPORT  __Vectors       ; EXPORT申明标号为可被外部引用</span><br><span class="line">                EXPORT  __Vectors_End</span><br><span class="line">                EXPORT  __Vectors_Size</span><br><span class="line">                </span><br><span class="line">__Vectors       DCD     __initial_sp               ; Top of Stack</span><br><span class="line">                DCD     Reset_Handler              ; Reset Handler</span><br><span class="line">                DCD     NMI_Handler                ; NMI Handler</span><br><span class="line">                DCD     HardFault_Handler          ; Hard Fault Handler</span><br><span class="line">                DCD     MemManage_Handler          ; MPU Fault Handler</span><br><span class="line">                DCD     BusFault_Handler           ; Bus Fault Handler</span><br><span class="line">                DCD     UsageFault_Handler         ; Usage Fault Handler</span><br><span class="line">...... 省略</span><br><span class="line">                DCD     OTG_HS_IRQHandler                 ; USB OTG HS                   </span><br><span class="line">                DCD     DCMI_IRQHandler                   ; DCMI                         </span><br><span class="line">                DCD     CRYP_IRQHandler                   ; CRYP crypto                   </span><br><span class="line">                DCD     HASH_RNG_IRQHandler               ; Hash and Rng</span><br><span class="line">                DCD     FPU_IRQHandler                    ; FPU             </span><br><span class="line">__Vectors_End</span><br><span class="line">__Vectors_Size  EQU  __Vectors_End - __Vectors</span><br></pre></td></tr></table></figure><p>上面这块代码初始化了中断向量表，第一个是SP指针初始化地址，后面是中断向量表，包含异常处理和外设中断，DCD会定义个4Bytes空间存储中断要跳转的地址。这块RESET数据段放在Flash开始，程序从Flash首地址开始运行，先初始化SP和PC(PC就是Reset_Handler)，再跳转去Reset_Handler执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">                AREA    |.text|, CODE, READONLY</span><br><span class="line">; Reset handler</span><br><span class="line">Reset_Handler    PROC</span><br><span class="line">                 EXPORT  Reset_Handler             [WEAK] ; 弱定义</span><br><span class="line">        IMPORT  SystemInit</span><br><span class="line">        IMPORT  __main</span><br><span class="line">                 LDR     R0, =SystemInit</span><br><span class="line">                 BLX     R0                 ; 跳转至SystemInit()函数初始化时钟</span><br><span class="line">                 LDR     R0, =__main        ; 跳转至__main()初始化堆栈, __main()由MDK自动生成</span><br><span class="line">                 BX      R0</span><br><span class="line">                 ENDP</span><br><span class="line"></span><br><span class="line">; Dummy Exception Handlers (infinite loops which can be modified)</span><br><span class="line"></span><br><span class="line">NMI_Handler     PROC</span><br><span class="line">                EXPORT  NMI_Handler                [WEAK]</span><br><span class="line">                B       .</span><br><span class="line">                ENDP</span><br><span class="line">...... 省略</span><br></pre></td></tr></table></figure><p>上面这块定义了中断服务函数，都是弱定义，用户可以在别的文件中重定义。除了Reset_Handler有实现，其他都为死循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">;*******************************************************************************</span><br><span class="line">; User Stack and Heap initialization</span><br><span class="line">;*******************************************************************************</span><br><span class="line">                 IF      :DEF:__MICROLIB</span><br><span class="line">                 EXPORT  __initial_sp</span><br><span class="line">                 EXPORT  __heap_base</span><br><span class="line">                 EXPORT  __heap_limit</span><br><span class="line">                </span><br><span class="line">                 ELSE</span><br><span class="line">                 IMPORT  __use_two_region_memory</span><br><span class="line">                 EXPORT  __user_initial_stackheap</span><br><span class="line">                 </span><br><span class="line">__user_initial_stackheap</span><br><span class="line">                 LDR     R0, =  Heap_Mem</span><br><span class="line">                 LDR     R1, =(Stack_Mem + Stack_Size)</span><br><span class="line">                 LDR     R2, = (Heap_Mem +  Heap_Size)</span><br><span class="line">                 LDR     R3, = Stack_Mem</span><br><span class="line">                 BX      LR</span><br><span class="line">                 ALIGN</span><br><span class="line">                 ENDIF</span><br></pre></td></tr></table></figure><p>启动代码的最后一部分，简单的汇编语言实现 IF ELSE语句。如果定义了__MICROLIB，那么程序是不会执行ELSE分支的代码。MDK中MicroLIB的作用，参考：<a href="https://blog.csdn.net/weixin_42682108/article/details/113357057">KeilMDK配置项中Use MicroLIB</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>串口通信三种方式232, 485, 422</title>
      <link href="/2022/10/17/221017-232485422/"/>
      <url>/2022/10/17/221017-232485422/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>之前UART用的比较多，232, 485, 422通信方式用的比较少，最近储能的项目用到了485通信，在之前卡片机的项目也用到485通信，今天来归纳下232, 485, 422这三种通信的区别。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>本文搬运自 <a href="https://www.jianshu.com/p/352872a0de9d">转载：串口通信232/485/422 详细解析！</a> ，自己复习使用</li></ol><h2 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h2><p>通用异步收发传输器(Universal Asynchronous Receiver/Transmitter)。</p><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>UART作为异步串口通信协议的一种，工作原理是将传输数据的每个字符一位接一位地传输，其中各位的意义如下:</p><p><strong>起始位</strong>：先发出一个逻辑”0”的信号，表示传输字符的开始。</p><p><strong>数据位</strong>：紧接着起始位之后。数据位的个数可以是4、5、6、7、8等，构成一个字符。通常采用ASCII码。从最低位开始传送，靠时钟定位。</p><p><strong>奇偶校验位</strong>：数据位加上这一位后，使得”1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。</p><p><strong>停止位</strong>：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。 由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。<strong>因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会</strong>。<strong>适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢</strong>。</p><p><strong>空闲位</strong>：处于逻辑”1”状态，表示当前线路上没有数据传送。</p><p><img src="hhttps://gitee.com/hao0527/hao0527/raw/img/21017-232485422/0.jpg" alt="图片"></p><h3 id="波特率与比特率"><a href="#波特率与比特率" class="headerlink" title="波特率与比特率"></a>波特率与比特率</h3><p><strong>比特率</strong>在数字信道中，比特率是数字信号的传输速率，它用单位时间内传输的二进制代码的有效位（bit）数来表示，其单位为每秒比特数bit/s（bps）、每秒千比特数（Kbps）或每秒兆比特数（Mbps）来表示（此处K和M分别为1000和1000000，而不是涉及计算机存储器容量时的1024和1048576）。</p><p><strong>波特率</strong>指数据信号对载波的调制速率，它用单位时间内载波调制状态改变次数来表示，其单位为波特（Baud）。波特率与比特率的关系为：比特率=波特率X单个调制状态对应的二进制位数。</p><p><strong>如何区分两者？</strong>显然，两相调制（单个调制状态对应1个二进制位）的比特率等于波特率；四相调制（单个调制状态对应2个二进制位）的比特率为波特率的两倍；八相调制（单个调制状态对应3个二进制位）的比特率为波特率的三倍；依次类推。</p><h2 id="232"><a href="#232" class="headerlink" title="232"></a>232</h2><p>232 通信主要是由RX,TX,GND三根线组成。RX与TX，TX接RX，GND接GND。因为发送和接收分别是由不同的线处理的，也就是能同时发送数据和接收数据，这就是所谓的全双工。</p><p><img src="hhttps://gitee.com/hao0527/hao0527/raw/img/21017-232485422/640-1666051381273.jfif" alt="图片"></p><p>在这里扩展一下，串口通信还有一个功能叫做<strong>全功能串口通信</strong>，也叫标准串口。因为在两个设备间进行数据传输，有些设备处理速度比较快，有些数据比较慢。为了保证数据能正常传输，在RX,TX的基础上，还增加了几个控制引脚，本来好端端就R，T，G，三根线，凑着就凑齐了9个引脚，召唤出了DB9这个东西。</p><p><img src="hhttps://gitee.com/hao0527/hao0527/raw/img/21017-232485422/1.jpg" alt="图片"></p><p>这要怪就怪当时使用电脑的时候，还没有互联网这个概念，但是又想在两台电脑间进行通信。所以才有这样一个东西。在后来的设备，很多控制器，人机界面，PLC等使用串口通信中，基本上就不使用标准串口，而是就直接使用RX，TX，GND三根线来通信了。但是这里为什么要提到这个呢。因为只是很多设备这样用，也就是还存在少数设备还保留了标准串口的功能。这就是为什么会遇到明明电脑通信是好的，换成触摸屏通信就不行了。因为很多触摸屏只使用了RX，TX，GND通信，遇到一些还保留标准串口功能的就比较讨厌了。</p><h2 id="485"><a href="#485" class="headerlink" title="485"></a>485</h2><p>485是为了解决232通信距离的问题。原理什么之类的就不多讲了。反正232通信距离就是不长。485主要是以一种差分信号进行传输，只需要两根线，+,-两根线，或者也叫A，B两根线。A，B两根线的差分电平信号就是作为数据信号传输。</p><p>那么问题来了，那是不是就没有RX和TX的概念了。是的，发送和接收就不能分开了。发送和接收都是靠这两根的来传输，也就是每次只能作发送或者只能作接收，这就是半双工的概念了，这在效率上就比232弱很多了。就像对讲机一样，经常是某个人讲完之后，都要说一个over，确保当前说完了，等待对方回复。</p><p><img src="hhttps://gitee.com/hao0527/hao0527/raw/img/21017-232485422/640-1666051910756.jfif" alt="图片"></p><p>485就是这样牺牲了232全双工的效率来达到自己传输距离远的代价。那有没有即保留了232的全双工，又可以像485这样提高传输距离呢，于是，422出来了。</p><h2 id="422"><a href="#422" class="headerlink" title="422"></a>422</h2><p>422呢，有些标注为485-4。而485就标注为485-2。有什么区别呢。就是为了好记呢。485-2就是2根线。485-4就是4根线。</p><p><img src="hhttps://gitee.com/hao0527/hao0527/raw/img/21017-232485422/640-1666051950808.jfif" alt="图片"></p><p>422就是把232的RX分成两根线，RX+，RX-，把TX分成TX+,TX-。这样就可以同时发送和同时接收了，还可以像485这样，有较远的传输距离。可是这样一种很有优势的通信方式，为什么用的不多呢。我个人的答案和理解就是：线太多了。特别是像我这样懒得接线的人，超过3根线就头晕的。搞个通信还需要接这么多线，什么TX,RX，正啊负啊。交换来交换去。</p><p>因为在很多设备通信中，基本上是属于一问一答式的，因此，232的全双工通信优势其实也并没有发挥出来。就像现在打电话，虽然两个人可以同时说话，但是两个人同时说话，叽叽歪歪的，谁知道说什么呀。特别是一个主站与多个从站通信的时候，485的接线就就方便多了，反正大家就两根线，把+都接一块，把-都接一块。如果是<strong>422作一主多从</strong>，接线上还要理半天呢，而且通信异常了也不好解决。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用Python做文件加密解密</title>
      <link href="/2022/10/14/221014-pyEncrypt/"/>
      <url>/2022/10/14/221014-pyEncrypt/</url>
      
        <content type="html"><![CDATA[<h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><p><a href="https://docs.python.org/zh-cn/3/library/argparse.html#module-argparse">argparse</a> — 命令行选项、参数和子命令解析器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个解析器</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">&#x27;use for Encrypting/Decrypting.&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加参数</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-d&#x27;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Decryption command&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-e&#x27;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Encryption command&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-r&#x27;</span>, action=<span class="string">&quot;store_true&quot;</span>, <span class="built_in">help</span>=<span class="string">&#x27;Rename command&#x27;</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-p&#x27;</span>, action=<span class="string">&quot;store&quot;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;file path or folder path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    args = <span class="built_in">vars</span>(parser.parse_args())</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>指令 -p 为必须，通过 -p 传入文件或文件夹路径参数，指令 -d -e -r 告知脚本要执行什么任务。</p><p><strong><a href="https://www.runoob.com/python/python-func-vars.html">Python vars() 函数</a></strong> 返回对象object的属性和属性值的字典对象。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\decipherer&gt; python main.py <span class="literal">-p</span> .\test1.c</span><br><span class="line">&#123;<span class="string">&#x27;d&#x27;</span>: False, <span class="string">&#x27;e&#x27;</span>: False, <span class="string">&#x27;r&#x27;</span>: False, <span class="string">&#x27;p&#x27;</span>: <span class="string">&#x27;.\\test1.c&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="解析路径"><a href="#解析路径" class="headerlink" title="解析路径"></a>解析路径</h2><p><a href="https://www.runoob.com/python/python-os-path.html">Python os.path() 模块</a> — 主要用于获取文件的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main_file_path = os.path.dirname(os.path.realpath(__file__))</span><br><span class="line">file_name = os.path.basename(file_path)</span><br><span class="line">file_content = fp.read()</span><br><span class="line">file_name_md5 = hashlib.md5(file_name.encode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>)).hexdigest()</span><br><span class="line">file_relative_path = os.path.realpath(file_path).replace(main_file_path, <span class="string">&#x27;&#x27;</span>)  <span class="comment"># 相对地址</span></span><br><span class="line">file_relative_dir = os.path.dirname(file_path).replace(main_file_path, <span class="string">&#x27;&#x27;</span>)  <span class="comment"># 相对地址不带文件名</span></span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/python3/python3-os-walk.html">Python3 os.walk() 方法</a> — 用于遍历文件夹</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">rename_dir</span>(<span class="params">dir_path</span>):</span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(dir_path, topdown=<span class="literal">False</span>):</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">            rename_file(os.path.join(root, name))</span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3/library/shutil.html?highlight=shutil%20rmtree#shutil.rmtree">shutil.rmtree()</a> — 删除一个完整的目录树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&#x27;./output_rename&#x27;</span>):</span><br><span class="line">    shutil.rmtree(<span class="string">&#x27;./output_rename&#x27;</span>)  <span class="comment"># 删除之前的目录</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.python.org/zh-cn/3/library/os.html?highlight=os%20makedirs#os.makedirs">makedirs()</a> — 递归目录创建函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">&#x27;./output_rename&#x27;</span> + file_relative_dir) == <span class="number">0</span>:</span><br><span class="line">    os.makedirs(<span class="string">&#x27;./output_rename&#x27;</span> + file_relative_dir)  <span class="comment"># 如果目录不存在 创建新目录</span></span><br></pre></td></tr></table></figure><h2 id="MD5加解密"><a href="#MD5加解密" class="headerlink" title="MD5加解密"></a>MD5加解密</h2><p><a href="https://docs.python.org/zh-cn/3/library/hashlib.html?highlight=hashlib#hash-algorithms">hashlib</a> — 安全哈希与消息摘要</p><h2 id="字符串编解码"><a href="#字符串编解码" class="headerlink" title="字符串编解码"></a>字符串编解码</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python/att-string-decode.html">string.decode(encoding=’UTF-8’, errors=’strict’)</a></td><td>以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</td></tr><tr><td><a href="https://www.runoob.com/python/att-string-encode.html">string.encode(encoding=’UTF-8’, errors=’strict’)</a></td><td>以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td></tr></tbody></table><p>保存文件名是用encode指定编码格式，再读取时用decode指定格式解码，否则遇到中文字读取会出问题。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RT-Thread使用笔记</title>
      <link href="/2022/10/13/221013-rtthread/"/>
      <url>/2022/10/13/221013-rtthread/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今天在移植陀螺仪项目时，之前的代码全局变量过多，函数功能不够独立，现在使用国产雅特力MCU，M4主频120MHz，64K ROM，16K RAM，想使用RTOS重新写代码，实践一次嵌入式RTOS编程。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>参考RT-Thread官网教程：<a href="https://www.rt-thread.org/document/site/#/">https://www.rt-thread.org/document/site/#/</a></li></ol><h2 id="开始干"><a href="#开始干" class="headerlink" title="开始干"></a>开始干</h2><h3 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h3><p>选用RT-Thread Nano版本，资源占用小：对 RAM 与 ROM 的开销非常小，在支持 semaphore 和 mailbox 特性，并运行两个线程 (main 线程 + idle 线程) 情况下，ROM 和 RAM 依然保持着极小的尺寸，RAM 占用约 1K 左右，ROM 占用 4K 左右。</p><h3 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h3><p>移植参考官网教程：<a href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-nano/nano-port-keil/an0039-nano-port-keil">使用 MDK 移植</a></p><h4 id="移植时遇到的几个问题"><a href="#移植时遇到的几个问题" class="headerlink" title="移植时遇到的几个问题"></a>移植时遇到的几个问题</h4><ol><li><code>#error &quot;TODO 1: OS Tick Configuration.&quot;</code>一直报错，这个只是编译时提醒我们要配置OS Tick，配置后需手动注释掉这条。</li><li><code>SysTick_Handler()</code>有时进有时不进，检查方法查看SysTick结构体，发现CTRL中使能位0，原因：后面的代码使用了delay函数关闭SysTick的使能位。</li></ol><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="初始化静态线程"><a href="#初始化静态线程" class="headerlink" title="初始化静态线程"></a>初始化静态线程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rt_err_t</span> <span class="title function_">rt_thread_init</span><span class="params">(<span class="keyword">struct</span> rt_thread* thread,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span>* name,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span> (*entry)(<span class="type">void</span>* parameter), <span class="type">void</span>* parameter,</span></span><br><span class="line"><span class="params">                        <span class="type">void</span>* stack_start, <span class="type">rt_uint32_t</span> stack_size,</span></span><br><span class="line"><span class="params">                        <span class="type">rt_uint8_t</span> priority, <span class="type">rt_uint32_t</span> tick)</span>;</span><br></pre></td></tr></table></figure><h4 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h4><p><code> rt_err_t rt_thread_startup(rt_thread_t thread);</code></p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol><li><p>遇到rt_thread_init()函数卡死，百度竟然啥都查不到（rt-thread用的人这么少的吗），后尝试将栈大小增加至256后成功初始化线程。虽然任务里没什么局部变量，但是一个简单的按键任务竟然占了500多字节内存，可能是因为栈中还保存了寄存器、TCB等信息，那我这单片机16K字节内存可能不够。</p></li><li><p>需要在main函数while(1)中加入rt_thread_mdelay(10); 否则main线程优先级更高，其他线程无法运行。</p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CAN (控制器域网, Controller Area Network)</title>
      <link href="/2022/09/27/220927-CAN/"/>
      <url>/2022/09/27/220927-CAN/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>这几天在做云途单片机的CAN接口移植，学习了CAN通信，还看了一些通信时用到的环形队列、通信协议栈。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p>本文搬运自 <a href="https://zhuanlan.zhihu.com/p/538834760">CAN通信讲解</a> ，自己复习使用</p></li><li><p>s32k144、云途ME0单片机参考手册</p></li></ol><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>CAN是<strong>控制器局域网络</strong>(Controller Area Network, CAN)的简称，是一种能够实现分布式实时控制的串行通信网络。</p><p>CAN的发展历史节点：</p><ul><li><strong>1983</strong>年，BOSCH开始着手开发CAN总线；</li><li><strong>1986</strong>年，在SAE会议上，CAN总线正式发布；</li><li><strong>1987</strong>年，Intel和Philips推出第一款CAN控制器芯片；</li><li><strong>1991</strong>年，奔驰 500E 是世界上第一款基于CAN总线系统的量产车型；</li><li><strong>1991</strong>年，Bosch发布CAN 2.0标准，分 <strong>CAN 2.0A</strong> （11位标识符）和 <strong>CAN 2.0B</strong> （29位标识符）；</li><li><strong>1993</strong>年，ISO发布CAN总线标准（<strong>ISO 11898</strong>），随后该标准主要有三部分：</li><li>ISO 11898-1：数据链路层协议</li><li>ISO 11898-2：高速CAN总线物理层协议，通信速度为 125kbps-1Mbps。</li><li>ISO 11898-3：（整合了ISO11519）低速CAN总线物理层协议，通信速度为 125kbps 以下。</li><li><strong>2011</strong>年，开始CAN FD协议的开发。</li><li><strong>2015</strong>年ISO11898-1进行了修订，将CAN FD加入其中。</li></ul><h2 id="CAN总线协议介绍"><a href="#CAN总线协议介绍" class="headerlink" title="CAN总线协议介绍"></a>CAN总线协议介绍</h2><p>CAN总线协议有CAN1.0、CAN2.0（CAN2.0A、CAN2.0B），其中CAN2.0对比1.0，主要是增加了CAN的扩展帧定义。现在我们所说的CAN通常都是指CAN2.0标准的总线。</p><p>CAN-FD协议在原有的CAN协议基础上，增加了可变波特率、扩大数据场、提升校验算法安全性等改进。</p><p>本文主要讲述CAN的数据通信，CAN-FD的区别会在其他文章单独讲解。</p><h2 id="CAN的物理通信形式"><a href="#CAN的物理通信形式" class="headerlink" title="CAN的物理通信形式"></a>CAN的物理通信形式</h2><p>通过两条通信线（双绞线）产生的电压差传输数据，一个CAN网络里的所有节点都挂在这两条通信线上，使用差分信号半双工通信。</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-23d364e14ef20208bac9b47fed047ada_r.jpg" alt="img"></p><p>CAN 使用称为 CANH / CANL 的通信线路执行传输和接收。没有电位差的信号称为隐性(Recessive)信号，其逻辑值为1。具有电位差的信号称为显性（Dominant）信号，其逻辑值0。如果通信总线上发生显性和隐性(Recessive)冲突，则显性（Dominant）优先。总线空闲时保持隐性。</p><p>CAN总线的物理层逻辑电平，分为高速ISO11898标准（125kbps ~ 1Mbps）和低速ISO11519标准（10kbps ~ 125kbps）；</p><p>低速的物理层电平如图：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-3667818bfa85894c20ee09fb428f363d_r.jpg" alt="img"></p><p>而我们现在通常使用的CAN2.0，都是使用高速CAN标准，其物理层电平如图：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-aabdb0a85b5bc7446840ed2b8c4d788e_r.jpg" alt="img"></p><p>对于高速CAN，总结一下，也就是：</p><ul><li>CAN_H-CAN_L &lt; 0.5V 时候为隐性的，逻辑信号表现为”逻辑1”- 高电平。</li><li>CAN_H-CAN_L &gt; 0.9V 时候为显性的，逻辑信号表现为”逻辑0”- 低电平。</li></ul><p>关于CAN通信的电平传输，一个<strong>重要概念</strong>就是：</p><p>CAN总线在电平传输上，具有仲裁判断逻辑，优先级为：显性（低电平）&gt;隐形（高电平）！</p><p>在理解CAN总线传输的整个过程中，主要就是清楚这一规则在传输时的灵活运用，并定义的各种帧形式。</p><h2 id="CAN的数据格式"><a href="#CAN的数据格式" class="headerlink" title="CAN的数据格式"></a>CAN的数据格式</h2><p>CAN的数据定义了有5种帧类型：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-1f0d94451bb01c75375b4c912012e39d_r.jpg" alt="img"></p><p>其中，遥控帧也常被称为远程帧。CAN的应用开发者只能使用“数据帧”和“遥控帧”，其他的3种帧类型是由CAN的底层固件自动帮我们在特定场景下进行收发，开发者无需担心也无法直接参与控制。</p><p>所以，本文把“数据帧”和“遥控帧”与其他的3种帧类型分别进行介绍。</p><h3 id="数据帧与遥控帧"><a href="#数据帧与遥控帧" class="headerlink" title="数据帧与遥控帧"></a>数据帧与遥控帧</h3><p>关于数据帧，也就是我们最常用的帧类型，用于数据的收发；也是CAN通信里最主要的内容。</p><p>而遥控帧，只是CAN网络里的某一节点发送一个遥控帧请求其他的节点反馈数据给自己，关于<em><strong>遥控帧其实在实际使用中，显得很鸡肋</strong></em>，原因有：</p><p>1、CAN通信作为一种半双工通信形式，在实际使用中的应用层通信协议往往会定义好数据的应答机制与时间间隔，节点与节点之间只要按照协议规定进行数据的收发即可。</p><p>2、遥控帧与数据帧对比，其实就是一条数据长度为0的数据帧而已，只是在帧格式里的仲裁段RTR位为隐性。那么，似乎有数据帧就足够了。</p><p>3、遥控帧的概念定义只是一个预定义，所谓的请求其他节点给自己发送数据并不是强制的，与数据帧一样完全根据应用层协议来规定其具体的使用。</p><p>综上所述，CAN里定义的遥控帧实际作用不大，而且可以用数据帧配合应用协议的定义，进行替代。所以在后来的CAN-FD中已经取消了遥控帧的定义了。</p><p>本文主要以数据帧进行介绍，并简单介绍遥控帧。</p><h3 id="数据帧与遥控帧的数据格式"><a href="#数据帧与遥控帧的数据格式" class="headerlink" title="数据帧与遥控帧的数据格式"></a>数据帧与遥控帧的数据格式</h3><p>不管是Classic CAN Frame还是CANFD Frame，其帧结构都由以下7个段组成：</p><p>— SOF帧起始;</p><p>— arbitration field仲裁段；</p><p>— control field控制段;</p><p>— data field数据段;</p><p>— CRC field;</p><p>— ACK field;</p><p>— EOF.</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-94586126c0989e25599b758d8ecc5295_r.jpg" alt="img"></p><p>这7个段，每个段里又都有自己的格式细分，有两种格式：标准格式和扩展格式。</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-f58bfd8f6bb42cf469dfb4c2243750ca_r.jpg" alt="img"></p><p><strong>CAN的应用开发者只使用其中的仲裁段、控制段和数据段。其他部分都由CAN底层固件自动封装！</strong></p><p>由上图可以看到，对于仲裁段和控制段在标准帧与扩展帧里有不同的定义，其他段一致。</p><h3 id="帧起始与帧结束"><a href="#帧起始与帧结束" class="headerlink" title="帧起始与帧结束"></a>帧起始与帧结束</h3><p>SOF帧起始：由一个显性位（低电平）组成，发送节点发送帧起始，其他节点同步于帧起始；</p><p>EOF帧结束：由7个隐形位（高电平）组成。</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-5d0c0aa1ef7750f0620e92407a09f4b8_r.jpg" alt="img"></p><h3 id="仲裁段"><a href="#仲裁段" class="headerlink" title="仲裁段"></a>仲裁段</h3><h4 id="仲裁机制"><a href="#仲裁机制" class="headerlink" title="仲裁机制"></a>仲裁机制</h4><p>只要总线空闲，总线上任何节点都可以发送报文，如果有两个或两个以上的节点开始传送报文，那么就会存在总线访问冲突的可能。但是CAN使用了标识符的逐位仲裁方法可以解决这个问题。帧ID越小，优先级越高。</p><p>CAN总线控制器在发送数据的同时监控总线电平，如果电平不同，则停止发送并做其他处理。如果该位位于仲裁段，则退出总线竞争；如果位于其他段，则产生错误事件。</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-b31c6be2bf95f5553e9b236fd5f8a562_r.jpg" alt="img"></p><h4 id="仲裁段内容"><a href="#仲裁段内容" class="headerlink" title="仲裁段内容"></a>仲裁段内容</h4><p>RTR位：用于指示这包数据是遥控帧还是数据帧，数据帧的RTR位为显性电平，远程帧为隐性电平。</p><p>所以帧格式和帧ID相同的情况下，数据帧优先于远程帧。</p><p>IDE位：用于指示这包数据是标准帧还是扩展帧，标准帧的IDE位为显性电平，扩展帧的IDE位为隐形电平。</p><p>对于前11位ID相同的标准帧（RTR为显性的遥控帧）和扩展帧，标准帧优先级比扩展帧高。</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-c1baaa702dd521f883248bf5d69357ce_r.jpg" alt="img"></p><p>可以看到，在标准格式里，仲裁段没有IDE位，其实这个位在标准格式里是放在控制段的第一位的，这样就正好可以和扩展格式的IDE位对应上进行仲裁了。</p><h3 id="控制段"><a href="#控制段" class="headerlink" title="控制段"></a>控制段</h3><p>仲裁段之后紧跟控制段，控制段共6位，标准帧的控制段由IDE、保留位r0和数据长度代码DLC组成；扩展帧控制段则由保留位r1、r0和DLC组成，如图：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-d7b37d72e67ba4fdc89dc6374a640754_r.jpg" alt="img"></p><p>在这里可以看到，在标准格式里，IDE位放到了控制段的第一位来了，对应前文仲裁段的内容，就可以使标准格式与扩展格式进行仲裁了。</p><p>保留位（ r0 、 r1 ）：保留位必须全部以显性电平发送。</p><p>数据长度码（ DLC ）：数据的字节数必须为 0 ～ 8 字节。数据帧的DLC表示的就是当前包数据段所带的字节数，遥控帧的DLC表示的是请求返回的数据长度。</p><h3 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h3><p>一个数据帧传输的数据量为0~8个字节。遥控帧的数据段长度固定为0。</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-ea717bbfd46d990dffefa9d6d78e7b88_r.jpg" alt="img"></p><h3 id="CRC段"><a href="#CRC段" class="headerlink" title="CRC段"></a>CRC段</h3><p>CAN-bus使用CRC校验进行数据检错，CRC校验值存放于CRC段。 CRC校验段由15位CRC值和1位CRC界定符构成如图：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-d153142849cef02d8701015681d3ef9b_r.jpg" alt="img"></p><h3 id="ACK段"><a href="#ACK段" class="headerlink" title="ACK段"></a>ACK段</h3><p>当一个接收节点接收的帧起始到CRC段之间的内容没发生错误时，它将在ACK段发送一个显性电平如图：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-123b6f8079ca6645f96c0a4b0379933d_r.jpg" alt="img"></p><h2 id="位填充"><a href="#位填充" class="headerlink" title="位填充"></a>位填充</h2><p>CAN数据在收发上除了会遵循以上数据格式定义之外，还有一个“位填充”的底层规则（类似通信协议里的“转义符”），这个操作是在CAN的底层固件中自动判断执行的，其目的是为了增强数据正确性，以便识别错误信号。</p><p>为防止突发错误而设定，CAN协议中规定，当相同极性的电平持续五位时，则添加一个极性相反的位。填充位的添加和删除是由发送节点和接收节点完成的，CAN-BUS只负责传输，不会操纵信号。</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-1886bf7c09fedcdb6d34a025e4f63d9d_r.jpg" alt="img"></p><ul><li>对于发送节点而言：</li></ul><p>在发送数据帧和遥控帧时，对于SOF~CRC(除去CRC界定符) 之间的位流，相同极性的电平如果持续5位，那么在下一个位插入一个与之前5位反型的电平；</p><ul><li>对于接收节点而言：</li></ul><p>在接收数据帧和遥控帧时，对于SOF~CRC(除去CRC界定符)之间的位流，相同极性的电平如果持续5位，那么需要删除下一位再接收。如果这个第 6 个位的电平与前 5 位相同，将被视为错误并发送<strong>位填充错误帧</strong>。</p><h2 id="错误帧、过载帧与帧间隔"><a href="#错误帧、过载帧与帧间隔" class="headerlink" title="错误帧、过载帧与帧间隔"></a>错误帧、过载帧与帧间隔</h2><p>对于这三种帧，都是在使用数据帧或遥控帧的过程当中进行错误、时序管理的辅助信号，并不会单独出现在CAN网络中；如前文所述是由CAN的底层固件自动判断并执行他们收发的，但是CAN的开发人员有必要对它们进行了解，以对CAN网络有一个整体的认识。</p><h3 id="错误帧"><a href="#错误帧" class="headerlink" title="错误帧"></a>错误帧</h3><p>尽管CAN-bus是可靠性很高的总线，但依然可能出现错误；CAN-bus的错误类型共有5种：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-873a92aa91e65481dc812b1bc85a3841_r.jpg" alt="img"></p><p>当出现5种错误类型之一时，发送或接收节点将发送错误帧。但是错误帧又有两种格式：主动错误格式和被动错误格式。</p><p>主动错误和被动错误，指的并不是发送方与接收方。而是指某一CAN节点的“错误状态”，无论发送方还是接收方，都会处于自己的错误状态，并根据自身的状态来决定自己要发送主动错误格式还是被动错误格式：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-32a00c5310f9ddb0f89f391b60fbd1ae_r.jpg" alt="img"></p><p>由上图可知，6个连续的显性或隐性电平位，正好违反了之前所提及的“位填充”规则，CAN总线设计上就是利用了自己的这一规则对错误数据进行刻意的覆盖破坏，使总线上其他节点都知道错误的发生。</p><h4 id="错误状态"><a href="#错误状态" class="headerlink" title="错误状态"></a>错误状态</h4><p>在CAN节点内，有两个计数器：发送错误计数器（TEC）和接收错误计数器（REC），当该节点检测到错误后，内部REC/TEC计数器会相应的增加，基于REC/TEC的值判定节点状态，CAN的错误状态如图：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-fddf34e76afc765a8030e7ec7feac111_r.jpg" alt="img"></p><p>节点错误状态的转换就是一个 “量变”到“质变” 的过程：</p><ul><li><strong>主动错误状态：【REC&lt;127 且TEC&lt;127】</strong></li></ul><p>初步可判定该节点相对稳定可靠，该错误计数很可能是由于某个节点异常导致的，那么其他节点很可能也会触发该错误，那么允许该节点破坏CAN总线的异常报文并告知其他节点；<br>节点检测到一个错误就会发送带有主动错误标志的错误帧，因为主动错误标志是连续六个显性位，所以这个时候主动错误标志将会“覆盖”掉总线上其它节点的发送，而之前在CAN总线上传输的报文就被这“六个连续显性位”破坏掉了。<br>如果发出主动错误帧的节点是发送节点，这个情况下就相当于：刚刚发送的那一帧报文我发错了，现在我破坏掉它（发送主动错误帧），你们不管收到什么都不算数；</p><p>如果发出主动错误帧的节点是接收节点，这个情况就相当于：刚刚我收报文的时候发现了错误，不管你们有没有发现这个错误，我现在主动站出来告诉大家这个错误，并把这一帧报文破坏掉（发送主动错误帧），刚才你们收到的东西不管对错都不算数了。</p><ul><li><strong>被动错误状态：【REC&gt;128 或TEC&gt;128】</strong></li></ul><p>节点发送错误帧的次数较多，初步可判定该节点相对不可靠，该错误计数很可能是由于自身节点问题导致，即该错误很可能仅有该节点才有，对于其他节点而言是可以正常交互的，总线不信任该节点提供的错误标识，将不允许破坏总线数据，那么允许该节点发送错误帧“6个连续隐性位”至CAN总线，仅告知其他节点异常；<br>如果发出被动错误帧的节点为报文的发送节点，那么在发送被动错误帧之后，刚刚正在发送的报文被破坏，并且该节点不能在错误帧之后随着连续发送刚刚发送失败的那个报文。随之而来的是帧间隔，并且连带着8位隐性位的 “延迟传送” 段；这样总线电平就呈现出连续11位隐性位，总线上的其它节点就能判定总线处于空闲状态，就能参与总线竞争。</p><p>此时如果该节点能够竞争成功，那么它就能接着发送，如果竞争不能成功，那么就接着等待下一次竞争。这种机制的目的正是为了让其它正常节点（处于主动错误）优先使用总线。</p><ul><li><strong>总线关闭状态：【TEC&gt;255】</strong></li></ul><p>一个处于被动错误状态的节点，仍然多次发送被动错误帧，使该节点转为总线关闭态；<br>该节点不能向总线上发送报文，也不能从总线上接收报文，整个节点脱离总线。等到检测到128次11个连续的隐性位时，TEC和REC置0，重新回到主动错误状态。<br>由于存在实现方式的不同，CAN总线关闭状态存在只允许用户请求恢复和检测到128个11位连续的隐性位时自恢复两种不同的恢复形式。</p><p>如果总线上只有一个节点，该节点发送数据帧后得不到应答，TEC最大只能计数到128，即这种情况下节点只会进入被动错误状态而不会进入总线关闭状态。</p><h4 id="错误帧的发送"><a href="#错误帧的发送" class="headerlink" title="错误帧的发送"></a>错误帧的发送</h4><p>按照CAN协议的规定：<br>发生位错误、填充错误、格式错误、ACK错误时，则在错误产生的那一位的下一位开始发送错误帧。<br>发生CRC错误时，紧随ACK界定符后的位发送错误帧。</p><p>错误帧发送完成后，总线空闲时自动重发出错的数据帧。</p><p><strong>【位错误】举例（情况1）：</strong></p><ul><li>设总线上所有节点处于主动错误状态；</li><li>当一个发送节点监控到总线上的位数值与发送的位数值不一致时，检测为位错误，并发送主动错误标志（6个连续的显性位）；</li><li>接收节点接收到发送节点发送的6个连续的显性位时，会检测为位填充错误，也会发送主动错误标志；</li><li>发送节点发送完主动错误标志后，开始监控总线是否为隐性位，当总线为隐性位时，开始发送错误界定符（8个连续的隐性位）；</li><li>当接收节点发送完主动错误标志后，开始向总线发送错误界定符； 等待错误帧发送完成，总线空闲后，发送节点重新发送出错的报文.</li></ul><blockquote><p>由于发送节点发送6个连续的显性位会破坏位填充规则，触发接收节点发送主动错误标志，发送节点和接收节点的结合是形成错误标志叠加部分的原因。</p></blockquote><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-2266e218b6061b77c37b34e3eb58c723_r.jpg" alt="img"></p><p><strong>【位错误】举例（情况2）：</strong></p><ul><li>假设发送节点处于被动错误状态，接收节点处于主动错误状态；</li><li>当发送节点监控到总线上的位数值与发送的位数值不一致时，检测为位错误，并发送被动错误标志（6个连续的隐性位）；</li><li>接收节点接收到发送节点发送的6个连续的隐性位时，会检测为位填充错误，并会发送主动错误标志；</li><li>发送节点发送完被动错误标志后，开始监控总线是否为隐性位，当总线为隐性位时，开始发送错误界定符（8个连续的隐性位）；</li><li>接收节点发送完主动错误标志后，开始监控总线是否为隐性位，当总线为隐性位时，开始发送错误界定符（8个连续的隐性位）；</li></ul><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-bc7b7162a61a7861ebf895c765122302_r.jpg" alt="img"></p><h3 id="过载帧与帧间隔"><a href="#过载帧与帧间隔" class="headerlink" title="过载帧与帧间隔"></a>过载帧与帧间隔</h3><p>过载帧与主动错误帧非常相似，甚至可以把过载帧直接理解成也是一种错误帧，只是它的错误触发条件不同罢了。</p><p>当某个接收节点没有做好接收下一帧数据的准备时，将发送过载帧以通知发送节点；过载帧由过载标志和过载帧界定符组成，如图所示：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-ae4660f6be52518c6ca8f24b9a5b39ce_r.jpg" alt="img"></p><p>由于存在多个节点同时过载且过载帧发送有时间差问题，可能出现过载标志叠加后超过6个位的现象，如图所示：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-443d97a46a841c5bb2900f0304414ac1_r.jpg" alt="img"></p><p>过载帧是用于接收单元通知发送单元它尚未完成接收准备的帧。在两种情况下，节点会发送过载帧：</p><ul><li>接收单元条件的制约，要求发送节点延缓下一个数据帧或远程帧的传输；</li><li>帧间隔（Intermission）的 <em><strong>3 bit</strong></em> 内检测到显性位</li></ul><p>帧间隔是用于分隔数据帧、遥控帧这些有效数据的帧。数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、 遥控帧、错误帧、过载帧）分开。</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-09da8cc2f7158aeb3e7ab5a05aed0bff_r.jpg" alt="img"></p><p>注意，过载帧和错误帧由于要按照发送条件立即执行，前不能插入帧间隔</p><h2 id="CAN的采样点与波特率"><a href="#CAN的采样点与波特率" class="headerlink" title="CAN的采样点与波特率"></a>CAN的采样点与波特率</h2><p>根据前文描述，由于CAN总线在通信时，每个节点都会不断的监控总线上的实际电平用于仲裁、判断错误等功能，因此CAN定义了采样点这一概念指明节点对总线的监控时间点。</p><p>因为CAN要对总线上特定数据里的每一个位都要进行一次单独的监控，所以这个监控的时间点，指的是在一个“位”的时间范围之内的一个“相对时间”，比如：一个位时间的中间时刻，就把它称为50%采样点（率）。这个解释只是让读者直接理解它的大体概念，实际情况并不是这么简单。</p><p>实际的CAN采样点的位时间划分如下：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-40e0a834157ea339143219a350f88373_r.jpg" alt="img"></p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-88bed791a65bcd50ec1eee089c1f067f_r.jpg" alt="img"></p><p>由上图可知，CAN每发送一个位，需要涉及的内容有：</p><p><strong>时间单元（Tq）：</strong>指的是CAN模块时钟提供的单位时间，与其他的芯片外设一样，任何外设模块都需要提供合适的时钟才能正常工作，在很多芯片里CAN时钟还会配合一个分频器，也就是：CAN时钟= CAN时钟源（如图中的晶振时钟） / CAN_Prescaler。<strong>时间单元</strong>指的就是分频后的实际<strong>CAN时钟</strong>的单位时间。</p><p><strong>位时间：</strong>就是我们理解的<strong>CAN波特率</strong>里一位的时间，由上图可知，CAN每发送一个位都由几个“段”组成，而每个段又需要占用几个“时间单元（Tq）”，所以我们在使用CAN的时候，就需要通过指定这些段的Tq个数来得到CAN的波特率。</p><p><strong>同步段（SS：Synchronization Segment）：</strong>用于同步CAN总线上的各个节点。输入信号的跳变沿就发生在同步段，该段持续时间固定为 1 Tq。同步段用于同步总线上的各个节点，一个位的跳变边沿在此时间段内。</p><p><strong>传播段（PTS：Propagation Time Segment）：</strong>用于补偿各节点之间的物理传输延迟时间。传输延迟时间为信号在总线上传播时间的两倍，包括总线驱动器延迟时间。传播段的长度一般有一个取值范围，不同的控制器不完全一致，典型值为 1 – 8 TQ。在CAN-FD中取消了传播段。</p><p><strong>相位缓冲段1（PBS1：Phase Buffer Segment 1）：</strong>用于补偿节点间的晶振误差，允许通过<strong>重同步（SJW）</strong>对该段<strong>加长</strong>。在该时间段结束时进行总线电平<strong>采样点</strong>的采样。</p><p><strong>相位缓冲段2（PBS2：Phase Buffer Segment 2）：</strong>用于补偿节点间的晶振误差，允许通过<strong>重同步（SJW）</strong>对该段<strong>缩短。</strong></p><p>不同的控制器，PBS1/PBS2 的取值范围不完全一致，一般 PS1 为 1 – 8 TQ，PS2 为 2 – 8 TQ。</p><p>在有的控制器里，把传播段与相位缓冲段1合并称为“<strong>时间段1</strong>”,而相位缓冲段2称为“<strong>时间段2</strong>”，如图：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-0ddb4086a6638f5d70a106bc583e55f6_r.jpg" alt="img"></p><p><strong>重同步（SJW）：</strong>在<strong>时间段1</strong>而不是在<strong>同步段(SS)<strong>检测到有效跳变，那么</strong>相位缓冲段1(PBS1)</strong> 的时间就被延长最多SJW那么长，从而采样点被延迟了。相反如果在<strong>时间段2</strong>而不是在<strong>同步段(SS)<strong>检测到有效跳变，那么</strong>相位缓冲段2(PBS2)</strong> 的时间就被缩短最多SJW那么长，从而采样点被提前了。如图：</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220927-CAN/v2-e731e178deca7a637b6e36e6976f9d5f_r.jpg" alt="img"></p><p>综上所述：</p><p>CAN时钟 = CAN时钟源 / 分频值CAN_Prescaler；</p><p>CAN波特率 = CAN时钟 / (SS(1Tq) + PTS + PBS1 + PBS2)的Tq总个数；</p><p>CAN采样点（率） = (SS(1Tq) + TSEG1) / (SS(1Tq) + TSEG1 + TSEG2) * 100%</p><p>= (SS(1Tq) + PTS + PBS1) / (SS(1Tq) + PTS + PBS1 + PBS2) * 100%；</p><p><strong>注意：</strong>在实际的CAN使用中，一个CAN网络的各节点最好把采样点设置成一样，如果采样点的设置偏差较大，虽然可能不会造成完全不能通信的情况，但是由于不同节点的判断时间点不同，会造成CAN通信上出现较大概率的错误数据。</p><p>如果发现通信误码率较高，不妨可以排查一下各个节点的CAN采样点设置。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>eeprom， norflash， nandflash</title>
      <link href="/2022/09/09/220909-flash/"/>
      <url>/2022/09/09/220909-flash/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>这几天在做云途单片机的flash接口移植，同时陀螺仪的代码也需要将校准参数保存到flash每次开机读取，于是就看了s32k单片机的flash操作和模拟eeprom，同时看了云途的手册和sdk，也看了stm32闪存编程参考手册和hal库。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.bilibili.com/video/BV1Lx411Z7Qa?p=66&spm_id_from=pageDriver&vd_source=67da16e91bf092509864c6a51f44c92e">【正点原子】 手把手教你学STM32入门教学视频单片机 嵌入式 之 F103-基于新战舰V3/精英/MINI板</a></li><li>《STM32F10xxx闪存编程参考手册》，《STM32 FLASH  模拟 EEPROM 使用和优化》</li><li>云途、s32k的参考手册，云途和stm32的sdk</li><li><a href="https://blog.csdn.net/qq_38179373/article/details/111660812">nor flash原理详细讲解</a></li><li><a href="https://blog.csdn.net/gongjiwei/article/details/83475544">NANDFlash原理</a></li></ol><h2 id="eeprom-norflash-nandflash特性"><a href="#eeprom-norflash-nandflash特性" class="headerlink" title="eeprom, norflash, nandflash特性"></a>eeprom, norflash, nandflash特性</h2><p>搬运自<a href="https://blog.csdn.net/qq_43564374/article/details/122602141">EEPROM, NAND FLASH, NOR FLASH</a></p><h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><p><strong>EEPROM</strong>基于浮栅管单元（Floating gate transister）的结构。 EEPROM 的 单元是由FLOTOX（Floating- gate tuneling oxide transister）及一个附加的Transister 组成。由于FLOTOX 的特性及两管结构，所以可以单bit写。它的每个存储单元并联。</p><p>flash属于广义的EEPROM。FLASH 基于EEPROM， 与EEPROM主要的不同是FLASH 去除了 EEPROM 存储单元里的Tansister， 简化了存储电路(注意不是控制电路)。除此之外FLASH 的浮栅工艺不同， 所以写入速度更快。</p><p><strong>NOR FLASH</strong>的每个存储单元(bit)以并联的方式连接到数据bit线，方便对每一位进行随机存取。同时具有专用的地址线(可以理解为字线)，可以实现byte的直接寻址。NORFLASH具有足够的地址和数据线来映射整个存储区域，类似于SRAM的工作方式。例如，具有16位数据总线的2Gbit（256MB）NOR闪存将具有27条地址线，可以对任何byte进行随机读取访问。所以NORFLASH可以按byte读取。</p><p><strong>NAND FLASH</strong>各存储单元(bit)之间是串联的。在读取数据时，当字线和位线锁定某个晶体管时，该晶体管的控制极不加偏置电压，其它的 7 个都加上偏置电压而导通，如果这个晶体管的浮栅中有电荷就会导通使位线为低电平，读出的数就是 0，反之就是 1。所以每次读取都是读取一行bytes里面的同一个bit， 最后整合为一个块:它是按块读取。</p><h3 id="成本，容量"><a href="#成本，容量" class="headerlink" title="成本，容量"></a>成本，容量</h3><p>EEPROM存储电路并联， 每个bit的存储单元还要多加一个三极管， 最复杂所以单位成本也最高(注意不是控制电路)<br>因此它容量最低。EEPROM都是几十kbytes到几百kbytes，基本没有有超过512K。</p><p>NOR FLASH去除了EEPROM存储单元的三极管，每个存储单元并联， 去除了EEPROM存储单元的三极管， 集成度较小， 所以单位成本高。容量一般为1～16MB。</p><p>NAND FLASH， 去除了EEPROM存储单元的三极管， 各存储单元之间串联， 所以集成度大，单位成本最低。容量一般为8～512MB。</p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>EEPROM和FLASH在写入新数据之前，必须先将一个单元擦除(写 1)。 然后再在相应位写0。</p><p>NOR&amp;NAND FLASH 去除了EEPROM存储单元的三极管。 所以只能整块的擦除。每次擦除只能擦除一行字节的一个bit。这是一个降低了单位成本的折衷办法，因为这容易导致损耗：减少了总擦除/写入次数。擦除块越小擦除越快。 然而擦除块越小芯片面积和存储器成本增加。 与NOR闪存相比NAND闪存可以更经济高效地支持更小的擦除块。目前，NAND闪存的典型块大小为8KB至32KB， NOR Flash为64KB至256KB。</p><p>除此之外在NOR闪存中，每个字节在擦除之前都需要写入“0”。这使得NOR闪存的擦除操作比NAND闪存慢得多。例如，NAND闪存S34ML04G2需要3。5ms才能擦除128KB块，而NOR闪存S70GL02GT则需要约520ms来擦除类似的128KB扇区。这相差近150倍。除此之外NOR的擦除块更大，这就更慢了。</p><p>EEPROM和FLASH的浮栅工艺不同， 所以NANDFLASH写入速度最快， EEPROM居中， NOR最慢。</p><h3 id="读取数据粒度与速度"><a href="#读取数据粒度与速度" class="headerlink" title="读取数据粒度与速度"></a>读取数据粒度与速度</h3><p>EEPROM可以单字节读取。EERPOM一般用于低端产品，读的速度不需要那么快，真要做的话，其实也是可以做的和FLASH 差不多。它的每个存储单元并联。 所以它的特点是可以随机访问和修改任何一个字节，可以往每个bit中写入0或者1。</p><p>NOR FLASH可以单字节读取。NORFLASH的每个存储单元(bit)以并联的方式连接到数据bit线，方便对每一位进行随机存取；同时具有专用的地址线(可以理解为字线)，可以实现byte的直接寻址。NORFLASH具有足够的地址和数据线来映射整个存储区域，类似于SRAM的工作方式。例如，具有16位数据总线的2Gbit（256MB）NOR闪存将具有27条地址线，可以对任何byte进行随机读取访问。所以NORFLASH可以按byte读取， 随机读取(给一个地址读一个字节)时间很短。</p><p>NAND FLASH以页为单位读取。NAND FLASH各存储单元(bit)之间是串联的。在读取数据时，当字线和位线锁定某个晶体管时，该晶体管的控制极不加偏置电压，其它的 7 个都加上偏置电压而导通，如果这个晶体管的浮栅中有电荷就会导通使位线为低电平，读出的数就是 0，反之就是 1。所以每次读取都是读取一行bytes里面的同一个bit， 最后整合为一个页:它是按页读取。 随机读取时间很长。NAND 的全部存储单元分为若干个块，每个块又分为若干个页，每个页是 512byte: 每个页有 512 条位线，每条位线下有 8 个存储单元。</p><p>NAND FLASH每页存储的数据正好跟硬盘的一个块存储的数据相同，这是设计时为了方便与磁盘进行数据交换而特意安排的。在NAND闪存中，使用多路复用地址和数据总线访问存储器。典型的NAND闪存使用8位或16位多路复用地址/数据总线以及其他信号，如芯片使能，写使能，读使能，地址锁存使能，命令锁存使能和就绪/忙碌。 NAND Flash需要提供命令（读，写或擦除），然后是地址和数据。这些额外的操作也使NAND闪存的随机读取速度慢得多。</p><p>NAND闪存的顺序访问持续时间通常低于NOR闪存设备中的随机访问持续时间。利用NOR Flash的随机访问架构，需要在每个读取周期切换地址线，从而累积随机访问以进行顺序读取。随着要读取的数据块的大小增加，NOR闪存中的累积延迟变得大于NAND闪存。因此，NAND Flash顺序读取可以更快。但是由于NAND Flash的初始读取访问持续时间要长得多，两者的性能差异只有在传输大数据块(超过1 KB)时才明显。</p><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><p>EEPROM存储电路复杂， 具有较高的可靠性， 最稳定可以保存100年。</p><p>NOR FLASH存储电路比复杂， 具有比较高的可靠性。</p><p>NAND FLASH存储电路简单， 可靠性比较低。</p><p>闪存会遭遇称为位翻转的现象，其中一些位可以被反转。这种现象在NAND存储电路简单中所以位翻转比NOR更常见。NAND器件中的坏块是随机分布的。以前也曾有过消除坏块的努力，但发现成品率太低，代价太高，根本不划算。NAND需要对介质进行初始化扫描以发现坏块，并将坏块标记为不可用。一般来说NAND的Block0是没有位翻转的。随着擦除和编程周期在NAND闪存的整个生命周期中持续，更多的存储器单元变坏。因此坏块处理(错误探测/错误更正(EDC/ECC)算法。)是NAND闪存的强制性功能。 这导致NAND的控制器电路复杂。这个问题对于用NAND存储多媒体信息时不是致命的。 但如果用本地存储设备来存储操作系统，配置文件或其他敏感信息时，必须使用EDC/ECC系统以确保可靠性。</p><p>另一方面， NOR闪存坏块少，在存储器的使用寿命期间具有非常低的坏块累积。因此，当涉及存储数据的可靠性时，NOR Flash优于NAND Flash。可靠性的另一个方面是数据保留，这方面，NOR Flash再次占据优势，例如，NOR Flash闪存S70GL02GT提供20年的数据保留，最高可达1K编程/擦除周期，NAND闪存S34ML04G2提供10年的典型数据保留。</p><h3 id="擦除次数"><a href="#擦除次数" class="headerlink" title="擦除次数"></a>擦除次数</h3><p>EEPROM 每次只需要擦除一个字节所以不容易损耗，可以擦写100w次。</p><p>NAND闪存编程和擦除次数比NOR闪存好10倍。在NAND闪存中每个块的最大擦写次数是一百万次，NOR的擦写次数是十万次，NAND存储器除了块擦除次数优势， 典型的NAND块尺寸要比NOR器件小8倍， 每个NAND存储器块在给定的时间内的删除次数要少一些。编程和擦除的数量曾是一个需要考虑的重要特性。随着技术进步，这已不再适用，因为这两种存储器在这方面的性能已经很接近。例如，S70GL02GT NOR和S34ML04G2 NAND都支持100，000个编程 - 擦除次数。但是，由于NAND闪存中使用的块尺寸较小，因此每次操作都会擦除较小的区域， 与NOR Flash相比其整体寿命更长。</p><h3 id="XIP（eXecute-In-Place）"><a href="#XIP（eXecute-In-Place）" class="headerlink" title="XIP（eXecute In Place）"></a>XIP（eXecute In Place）</h3><p>eXecute In Place，即芯片内执行、就地执行，是指CPU直接从存储器中读取程序代码执行，而不用再读到内存中。应用程序可以直接在flash闪存内运行，不必再把代码读到系统RAM中。</p><p>flash内执行是指nor flash不需要初始化，可以直接在flash内执行代码。但往往只执行部分代码，比如初始化RAM。好处即是程序代码无需占用内存，减少内存的要求。</p><p>EEPROM&amp;NORFLASH 可以像内存一样读任意地址(任意字节)，可以XIP，当然这也要看接口是不是内存接口，如果不支持随机读取就一般不行，大部分NOR flash带有SRAM接口，有足够的地址引脚来寻址，可以很容易地存取其内部的每一个字节。可以非常直接地使用基于NOR的闪存，可以像其他存储器那样连接，并可以在上面直接运行代码。有的Norflash可以并行连接实现XIP，也可以串行通过SPI实现XIP。对于PC这需要相应的总线桥(内存控制器)芯片支持， Soc内部要集成相应桥芯片， 挂接到PCIE或者AMBA总线。 桥芯片的硬件逻辑会实现串并转换，总线仲裁，Cache结构，Burst等逻辑。</p><p>NANDFLASH 是按块读取，随机读取太慢所以不适合XIP当然这也要看接口是不是内存接口，如果不支持随机读取就一般不行，NAND使用复杂的I/O口来串行地存取数据。 一般是8个引脚用来传送控制，地址和数据信息 NANDFLASH只是不适合做XIP，但并不是不能做XIP，它坏块多，读取也太慢。比如EMMC启动就必须要把代码load到RAM里才能启动，你看到某些芯片支持EMMC启动，必定是有片内程序把EMMC的代码读到了RAM里。</p><h3 id="驱动复杂程度"><a href="#驱动复杂程度" class="headerlink" title="驱动复杂程度"></a>驱动复杂程度</h3><p>NAND更容易遇到位翻转， 驱动和控制电路要复杂的多。在使用NAND器件时，必须先写入驱动程序，才能继续执行其他操作。NAND在每一行上有CRC位标记，以及一些用于指示行是否为好的位。NAND处理芯片将管理CRC计算，允许在读取时纠正位错误，并管理坏行。</p><p>在USB驱动器中，这一切都由USB接口芯片处理。在SSD中，它由SATA（或其他接口模式）芯片处理，因此CRC错误和坏点映射对用户来说都是不可见的。这意味着在NAND器件上自始至终都必须进行虚拟映射。NAND内存的可靠运行还需要损耗均衡(就是把擦除平均到每个块上)，损耗均衡也由USB或SSD控制器处理，因此用户也不可见。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>通常，NOR闪存是需要较低容量，快速随机读取访问和更高数据可靠性的应用的理想选择，例如代码执行。<br>NAND闪存则非常适用于需要更高内存容量和更快写入和擦除操作的数据存储等应用。</p><p>LINUX嵌入式系统多用一个小容量的nor flash存储引导代码，用一个大容量的nand flash存放文件系统和内核。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ADC采样滤波算法</title>
      <link href="/2022/08/24/220824-adc%E9%87%87%E6%A0%B7/"/>
      <url>/2022/08/24/220824-adc%E9%87%87%E6%A0%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="ADC过采样"><a href="#ADC过采样" class="headerlink" title="ADC过采样"></a>ADC过采样</h2><p>用过不少模块中有ADC采样，如陀螺仪、磁罗盘、气压计、AFE中，都有ADC过采样率的配置，这些模块配置过采样率，输出的ADC量化位数没变，ADC值静态偏移量减小（信噪比提高），所以可以理解为多次采样取平均值。使用ADC过采样能提升精度，但是由于输出ADC值为多次采样平均，并不是单次采样时刻的值，AFE采电池电压的同时采电流，电压的值不是采电流那一时刻的瞬时值，导致SOC估算不准确。使用ADC过采样会提升采样次数，增大ADC的功耗。</p><p>下面来说说书里介绍的过采样。首先是结论：<strong>过采样率每提高4倍，可以提高ADC 1bit的有效分辨率</strong>。</p><p>假设ADC过采样率为4，ADC会采集4次将值相加，这其实增加了2bits的有效分辨率，这个过程还需要降低采样，或者下抽，下抽是将四次采样累计值&gt;&gt;1，这么做除了降低数据量外，就是可以提高分辨率。</p><h2 id="ADC降采样-减采样-下采样-down-sampling"><a href="#ADC降采样-减采样-下采样-down-sampling" class="headerlink" title="ADC降采样(减采样/下采样/down sampling)"></a>ADC降采样(减采样/下采样/down sampling)</h2><p>降采样网上的资料比较少，一般是原有的采样率比实际信号的有效最高频率要高很多，就可以对采到的信号做低通滤波，除去高频干扰后向下抽样。</p><p>采样这一块还得向香农和奈奎斯特学习，<a href="https://baike.baidu.com/item/%E9%A6%99%E5%86%9C%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86/7259506">香农-奈奎斯特采样定理</a>，当一个信号被减采样时，必须满足采样定理以避免混叠。为了满足采样定理的要求，信号在进行减采样操作前，必须通过一个具有适当截止频率的低通滤波器。这个用于避免混叠的低通滤波器，称为抗混叠滤波器。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GPS报文解析</title>
      <link href="/2022/08/17/220817-gps/"/>
      <url>/2022/08/17/220817-gps/</url>
      
        <content type="html"><![CDATA[<h2 id="GPS模块"><a href="#GPS模块" class="headerlink" title="GPS模块"></a>GPS模块</h2><p>商品链接：<a href="https://detail.tmall.com/item.htm?spm=a1z0d.6639537/tb.1997196601.377.28fa7484mpFNB4&id=619952916530&skuId=4626828970522">Beitian北天高精度GPS模块NEO-M8M陶瓷天线GPS北斗GLONASS三模GNSS授时BN-357</a></p><p>输出协议：NMEA-0183协议</p><h2 id="NMEA-0183协议"><a href="#NMEA-0183协议" class="headerlink" title="NMEA-0183协议"></a>NMEA-0183协议</h2><p><code>&lt;CR&gt;</code> 回车，(ASCII 13, \r)<br><code>&lt;LF&gt;</code> 换行，(ASCII 10, \n)<br><code>hh</code> 报文$到*之间数据的异或校验</p><h3 id="RMC"><a href="#RMC" class="headerlink" title="RMC"></a>RMC</h3><p>Recommended Minimum Specific GPS/TRANSIT Data（<strong>RMC</strong>）推荐定位信息</p><p>报文：<code>$GPRMC,&lt;1&gt;,&lt;2&gt;,&lt;3&gt;,&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;,&lt;8&gt;,&lt;9&gt;,&lt;10&gt;,&lt;11&gt;,&lt;12&gt;*hh&lt;CR&gt;&lt;LF&gt;</code><br>&lt;1&gt; UTC 时间，hhmmss.sss（时分秒）格式<br>&lt;2&gt; 定位状态，A=有效定位，V=无效定位<br>&lt;3&gt; 纬度ddmm.mmmm（度分）格式（前面的0也将被传输）<br>&lt;4&gt; 纬度半球N（北半球）或S（南半球）<br>&lt;5&gt; 经度dddmm.mmmm（度分）格式（前面的0也将被传输）<br>&lt;6&gt; 经度半球E（东经）或W（西经）<br>&lt;7&gt; 地面速率（000.0~999.9 节，前面的0 也将被传输）<br>&lt;8&gt; 地面航向（000.0~359.9 度，以真北为参考基准，前面的0 也将被传输）<br>&lt;9&gt; UTC 日期，ddmmyy（日月年）格式<br>&lt;10&gt; 磁偏角（000.0~180.0 度，前面的0 也将被传输）<br>&lt;11&gt; 磁偏角方向，E（东）或W（西）<br>&lt;12&gt; 模式指示（仅NMEA0183 3.00 版本输出，A=自主定位，D=差分，E=估算，N=数据无效）</p><h3 id="GGA"><a href="#GGA" class="headerlink" title="GGA"></a>GGA</h3><p>Global Positioning System Fix Data（<strong>GGA</strong>）GPS 定位信息</p><p>报文：<code>$GPGGA,&lt;1&gt;,&lt;2&gt;,&lt;3&gt;,&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;,&lt;8&gt;,&lt;9&gt;,M,&lt;10&gt;,M,&lt;11&gt;,&lt;12&gt;*hh&lt;CR&gt;&lt;LF&gt;</code><br>&lt;1&gt; UTC 时间，hhmmss.sss（时分秒）格式<br>&lt;2&gt; 纬度ddmm.mmmm（度分）格式（前面的0 也将被传输）<br>&lt;3&gt; 纬度半球N（北半球）或S（南半球）<br>&lt;4&gt; 经度dddmm.mmmm（度分）格式（前面的0 也将被传输）<br>&lt;5&gt; 经度半球E（东经）或W（西经）<br>&lt;6&gt; GPS 状态：0=未定位，1=非差分定位，2=差分定位，6=正在估算<br>&lt;7&gt; 正在使用解算位置的卫星数量（00~12）（前面的0 也将被传输）<br>&lt;8&gt; HDOP 水平精度因子（0.5~99.9）<br>&lt;9&gt; 海拔高度（-9999.9~99999.9）<br>&lt;10&gt; 地球椭球面相对大地水准面的高度<br>&lt;11&gt; 差分时间（从最近一次接收到差分信号开始的秒数，如果不是差分定位将为空<br>&lt;12&gt; 差分站ID 号0000~1023（前面的0 也将被传输，如果不是差分定位将为空）</p><h3 id="GSA"><a href="#GSA" class="headerlink" title="GSA"></a>GSA</h3><p>GPS DOP and Active Satellites（<strong>GSA</strong>）当前卫星信息</p><p>报文：<code>$GPGSA,&lt;1&gt;,&lt;2&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;3&gt;,&lt;4&gt;,&lt;5&gt;,&lt;6&gt;*hh&lt;CR&gt;&lt;LF&gt;</code><br>&lt;1&gt; 模式，M=手动，A=自动<br>&lt;2&gt; 定位类型，1=没有定位，2=2D 定位，3=3D 定位<br>&lt;3&gt; PRN 码（伪随机噪声码），正在用于解算位置的卫星号（01~32，前面的0 也将被传输）<br>&lt;4&gt; PDOP 位置精度因子（0.5~99.9）<br>&lt;5&gt; HDOP 水平精度因子（0.5~99.9）<br>&lt;6&gt; VDOP 垂直精度因子（0.5~99.9）</p><h3 id="GSV"><a href="#GSV" class="headerlink" title="GSV"></a>GSV</h3><p>报文：<code>$GPGSV,&lt;1&gt;,&lt;2&gt;,&lt;3&gt;,&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;,…&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;*hh&lt;CR&gt;&lt;LF&gt;</code></p><p>&lt;1&gt; GSV 语句的总数<br>&lt;2&gt; 本句GSV 的编号<br>&lt;3&gt; 可见卫星的总数（00~12，前面的0 也将被传输）<br>&lt;4&gt; PRN 码（伪随机噪声码）（01~32，前面的0 也将被传输）<br>&lt;5&gt; 卫星仰角（00~90 度，前面的0 也将被传输）<br>&lt;6&gt; 卫星方位角（000~359 度，前面的0 也将被传输）<br>&lt;7&gt; 信噪比（00~99dB，没有跟踪到卫星时为空，前面的0 也将被传输）<br>注：&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;信息将按照每颗卫星进行循环显示，每条GSV 语句最多可以显示4 颗卫星的信息。其他卫星信息将在下一序列的NMEA0183 语句中输出。</p><h3 id="VTG"><a href="#VTG" class="headerlink" title="VTG"></a>VTG</h3><p>Track Made Good and Ground Speed（<strong>VTG</strong>）地面速度信息</p><p>报文：<code>$GPVTG,&lt;1&gt;,T,&lt;2&gt;,M,&lt;3&gt;,N,&lt;4&gt;,K,&lt;5&gt;*hh&lt;CR&gt;&lt;LF&gt;</code><br>&lt;1&gt; 以真北为参考基准的地面航向（000~359 度，前面的0 也将被传输）<br>&lt;2&gt; 以磁北为参考基准的地面航向（000~359 度，前面的0 也将被传输）<br>&lt;3&gt; 地面速率（000.0~999.9 节，前面的0 也将被传输）<br>&lt;4&gt; 地面速率（0000.0~1851.8 公里/小时，前面的0 也将被传输）<br>&lt;5&gt; 模式指示（仅NMEA0183 3.00 版本输出，A=自主定位，D=差分，E=估算，N=数据无效）</p><h3 id="GLL"><a href="#GLL" class="headerlink" title="GLL"></a>GLL</h3><p>Geographic Position（<strong>GLL</strong>）定位地理信息</p><p>报文：<code>$GPGLL,&lt;1&gt;,&lt;2&gt;,&lt;3&gt;,&lt;4&gt;,&lt;5&gt;,&lt;6&gt;,&lt;7&gt;*hh&lt;CR&gt;&lt;LF&gt;</code><br>&lt;1&gt; 纬度ddmm.mmmm（度分）格式（前面的0 也将被传输）<br>&lt;2&gt; 纬度半球N（北半球）或S（南半球）<br>&lt;3&gt; 经度dddmm.mmmm（度分）格式（前面的0 也将被传输）<br>&lt;4&gt; 经度半球E（东经）或W（西经）<br>&lt;5&gt; UTC 时间，hhmmss（时分秒）格式<br>&lt;6&gt; 定位状态，A=有效定位，V=无效定位<br>&lt;7&gt; 模式指示（仅NMEA0183 3.00 版本输出，A=自主定位，D=差分，E=估算，N=数据无效）</p><h2 id="str转int-float函数"><a href="#str转int-float函数" class="headerlink" title="str转int/float函数"></a>str转int/float函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hexStr2Int</span><span class="params">(<span class="type">char</span> *pStr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*pStr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">num *= <span class="number">16</span>;</span><br><span class="line">num += *pStr - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(*pStr &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">num *= <span class="number">16</span>;</span><br><span class="line">num += *pStr - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(*pStr &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">num *= <span class="number">16</span>;</span><br><span class="line">num += *pStr - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">decStr2Int</span><span class="params">(<span class="type">char</span> *pStr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> isMinus = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(*pStr == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">isMinus = <span class="number">1</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(*pStr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">num *= <span class="number">10</span>;</span><br><span class="line">num += *pStr - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isMinus)</span><br><span class="line">num = -num;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">str2Float</span><span class="params">(<span class="type">char</span> *pStr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> intNum = <span class="number">0</span>;</span><br><span class="line"><span class="type">float</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> isMinus = <span class="number">0</span>;</span><br><span class="line">intNum = decStr2Int(pStr);</span><br><span class="line"><span class="keyword">if</span>(*pStr == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">isMinus = <span class="number">1</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(*pStr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(*pStr == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">pStr++;</span><br><span class="line"><span class="keyword">if</span>(*pStr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">num = decStr2Int(pStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(*pStr &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; *pStr &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">num /= <span class="number">10.f</span>;</span><br><span class="line">pStr++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isMinus)</span><br><span class="line">num = intNum - num;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">num = intNum + num;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找char和异或校验函数"><a href="#查找char和异或校验函数" class="headerlink" title="查找char和异或校验函数"></a>查找char和异或校验函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">uint16_t</span> <span class="title function_">findChar</span><span class="params">(<span class="type">uint8_t</span> findValue, <span class="type">uint8_t</span> *pStr, <span class="type">uint16_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint16_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++, pStr++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(*pStr == findValue)</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0xffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">uint8_t</span> <span class="title function_">calcXorCheck</span><span class="params">(<span class="type">uint8_t</span> *pStart, <span class="type">uint8_t</span> *pEnd)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(pStart &lt; pEnd)</span><br><span class="line">&#123;</span><br><span class="line">ret ^= *pStart;</span><br><span class="line">pStart++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="utcTime增加一秒函数"><a href="#utcTime增加一秒函数" class="headerlink" title="utcTime增加一秒函数"></a>utcTime增加一秒函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> <span class="title function_">gps_addSecondUtcTime</span><span class="params">(<span class="type">uint32_t</span> now)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint8_t</span> hh, mm, ss;</span><br><span class="line">ss = now%<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(ss &lt; <span class="number">59</span>)</span><br><span class="line">&#123;</span><br><span class="line">now++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ss = <span class="number">0</span>;</span><br><span class="line">mm = (now/<span class="number">100</span>)%<span class="number">100</span>;</span><br><span class="line">hh = (now/<span class="number">10000</span>)%<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(mm &lt; <span class="number">59</span>)</span><br><span class="line">&#123;</span><br><span class="line">mm++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">mm = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(hh &lt; <span class="number">23</span>)</span><br><span class="line">&#123;</span><br><span class="line">hh++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">hh = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">now = hh*<span class="number">10000</span> + mm*<span class="number">100</span> + ss;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析函数"><a href="#解析函数" class="headerlink" title="解析函数"></a>解析函数</h2><p>Github：<a href="https://github.com/hao0527/gps_data_parse">https://github.com/hao0527/gps_data_parse</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows C/C++编程</title>
      <link href="/2022/07/31/220731-WindowsC%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/07/31/220731-WindowsC%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows串口接收代码"><a href="#Windows串口接收代码" class="headerlink" title="Windows串口接收代码"></a>Windows串口接收代码</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/weixin_39100510/article/details/124292893">windows串口通信函数API</a></li><li><a href="http://www.yfvb.com/help/win32sdk/webhelplefth.htm">Win32API参考手册</a></li><li><a href="http://t.zoukankan.com/zhuguanhao-p-2887210.html">使用CreateFile()打开COM10及以上串口的问题</a></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">serial_openSerial</span><span class="params">(<span class="type">void</span>* lpFileName, <span class="type">unsigned</span> <span class="type">int</span> baudRate, <span class="type">unsigned</span> <span class="type">int</span> dwInQueue, <span class="type">unsigned</span> <span class="type">int</span> dwOutQueue)</span> &#123;</span><br><span class="line">    HANDLE hComm = <span class="literal">NULL</span>;</span><br><span class="line">    DCB dcb;</span><br><span class="line">    COMMTIMEOUTS commTimeOuts;</span><br><span class="line">    hComm = CreateFile(lpFileName,       <span class="comment">//串口名称</span></span><br><span class="line">                        GENERIC_READ | GENERIC_WRITE, <span class="comment">//允许读和写</span></span><br><span class="line">                        <span class="number">0</span>,             <span class="comment">//独占方式</span></span><br><span class="line">                        <span class="literal">NULL</span>,          <span class="comment">// 无安全属性，不可被子程序继承</span></span><br><span class="line">                        OPEN_EXISTING, <span class="comment">//创建文件的性质，打开而不是创建</span></span><br><span class="line">                        <span class="number">0</span>,             <span class="comment">// Non Overlapped I/O</span></span><br><span class="line">                        <span class="literal">NULL</span>);         <span class="comment">// Null for Comm Devices</span></span><br><span class="line">    SetupComm(hComm, dwInQueue, dwOutQueue);</span><br><span class="line">    GetCommState(hComm, &amp;dcb);</span><br><span class="line">    dcb.BaudRate = baudRate;</span><br><span class="line">    SetCommState(hComm, &amp;dcb);</span><br><span class="line">    commTimeOuts.ReadIntervalTimeout = <span class="number">0</span>;</span><br><span class="line">    commTimeOuts.ReadTotalTimeoutMultiplier = <span class="number">0</span>;</span><br><span class="line">    commTimeOuts.ReadTotalTimeoutConstant = <span class="number">0</span>;</span><br><span class="line">    commTimeOuts.WriteTotalTimeoutMultiplier = <span class="number">0</span>;</span><br><span class="line">    commTimeOuts.WriteTotalTimeoutConstant = <span class="number">0</span>;</span><br><span class="line">    SetCommTimeouts(hComm, &amp;commTimeOuts);<span class="comment">// 配置Timeout参数(ms)，0表示不Timeout</span></span><br><span class="line">    <span class="keyword">return</span> hComm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">serial_readLen</span><span class="params">(<span class="type">void</span>* hComm, <span class="type">unsigned</span> <span class="type">char</span>* pBuff, <span class="type">unsigned</span> <span class="type">int</span> len, <span class="type">unsigned</span> <span class="type">int</span>* pLenRead)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ReadFile(hComm, pBuff, len, pLenRead, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">serial_closeSerial</span><span class="params">(<span class="type">void</span>* hComm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> CloseHandle(hComm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">serial_purgeSerial</span><span class="params">(<span class="type">void</span>* hComm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PurgeComm(hComm, PURGE_RXCLEAR | PURGE_TXCLEAR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>Windows.h的api是<strong>正确返回非0</strong></p><h2 id="不同系统编译各数据类型所占内存空间大小"><a href="#不同系统编译各数据类型所占内存空间大小" class="headerlink" title="不同系统编译各数据类型所占内存空间大小"></a>不同系统编译各数据类型所占内存空间大小</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th>类型</th><th>win32</th><th>win64</th><th>linux32</th><th>linux64</th></tr></thead><tbody><tr><td>char</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>short</td><td>2</td><td>2</td><td>2</td><td>2</td></tr><tr><td>int</td><td>4</td><td>4</td><td>4</td><td>4</td></tr><tr><td>long</td><td>4</td><td>4</td><td>4</td><td>8</td></tr><tr><td>long long</td><td>8</td><td>8</td><td>8</td><td>8</td></tr><tr><td>float</td><td>4</td><td>4</td><td>4</td><td>4</td></tr><tr><td>double</td><td>8</td><td>8</td><td>8</td><td>8</td></tr><tr><td>void*</td><td>4</td><td>8</td><td>4</td><td>8</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>指针所占空间看系统是16位、32位还是64位。</li><li>win64把long编成4字节，linux64把long编成8字节。</li><li>在32位系统中，int和long都是4字节，取值范围相同。</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeMX使用上遇到的一些问题</title>
      <link href="/2022/07/31/220731-CubeMX/"/>
      <url>/2022/07/31/220731-CubeMX/</url>
      
        <content type="html"><![CDATA[<h2 id="使用DMA发送串口数据问题"><a href="#使用DMA发送串口数据问题" class="headerlink" title="使用DMA发送串口数据问题"></a>使用DMA发送串口数据问题</h2><ol><li>CubeMX生成的代码初始化DMA和UART顺序问题，应该先初始化DMA再UART，可以在CubeMX中调整生成初始化代码的顺序。<img src="https://hao0527.githttps//gitee.com/hao0527/hao0527/raw/img/31-CubeMX-1.jpg" alt="2207031-CubeMX-1.jpg"></li><li>CubeMX生成的代码使用<code>HAL_UART_Transmit_DMA()</code>后需要手动将串口状态配置成空闲状态，可以在DMA传输完成中断中加<code>(&amp;huart1)-&gt;gState = HAL_UART_STATE_READY;</code></li></ol><h2 id="串口接收溢出后接收不到数据"><a href="#串口接收溢出后接收不到数据" class="headerlink" title="串口接收溢出后接收不到数据"></a>串口接收溢出后接收不到数据</h2><ol><li>产生问题的原因：超出接收size、在没接收的时候接收超过1个字节的数据。</li><li>解决方法参考：<a href="https://blog.csdn.net/chengj_/article/details/122689442">stm32cube，HAL库 HAL_UART_Receive_IT中断接收多个字符，串口溢出卡死问题</a>。</li><li>关闭检测Overrun功能，或者使用错误处理回调函数。</li></ol><h2 id="串口接收一帧不定长数据"><a href="#串口接收一帧不定长数据" class="headerlink" title="串口接收一帧不定长数据"></a>串口接收一帧不定长数据</h2><ol><li>可使用<code>tm32f7xx_hal_uart_ex.h</code>中的<code>HAL_UARTEx_ReceiveToIdle()</code>函数。</li></ol><h2 id="HAL库操作Flash"><a href="#HAL库操作Flash" class="headerlink" title="HAL库操作Flash"></a>HAL库操作Flash</h2><ol><li>参考：<a href="https://blog.csdn.net/shoufei403/article/details/81978731">基于STM32F407 HAL库的Flash编程操作</a> 和 STM32F10xxx闪存编程参考手册</li><li>在每次擦除或编程前先要解锁Flash，在HAL库中，只需要调用<code>stm32f1xx_hal_flash.h</code>中的<code>HAL_FLASH_Unlock()</code>函数。</li><li>擦除时最小要以页为单位，传入的地址需要注意是否是页的起始地址。</li><li>编程时要注意4字节对齐，不同单片机可能不同。</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用Python统计花费</title>
      <link href="/2022/07/24/220724-python%E8%B4%A6%E6%9C%AC%E5%A4%84%E7%90%86/"/>
      <url>/2022/07/24/220724-python%E8%B4%A6%E6%9C%AC%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>不喜欢用现成的账本app记账，喜欢在手机记事本里记账，没次统计花费总额都需要按计算器，比较麻烦也不确定会不会按错，所以用Python写个脚本算算总共花费多少，额外也可以统计些自己想知道的数据。</p><h2 id="账本格式"><a href="#账本格式" class="headerlink" title="账本格式"></a>账本格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7.8 两餐-29 电费-57 开箱-30 充气宝-160</span><br><span class="line">7.9 一餐-10 充话费-54</span><br><span class="line">7.10 两餐-33 鼠标脚垫-11 早餐包-24</span><br><span class="line">7.11 两餐-22 出行-7 理发-13</span><br></pre></td></tr></table></figure><h2 id="脚本代码"><a href="#脚本代码" class="headerlink" title="脚本代码"></a>脚本代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">costStruct = [  &#123;&#x27;date&#x27;: &#x27;7.1&#x27;, &#x27;item&#x27;: [&#x27;两餐&#x27;], &#x27;consume&#x27;: [33]&#125;,</span></span><br><span class="line"><span class="string">                &#123;&#x27;date&#x27;: &#x27;7.2&#x27;, &#x27;item&#x27;: [&#x27;两餐&#x27;, &#x27;遮阳布&#x27;, &#x27;出行&#x27;], &#x27;consume&#x27;: [25, 6, 13]&#125;,</span></span><br><span class="line"><span class="string">                ...</span></span><br><span class="line"><span class="string">             ]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">costStruct = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file=<span class="string">&#x27;cost.txt&#x27;</span>, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    costStrList = fp.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除空白行</span></span><br><span class="line">delNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(costStrList)):</span><br><span class="line">    j = i - delNum</span><br><span class="line">    costStrList[j] = costStrList[j].strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(costStrList[j].replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)) == <span class="number">0</span>:</span><br><span class="line">        delNum = delNum + <span class="number">1</span></span><br><span class="line">        <span class="keyword">del</span>(costStrList[j])</span><br><span class="line"><span class="comment"># print(costStrList)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(costStrList)):</span><br><span class="line">    costDic = &#123;<span class="string">&#x27;date&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;item&#x27;</span>: [], <span class="string">&#x27;consume&#x27;</span>: []&#125;</span><br><span class="line">    strList = costStrList[i].split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    costDic[<span class="string">&#x27;date&#x27;</span>] = strList[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(strList)):</span><br><span class="line">        cost = strList[j].split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        costDic[<span class="string">&#x27;item&#x27;</span>].append(cost[<span class="number">0</span>])</span><br><span class="line">        costDic[<span class="string">&#x27;consume&#x27;</span>].append(<span class="built_in">int</span>(cost[<span class="number">1</span>]))</span><br><span class="line">    costStruct.append(costDic)</span><br><span class="line"><span class="comment"># print(costStruct)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算总共花费</span></span><br><span class="line">dayCost = []</span><br><span class="line">dateStr = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(costStruct)):</span><br><span class="line">    dayCost.append(<span class="built_in">sum</span>(costStruct[i][<span class="string">&#x27;consume&#x27;</span>]))</span><br><span class="line">    dateStr.append(costStruct[i][<span class="string">&#x27;date&#x27;</span>])</span><br><span class="line">    <span class="built_in">print</span>(costStruct[i][<span class="string">&#x27;date&#x27;</span>] + <span class="string">&#x27; cost ￥&#x27;</span> + <span class="built_in">str</span>(dayCost[i]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;total cost ￥&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">sum</span>(dayCost)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">3</span>+<span class="number">0.25</span>*<span class="built_in">len</span>(dayCost), <span class="number">8</span>), dpi=<span class="number">100</span>)    <span class="comment"># 自适应长度</span></span><br><span class="line">plt.bar(dateStr, dayCost)</span><br><span class="line">plt.xticks(rotation=<span class="number">45</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;total cost &#x27;</span> + <span class="built_in">str</span>(<span class="built_in">sum</span>(dayCost)) + <span class="string">&#x27; yuan&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;date&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;consume&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p>代码存放在<a href="https://github.com/hao0527/costSummary">https://github.com/hao0527/costSummary</a>，以后有新的统计分析需求，会直接在我的Github更新。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RC振荡器 晶体振荡器</title>
      <link href="/2022/07/10/220710-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/"/>
      <url>/2022/07/10/220710-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="RC振荡器"><a href="#RC振荡器" class="headerlink" title="RC振荡器"></a>RC振荡器</h2><p>在振荡电路中的频率选择部分可以只用电阻和电容构成，这种只用电阻和电容构成的振荡器称为RC振荡器。RC振荡器需要起振电路，常用的正弦波荡电路有文氏桥振荡电路，要起振所以电路是正反馈，RC构成选频网络，两个二极管和R3构成稳幅电路。</p><p><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/710-RC与晶体振荡器/2207010-RC与晶体振荡器-1.jpg" alt="2207010-RC与晶体振荡器-1.jpg"></p><p>RC振荡器容易封装到芯片中，MCU内部的时钟一般就是RC振荡器。成本低、功耗小、电路板上无需外部晶振，这些都是RC振荡器的优点。</p><p>缺点：MCU的内部振荡电路对外界干扰很敏感，非常容易受到外界环境温度的影响。同时精度也低，下图是用F767内部和外部振荡器生成1Hz方波的区别。</p><p><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/710-RC与晶体振荡器/2207010-RC与晶体振荡器-2.jpg" alt="2207010-RC与晶体振荡器-2.jpg"></p><h2 id="晶体振荡器"><a href="#晶体振荡器" class="headerlink" title="晶体振荡器"></a>晶体振荡器</h2><p>只要在晶体板级上施加交变电压，就会是晶片产生机械变形振动，此现象即所谓逆压电效应。当外加电压频率等于晶体谐振器的固有频率时，就会发生压电谐振，从而导致机械变形的振幅突然增大。一般而言，晶振的振荡频率比较稳定。但是价格稍微高点，还有用晶体振荡器一般还要接两个15-33pF起振电容。</p><p>有源晶振（Oscillator，晶振）只需要供电自身就能起振，无源晶振（Crystal，晶体）最高精度为5ppm，而有源晶振的精度则可以达到0.1ppm。有源晶振的信号电平是固定，所以需要选择好合适输出电平，灵活性较差。无源晶振单片机可以配置振荡输出电压。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0710-RC与晶体振荡器/2207010-RC与晶体振荡器-3.jpg" alt="有源晶振"><img src="https://hahttps//gitee.com/hao0527/hao0527/raw/img/%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8/2207010-RC%E4%B8%8E%E6%99%B6%E4%BD%93%E6%8C%AF%E8%8D%A1%E5%99%A8-4.jpg" alt="无源晶振"></p><h2 id="STM32CubeMX中的时钟配置"><a href="#STM32CubeMX中的时钟配置" class="headerlink" title="STM32CubeMX中的时钟配置"></a>STM32CubeMX中的时钟配置</h2><p><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/710-RC与晶体振荡器/2207010-RC与晶体振荡器-5.jpg" alt="STM32中的时钟配置"></p><p>BYPASS Clock Source：使用有源晶振的话，则只需要给它加上电源，即可输出时钟到MCU的时钟输入端，绕过MCU的OSC模块，时钟直接供MCU使用。</p><p>Crystal/Ceramic Resonator：使用晶体的话，除了外部需要加上谐振电容（有些会加上MΩ的反馈电阻）之外，还需要<strong>MCU内部的OSC振荡电路辅助</strong>才能正常产生所需时钟。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Xilinx FPGA 点灯</title>
      <link href="/2022/07/08/220708-XilinxFPGA%E7%82%B9%E7%81%AF/"/>
      <url>/2022/07/08/220708-XilinxFPGA%E7%82%B9%E7%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="好久不见，甚是想念"><a href="#好久不见，甚是想念" class="headerlink" title="好久不见，甚是想念"></a>好久不见，甚是想念</h2><p>一个多月没写博客了，毕业后学习时间少了，白天忙公司的项目，偶尔晚上有空看看自己想学的资料，自己还在做个地质分析仪的项目，每周日会花一天的时间做。为自己加油，2022年我还要完成这块FPGA的学习，感谢那位支持我学这块开发板的人。</p><h2 id="安装Vivado"><a href="#安装Vivado" class="headerlink" title="安装Vivado"></a>安装Vivado</h2><ol><li>下载vivado安装包，资料链接B盘：<a href="https://pan.baidu.com/s/1eM7Sx-RmeYFE1ht_RPqxhw">https://pan.baidu.com/s/1eM7Sx-RmeYFE1ht_RPqxhw</a> 提取码：a8vu</li><li>解压安装包到<strong>无中文路径的目录</strong>下，否则会出现安装包无法打开的情况。打开安装包，我在安装选件的页面取消了K系列、V系列和Soc Zynq的选件，安装空间要70GB左右，因此我还买了个1T的固态。</li><li>激活只需要网上下载对应版本的激活licences，在激活页面load a licences即可。</li></ol><h2 id="软件操作"><a href="#软件操作" class="headerlink" title="软件操作"></a>软件操作</h2><ol><li>Tools -&gt; Settings -&gt; Text Editor中选择编辑器，我选择的是notepad++，需要将编辑器路径加到系统环境变量。</li><li>创建PLL IP核：<img src="htthttps://gitee.com/hao0527/hao0527/raw/img/708-XilinxFPGA点灯/220708-XilinxFPGA点灯-2.jpg" alt="220708-XilinxFPGA点灯-2.jpg"></li><li>功能仿真，RTL分析，综合，约束输入，设计实现都在左侧的Flow Navigator中。</li></ol><h2 id="流水灯"><a href="#流水灯" class="headerlink" title="流水灯"></a>流水灯</h2><ol><li>New Project，芯片选择xc7a35tfgg484-2。<img src="httpshttps://gitee.com/hao0527/hao0527/raw/img/8-XilinxFPGA点灯/220708-XilinxFPGA点灯-1.jpg" alt="220708-XilinxFPGA点灯-1.jpg"></li><li>Add Sources -&gt; Create File，创建led_top.v文件。</li><li>Vivado中打开文件会调用Notepad++编辑器，编写流水灯代码：<img src="https://haohttps//gitee.com/hao0527/hao0527/raw/img/nxFPGA%E7%82%B9%E7%81%AF/220708-XilinxFPGA%E7%82%B9%E7%81%AF-5.jpg" alt="220708-XilinxFPGA点灯-5.jpg"></li><li>再功能仿真（可选），再综合、约束输入。</li><li>最后生成bit流下载到开发板：<img src="https://https//gitee.com/hao0527/hao0527/raw/img/ilinxFPGA%E7%82%B9%E7%81%AF/220708-XilinxFPGA%E7%82%B9%E7%81%AF-4.jpg" alt="220708-XilinxFPGA点灯-4.jpg"></li><li>Xilinx的集成开发环境要比Altera的好用不少，就是编译速度较慢。</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>交叉编译工具链的使用</title>
      <link href="/2022/05/22/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
      <url>/2022/05/22/220522-%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="交叉编译简介"><a href="#交叉编译简介" class="headerlink" title="交叉编译简介"></a>交叉编译简介</h2><p>交叉编译，是一个和本地编译相对应的概念，交叉编译通俗地讲就是一种平台上编译出的程序能够运行在不同体系结构的平台上，比如在PC平台（X86 CPU）上编译出能运行在ARM CPU的程序。</p><h2 id="使用交叉编译的原因"><a href="#使用交叉编译的原因" class="headerlink" title="使用交叉编译的原因"></a>使用交叉编译的原因</h2><p>主要原因是：嵌入式系统中的资源太少。具体的解释就是：所要运行的目标环境中，各种资源，都相对有限，所以很难进行直接的本地编译。嵌入式开发板的CPU、RAM、Falsh等硬件资源相对比较紧张，在已经运行了嵌入式Linux的前提下，没法方便的进行本地编译。因为编译，开发，都需要相对比较多的CPU，内存，硬盘等资源，而嵌入式开发上的资源，只够嵌入式（Linux）系统运行的，没太多剩余的资源，供你本地编译。</p><h2 id="交叉编译工具链组成"><a href="#交叉编译工具链组成" class="headerlink" title="交叉编译工具链组成"></a>交叉编译工具链组成</h2><p>常用交叉编译工具有交叉编译器、交叉连接器、交叉解释器还有交叉ELF文件工具、交叉反汇编器等工具。交叉编译工具链主要由binutils、gcc和glibc三个部分组成。有时出于减小 libc 库大小的考虑，也可以用别的 c 库来代替 glibc，例如 uClibc、dietlibc 和 newlib。</p><p>编译器能将我们编写的语言转成计算机可以识别的机器语言，解释器能够执行用其他计算机语言编写的程序的系统软件，它是一种翻译程序，转换一行，运行一行，再转换一行，再运行一行。<strong>解释性</strong>语言：Python，JavaScript，<strong>编译性</strong>语言：Java，c，c++。</p><h2 id="交叉工具链命名规则"><a href="#交叉工具链命名规则" class="headerlink" title="交叉工具链命名规则"></a>交叉工具链命名规则</h2><p>交叉编译工具链的命名规则为：arch - vendor - os - (gnu)eabi</p><p>arch – 体系架构，如ARM，MIPS，表示该编译器用于编译哪个目标平台的程序<br>vendor – 工具链提供商，通常是把vendor写成体系架构的值，比如cortex_a8<br>os – 运行编译产生的程序的目标操作系统，一般用linux表示有操作系统，none表示裸系统，uboot编译无os<br>eabi – 嵌入式应用二进制接口（Embedded Application Binary Interface），abi是计算机上的</p><h2 id="编译工具使用（持续更新）"><a href="#编译工具使用（持续更新）" class="headerlink" title="编译工具使用（持续更新）"></a>编译工具使用（持续更新）</h2><p>交叉编译工具使用方法与本地编译工具链基本一样，只是命名不同。</p><h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><p>Linux系统下的GCC编译器实际上是GNU编译工具链中的一款软件，可以用它来调用其他不同的工具进行诸如预处理、编译、汇编和链接这样的工作。gcc编译器从拿到一个c源文件到生成一个可执行程序，中间一共经历了四个步骤：</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/22-交叉编译工具链/220522-交叉编译工具链-1.jpg" alt="220522-交叉编译工具链-1.jpg"></p><h3 id="ld"><a href="#ld" class="headerlink" title="ld"></a>ld</h3><p>ld是GNU操作系统上的连接器，把二进制文件连接成可执行文件。<strong>ELF文件</strong>可用于程序的链接，重定位目标文件。用于链接的ELF文件格式：</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/22-交叉编译工具链/220522-交叉编译工具链-2.jpg" alt="220522-交叉编译工具链-2.jpg"></p><p>从编译和链接角度看ELF文件<strong>ELF头</strong>，每个ELF文件都必须存在一个ELF_Header，这里存放了很多重要的信息用来<strong>描述整个文件的组织</strong>，如：版本信息、入口信息、偏移信息等，程序执行也必须依靠其提供的信息。</p><p><strong>段头表</strong>，存放的是所有<strong>不同段将在内存中的位置</strong>。代码段.text section，存放已编译程序的机器代码，一般是只读的。只读数据段.rodata section，此段的数据不可修改，存放常量。数据段.data section，存放已初始化的全局变量。.bss section，未初始化全局变量，仅是占位符，不占据任何实际磁盘空间，目标文件格式区分初始化和非初始化是为了空间效率。</p><p>符号表.symtab section，它存放在程序中定义和引用的函数和全局变量的信息。.text节的重定位信息.rel.txt section，用于重新修改代码段的指令中的地址信息。.data节的重定位信息.rel.data section，用于对被模块使用或定义的全局变量进行重定位的信息。调试用的符号表.debug section。.strtab section，包含symtab和debug节中符号及节名。.line section，存储调试的行号信息，描述源代码和机器码之间的对应关系。</p><p>ELF(Executable and Linkable Format)的完整描述，可以参考这个文档 - <a href="http://www.uclibc.org/docs/elf-64-gen.pdf">这里</a></p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/22-交叉编译工具链/220522-交叉编译工具链-3.jpg" alt="220522-交叉编译工具链-3.jpg"></p><p>用于显示二进制文件各节的大小。</p><p>text段最终是存放在FLASH存储器中的，text段不仅包含函数，还有常量。</p><p>data段是用于初始化数据（全局/外部），既有初始化值的数据。</p><p>bss段包含着所有未初始化（或初始化值为0）的数据（全局/外部）。</p><p>dec（decimal的缩写，即十进制数）是text，data和bss的算术和。</p><h3 id="objcopy"><a href="#objcopy" class="headerlink" title="objcopy"></a>objcopy</h3><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/22-交叉编译工具链/220522-交叉编译工具链-4.jpg" alt="220522-交叉编译工具链-4.jpg"></p><p>把一种目标文件中的内容复制到另一种类型的目标文件中。</p><p><code>objcopy -O ihex xxxxxx.elf xxxxxx.hex</code> 将编译生成的elf文件转换为hex格式的文件。</p><p><code>objcopy -O srec xxxxxx.elf xxxxxx.srec</code> 将编译生成的elf文件转换为srec格式的文件。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git和SVN</title>
      <link href="/2022/05/12/220512-Git%E5%92%8CSVN/"/>
      <url>/2022/05/12/220512-Git%E5%92%8CSVN/</url>
      
        <content type="html"><![CDATA[<h2 id="Git和SVN"><a href="#Git和SVN" class="headerlink" title="Git和SVN"></a>Git和SVN</h2><p>公司里常用的两种版本控制工具：Git和SVN，两者最大的区别就是Git是分布式，SVN是集中式。<strong>集中式</strong>的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 <strong>分布式</strong>的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们在自己本地也会创建一个库，用于保存自己的修改与提交，之后再将自己库提交至服务器库进行更新。</p><p><strong>Subversion的特点概括起来主要由以下几条：</strong></p><ul><li>每个版本库有唯一的URL（官方地址），每个用户都从这个地址获取代码和数据；</li><li>获取代码的更新，也只能连接到这个唯一的版本库，同步以取得最新数据；</li><li>提交必须有网络连接（非本地版本库）；</li><li>提交需要授权，如果没有写权限，提交会失败；</li><li>提交并非每次都能够成功。如果有其他人先于你提交，会提示“改动基于过时的版本，先更新再提交”… 诸如此类；</li><li>冲突解决是一个提交速度的竞赛：手快者，先提交，平安无事；手慢者，后提交，可能遇到麻烦的冲突解决；</li></ul><p><strong>Git具有以下特点：</strong></p><ul><li>Git中每个克隆(clone)的版本库都是平等的。你可以从任何一个版本库的克隆来创建属于你自己的版本库，同时你的版本库也可以作为源提供给他人，只要你愿意；</li><li>Git的每一次提取操作，实际上都是一次对代码仓库的完整备份；</li><li>提交完全在本地完成，无须别人给你授权，你的版本库你作主，并且提交总是会成功；</li><li>甚至基于旧版本的改动也可以成功提交，提交会基于旧的版本创建一个新的分支；</li><li>Git的提交不会被打断，直到你的工作完全满意了，PUSH给他人或者他人PULL你的版本库，合并会发生在PULL和PUSH过程中，不能自动解决的冲突会提示您手工完成；</li><li>冲突解决不再像是SVN一样的提交竞赛，而是在需要的时候才进行合并和冲突解决；</li><li>Git 也可以模拟集中式的工作模式，Git版本库统一放在服务器中，Git 的集中式工作模式非常灵活；</li><li>可以为 Git 版本库进行授权：谁能创建版本库，谁能向版本库PUSH，谁能够读取（克隆）版本库;</li><li>团队的成员先将服务器的版本库克隆到本地；并经常的从服务器的版本库拉（PULL）最新的更新；</li><li>团队的成员将自己的改动推（PUSH）到服务器的版本库中，当其他人和版本库同步（PULL）时，会自动获取改变；</li><li>你完全可以在脱离Git服务器所在网络的情况下，如移动办公或出差时，照常使用代码库；</li><li>你只需要在能够接入Git服务器所在网络时，PULL和PUSH即可完成和服务器同步以及提交；</li><li>Git提供 rebase 命令，可以让你的改动看起来是基于最新的代码实现的改动；</li><li>Git 有更多的工作模式可以选择，远非 Subversion可比；</li><li>Git 分支是指针指向某次提交，而 SVN 分支是拷贝的目录，这个特性使 Git 的分支切换非常迅速，且创建成本非常低；</li></ul><h2 id="Git基本概念和常用命令"><a href="#Git基本概念和常用命令" class="headerlink" title="Git基本概念和常用命令"></a>Git基本概念和常用命令</h2><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库，版本库可分为远程仓库和本地仓库。<br><img src="https://gitee.com/hao0527/hao0527/raw/img/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-1.jpg" alt="220512-Git和SVN-1.jpg"></li></ul><p>Git 常用的是以下 6 个命令：<strong>git clone</strong>、<strong>git push</strong>、<strong>git add</strong> 、<strong>git commit</strong>、<strong>git checkout</strong>、<strong>git pull</strong><br><img src="https://gitee.com/hao0527/hao0527/raw/img/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-2.jpg" alt="220512-Git和SVN-2.jpg"></p><p> git 创建仓库的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化仓库</td></tr><tr><td align="left"><code>git clone</code></td><td align="left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><p>提交与修改的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git add</code></td><td align="left">添加文件到暂存区</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="left"><code>git commit</code></td><td align="left">提交暂存区到本地仓库。</td></tr><tr><td align="left"><code>git reset</code></td><td align="left">回退版本。</td></tr><tr><td align="left"><code>git rm</code></td><td align="left">删除工作区文件。</td></tr><tr><td align="left"><code>git mv</code></td><td align="left">移动或重命名工作区文件。</td></tr></tbody></table><p>提交日志的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看历史提交记录</td></tr><tr><td align="left"><code>git blame </code></td><td align="left">以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><p>远程操作的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote</code></td><td align="left">远程仓库操作</td></tr><tr><td align="left"><code>git fetch</code></td><td align="left">从远程获取代码库</td></tr><tr><td align="left"><code>git pull</code></td><td align="left">下载远程代码并合并</td></tr><tr><td align="left"><code>git push</code></td><td align="left">上传远程代码并合并</td></tr></tbody></table><p>Git 分支管理：<a href="https://www.runoob.com/git/git-branch.html">https://www.runoob.com/git/git-branch.html</a><br>Git 查看提交历史：<a href="https://www.runoob.com/git/git-commit-history.html">https://www.runoob.com/git/git-commit-history.html</a><br>Git 标签：<a href="https://www.runoob.com/git/git-tag.html">https://www.runoob.com/git/git-tag.html</a><br>更多命令查看Git完整命令手册地址：<a href="http://git-scm.com/docs">http://git-scm.com/docs</a></p><h2 id="Tortoise-SVN"><a href="#Tortoise-SVN" class="headerlink" title="Tortoise SVN"></a>Tortoise SVN</h2><p>SVN教程：<a href="https://www.runoob.com/svn/svn-tutorial.html">https://www.runoob.com/svn/svn-tutorial.html</a></p><p>TortoiseSVN 是 SVN(Subversion) 版本控制系统的一个免费开源客户端，可以超越时间的管理文件和目录。TortoiseSVN 使用教程：<a href="https://www.runoob.com/svn/tortoisesvn-intro.html">https://www.runoob.com/svn/tortoisesvn-intro.html</a></p><p>企业通常是使用TortoiseSVN提供的图像化界面操作，使用较简单。Windows的Git提供了GitGUI，也可以使用TortoiseGit，配置参数也有图形化界面，之前实习的一家公司就是 TortoiseGit 和 TortoiseSVN 。</p><h2 id="版本管控工具分支管理"><a href="#版本管控工具分支管理" class="headerlink" title="版本管控工具分支管理"></a>版本管控工具分支管理</h2><h3 id="SVN分支管理策略"><a href="#SVN分支管理策略" class="headerlink" title="SVN分支管理策略"></a>SVN分支管理策略</h3><ul><li>trunk(主干|主线|主分支)：是用来做主方向开发的，新功能的开发应放在主线中，当模块开发完成后，需要修改，就用branch。</li><li>branches(分支)：分支开发和主线开发是可以同时进行的，也就是并行开发，分支通常用于修复bug时使用。</li><li>tags (标记)：用于标记某个可用的版本，可以标记已经上线发布的版本，也可以标记正在测试的版本，通常是只读的。</li></ul><p>branch是用来做并行开发的，这里的并行是指和trunk进行比较。比如，3.0开发完成，这个时候要做一个tag，tag_release_3_0，然后基于这个tag做release，比如安装程序等。trunk进入3.1的开发，但是3.0发现了bug，那么就需要基于tag_release_3_0做一个branch，branch_bugfix_3_0，基于这个branch进行bugfix，等到bugfix结束，做一个tag，tag_release_3_0_1，然后，根据需要决定branch_bugfix_3_0是否并入trunk。</p><h3 id="Git分支管理策略"><a href="#Git分支管理策略" class="headerlink" title="Git分支管理策略"></a>Git分支管理策略</h3><p><strong>Git Flow模型</strong>中定义了主分支和辅助分支两类分支。其中主分支用于组织与软件开发、部署相关的活动，辅助分支组织用于解决特定的问题而进行的各种开发活动。Git Flow开发模型从源代码管理角度对通常意义上的软件开发活动进行了约束，为软件开发提供了一个可供参考的管理模型。Git Flow开发模型让代码仓库保持整洁，让小组各个成员之间的开发相互隔离，能够有效避免处于开发状态中的代码相互影响而导致的效率低下和混乱。</p><p>Git Flow模型的特点是只有2个主干分支，Master和Develop分支：Master分支上只有稳定的生产版本，Develop分支用于集成。其中还涉及到HotFix分支。而其他还有三类分支：Feature分支用于开发人员各自开发；Release用于代码合并和集成；HotFix用于产品版本代码的紧急修订。</p><p><strong>master分支</strong>通常只能从其它分支合并，不能在master分支直接修改。master分支上存放的是随时可供在生产环境中部署的代码（Production Ready state）。当开发活动到一定阶段，产生一份新的可供部署的代码时，master分支上的代码会被更新。同时，每一次更新，最好添加对应的版本号标签（TAG），所有在Master分支上的Commit应该打Tag。</p><p><strong>develop分支</strong>是保持当前开发最新成果的分支，一般会在此分支上进行晚间构建（Nightly Build）并执行自动化测试。develop分支产生于master分支, 并长期存在。当一个版本功能开发完毕且通过测试功能稳定时，就会合并到master分支上，并打好带有相应版本号的tag。develop分支是主开发分支，包含所有要发布到下一个Release的代码，主要合并其它分支，比如Feature分支。</p><p><strong>辅助分支</strong>是用于组织解决特定问题的各种软件开发活动的分支。辅助分支主要用于组织软件新功能的并行开发、简化新功能开发代码的跟踪、辅助完成版本发布工作以及对生产代码的缺陷进行紧急修复工作。辅助分支通常只会在有限的时间范围内存在。辅助分支包括用于开发新功能时所使用的feature分支，用于辅助版本发布的release分支，用于修正生产代码中的缺陷的hotfix分支。辅助分支都有固定的使用目的和分支操作限制。通过对分支的命名，定义了使用辅助分支的方法。</p><p><strong>feature分支</strong>可以从develop分支派生。feature分支的命名可以使用除master，develop，release-*，hotfix-*之外的任何名称。feature分支（topic分支）通常在开发一项新的软件功能的时候使用，分支上的代码变更最终合并回develop分支或者干脆被抛弃掉（例如实验性且效果不好的代码变更）。一般而言，feature分支代码可以保存在开发者自己的代码库中而不强制提交到主代码库里。Feature分支开发完成后，必须合并回Develop分支，合并完分支后一般会删feature分支，但也可以保留。</p><p><strong>release分支</strong>可以从develop分支派生。release分支是为发布新的产品版本而设计的。在release分支上的代码允许做测试、bug修改、准备发布版本所需的各项说明信息（版本号、发布时间、编译时间等）。通过在release分支上进行发布相关工作可以让develop分支空闲出来以接受新的feature分支上的代码提交，进入新的软件开发迭代周期。当develop分支上的代码已经包含了所有即将发布的版本中所计划包含的软件功能，并且已通过所有测试时，可以考虑准备创建release分支。而所有在当前即将发布的版本外的业务需求一定要确保不能混到release分支内（避免由此引入一些不可控的系统缺陷）。成功的派生release分支并被赋予版本号后，develop分支就可以为下一个版本服务。版本号的命名可以依据项目定义的版本号命名规则进行。发布Release分支时，合并Release到Master和Develop， 同时在Master分支上打个Tag记住Release版本号，然后就可以删除Release分支。</p><p><strong>hotfix分支</strong>可以从master分支派生。hotfix分支是计划外创建的，可以产生一个新的可供在生产环境部署的软件版本。当生产环境中的软件遇到异常情况或者发现了严重到必须立即修复的软件缺陷时，就需要从master分支上指定的TAG版本派生hotfix分支来组织代码的紧急修复工作。优点是不会打断正在进行的develop分支的开发工作，能够让团队中负责新功能开发的人与负责代码紧急修复的人并行的开展工作。hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag。</p><h2 id="使用Git遇到的问题"><a href="#使用Git遇到的问题" class="headerlink" title="使用Git遇到的问题"></a>使用Git遇到的问题</h2><h3 id="Git-tag"><a href="#Git-tag" class="headerlink" title="Git tag"></a>Git tag</h3><p>参考：<a href="https://blog.csdn.net/qq_21746331/article/details/1207767">GIT 中如何打标签（git tag）</a></p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-3.jpg" alt="220512-Git和SVN-3.jpg"></p><h3 id="Git-show"><a href="#Git-show" class="headerlink" title="Git show"></a>Git show</h3><p>给历史版本打标签时用的commit可以通过git show查看历史版本的hash。</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-4.jpg" alt="220512-Git和SVN-4.jpg"></p><h3 id="Git-log"><a href="#Git-log" class="headerlink" title="Git log"></a>Git log</h3><p>查看提交日志，当你要修改历史提交前，你可以通过git log看看要修改第几次的提交。</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-5.jpg" alt="220512-Git和SVN-5.jpg"></p><h3 id="Git-rebase"><a href="#Git-rebase" class="headerlink" title="Git rebase"></a>Git rebase</h3><p>通过git rebase可以修改历史的版本，参考：<a href="https://blog.csdn.net/weixin_62277266/article/details/124260568">Git系列之修改历史提交信息</a>，使用rebase指令后会在vi编辑器中选择要修改哪次提交，然后通过vi编辑器修改提交的内容。</p><p>注意：异常退出可能导致文件丢失，不要慌终端有提示如何恢复。</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220512-Git%E5%92%8CSVN/220512-Git%E5%92%8CSVN-6.jpg" alt="220512-Git和SVN-6.jpg"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言预处理</title>
      <link href="/2022/05/11/220511-C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/"/>
      <url>/2022/05/11/220511-C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="ANSI-C标准"><a href="#ANSI-C标准" class="headerlink" title="ANSI C标准"></a><a href="https://baike.baidu.com/item/ANSI%20C%E6%A0%87%E5%87%86/6044290?fr=aladdin">ANSI C标准</a></h3><p>ANSI C是<a href="https://baike.baidu.com/item/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E5%8D%8F%E4%BC%9A/5709537">美国国家标准协会</a>（ANSI）对<a href="https://baike.baidu.com/item/C%E8%AF%AD%E8%A8%80">C语言</a>发布的标准。使用C的软件开发者被鼓励遵循ANSI C文档的要求，因为它鼓励使用<a href="https://baike.baidu.com/item/%E8%B7%A8%E5%B9%B3%E5%8F%B0/8558902">跨平台</a>的代码。</p><p>发展过程中产生了C89、C90、C99、C11四套标准，最早的C89在1983年创立，C90是1990年创立的ANSI C标准（带有一些小改动），C99在2000年3月创立，C11在2011年12月创立。</p><h3 id="C预处理器"><a href="#C预处理器" class="headerlink" title="C预处理器"></a><a href="https://www.runoob.com/cprogramming/c-preprocessors.html">C预处理器</a></h3><table><thead><tr><th align="left">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">#define</td><td align="left">定义宏</td></tr><tr><td align="left">#include</td><td align="left">包含一个源代码文件</td></tr><tr><td align="left">#undef</td><td align="left">取消已定义的宏</td></tr><tr><td align="left">#ifdef</td><td align="left">如果宏已经定义，则返回真</td></tr><tr><td align="left">#ifndef</td><td align="left">如果宏没有定义，则返回真</td></tr><tr><td align="left">#if</td><td align="left">如果给定条件为真，则编译下面代码</td></tr><tr><td align="left">#else</td><td align="left">#if 的替代方案</td></tr><tr><td align="left">#elif</td><td align="left">如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码</td></tr><tr><td align="left">#endif</td><td align="left">结束一个 #if……#else 条件编译块</td></tr><tr><td align="left">#error</td><td align="left">当遇到标准错误时，输出错误消息</td></tr><tr><td align="left">#pragma</td><td align="left">使用标准化方法，向编译器发布特殊的命令到编译器中</td></tr></tbody></table><h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><p>ANSI C 定义了许多宏。在编程中可以使用这些宏，但是不能直接修改这些预定义的宏。</p><table><thead><tr><th align="left">宏</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">__DATE__</td><td align="left">当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量。</td></tr><tr><td align="left">__TIME__</td><td align="left">当前时间，一个以 “HH:MM:SS” 格式表示的字符常量。</td></tr><tr><td align="left">__FILE__</td><td align="left">这会包含当前文件名，一个字符串常量。</td></tr><tr><td align="left">__LINE__</td><td align="left">这会包含当前行号，一个十进制常量。</td></tr><tr><td align="left">__STDC__</td><td align="left">当编译器以 ANSI 标准编译时，则定义为 1。</td></tr></tbody></table><h3 id="pragma"><a href="#pragma" class="headerlink" title="#pragma"></a><a href="https://blog.csdn.net/weixin_39640298/article/details/84503428">#pragma</a></h3><p>#pragma指令的作用是：用于指定计算机或操作系统特定的编译器功能。C 和 C++ 的每个实现均支持某些对其主机或操作系统唯一的功能。 例如，某些程序必须对将数据放入的内存区域进行准确的控制或控制某些函数接收参数的方式。 在保留与 C 和 C++ 语言的总体兼容性的同时，#pragma 指令使每个编译器均能够提供特定于计算机和操作系统的功能。</p><p>根据定义，#pragma指令是计算机或操作系统特定的，并且通常对于每个编译器而言都有所不同。 #pragma指令可用于条件语句以提供新的预处理器功能，或为编译器提供实现所定义的信息。</p><p><code>#pragma pack([ show ] | [ push | pop ] [, identifier ] , n)</code>，用于内存对齐。<br><code>#pragma message(messageString)</code>，用于不中断编译的情况下，发送一个字符串文字量到标准输出。</p><p>编译器可识别的指令还有很多。</p><h3 id="和…"><a href="#和…" class="headerlink" title="##和…"></a><a href="https://blog.csdn.net/ysds20211402/article/details/122300354">##和…</a></h3><p><code>##</code> 起连接字符串的作用，用于把参数宏中的“形参”与其它没有天然分割的内容粘连在一起。<br>例如：<code>#define def_u32_array(__name, __size)    uint32_t array_##__name[__size];</code><br><code>def_u32_array(sample_buffer, 64)</code>，宏展开后为：<code>uint32_t array_sample_buffer[64];</code></p><p><code>...</code> 是ANSI-C99标准引入的另外一个参数宏扩展，“可变参数宏”，其实就是将__VA_ARGS__替换为…中的值。<br>例如：<code>#define log_info(__STRING, ...)    printf(__STRING, __VA_ARGS__)</code><br><code>log_info(&quot;Count:%d&quot;, total_cycle_cnt);</code>，宏展开后：<code>printf(&quot;Count:%d&quot;, total_cycle_cnt);</code><br><code>log_info(&quot;-----------------\r\n&quot;);</code>，宏展开后：<code>printf(&quot;-----------------\r\n&quot;,);</code>，…无参数，__VA_ARGS__为空，但是宏展开后仍有逗号。</p><p>逗号后无内容可能会产生个warning，想解决逗号问题，可以##和…一起使用。<br>例如：<code>\#define log_info(__STRING, ...)    printf(__STRING,##__VA_ARGS__)</code><br><code>log_info(&quot;-----------------\r\n&quot;);</code>，宏展开后：<code>printf(&quot;-----------------\r\n&quot;);</code></p><h3 id="…初始化数组"><a href="#…初始化数组" class="headerlink" title="…初始化数组"></a>…初始化数组</h3><p><code>int a[5] = &#123;[0...2] = 1, [3...4] = 2&#125;;</code>使数组a[0]~a[2] = 1, a[3]和a[4] = 2。</p><p>这种写法只可以在gcc编译C的情况下使用，gcc编译c++也不行。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Altera FPGA的网络摄像机设计与实现</title>
      <link href="/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/05/01/220501-%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="研究内容"><a href="#研究内容" class="headerlink" title="研究内容"></a>研究内容</h3><p>本文介绍了如何设计一个以Altera FPGA为核心的网络摄像机，将图像传感器和MEMS麦克风作为的主要传感器，辅以千兆以太网模块、电源模块等模块，最终完成实现一个低成本易使用的网络摄像机的功能。要求该网络摄像机能够实时传输图像和音频信息，在电脑端可以将图像实时处理显示并将音频实时播放。此外，还能够将数据流存储在设备中，便于用户对视频进行回放等操作。</p><h2 id="总体设计方案描述"><a href="#总体设计方案描述" class="headerlink" title="总体设计方案描述"></a>总体设计方案描述</h2><p>本设计方案是以Altera FPGA为核心，在Quartus 18.0开发平台上，实现FPGA接收图像传感器和麦克风数据，并通过千兆以太网PHY芯片，将图像和声音数据发送至电脑上位机，电脑上位机利用Python3编程语言编写，在PyCharm IDE中执行，实现音视频实时播放和音视频回放的功能。主要由Altera FPGA控制器、图像传感器模块、麦克风模块、以太网模块和电脑上位机组成，系统框图如下图所示。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-1.png" alt="220501-毕业设计-1.png"></p><h3 id="硬件选型"><a href="#硬件选型" class="headerlink" title="硬件选型"></a>硬件选型</h3><p>FPGA选用Cyclone IV EP4CE15 Starter Kit开发板。开发板板载W25Q64 SPI Flash芯片，8MB字节的存储容量，开发板给主控提供了50MHz的外部时钟源，芯片逻辑单元数为 15K LE，开发板引出了芯片的JTAG调试端口，引出了GMII千兆以太网接口，采用了RealTek的RTL8211EG芯片，引出了一个CMOS/CCD摄像头接口和40P的排座。开发板条件满足本设计的所有需求。</p><p>图像传感器选择经典的OV2640模组，OV2640适配开发板引出的40P的排座，提供了SCCB接口，可供配置传感器参数，可以配置最大1600*1200分辨率的图像输出，还可以配置JPEG压缩格式输出图像，模组拥有8位并口，可以高速输出图像信息，拥有帧场同步信号管脚，和电源使能管脚，方便FPGA控制和接收图像信息。</p><p>麦克风选择INMP441全向麦克风传感器，INMP441麦克风直接输出数字信号，采用的接口是I2S，非常适合FPGA去读取总线数据。传统驻极体麦克风输出模拟信号，选用INMP441省去了传统驻极体麦克所需的放大器、滤波器和模数转换器等硬件设计。</p><h3 id="FPGA设计方案"><a href="#FPGA设计方案" class="headerlink" title="FPGA设计方案"></a>FPGA设计方案</h3><p>FPGA设计采用模块化设计的方案，通过模块化设计，可以使一个大型设计分成多个模块，这样分工协作可使仿真测试更加容易，并且代码维护和代码升级也会更加方便。顶层模块不做逻辑设计，只通过例化调用子模块接口。因此，顶层模块下就由各功能模块组成，各功能模块下还可以分成多个子功能模块来实现。通过编译器对每个模块的综合仿真约束等设计，最后将所有模块连在一起，构成整个网络摄像机FPGA部分的设计。</p><p>本设计模块层次设计图如下所示，由时钟模块、数据交互模块、图像传感器模块、麦克风模块、千兆网络模块总共5个模块组成，各模块又由各个子模块组成，顶层模块通过例化的方式，将5个模块之间的接口互相连接起来，实现顶层模块的最终设计。该模块层次设计的各个子模块功能相对独立，各模块内部联系紧密，模块之间的连接简单，满足FPGA的模块化设计基本规则。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-2.png" alt="220501-毕业设计-2.png"></p><h3 id="上位机设计方案"><a href="#上位机设计方案" class="headerlink" title="上位机设计方案"></a>上位机设计方案</h3><p>上位机采用Python3编程语言设计，主要功能分为接收数据包、实时解码播放、保存回放。FPGA传来的UDP数据包包含了音频和图像，两者通过两个不同的端口传输，这样更便于应用层的分开处理。在UDP数据包中还加入了帧序列号，上位机可通过校验前后两帧的序列号是否对应，来判断是否发生掉包的现象。实时解码播放是通过数据包的传输协议将有用数据部分取出，图像数据为JPEG压缩图像，通过OpenCV对JPEG图像解码，通过图像流的方式显示在屏幕上。音频是通过PCM码流传输，通过约定好的采样频率、量化位数、声道数等信息，调用PyAudio函数库接口进行播放。回放功能是将图片流保存成avi视频格式，音频流保存成wav音频格式，然后在电脑文件系统中可以打开进行回放。通过多进程多线程将这三个功能配合起来，通过流水线操作的方式，让整个上位机程序执行更加的高效、稳定。上位机的程序流程图如下图所示。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-3.png" alt="220501-毕业设计-3.png"></p><h2 id="FPGA各模块功能实现"><a href="#FPGA各模块功能实现" class="headerlink" title="FPGA各模块功能实现"></a>FPGA各模块功能实现</h2><h3 id="时钟模块实现"><a href="#时钟模块实现" class="headerlink" title="时钟模块实现"></a>时钟模块实现</h3><h4 id="系统时钟输入和PLL配置"><a href="#系统时钟输入和PLL配置" class="headerlink" title="系统时钟输入和PLL配置"></a>系统时钟输入和PLL配置</h4><p>下图为FPGA开发板硬件原理图中的时钟部分，FPGA系统时钟信号由一颗50MHz有源晶振，从FPGA的T2引脚传入，由该时钟通过PLL锁相环和分频器，得到各模块所需的时钟，为整个系统提供准确的时钟信号。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-4.jpg" alt="220501-毕业设计-4.jpg"></p><p>锁相环（Phase Locked Loop, PLL）是一种反馈型的控制电路，可以通过PLL对输入时钟进行系统级的时钟控制，可以配置管理时钟相位、偏移，具有倍频、分频和可编程占空比等功能。由于本设计使用到的模块较多，使用单一的时钟通过软件分频无法得到精准音频采样的频率，所以满足本设计要求。故使用PLL模块来满足该设计的不同时钟频率和不同时钟相位偏移的要求。通过Quartus提供的PLL IP核，对Altera FPGA片上的可编程PLL进行控制，使其输出各种时钟信号提供给各个模块使用。</p><p>下图为在Quartus 18.0中通过PLL IP核配置输入50Mhz时钟，输出2.205MHz时钟提供给麦克风模块的采样频率使用，配置软件会根据输入输出时钟频率自动计算出PLL的各个参数（时钟倍频参数、时钟分频参数），提供给麦克风模块的采样频率不需要相位偏移和特殊的占空比，故设置相位偏移为0，占空比为50%。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-5.jpg" alt="220501-毕业设计-5.jpg"></p><h4 id="软件分频器实现"><a href="#软件分频器实现" class="headerlink" title="软件分频器实现"></a>软件分频器实现</h4><p>由于片上PLL资源数量有限，部分对时钟精准度要求不高的模块也可以采用软件分频器实现。例如I²C模块中的时钟信号采用250KHz，通过对输入的50MHz系统时钟上升沿或者下降沿计数，计数器值累加到100时，让输出信号产生翻转，即可产生250KHz的I²C驱动信号。这就是软件分频器的实现原理，占用硬件资源少，像这种整数倍分频，也可以提供较好的精度。</p><h3 id="数据交互模块实现"><a href="#数据交互模块实现" class="headerlink" title="数据交互模块实现"></a>数据交互模块实现</h3><p>设计FPGA各模块交互时，需要将图像和音频的数据传送给网络模块封装发送，故使用FIFO来做数据的缓冲。而网络模块的时钟信号是125MHz，与图像传感器模块24MHz和麦克风模块44100Hz有较大的区别，所以不能直接将数据通过同读写同时钟的FIFO传送给网络模块发送。FIFO模块可以配置读写相同时钟和读写不同时钟，在实际测试中，由于读取时钟为125MHz高频率信号，读写不同时钟情况下，FIFO的读写会产生严重的数据错误。因此本设计采用读写同时钟，FIFO模块输入时钟为网络模块的时钟125MHz，再手动编写跨时钟数据交互的时序逻辑，实现不同时钟域数据通过FIFO的转换。</p><h4 id="FIFO模块配置"><a href="#FIFO模块配置" class="headerlink" title="FIFO模块配置"></a>FIFO模块配置</h4><p>FIFO（First In First Out）模块是对数据缓冲时用到存储器，使模块可以被突发性读写。通常也被用于高速信号跨时钟域的数据交互，它可以被顺序写入，然后可以被顺序读出，先进先出的特性是FIFO不同于其他存储器的地方。</p><p>在Quartus 18.0中也可以通过IP核的方式来配置FIFO模块，关系FIFO容量的两个参数是FIFO的宽度和深度，宽度是指同时多少位可以被读写，深度是指可以存储多少该宽度的数据。由于FPGA中以太网是以字（4Bytes）的宽度来发送数据，并且以太网一帧默认最长大小是1500个字节，其中有用的数据为1472个字节，因此这里选择宽度为32bits，深度为512words可以满足缓冲一阵的以太网数据包。这里配置时我们采用读写相同时钟，从而使FIFO高速稳定的运行。需要打开usedw[]的功能，让网络模块读取已经使用的FIFO数量，当已经使用的数量大于等于1472字节时，可以开始发送一帧以太网数据。在输出寄存器一选项中，选择要求时间同步，Yes(best speed)，由于FIFO时钟是125MHz，不选速度优先的话也会导致FIFO读写混乱错误。同时关闭上下溢出检测以提升FIFO模块性能。下图为最后FIFO模块配置的部分参数，配置时一定要使性能最优。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-6.jpg" alt="220501-毕业设计-6.jpg"></p><h4 id="将数据写入FIFO模块实现"><a href="#将数据写入FIFO模块实现" class="headerlink" title="将数据写入FIFO模块实现"></a>将数据写入FIFO模块实现</h4><p>FIFO模块的时钟为125MHz，在图像FIFO存储模块中，图像传感器的时钟是24MHz，并且是8位宽度，需要手动编写跨时钟数据交互的时序逻辑，实现不同时钟域数据通过FIFO的转换。图像FIFO写模块输入有时钟、复位、图像数据、数据有效使能、垂直同步信号，输出有32位FIFO写入、FIFO写使能信号。捕获四个数据有效使能信号上升沿，将4个8位数据合并成1个32位数据，并向FIFO模块发送写使能，由于FIFO模块的时钟为125MHz，要写1个数据到FIFO模块，写使能信号高电平时间只能为8ns。为了使每幅图像不会等到下一张图像数据写入FIFO，直到FIFO满1472字节才发送，即使每幅图像都可以在该图像接收结束被发送完成，在垂直同步（一幅图像数据结束）信号产生后就向FIFO中追加写入1472个字节的0x00数据。</p><p>麦克风模块和网络模块也通过FIFO传递数据，麦克风模块的采样频率为44100Hz，也需要做个时钟转换和数据宽度转换，转换成FIFO模块的125MHz和32位宽才能写入FIFO，实现方法与图像数据写入FIFO模块类似。由于音频数据的采样量化位数是24位，转换成32位数据需要在首位补0x00，为了上位机方便保存成wav格式，采用小段存储方方式写入FIFO模块。</p><h4 id="从FIFO模块读取数据实现"><a href="#从FIFO模块读取数据实现" class="headerlink" title="从FIFO模块读取数据实现"></a>从FIFO模块读取数据实现</h4><p>网络模块在判断FIFO存储数量大于等于1472字节时会开始发送数据，发送数据时会请求读取FIFO模块数据，以太网发送数据的时钟是125MHz的，读取FIFO数据后要及时锁存，在锁存进入稳态后才可以被网络模块读取发送，否则由于FIFO发送速度过快，数据在信号线上容易未进入稳态被读取，造成读取和发送的数据出现错误。因为音频传送的数据量小，且实时性要求高，所以音频FIFO模块读取的优先级要设置比图像FIFO模块读取的优先级高。</p><h3 id="图像传感器模块实现"><a href="#图像传感器模块实现" class="headerlink" title="图像传感器模块实现"></a>图像传感器模块实现</h3><h4 id="I²C驱动模块实现"><a href="#I²C驱动模块实现" class="headerlink" title="I²C驱动模块实现"></a>I²C驱动模块实现</h4><p>使用OV2640传感器，需要用SCCB类I²C总线配置OV2640传感器的寄存器。I²C总线协议由飞利浦公司发明，由一根数据线和一根时钟线构成，属于半双工同步通信，较常用的时钟速率有低速模式100KHz，高速模式400KHz，超高速模式3.4MHz。I²C总线协议支持一主多从，由于I²C总线协议中设备标识符占7位空间，所以I²C总线理论可以挂载128个设备，但实际考虑I²C总线上设备的驱动能力，只可以挂载5个左右从设备。</p><p>I²C总线协议发送起始位后开始通信，起始位的标识是时钟线为高电平时，数据线从高电转变为低电平。通信时发送的第一个字节高7位内容为从设备的设备地址，末一位为读或写请求，低标识写标志位，反之则是读标志位。I²C通信协议中每发送一个字节后一位（第9位），对应的从机接收到就要发送应答响应，即第9位需要将数据线拉低响应，若主机读取到第9位仍为高电平，则标识无对应从机应答。发送设备地址后，若从机有应答，则主从双方继续通信，若主机写请求，就可以发送数据，向从机对应寄存器地址写入数据，从机收到数据后会返回应答信号，若主机读请求，则从机会向主机发送对应地址的数据内容，主机在接收后也需要拉低数据线响应。通信结束后主机发送停止位信号，停止位的标识是时钟线保持高电平，数据线从低电平转变为高电平的状态。</p><p>在FPGA中实现I²C驱动相对别的通信方式（USART、SPI等）难度较高，因为I²C驱动存在有多个工作状态，需要采用复杂的有限状态机来实现I²C驱动。下图是FPGA程序的有限状态机状态转移图，I²C驱动部分程序的代码见附录。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-7.jpg" alt="220501-毕业设计-7.jpg"></p><h4 id="图像传感器配置模块实现"><a href="#图像传感器配置模块实现" class="headerlink" title="图像传感器配置模块实现"></a>图像传感器配置模块实现</h4><p>OV2640图像传感器有较多的寄存器，参考数据手册配置，在图像传感器配置模块中总共配置了201个寄存器，通过case语句，用查表的形式读取相应寄存器地址和寄存器数据，发送给I²C驱动模块，配置OV2640图像传感器。</p><p>先对传感器软复位，后根据本设计的需要配置寄存器，例如：分辨率采用UXGA模式，对输入时钟不分频，倍频系数2，配置JPEG输出，设置图像窗口大小和图像尺寸大小等。配置的程序代码和各寄存器的配置的值见附录。在配置完成后，图像传感器配置模块会发送给图像数据读取模块OV2640初始化完成信号。</p><h4 id="图像数据读取模块实现"><a href="#图像数据读取模块实现" class="headerlink" title="图像数据读取模块实现"></a>图像数据读取模块实现</h4><p>图像传感器数据通讯接口采用的是DCMI接口，在OV2640中DCMI接口是8位数据并口，并且配有行同步垂直同步信号。行同步信号高电平时为图片中一行像素点有效数据，低电平为无效数据，所以每当出现行同步信号上升沿时就是该幅图像传输新的一行标识位。垂直同步信号是一张图片中有效数据的标识，当垂直同步高电平时为有效，每当出现垂直信号的下降沿时，表示该幅图像传输完成，当出现垂直信号的上升沿时，表示新的一幅图像传输开始。</p><p>图像数据读取模块收到配置模块发来的初始化完成信号后开始采集数据，在OV2640传感器实际应用中，图像传感器传来的前几幅图像会有显示问题，所以将开始传来的数据丢弃，根据垂直同步信号计数，第10幅图像开始开始采集图像数据发送给写FIFO模块。数据读取模块实现的代码见附录。</p><h3 id="麦克风模块实现"><a href="#麦克风模块实现" class="headerlink" title="麦克风模块实现"></a>麦克风模块实现</h3><h4 id="I²S总线数据读取模块实现"><a href="#I²S总线数据读取模块实现" class="headerlink" title="I²S总线数据读取模块实现"></a>I²S总线数据读取模块实现</h4><p>使用的MEMS硅麦克风采用的是I²S通信协议，当INMP441的L/R引脚为低电平时，INMP441提供单个左通道音频数据，时序图如下图所示。和I²C比较而言，I²S多了个WS接口，WS接口是串行数据声道选择，为低时左声道麦克风模块在I²S总线上发送数据，右声道是高阻态。WS为高时右声道麦克风模块在I²S总线上发送数据，而左声道是高阻态。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-8.jpg" alt="220501-毕业设计-8.jpg"></p><p>根据时序图可以编写FPGA的I²S驱动，可见经过WS的一周期会得到一组声音信号，WS在SCK下降沿时跳变，在WS跳变后的第二个SCK上升沿可以读取音频数据的最高位，依次24个SCK后得到完整的24位左声道音频数据。设计FPGA程序时，一周期WS会有50次SCK上升沿，因此SCK的频率会比WS高50倍，要保证采样率为44100Hz，就需要通过PLL模块给麦克风模块提供2.205MHz的SCK信号。具体的I²S驱动代码见附录。</p><h3 id="千兆以太网模块实现"><a href="#千兆以太网模块实现" class="headerlink" title="千兆以太网模块实现"></a>千兆以太网模块实现</h3><p>千兆以太网模块是本设计FPGA部分实现起来最复杂和困难的模块，由于千兆以太网PHY芯片采用125MHz高速时钟和8位并口数据传输，容易导致数据传输时未进入稳定态，出现时序混乱的现象。网络模块由三个部分组成，分别是网络发送模块、网络接收模块、CRC-32校验模块，三个模块之间的连接关系RTL视图如下图所示。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-9.jpg" alt="220501-毕业设计-9.jpg"></p><h4 id="CRC-32校验模块实现"><a href="#CRC-32校验模块实现" class="headerlink" title="CRC-32校验模块实现"></a>CRC-32校验模块实现</h4><p>以太网帧组成如下图所示，它是由前导、帧起始定界符、以太网帧头、以太网数据、帧校验序列组成，其中网络中帧校验序列使用最广泛的是采用4字节的循环冗余校验方式，即CRC-32校验。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-10.jpg" alt="220501-毕业设计-10.jpg"></p><p>CRC-32计算方式可以采用串行或并行计算，为了发挥FPGA并行优势，本设计采用并行的方式计算CRC-32校验码，并行CRC-32计算的表可以由工具生成。在FPGA设计中，该模块输入的值有时钟、使能、一字节数据，以太网每发送一字节数据，就要将发送的数据值发送给CRC-32校验模块，会根据上次CRC-32的结果和本次传来的数据值，同步更新CRC-32的值，最后输出为CRC-32校验的结果加在以太网帧的帧尾发送出去，如果目的主机校验CRC-32结果失败，则会在数据链路层丢弃该帧。具体的CRC-32校验模块实现代码见附录。</p><h4 id="千兆以太网数据发送模块实现"><a href="#千兆以太网数据发送模块实现" class="headerlink" title="千兆以太网数据发送模块实现"></a>千兆以太网数据发送模块实现</h4><p>实现以太网数据发送模块，要解决两个问题，需要发送的数据包含哪些信息，需要如何控制千兆以太网PHY芯片。</p><p>在CRC-32校验模块实现一节中介绍了以太网帧的组成结构，在发送目的MAC地址时使用ff-ff-ff-ff-ff-ff广播地址。以太网帧中的以太网数据段格式如下图所示，由于网络摄像机传输要满足实时性，且网络传输在局域网环境下环境不复杂，所以采用UDP协议传输数据，即在IP首部选择协议的地址中写入17表示UDP，生存时间一般为64，标识部分需要每次发送后累加，首部校验和是对IP首部内容累加保留末四位进行校验，在本设计中将源IP地址（FPGA的IP地址）设置为192.168.0.2，目的IP地址（电脑的IP地址）设置为192.168.0.3。以太网数据一般不超过1500字节，IP首部占了24字节，所以IP数据部分最大可为1476字节，其中IP数据的首四字节为用户自定义的帧序列号，用于上位机校验是否有丢包现象产生，所以实际每帧的IP数据中传输有用信息的只有1472个字节。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-11.jpg" alt="220501-毕业设计-11.jpg"></p><p>下图为物理层芯片RTL8211的硬件原理图，可见RTL8211与FPGA的连接主要包含8个发送引脚、8个接收引脚，还有发送和接收的时钟引脚，MDC和MDIO属于配置RTL8211芯片寄存器的接口，在本设计中采用默认寄存器值，所以未用到配置引脚。RTL8211发送和接收时钟均为125MHz，上升沿采样，发送和接收均为8位并口，可以满足1000Mbps全双工通信。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-12.jpg" alt="220501-毕业设计-12.jpg"></p><p>设计千兆以太网数据发送模块也是用有限状态机实现，使用了idle, start, make, send55, sendmac, sendheader, sendpicdata, sendmicdata, sendcrc共9个状态。在idle状态的时候，程序主要是初始化数据，并且检测图像FIFO和音频FIFO是否有超过1472个字节，其中先检测音频FIFO的使用量，若有超过1472个字节跳转到下个状态start。在start状态中会对IP首部进行配置，如果是图像FIFO大于1472字节，会配置端口号为8080，如果是音频FIFO大于1472字节，会配置端口号为8081，配置完成后会跳到下一个状态。make状态中会对IP首部计算校验和，并写入IP首部配置变量ip_header中，跳转至send55状态。在send55状态下，FPGA会和RTL8211通信，发送7字节前导码0x55和1字节帧起始界定符0xD5，发送完成后跳转到下个状态sendmac。在sendmac状态中会发送以太网帧头，包含目的MAC地址，源MAC地址，长度类型这些信息。下个状态sendheader，即发送start状态下存入ip_header变量中的IP首部信息，接下来进入发送数据的状态。发送数据的状态分两种一种是发送图像的状态，另一种是发送音频数据的状态，两个实现的方法一致，只是FIFO读请求所对应的FIFO不同，在发送数据状态中要先发送帧序列号，图像和音频的帧序列号是分开的，发送完帧序列号后循环请求读FIFO368次，将1472字节数据发送给RTL8211芯片，RTL8211会将从FPGA接收到的数据通过网线中的两对差分信号线发送到电脑网口。发送数据状态结束后进入最后一个sendcrc状态，该状态下会读取最后CRC-32的校验值发送给以太网PHY芯片，该状态结束后，表示一帧以太网数据传输结束，状态又跳转至空闲状态检测两个FIFO使用量。具体实现详见附录代码。</p><h2 id="上位机功能实现"><a href="#上位机功能实现" class="headerlink" title="上位机功能实现"></a>上位机功能实现</h2><h3 id="图像功能实现"><a href="#图像功能实现" class="headerlink" title="图像功能实现"></a>图像功能实现</h3><h4 id="接收和解析图像数据包功能实现"><a href="#接收和解析图像数据包功能实现" class="headerlink" title="接收和解析图像数据包功能实现"></a>接收和解析图像数据包功能实现</h4><p>接收UDP的数据包使用了Python中socket库，在程序开始引用该库，通过socket.socket(socket.AF_INET, socket.SOCK_DGRAM)构造函数构造一个套接字，配置使用UDP协议，并且通过server.bind(‘192.168.0.3’, 8080)绑定该套接字对应的IP地址和端口号。接收UDP数据包通过函数server.recvfrom(BUFSIZE)，其中BUFSIZE为缓冲大小，由于一帧以太网数据1472字节，这里将BUFSIZE设置为1472*1000，以实现每次接收缓冲区满足处理的速度。在每次接收UDP数据包后，首先会校验帧序列号，即数据区前四字节，帧序列号是否为上次接收的累加1，若帧序列号不连续则表示存在丢包的现象，通过打印verify error告诉用户帧序列号校验失败。处理图像数据时，传来的图像数据时JPEG编码格式，由于JPEG编码格式帧起始标识符值为0xFFD8、帧结束标识符值为0xFFD9，提取数据包中的有用数据就是通过find(0xff, index)函数找到0xff功能标识符，然后再判断的下一字节是否为0xD8，若判断为真即表示找到JPEG图像数据头，再找尾标识符0xFFD9，通过同样的方法找到数据尾标识符后，将JPEG图像数据包头到包尾数据通过fp.write(data)函数写入jpg格式的文件，就完成了一张图像的保存。</p><h4 id="图像流实时播放功能实现"><a href="#图像流实时播放功能实现" class="headerlink" title="图像流实时播放功能实现"></a>图像流实时播放功能实现</h4><p>要实现图像流实时播放功能，需按照拍摄图像的帧率，连续读取保存在磁盘中的图像，再在屏幕上不断刷新显示。本设计上位机程序采用OpenCV函数库实现图像的读取，解码和显示的功能。首先，在程序的开头通过import cv2引用OpenCV库。通过img = cv2.imread(img_root + str(i)+’.jpg’, cv2.IMREAD_COLOR)读取jpg格式的文件，其中img_root为图像所在文件夹的名字，imread的第一个参数就是图像路径，将读取到的数据保存在mat对象img中。调用cv2.namedWindow(“video”, cv2.WINDOW_AUTOSIZE)创建一个显示图像的窗口，窗口名为video。最后通过cv2.imshow(“video”, img)函数，该函数可以让名为video的显示窗口中显示img图像信息。cv2.waitKey(55)函数是使该窗口显示时间为55ms，这个延时时间由视频的帧数决定。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-13.jpg" alt="220501-毕业设计-13.jpg"></p><h4 id="图像流存储功能实现"><a href="#图像流存储功能实现" class="headerlink" title="图像流存储功能实现"></a>图像流存储功能实现</h4><p>OpenCV库中有支持导出avi视频的函数，fourcc = cv2.VideoWriter_fourcc(*’XVID’)函数，其中XVID参数是指将视频以MPEG-4编码类型保存，保存成avi格式的文件。videoWriter = cv2.VideoWriter(‘./avi/‘ + str(j) + ‘.avi’, fourcc, fps, size)函数配置了视频保存的路径，编码格式，帧率和每帧图像的分辨率，size = (1600, 1200)图像为1600 * 1200的分辨率。通过videoWriter.write(img)函数可以将img图像信息传入，让OpenCV处理生成视频。每隔150张图像发布一个10秒钟时长的avi视频，通过函数videoWriter.release()实现avi视频的发布。每次发布成功后程序会打印release告诉用户，可以在avi文件夹下查看保存的回放视频。</p><h3 id="音频功能实现"><a href="#音频功能实现" class="headerlink" title="音频功能实现"></a>音频功能实现</h3><h4 id="接收和解析音频数据包功能实现"><a href="#接收和解析音频数据包功能实现" class="headerlink" title="接收和解析音频数据包功能实现"></a>接收和解析音频数据包功能实现</h4><p>接收音频数据的方式与接收图像数据方式相同，通过Python的socket库。在接收音频数据后做帧序列号校验，并提取有效部分。接收到的音频数据是24位的麦克风adc原始值，由于自己电脑声卡输出只支持16位，播放24位音频会没有声音，故在上位机上做了个24位转换为16位的操作，即提取高16位数据，保存到pcm文件中。使用20ms的数据缓冲时间，分别将20ms的pcm数据保存到电脑中。</p><h4 id="音频流实时播放功能实现"><a href="#音频流实时播放功能实现" class="headerlink" title="音频流实时播放功能实现"></a>音频流实时播放功能实现</h4><p>上位机使用pyaudio库播放PCM音频，在程序的开始通过import pyaudio引用该库，读取已经保存在硬盘中的音频数据，通过p = pyaudio.PyAudio()初始化音频播放器，由于PCM是音频的原始数据，不包含量化位数、通道数、采样率等参数，所以，通过stream = p.open(format=p.get_format_from_width(2), channels=1, rate=44563, output=True)配置要播放音频的参数，并赋值给stream对象。通过stream.write(data)向stream播放器对象中写入音频数据，就可以完成音频的实时播放。</p><h4 id="音频流存储功能实现"><a href="#音频流存储功能实现" class="headerlink" title="音频流存储功能实现"></a>音频流存储功能实现</h4><p>使用wave库，将pcm音频保存成wav格式的音频文件写入磁盘，为了方便回放，每10s中保存一个wav音频。通过wavfile = wave.open(‘./wav/‘ + str(j) + ‘.wav’, ‘wb’)打开一个wav文件，通过设置函数给wavfile对象设置音频的通道数、量化位数和采样率。最后通过wavfile.writeframes(data)就可以往wav文件中追加音频内容，每10s保存成一个文件。</p><h3 id="通过多进程实现各个功能"><a href="#通过多进程实现各个功能" class="headerlink" title="通过多进程实现各个功能"></a>通过多进程实现各个功能</h3><h4 id="多进程并行工作实现"><a href="#多进程并行工作实现" class="headerlink" title="多进程并行工作实现"></a>多进程并行工作实现</h4><p>为了让程序高效运行，发挥CPU的多核优势，采用多进程并行的思想来实现上位机的设计。使用多进程可以实现流水线架构，例如，让解码显示图像的操作不阻塞接收UDP数据。在本上位机中共使用了四个进程，分别是图像接收数据和解析数据进程、音频接收数据和解析数据进程、图像实时显示和保存回放进程、音频实时播放和保存回放进程，四个进程互不影响，并行运行。在Python中使用multiprocessing库可实现多进程，例如创建接收和保存数据的进程p1 = multiprocessing.Process(target=receive_save_process, args=(pipe[0], ))，第一个参数是传入进程所执行的函数，第二个参数是所要执行的函数对外的参数接口。通过p1.start()就可以使进程开始运行。</p><h4 id="数据包进程间通信实现"><a href="#数据包进程间通信实现" class="headerlink" title="数据包进程间通信实现"></a>数据包进程间通信实现</h4><p>在Python中进程间通信的常用方式有文件IO，共享内存，管道，消息队列等。通过文件的方式内存通信比较占用IO资源，为了使视频有更好的实时性，本设计采用管道和IO流的方式进程间通信。通过fp = io.BytesIO()创建IO流让fp指向该字节流，fp可以像文件一样通过write函数被写入，通过read函数读取IO流中的数据。多进程库提供了管道这种通信方式，通过multiprocessing.Pipe()创建管道。在多进程通信中，将数据写入IO流，并通过管道传输IO流的地址，使数据可以在内存中被交互，从而达到减小传输时延，使视频更具实时性。</p><h2 id="系统性能测试与功能展示"><a href="#系统性能测试与功能展示" class="headerlink" title="系统性能测试与功能展示"></a>系统性能测试与功能展示</h2><h3 id="系统性能测试"><a href="#系统性能测试" class="headerlink" title="系统性能测试"></a>系统性能测试</h3><h4 id="FIFO和以太网高带宽传输测试"><a href="#FIFO和以太网高带宽传输测试" class="headerlink" title="FIFO和以太网高带宽传输测试"></a>FIFO和以太网高带宽传输测试</h4><p>FPGA编写测试模块，往FIFO模块中高速写入数据，再从FIFO中读取出进行对比，若对比不正确则亮红灯提示。测试的数据需要每次都不一致，竟可能有多个位产生变化，可以采用随机值。噪声的ADC值可以作为硬件真随机值，在本设计中通过麦克风传感器的低八位ADC值来作为测试数据，通过测试FIFO可以在125MHz频率下全速读写。</p><p>以太网测试也是采用比对发送和接收到的数据，由于发送和接收数据无法简单的通过其他的方式高速传输，所以要发送的数据选择有规律的数据。数据选择从0x00开始，下一字节都发送上一个数据加一后的补码，这样可以使每次发送的数据较上一次数据有更多的位会产生变化，通过此方法可以检测出更多的异常数据，若只通过单纯的数据累加测试，无法发现异常数据。经测试，以太网数据在200Mbps带宽下有较好的准确性，丢包现象不常发生，以太网在P2P模式下，全速传输千兆带宽数据时，丢包率为2%左右。</p><h4 id="系统稳定性测试"><a href="#系统稳定性测试" class="headerlink" title="系统稳定性测试"></a>系统稳定性测试</h4><p>对本设计经过长时间的稳定性测试，本设计不会产生图像卡顿，回放保存失败等现象，说明本设计具有良好的系统稳定性。</p><h3 id="作品展示"><a href="#作品展示" class="headerlink" title="作品展示"></a>作品展示</h3><p>下图为FPGA部分的图片，包含FPGA开发板、图像传感器和麦克风传感器。</p><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0501-毕业设计/220501-毕业设计-14.jpg" alt="220501-毕业设计-14.jpg"></p><h2 id="总结与不足"><a href="#总结与不足" class="headerlink" title="总结与不足"></a>总结与不足</h2><p>毕业设计是对学生四年所学知识的一次考察，也是对我们四年学习成绩的一次考验。本次毕业设计让我学习了FPGA设计和上位机开发，经过此次毕业设计，我懂得了如何将一整个设计划分成多个小功能逐个实现，在联调的过程中也学习了如何分析问题和解决问题。通过本次毕业设计，让我懂得了学习其实是长期积累的过程，越往深的学会发现自己有越多的不会，所以在今后工作是也要学会敬畏知识，学习是个长期积累的过程，就算毕业工作会我也会持续学习，努力提高自己的综合水平。</p><p>本次毕业设计还有几个可以改进的地方：第一，在传输UDP的时候为采用丢包重传，上位机具备发现丢包的能力，可以在丢包发生时将帧序列号发回FPGA，请求FPGA重发数据。第二，上位机软件没有图形化界面，可以使用QT对上位机的图形化界面做开发。第三，FPGA可以尝试设计个MCU，在MCU中跑操作系统和lwip协议栈，使用TCP协议传输语音数据。本设计还有更多功能待完善。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GPIO输入输出各种模式（推挽、开漏、准双向端口）详解</title>
      <link href="/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/04/26/220426-GPIO%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>此文章是搬运来的，<a href="https://blog.csdn.net/techexchangeischeap/article/details/72569999">原地址点击此处</a>，写的真好，能看的非常懂，原作者有个地方可能笔误写错了，做了改正。</p><h2 id="输入IO"><a href="#输入IO" class="headerlink" title="输入IO"></a>输入IO</h2><p>这里所说的输入IO，指的是只作为输入，不具有输出功能。此时对于input引脚的要求就是高阻（高阻与三态是同一个概念）。基本输入电路的类型大致可以分为3类：基本输入IO电路、施密特触发输入电路以及弱上拉输入电路。</p><p>先从最基本的基本输入IO电路说起，其电路如图 1所示。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-1.jpg" alt="220426-GPIO输入输出各种模式-1.jpg"></p><p>其中的缓冲器U1是具有控制输入端，且具有高阻抗特性的三态缓冲器。通俗地说就是这个缓冲器对外来说是高阻的，相当于在控制输入端不使能的情况下，物理引脚与内部总线之间是完全隔离的，完全不会影响内部电路。而控制输入端的作用就是可以发出读Pin状态的操作指令。其过程如图 2所示。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-2.jpg" alt="220426-GPIO输入输出各种模式-2.jpg"></p><p>这种基本电路的一个缺点是在读取外部信号的跳变沿时会出现抖动，如下图所示。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-3.jpg" alt="220426-GPIO输入输出各种模式-3.jpg"></p><p>于是施密特触发输入电路就是解决了上述这种抖动的问题，其经过施密特触发器后的信号如图 4所示。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-4.jpg" alt="220426-GPIO输入输出各种模式-4.jpg"></p><p>对于输入电路还存在另外一个问题，就是当输入引脚悬空的时候，输入端检测到的电平是高还是低？当输入信号没有被驱动，即悬空(Floating)时，输入引脚上任何的噪声都会改变输入端检测到的电平，如图 5所示。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-5.jpg" alt="220426-GPIO输入输出各种模式-5.jpg"></p><p>为了解决这个问题，可以在输入引脚处加一个弱上拉电阻，如图 6所示。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-6.jpg" alt="220426-GPIO输入输出各种模式-6.jpg"></p><p>这样，当输入引脚悬空时，会被RP上拉到高电平，在内部总线上就有确定的状态了。</p><p>但是这种结构是有一定问题的。首先很明显的一点是，当输入引脚悬空时读到的是1，当输入引脚被高电平驱动时读到的也是1，只有当输入引脚被低电平驱动时读到的才是0。也就是对于读1采取的方式是”读取非零”的方式。</p><p>另一个问题是该电路对外呈现的不是高阻，某种意义上说也在向外输出，当外部驱动电路不同时可能出现错误的检测结果。例如外部驱动电路是如图 7所示的结构，该电路结构中通过K打到不同端可以输出高电平或者低电平。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-7.jpg" alt="220426-GPIO输入输出各种模式-7.jpg"></p><p>如果将如图 7所示的电路输出低电平，连接到带有弱上拉电阻的输入引脚，其结构如下所示。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-8.jpg" alt="220426-GPIO输入输出各种模式-8.jpg"></p><p>由欧姆定律知，测试点处的电平是4.545V，于是CPU测得的输入信号为高，而外部驱动电路希望输出的电平为低。这种错误的原因就在于这种结构的输入电路并不是真正的高阻，或者说这个输入IO其实也在输出，而且影响了外部输入电路。</p><p>这种情况的发生也说明了：信号前后两级传递，为什么需要输出阻抗小，输入阻抗大的原因。在这个例子中，外围驱动电路的输出阻抗很大，达到了100Kohm;而输入端的阻抗又不够大，只有10Kohm，于是就出现了问题。如果输入端的输入阻抗真正做到高阻（无穷大），如下所示，就不会出现问题。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-9.jpg" alt="220426-GPIO输入输出各种模式-9.jpg"></p><p>上面提到的这个带弱上拉的输入电路，也就是在后续章节会提到的准双向端口的情况。</p><h2 id="输出IO"><a href="#输出IO" class="headerlink" title="输出IO"></a>输出IO</h2><p>IO输出电路最主要的两种模式分别是推挽输出（Push-Pull Output）和开漏输出（Open Drain Output）。</p><h3 id="推挽输出（Push-Pull-Output）"><a href="#推挽输出（Push-Pull-Output）" class="headerlink" title="推挽输出（Push-Pull Output）"></a>推挽输出（Push-Pull Output）</h3><p>推挽输出的结构是由两个三极管或者MOS管受到互补信号的控制，两个管子始终保持一个处于截止，另一个处于导通的状态。如图 10所示。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-10.jpg" alt="220426-GPIO输入输出各种模式-10.jpg"></p><p>推挽输出的最大特点是可以真正能真正的输出高电平和低电平，在两种电平下都具有驱动能力。</p><p><em><strong>补充说明</strong></em>：所谓的驱动能力，就是指输出电流的能力。对于驱动大负载（即负载内阻越小，负载越大）时，例如IO输出为5V，驱动的负载内阻为10ohm，于是根据欧姆定律可以正常情况下负载上的电流为0.5A（推算出功率为2.5W）。显然一般的IO不可能有这么大的驱动能力，也就是没有办法输出这么大的电流。于是造成的结果就是输出电压会被拉下来，达不到标称的5V。</p><p>当然如果只是数字信号的传递，下一级的输入阻抗理论上最好是高阻，也就是只需要传电压，基本没有电流，也就没有功率，于是就不需要很大的驱动能力。</p><p>对于推挽输出，输出高、低电平时电流的流向如图 11所示。所以相比于后面介绍的开漏输出，输出高电平时的驱动能力强很多。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-11.jpg" alt="220426-GPIO输入输出各种模式-11.jpg"></p><p>但推挽输出的一个缺点是，如果当两个推挽输出结构相连在一起，一个输出高电平，即上面的MOS导通，下面的MOS闭合时；同时另一个输出低电平，即上面的MOS闭合，下面的MOS导通时。电流会从第一个引脚的VCC通过上端MOS再经过第二个引脚的下端MOS直接流向GND。整个通路上电阻很小，会发生短路，进而可能造成端口的损害。这也是为什么推挽输出不能实现” 线与”的原因。</p><h3 id="开漏输出（Open-Drain-Output）"><a href="#开漏输出（Open-Drain-Output）" class="headerlink" title="开漏输出（Open Drain Output）"></a>开漏输出（Open Drain Output）</h3><p>常说的与推挽输出相对的就是开漏输出，对于开漏输出和推挽输出的区别最普遍的说法就是开漏输出无法真正输出高电平，即高电平时没有驱动能力，需要借助外部上拉电阻完成对外驱动。下面就从内部结构和原理上说明为什么开漏输出输出高电平时没有驱动能力，以及进一步比较与推挽输出的区别。</p><p>首先需要介绍一些开漏输出和开集输出。这两种输出的原理和特性基本是类似的，区别在于一个是使用MOS管，其中的”漏”指的就是MOS管的漏极；另一个使用三极管，其中的”集”指的就是MOS三极管的集电极。这两者其实都是和推挽输出相对应的输出模式，由于使用MOS管的情况较多，很多时候就用”开漏输出”这个词代替了开漏输出和开集输出。</p><p>介绍就先从开集输出开始，其原理电路结如图 12所示。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-12.jpg" alt="220426-GPIO输入输出各种模式-12.jpg"></p><p>图 12左边的电路是开集（OC）输出最基本的电路，当输入为高电平时，NPN三极管导通，Output被拉到GND，输出为低电平；当输入为低电平时，NPN三极管闭合，Output相当于开路（输出高阻）。高电平时输出高阻（高阻、三态以及floating说的都是一个意思），此时对外没有任何的驱动能力。这就是开漏和开集输出最大的特点，如何利用该特点完成各种功能稍后介绍。这个电路虽然完成了开集输出的功能，但是会出现input为高，输出为低；input为低，输出为高的情况。</p><p>图 12右边的电路中多使用了一个三极管完成了”反相”。当输入为高电平时，第一个三极管导通，此时第二个三极管的输入端会被拉到GND，于是第二个三极管闭合，输出高阻；当输入为低电平时，第一个三极管闭合，此时第二个三极管的输入端会被上拉电阻拉到高电平，于是第二个三极管导通，输出被拉到GND。这样，这个电路的输入与输出是同相的了。</p><p>接下来介绍开漏输出的电路，如图 13所示。原理与开集输出基本相同，只是将三极管换成了MOS而已。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-13.jpg" alt="220426-GPIO输入输出各种模式-13.jpg"></p><p>接着说说开漏、开集输出的特点以及应用，由于两者相似，后文中若无特殊说明，则用开漏表示开漏和开集输出电路。</p><ol><li><p>开漏输出最主要的特性就是高电平没有驱动能力，需要借助外部上拉电阻才能真正输出高电平，其电路如图 14所示。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-14.jpg" alt="220426-GPIO输入输出各种模式-14.jpg"></p></li></ol><p>当MOS管<em><strong>断开</strong></em>时，开漏输出电路输出高电平，且连接着负载时，电流流向是从外部电源，流经上来电阻RPU，流进负载，最后进入GND。</p><ol><li>开漏输出的这一特性一个明显的优势就是可以很方便的调节输出的电平，因为输出电平完全由上拉电阻连接的电源电平决定。所以在需要进行电平转换的地方，非常适合使用开漏输出。</li><li>开漏输出的这一特性另一个好处在于可以实现”线与”功能，所谓的”线与”指的是多个信号线直接连接在一起，只有当所有信号全部为高电平时，合在一起的总线为高电平；只要有任意一个或者多个信号为低电平，则总线为低电平。而推挽输出就不行，如果高电平和低电平连在一起，会出现电流倒灌，损坏器件。</li></ol><h3 id="推挽与开漏输出的区别"><a href="#推挽与开漏输出的区别" class="headerlink" title="推挽与开漏输出的区别"></a>推挽与开漏输出的区别</h3><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-15.jpg" alt="220426-GPIO输入输出各种模式-15.jpg"></p><h2 id="双向IO"><a href="#双向IO" class="headerlink" title="双向IO"></a>双向IO</h2><p>很多处理器的引脚可以设置为双向端口，双向端口的要求就是既可以输出信号，又可以读回外部信号输入。要同时做到这两点从原理上来说有点困难，首先从处理器的开漏输出IO口的内部结构说起，如图 16所示。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-16.jpg" alt="220426-GPIO输入输出各种模式-16.jpg"></p><p>该结构是在图 13的基础上，在三极管之前加入了一个FF，目的是用于控制输出信号的时间。比较常见的一个应用场合是多个IO作为一个总线时，需要总线上的各个引脚同时将数据输出。</p><p>对于开漏输出结构，会将FF的输出Q端连接会输入驱动缓冲器，这样的话执行读操作是读的并不是外部引脚的状态，而是自己输出的状态。</p><h3 id="双向开漏IO"><a href="#双向开漏IO" class="headerlink" title="双向开漏IO"></a>双向开漏IO</h3><p>但是对图 16的结构稍作修改，如图 17所示时，该结构称为双向开漏IO的结构。所做的改动是将输入驱动缓冲器连接到了PIN上。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-17.jpg" alt="220426-GPIO输入输出各种模式-17.jpg"></p><p>该结构输出为”1”时，T1断开，此时pin对外呈现高阻，作为输入引脚没有任何问题。但是如果该结构输出”0”时，T1导通，此时pin对外短路到地，即无论外部输入什么信号，U2读回的全部是低。所以对于这样的结构，如果需要作为输入引脚使用时，必须给U1输出”1”后才能读取外部引脚数据。</p><h3 id="准双向开漏IO"><a href="#准双向开漏IO" class="headerlink" title="准双向开漏IO"></a>准双向开漏IO</h3><p>很多文献中还提到了准双向端口，其实准双向端口就是图 17的结构中加了一个上拉电阻，如图 18所示。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-18.jpg" alt="220426-GPIO输入输出各种模式-18.jpg"></p><p>这个结构与图 17相比有以下相同与不同之处：</p><ol><li>作为输入引脚使用时，也必须先向U1中写”1”，以达到断开T1的目的。所以是否需要提前写”1”并不是双向IO与准双向IO的区别。两者做输入端口时都需要提前写”1”。</li><li>双向端口作为输入时是真正的高阻态，而准双向IO作为输入端口时，输入阻抗不为高阻，于是有可能出现如本文图 8所示的问题。</li><li>准双向端口读取输入状态，默认为高。也就是判断外部输入信号的方法是”非低则为高”。即该结构只能准确的识别外部的低电平，无法区分悬空和真正的高。于是只要读到的不是0，都认为外部为1。</li></ol><h3 id="推挽输出作为双向IO"><a href="#推挽输出作为双向IO" class="headerlink" title="推挽输出作为双向IO"></a>推挽输出作为双向IO</h3><p>如果双向端口中的输出部分采用的是推挽输出结构，那么作为输入时必须将上下两个管子全部端口才能成为高阻，作为输入。</p><h3 id="51单片机的P0端口"><a href="#51单片机的P0端口" class="headerlink" title="51单片机的P0端口"></a>51单片机的P0端口</h3><p>在双向端口的讨论中，比较复杂的就是51单片机的P0端口了。这里就详细讨论一下51单片机的P0端口结构和工作原理。</p><p>P0端口的内部结构如图 19所示。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-19.jpg" alt="220426-GPIO输入输出各种模式-19.jpg"></p><p>内部结构比较复杂，包括以下这些器件：</p><ol><li>U1：与门。一个输入连着控制线，另一个输入连接这地址/数据信号。由于与门的特性，当控制线为1时，与门输出与地址/数据信号的电平保持一致；如果控制线为0，则输出恒为。于是控制信号线相当于与门的使能信号。</li><li>U2：反相器，输出信号为地址/数据信号的反相信号。</li><li>U3和U6都是具有控制输入端且具有高阻抗特性的三态缓冲器，作用是对于外部呈现高阻态。当控制端使能时可以将外部信号的电平读进数据总线。</li><li>U4：为锁存器，目的就是控制引脚输出信号的时间。</li><li>U5：模拟开关，可以控制V2的输入信号是来自锁存器U4的Q非输出还是来自于反相器U2的输出。</li><li>V1和V2分别是两个MOS管。</li></ol><p>了解了各个独立器件之后就开始介绍工作在各个模式下的工作原理：</p><p><strong>P0用于地址/数据线时：</strong></p><p>在P0作为地址/数据线时，是地址、数据复用总线，P0需要输出地址，同时需要读回数据信号。</p><p>当P0需要输出地址信息时，U1的控制信号为0，模拟开关U5接到U2反相器的输出。于是当地址信号线传来的信号为1，与控制线”1”相与之后输出到V1的输入信号为”0”，V1截止。地址信号”1”经反相之后，通过模拟开关输出到V2的输入端为”1”，V2导通，于是情况如图 20所示，pin输出”0”。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-20.jpg" alt="220426-GPIO输入输出各种模式-20.jpg"></p><p>当地址信号线传来的信号为1，与控制线”1”相与之后输出到V1的输入信号为”1”，V1导通。地址信号”0”经反相之后，通过模拟开关输出到V2的输入端为”0”，V2截止，于是情况如图 21所示，pin输出”1”。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-21.jpg" alt="220426-GPIO输入输出各种模式-21.jpg"></p><p>于是在作为地址线输出时，V1、V2两个MOS管均使用了，是推挽输出。</p><p>当P0在输出低8位地址信息后，将变为数据总线，此时CPU的操作是控制端输出0，模拟开关打到锁存器的Q非端，且向锁存器中打入”1”。于是Q非输出为0，V2截止。同时控制线为0使得与门输出为0，V1截止。由于V1和V2都截止，所以此时pin对外完全呈现高阻，作为输入端口，外部数据通过U6进入内部总线，情况如图 22所示。（相当于将推挽输出的两个MOS管全部断开了）此时由于对外呈现高阻，所以是真正的输入引脚。这就解释了为什么说P0是真正的双线端口。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-22.jpg" alt="220426-GPIO输入输出各种模式-22.jpg"></p><p><strong>P0用于普通IO时：</strong></p><p>在P0作为普通IO并作为输出时，控制信号为0，使V1始终处于截止状态。模拟开关连接到Q非输出，当作为输出时，锁存器的输入端直接输入0或者1，Q非将反相信号输入到V2的输入端。即当输出”0”时，V2输入端为”1”，V2导通，pin输出”0”；当输出”1”时，V2输入端为”0”，V2截止，pin输出高阻的0。即当P0工作在普通IO模式下，输出为开漏输出，且内部没有上拉电阻。</p><p>在P0作为普通IO并作为输入时，控制信号为0，使V1始终处于截止状态。模拟开关连接到Q非输出，且CPU自动向锁存器输入端写1，则V2输入端为0，V2截止。与之前在作为地址/数据线，作为输入时一样，也是两个MOS管全部断开，pin直接连接到U6，对外呈现高阻。于是也是真正的输入引脚。</p><p>综上P0无论工作在哪种模式下都是真正的双端口IO。</p><h3 id="51单片机的P1～P3端口"><a href="#51单片机的P1～P3端口" class="headerlink" title="51单片机的P1～P3端口"></a>51单片机的P1～P3端口</h3><p>51单片机的其他三个端口的内部结构如图 23所示，与P0相比简单了很多，没有了顶部的MOS管，也没有了地址/数据信号的选项。作为输出时是带有上拉电阻的的开漏输出，作为输入时是有上拉电阻存在的，于是输入端口对外不是高阻。这就解释了为什么P1～P3只能是准双向端口。</p><p><img src="httphttps://gitee.com/hao0527/hao0527/raw/img/26-GPIO输入输出各种模式/220426-GPIO输入输出各种模式-23.jpg" alt="220426-GPIO输入输出各种模式-23.jpg"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C/C++中几个易混淆的点</title>
      <link href="/2022/04/04/220404-C%E7%9A%84%E7%96%91%E6%83%91/"/>
      <url>/2022/04/04/220404-C%E7%9A%84%E7%96%91%E6%83%91/</url>
      
        <content type="html"><![CDATA[<h2 id="数组指针-amp-指针数组"><a href="#数组指针-amp-指针数组" class="headerlink" title="数组指针&amp;指针数组"></a>数组指针&amp;指针数组</h2><p>参考：<a href="https://www.cnblogs.com/mq0036/p/3382732.html%EF%BC%8C%E4%B8%A4%E8%80%85%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%86%99%E7%9A%84%E5%BE%88%E8%AF%A6%E7%BB%86%E3%80%82">https://www.cnblogs.com/mq0036/p/3382732.html，两者内存分布写的很详细。</a></p><h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>定义<code>int (*p)[n];</code></p><p>()优先级比[]高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。</p><p>如要将二维数组赋给一指针，应这样赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>];   <span class="comment">//该语句是定义一个数组指针，指向含4个元素的一维数组。</span></span><br><span class="line">p = a;     <span class="comment">//将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0]</span></span><br><span class="line">p++;       <span class="comment">//该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]</span></span><br></pre></td></tr></table></figure><p>所以数组指针也称指向一维数组的指针，亦称行指针。</p><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>定义<code>int *p[n];</code></p><p>[]优先级比*高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1时，则p指向下一个数组元素，这样赋值是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]…p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 <em>p=a; 这里</em>p表示指针数组第一个元素的值，a的首地址的值。<br>如要将二维数组赋给一指针数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">p++;  <span class="comment">//该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    p[i] = a[i];</span><br></pre></td></tr></table></figure><p>这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]，所以要分别赋值。</p><h2 id="常量指针-amp-指针常量"><a href="#常量指针-amp-指针常量" class="headerlink" title="常量指针&amp;指针常量"></a>常量指针&amp;指针常量</h2><h3 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h3><p>定义<code>int * const p = &amp;a;</code></p><p>p是个常量，p的类型是int*，所以p的值不能改变，但是*p的值可以改变。</p><h3 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h3><p>定义<code>const int * p = NULL;</code></p><p>*p是个常量，p的类型是int*，所以*p的值不能改变，但是p的值可以改变。利用这个特性，在函数传参时使用常量指针可以防止函数对变量值的误修改。</p><h3 id="常量指针常量"><a href="#常量指针常量" class="headerlink" title="常量指针常量"></a>常量指针常量</h3><p>定义<code>const int * const p = &amp;a;</code></p><p>p是个常量，*p也是个常量，p的类型是int*，所以*p的值不能改变，p的值也不能改变。</p><h2 id="引用-amp-常量引用"><a href="#引用-amp-常量引用" class="headerlink" title="引用&amp;常量引用"></a>引用&amp;常量引用</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>定义<code>int&amp; r = a;</code></p><p><a href="https://www.runoob.com/cplusplus/cpp-references.html">C++ 引用</a>，引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。</p><p>函数可以通过引用传参，<code>void foo(int &amp;a)&#123;a = 1;&#125;</code>修改引用形参可以改变实参。</p><h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><p>定义<code>const int&amp; r = a;</code></p><p>函数可以通过常量引用传参，<code>void foo(const int &amp;a) &#123;;&#125;</code>只能读取a，不能修改a。利用这个特性，在函数传参时使用常量指针可以防止函数对变量值的误修改。</p><h2 id="函数指针-amp-指针函数"><a href="#函数指针-amp-指针函数" class="headerlink" title="函数指针&amp;指针函数"></a>函数指针&amp;指针函数</h2><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>定义函数指针<code>void (*pFun)(int a, int b);</code></p><p>定义函数<code>void Fun(int a, int b) &#123;;&#125;</code></p><p>将Fun函数的首地址赋给指针变量pFun<code>pFun = Fun;</code>也可以是<code>pFun = &amp;Fun;</code></p><p>通过指针函数调用<code>pFun(1, 2);</code>也可以是<code>(*pFun)(1, 2);</code></p><p>函数指针定义时返回值，参数类型，个数都必须与要指向的函数相同。</p><h3 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h3><p>指针函数是返回类型为指针的函数。</p><h2 id="C结构体内存对齐"><a href="#C结构体内存对齐" class="headerlink" title="C结构体内存对齐"></a>C结构体内存对齐</h2><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《操作系统》笔记</title>
      <link href="/2022/03/26/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/03/26/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="课程链接"><a href="#课程链接" class="headerlink" title="课程链接"></a>课程链接</h2><ul><li><p><a href="https://www.bilibili.com/video/BV1d4411v7u7?p=1">操作系统（哈工大李治军老师）32讲（全）超清</a></p></li><li><p><a href="https://www.shiyanlou.com/courses/115">配套实验课</a></p></li></ul><h2 id="课程笔记"><a href="#课程笔记" class="headerlink" title="课程笔记"></a>课程笔记</h2><h3 id="L1-L3"><a href="#L1-L3" class="headerlink" title="L1~L3"></a>L1~L3</h3><ol><li><p>课程目标：进入操作系统，学习操作系统的运作。</p></li><li><p>计算机工作方式：取址执行，取CS和PC指针指向内存中的指令，在CPU执行</p></li><li><p>操作系统引导：启动引导时内核在内存中的位置和移动后的位置情况图<img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1.jpg" alt="220326-操作系统-1.jpg"></p><p>开机时，CS=0xffff，IP=0x0000，CPU处于实模式。实模式寻址CS&lt;&lt;4+IP，CS存放段地址，IP存放4位段偏移量，共20位。0xffff0地址属于BIOS映射区，在BIOS里检查硬件（RAM，键盘，…）；</p><p>将磁盘0磁道0扇区（引导扇区）读到内存0x7c00，引导扇区代码存放在bootsect.s；</p><p>将引导扇区代码从内存0x7c00处移动到0x90000处；</p><p><code>jmpi go, INITSEG</code>，INITSEG=0x9000，跳至bios的go标号处；</p><p><code>jmpi 0, SETUPSEG</code>，SETUPSEG=0x9020，跳至setup.s；</p><p>在setup.s  start:中读取扩展内存大小，读取显卡参数，…；</p><p>do_move:中将system模块移动到0地址，<code>jmpi 0, 8</code>，跳转到system模块，system模块开始是head.s；</p><p>通过设置cr0最后一位，PE=1由16位实模式转到32位保护模式，在保护模式下，CS表示选择子，查GDT表得到；</p><p>在head.s中初始化GDT表和IDT表，setup_paging执行ret后，会执行函数main()，进入main()后的栈为0，0，0，L6，三个0表示main函数的参数，L6表示main函数返回时进入死循环；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">after_page_tables:</span><br><span class="line">    pushl $0 # These are the parameters to main :-)</span><br><span class="line">    pushl $0 # 这些是调用 main 程序的参数（指 init/main.c）。</span><br><span class="line">    pushl $0 # 其中的&#x27;$&#x27;符号表示这是一个立即操作数。</span><br><span class="line">    pushl $L6 # return address for main, if it decides to.</span><br><span class="line">    pushl $_main # &#x27;_main&#x27;是编译程序对 main 的内部表示方法。</span><br><span class="line">    jmp setup_paging # 跳转至第 198 行。</span><br><span class="line">L6:</span><br><span class="line">    jmp L6 # main should never return here, but</span><br><span class="line">    # just in case, we know what happens.</span><br><span class="line">    # main 程序绝对不应该返回到这里。不过为了以防万一，</span><br><span class="line">    # 所以添加了该语句。这样我们就知道发生什么问题了。</span><br><span class="line">setup_paging:</span><br><span class="line">    设置页表...</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure></li></ol><h3 id="L4-L7"><a href="#L4-L7" class="headerlink" title="L4~L7"></a>L4~L7</h3><ol><li>操作系统接口：接口表现为函数调用，又由系统提供，所以称为系统调用，可移植操作系统接口(Portable Operating System Interface of uniX, POSIX)</li><li>系统调用的实现：应用层要通过接口访问内核，不能直接读内核内存，内核是受保护的。中断是进入内核的唯一方法；<img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-2.jpg" alt="220326-操作系统-2.jpg"><img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-3.jpg" alt="220326-操作系统-3.jpg"></li><li>课程任务：操作系统要学习CPU管理、内存管理、文件管理；</li></ol><h3 id="L8-L19"><a href="#L8-L19" class="headerlink" title="L8~L19"></a>L8~L19</h3><ol><li><p>CPU管理：多道程序，交替执行（并发）。运行的程序是进程，多进程切换时要保存现场。通过进程控制块(Process Control Block, PCB)来记录进程信息。操作系统要把这些进程记录好，要按照合理的次序分配资源、调度；</p></li><li><p>进程状态图：<img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-4.jpg" alt="220326-操作系统-4.jpg"></p></li><li><p>通过进程内存映射表来实现内存分离，切换进程时要切换内存映射表；通过上锁，来保证共享内存的正确被读写；</p></li><li><p>用户级线程和核心级线程区别：用户级线程创建、切换无需进内核，一个线程阻塞进程会被切换；</p></li><li><p>线程的优点：线程切换无需切换内存映射表。<img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-5.jpg" alt="220326-操作系统-5.jpg"></p></li><li><p>用户级线程切换通过Yield()，要先切换栈，栈会存在TCB（线程控制块）中，每个线程对应一个TCB；</p></li><li><p>核心级线程切换时除了用户栈还有内核栈也要一起切换。在内核阻塞时要进行TCB切换，使用<code>switch_to(cur, next);</code>TCB切换完后根据TCB完成内核栈切换，最后IRET返回用户态，切换用户栈；</p></li><li><p>前台任务需要响应时间小-&gt;导致切换次数多-&gt;导致系统内耗大-&gt;导致吞吐量（完成任务的量）小。后台任务更加关注周转时间。任务可分成IO约束型任务和CPU约束型任务；</p></li><li><p>CPU调度策略：FIFO、Priority；CPU调度算法：先来先服务（First come, first served），短作业优先（SJF）这个算法周转时间最小，按时间片来轮转调度（RR），优先级调度（前台&gt;后台）；</p></li><li><p>linux0.11中的调度函数既考虑了优先级又考虑了时间片：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Schedule</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">// 在 kernel/sched.c 中</span></span><br><span class="line">&#123; <span class="keyword">while</span>(<span class="number">1</span>)&#123; c=<span class="number">-1</span>; next=<span class="number">0</span>; i=NR_TASKS; p=&amp;task[NR_TASKS];</span><br><span class="line">    <span class="keyword">while</span>(--i)&#123; <span class="keyword">if</span>((*p-&gt;state == TASK_RUNNING&amp;&amp;(*p)-&gt;counter&gt;c)</span><br><span class="line">        c=(*p)-&gt;counter, next=i; &#125;</span><br><span class="line">    <span class="keyword">if</span>(c) <span class="keyword">break</span>; <span class="comment">// 找到了最大的counter,跳出，执行switch_to()</span></span><br><span class="line">    <span class="keyword">for</span>(p=&amp;LAST_TASK;p&gt;&amp;FIRST_TASK;--p)</span><br><span class="line">        (*p)-&gt;counter=((*p)-&gt;counter&gt;&gt;<span class="number">1</span>)+(*p)-&gt;priority; </span><br><span class="line">    &#125;</span><br><span class="line">switch_to(next);&#125;</span><br></pre></td></tr></table></figure></li><li><p>进程间同步看信号量（Semaphore），可使多个进程合理有序运行。<strong>读写信号量的代码一定在临界区</strong>，或者原子操作。临界区：一次只允许一个进程进入该进程的那段代码。原子操作：不会被线程调度机制打断的操作;</p></li><li><p>保护临界区的方法：关闭中断<code>cli();</code>，临界区，开中断<code>sti();</code>，剩余区。这种方法只适用于小系统，不适用于多核CPU。还可以采取硬件原子指令法，硬件一条指令修改mutex变量；</p></li><li><p>信号量未互斥使用会造成死锁。死锁处理：死锁预防，死锁避免，死锁检测+恢复，死锁忽略；</p></li></ol><h3 id="L20-L25"><a href="#L20-L25" class="headerlink" title="L20~L25"></a>L20~L25</h3><ol><li><p>内存使用：将程序放到内存中，PC指向开始的地址。将程序从硬盘载入内存需要重定位，物理地址=基址+逻辑地址。重定位可以在编译时（静态系统）、载入时执行、<strong>运行时执行</strong>。编译时重定位的程序只能放在内存固定位，载入时重定位的程序一旦载入内存就不能动了；<img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-6.jpg" alt="220326-操作系统-6.jpg"></p></li><li><p>程序载入后还需要移动，引入<strong>交换</strong>（swap）概念，可以把暂时不用的内存搬到交换分区，充分利用内存。</p></li><li><p>引入分段，程序由若干部分(段)组成，每个段有各自的特点、用途：主程序（只读）、变量集（可写、不会动态增长）、函数集、动态数组（会动态增长）、栈。使用分段思想可以让用户分治每个段，可以让内存更高效使用。定位具体指令<code>mov [es:bx], ax</code>。地址组成：&lt;段号，段内偏移&gt;。进程段表存放在LDT表，系统段表存放在GDT表，LDT存放在PCB中；<img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-7.jpg" alt="220326-操作系统-7.jpg"></p></li><li><p><strong>内存分区</strong>可分为固定分区和可变分区。可变分区的管理：空闲分区表、已分配分区表。可变分区分配内存算法：首先适配（最快）、最佳适配和申请空间长度最接近（会导致内存碎片）、最差适配；</p></li><li><p>实际物理内存采用<strong>分页</strong>来管理，分区是对虚拟内存（交换分区）的管理方法。分区会造成内存碎片，分页会将物理内存分割（比如每4k分割），程序也会被分页，每段都会被分页，分页会使内存存储离散化。地址翻译有专门的硬件内存管理单元（MMU）执行；<img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-8.jpg" alt="220326-操作系统-8.jpg"></p></li><li><p>为了提高内存空间利用率，页应该小，但是页小了页表就大了。如果页表只存放用到的页，则需要顺序查找页表，速度慢。采用多级页表可兼顾速度和空间，即页目录表+页表，地址组成&lt;10bits页目录号，10bits页号，12bits偏移&gt;，12bits偏移刚好是4K。</p></li><li><p>多级页表增加了访存的次数，尤其是64位系统。硬件上引入转译后备缓冲区（Translation Look-aside Buffer，TLB，快表），快表能存放最近查过多级页表的逻辑页和物理页，可以根据页号直接查物理页号；<img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-9.jpg" alt="220326-操作系统-9.jpg"></p></li><li><p>段页结合：段面向用户，页面向硬件。实际的段页内存管理，程序如何载入内存，fork后内存做了什么可以看<a href="https://www.bilibili.com/video/BV1d4411v7u7?p=23">L23 段页结合的实际内存管理</a>；<img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-10.jpg" alt="220326-操作系统-10.jpg"></p></li><li><p>用内存换入换出实现“大内存”，虚拟内存4G，物理内存可以只有1G。当程序运行缺页时， page fault中断请求do_no_page调页（读磁盘），这就是换入；</p></li><li><p>内存换出：将内存中不用的页换出到磁盘。如何找不用的页？换出算法：FIFO（先来的先被换出，不太行）、MIN（将未来最远要使用的页淘汰，是最优方案，但无法预测未来）、LRU（Least Recently Used，最近最少使用）；</p></li><li><p>LUR的准确实现：可以用时间戳，每次地址访问都需要修改时间戳，需维护一个全局时钟，实现代价较较大，可以用页码栈，选择栈底淘汰，代价也太大。在实际中内存换出算法采用LUR的近似实现：时钟算法（环形队列）<img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-11.jpg" alt="220326-操作系统-11.jpg"><img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-12.jpg" alt="220326-操作系统-12.jpg"></p></li><li><p>给进程分配多少页框？分配多了，请求调页导致的内存高效利用就没有了。分配少了，会频繁请求调页导致系统低效。系统低效解释：系统内进程增多多，每个进程的缺页率增大大，缺页率增大到一定程度，进程总等待调页完成，CPU利用率降低低，进程进一步增多，缺页率更大，称这一现象为颠簸(thrashing)；</p></li></ol><h3 id="L26-L32"><a href="#L26-L32" class="headerlink" title="L26~L32"></a>L26~L32</h3><ol><li><p>IO设备、显示器、键盘，让这些外设工作的基本思想就是往外设硬件寄存器写值，外设处理完再产生中断，CPU处理。在Linux中无论什么设备都用文件接口open、read、write、close，例如<code>int fd = open(&quot;/dev/xxx&quot;);</code>到最后是通过out写对应寄存器；</p></li><li><p>生磁盘的使用：磁盘驱动负责从盘块号（block）计算出柱面（cgl）、磁头（head）、扇区号（sec）。从CHS到扇区号，从扇区到盘块（第一层抽象）：<strong>扇区号 = C×H×S+H×S+S</strong> 。<img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-13.jpg" alt="220326-操作系统-13.jpg"></p></li><li><p>多个进程通过<strong>请求队列</strong>使用磁盘（第二层抽象）；<img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-14.jpg" alt="220326-操作系统-14.jpg"></p></li><li><p><strong>访问磁盘时间 = 写入控制器时间 + 寻道时间（8~12ms）+ 旋转时间（7200rmp，半周4ms）+ 传输时间（50MB/s，约0.3ms）</strong>。可见访问磁盘主要时间花在寻道，block相邻的盘块可以快速读出，因此需要考虑寻道算法。寻道调度算法有FCFS（先来先服务）、SSTF（短寻道优先算法，可能有磁道长时间访问不到）、SCAN（SSTF+中途不折回）、C-SCAN（SCAN+直接移动到另一端，电梯算法）；</p></li><li><p>引入文件（第三层抽象），文件是建立字符流在磁盘块集合的映射关系，每个文件都对应一个文件控制块（FCB），连续结构存储FCB包含文件名、起始块、块数的信息，链式结构存储FCB包含文件名、起始块的信息，链式结构存储顺序访问慢、可靠性差，<strong>索引结构</strong>存储文件是连续和链式的有效折中，FCB包含文件名、索引块的信息。在实际系统中采用的是<strong>多级索引结构</strong>，根据不同大小文件分成不同级索引通过<strong>inode</strong>一级级查询访问，因此可以标识很大的文件，很小的文件可以高效访问，中等大小的文件访问速度也不慢；</p></li><li><p>引入文件系统（第四层抽象），文件系统引入目录树，文件目录也是个文件，存放目录下其他文件名和对应文件的FCB指针。inode位图：哪些inode空闲，哪些被占用。盘块位图：哪些盘块是空闲的，硬盘大小不同这个位图的大小也不同。超级块：存放i节点位图和盘块位图的大小，因此可以计算出i节点起始地址；<img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-15.jpg" alt="220326-操作系统-15.jpg"><img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-16.jpg" alt="220326-操作系统-16.jpg"><img src="https://gitee.com/hao0527/hao0527/raw/img/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/220326-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-17.jpg" alt="220326-操作系统-17.jpg"></p></li></ol><h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><p>通过本次操作系统的学习，了解了操作系统全图（CPU、内存、文件设备），学习了多进程视图、文件视图。哈工大的几个实验非常的难，Study OS by coding !!!</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用GDB调试C/C++程序</title>
      <link href="/2022/03/17/220317-gdb/"/>
      <url>/2022/03/17/220317-gdb/</url>
      
        <content type="html"><![CDATA[<h2 id="GDB介绍"><a href="#GDB介绍" class="headerlink" title="GDB介绍"></a>GDB介绍</h2><h3 id="GDB是什么"><a href="#GDB是什么" class="headerlink" title="GDB是什么"></a>GDB是什么</h3><p><a href="http://www.sourceware.org/gdb/">GDB: The GNU Project Debugger</a>，GDB是GNU开源组织发布的一个强大的Linux下的程序调试工具，GDB主要帮助你完成下面四个方面的功能：</p><ul><li>启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。</li><li>可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）</li><li>当程序被停住时，可以检查此时你的程序中所发生的事。</li><li>你可以改变你的程序，将一个BUG产生的影响修正从而测试其他BUG。</li></ul><h3 id="GDB支持哪些语言"><a href="#GDB支持哪些语言" class="headerlink" title="GDB支持哪些语言"></a>GDB支持哪些语言</h3><p>GDB主要来调试C/C++语言写的程序，当然也就可以调试其他语言程序，另外的语言没了解过。</p><h2 id="GDB使用"><a href="#GDB使用" class="headerlink" title="GDB使用"></a>GDB使用</h2><h3 id="在Ubuntu中安装GDB"><a href="#在Ubuntu中安装GDB" class="headerlink" title="在Ubuntu中安装GDB"></a>在Ubuntu中安装GDB</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt install gdb</span><br></pre></td></tr></table></figure><h3 id="补一下GCC的知识"><a href="#补一下GCC的知识" class="headerlink" title="补一下GCC的知识"></a>补一下GCC的知识</h3><p><a href="https://www.runoob.com/w3cnote/gcc-parameter-detail.html">GCC参数详解</a>，gcc 与 g++ 分别是 gnu 的 c &amp; c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：</p><ul><li><p>预处理,生成 .i 的文件[预处理器cpp]，指令：-E</p></li><li><p>将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]，指令：-S</p></li><li><p>由汇编变为目标代码(机器代码)生成 .o 的文件[汇编器as]，指令：-c</p></li><li><p>连接目标代码, 生成可执行程序 [链接器ld]，指令：-o FILE</p></li></ul><p>在配合GDB时，gcc的指令选项有：</p><ul><li>-g（生成调试信息，GNU 调试器可利用该信息）</li><li>-ggdb（此选项将尽可能的生成 gdb 的可以使用的调试信息）</li></ul><h3 id="GDB中的基本调试命令"><a href="#GDB中的基本调试命令" class="headerlink" title="GDB中的基本调试命令"></a>GDB中的基本调试命令</h3><table><thead><tr><th><strong>命令</strong></th><th><strong>命令缩写</strong></th><th><strong>命令说明</strong></th></tr></thead><tbody><tr><td>set args</td><td></td><td>设置主程序的参数。例如：./test 1 2设置参数的方法是：gdb test(gdb) set args 1 2</td></tr><tr><td>break</td><td>b</td><td>设置断点，b 20 表示在第20行设置断点，可以设置多个断点。</td></tr><tr><td>run</td><td>r</td><td>开始运行程序, 程序运行到断点的位置会停下来，如果没有遇到断点，程序一直运行下去。</td></tr><tr><td>next</td><td>n</td><td>执行当前行语句，如果该语句为函数调用，不会进入函数内部执行。</td></tr><tr><td>step</td><td>s</td><td>执行当前行语句，如果该语句为函数调用，则进入函数执行其中的第一条语句。注意了，如果函数是库函数或第三方提供的函数，用s也是进不去的，因为没有源代码，如果是您自定义的函数，只要有源码就可以进去。</td></tr><tr><td>print</td><td>p</td><td>显示变量值，例如：p name表示显示变量name的值，print可以做运算。</td></tr><tr><td>continue</td><td>c</td><td>继续程序的运行，直到遇到下一个断点。</td></tr><tr><td>set var name=value</td><td></td><td>设置变量的值，假设程序有两个变量：int ii; char name[21];set var ii=10 把ii的值设置为10；set var name=”abc” 把name的值设置为”abc”，注意，不是strcpy。</td></tr><tr><td>quit</td><td>q</td><td>退出gdb环境。</td></tr></tbody></table><h3 id="进入GDB调试"><a href="#进入GDB调试" class="headerlink" title="进入GDB调试"></a>进入GDB调试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -g -o test</span><br><span class="line">gdb test # 进入gdb，指定test为可执行文件</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以只执行gdb，在gdb中用file命令指定可执行文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来就可以使用GDB的基本调试命令调试程序了</span></span><br></pre></td></tr></table></figure><h3 id="调试正在运行的程序"><a href="#调试正在运行的程序" class="headerlink" title="调试正在运行的程序"></a>调试正在运行的程序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过ps获取程序进程号</span></span><br><span class="line">gdb test -p [进程号]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入gdb后，程序会被暂停</span></span><br><span class="line">(gdb)bt # 使用bt查看程序的调用栈</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Print backtrace of all stack frames, or innermost COUNT frames.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出后，程序继续执行</span></span><br></pre></td></tr></table></figure><h3 id="调试多进程程序"><a href="#调试多进程程序" class="headerlink" title="调试多进程程序"></a>调试多进程程序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb)set follow-fork-mode [parent|child]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（缺省是parent）调试父|子进程，父|子进程不受影响</span></span><br><span class="line">(gdb)set datach-on-fork [on|off]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">（缺省是on）on表示调试当前进程时，其他进程继续运行，off表示调试当前进程时，其他进程被GDB挂起</span></span><br><span class="line">(gdb)info inferiors # 查看调试的进程</span><br><span class="line">(gdb)inferior # 切换当前调试的进程，进程id是查看调试的进程返回的Num值</span><br></pre></td></tr></table></figure><h3 id="调试多线程程序"><a href="#调试多线程程序" class="headerlink" title="调试多线程程序"></a>调试多线程程序</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep test # 查看当前运行的进程，查找符合&quot;test&quot;的字符串</span><br><span class="line">ps -aL|grep test # 查看当前运行的轻量级进程</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">轻量级进程(LWP)是建立在内核之上并由内核支持的用户线程，它是内核线程的高度抽象，每一个轻量级进程都与一个特定的内核线程关联。</span></span><br><span class="line">pstree -p [主线程ID] # 查看主线程和新线程的关系</span><br><span class="line">(gdb)info threads # 查看线程</span><br><span class="line">(gdb)thread [线程ID] # 切换线程，线程ID是查看线程返回的Num值</span><br><span class="line">(gdb)set scheduler-locking [on|off] # on：只运行当前线程，off：运行全部的线程</span><br><span class="line">(gdb)thread apply [线程ID|all] [cmd] # 让某个|全部线程执行某GDB命令</span><br></pre></td></tr></table></figure><h3 id="服务程序运行日志"><a href="#服务程序运行日志" class="headerlink" title="服务程序运行日志"></a>服务程序运行日志</h3><p>设置断点或单步跟踪可能会严重干扰多进程、多线程之间的竞争状态，导致我们看到一个假象。一旦我们在某个线程设置了断点，该线程在断点处挺住了，只剩下另一个线程在跑。这时候，并发的场景已经完全被破坏了，通过调试器看到的只是一个和谐的场景（理想状态）。<strong>输出Log日志</strong>可以避免断点和单步跟踪所导致的副作用。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言内嵌汇编</title>
      <link href="/2022/02/25/220225-asmInC/"/>
      <url>/2022/02/25/220225-asmInC/</url>
      
        <content type="html"><![CDATA[<h2 id="今晨的日出"><a href="#今晨的日出" class="headerlink" title="今晨的日出"></a>今晨的日出</h2><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220225-asmInC/220225-asmInC-1.jpg" alt="220225-asmInC-1.jpg"></p><p>早晨学习操作系统，看到系统调用实现时，遇到了C内嵌汇编，所以补了下相关知识。</p><h2 id="asm"><a href="#asm" class="headerlink" title="__asm__"></a>__asm__</h2><p>补充资料：<a href="https://dirtysalt.github.io/html/gcc-asm.html">https://dirtysalt.github.io/html/gcc-asm.html</a></p><p>在内嵌汇编中，可以将C语言表达式指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入哪个寄存器，以及如何将计算结果写回C 变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可，GCC会自动插入代码完成必要的操作。</p><p>完整的内嵌汇编格式：<code>__asm__ __volatile__(&quot;Instruction List&quot; : Output : Input : Clobber/Modify);</code></p><p>__asm__ 是GCC关键字asm的宏定义，asm用于声明这行代码是一个内嵌汇编表达式，任何内嵌的汇编表达式都以此关键字作为开头。</p><p>一个最简单的内嵌汇编：<code>__asm__(&quot;nop&quot;);</code> 括号里的是汇编指令，表示运行空指令，一个机器周期。Instruction List 是汇编指令序列，它可以是空的。可以有多条汇编指令，需要将所有指令放在多对引号中，两条指令必须用换行或分号分开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    ……</span></span><br><span class="line">    __asm__(<span class="string">&quot;push %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;push %%ds\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl $buf\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pushl $0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;call tty_write\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;addl $8,%%esp\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;popl %0\n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;pop %%fs&quot;</span></span><br><span class="line">            ::<span class="string">&quot;r&quot;</span> (i):<span class="string">&quot;ax&quot;</span>,<span class="string">&quot;cx&quot;</span>,<span class="string">&quot;dx&quot;</span>);</span><br><span class="line"><span class="comment">//    ……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看上面<code>printk()</code>的例子，首先<code>push %fs</code>保存这个指向用户段的寄存器，在最后<code>pop %fs</code>将其恢复，<code>printk()</code>的核心是调用<code>tty_write()</code>。</p><p>Output Input 用来指定当前内联汇编语句的输出与输入，格式为形如“constraint”(variable)的列表（逗号分隔)，constraint是限制字符，下面表中列出几个常用限制字符作用，更多用法见：<a href="https://blog.csdn.net/qq_15974389/article/details/76416668">GCC内嵌汇编一些限制字符串</a>。</p><table><thead><tr><th>限制字符</th><th>作用</th></tr></thead><tbody><tr><td>a/b/c/d/s/d</td><td>将输入变量放入eax/ebx/ecx/edx/esi/edi</td></tr><tr><td>q</td><td>将输入变量放入eax,ebx,ecx,edx中的一个</td></tr><tr><td>r</td><td>输入变量放入通用寄存器，也就是eax,ebx,ecx,edx,esi,edi中的一个</td></tr><tr><td>=/+</td><td>操作数在指令中是只写/读写类型的（输出操作数）</td></tr></tbody></table><h2 id="volatile"><a href="#volatile" class="headerlink" title="__volatile__"></a>__volatile__</h2><p>__volatile__ 是GCC关键字volatile的宏定义，在内联汇编中，它是可选的。使用它会向GCC声明不允许对该内联汇编优化，否则当使用了优化选项(-O)进行编译时，GCC将会根据自己的判断决定是否将这个内联汇编表达式中的指令优化掉。</p><p>编译器优化常用的方法有：将内存变量缓存到寄存器；调整指令顺序充分利用CPU指令流水线，常见的是重新排序读写指令。对常规内存进行优化的时候，这些优化是透明的，而且效率很好。由编译器优化或者硬件重新排序引起的问题的解决办法是在从硬件（或者其他处理器）的角度看必须以特定顺序执行的操作之间设置内存屏障（memory barrier），linux 提供了一个宏，<code>barrier()</code>，解决编译器的执行顺序问题，但对硬件无效。</p><p>有一种硬件级别的优化：内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入硬件高速缓存Cache，加速对内存的访问。在现代CPU中指令的执行并不一定严格按照顺序执行，没有相关性的指令可以乱序执行，以充分利用CPU的指令流水线，提高执行速度。</p><h2 id="Clobber-Modify"><a href="#Clobber-Modify" class="headerlink" title="Clobber/Modify"></a>Clobber/Modify</h2><p>有时候，你想通知GCC当前内联汇编语句可能会对某些寄存器或内存进行修改，希望GCC在编译时能够将这一点考虑进去。那么你就可以在Clobber/Modify域声明这些寄存器或内存。这种情况一般发生在一个寄存器出现在”Instruction List”，但却不是由Input/Output操作表达式所指定的，也不是在一些Input/Output操作表达式使用”r”约束时由GCC 为其选择的，同时此寄存器被”Instruction List”中的指令修改，而这个寄存器只是供当前内联汇编临时使用的情况。</p><p>例如：<code>__asm__ (&quot;mov R0, #0x34&quot; : : : &quot;R0&quot;);</code>寄存器R0出现在”Instruction List中”，并且被mov指令修改，但却未被任何Input/Output操作表达式指定，所以你需要在Clobber/Modify域指定”R0”，以让GCC知道这一点。</p><p>因为你在Input/Output操作表达式所指定的寄存器，或当你为一些Input/Output操作表达式使用”r”约束，让GCC为你选择一个寄存器时，GCC对这些寄存器是非常清楚的——它知道这些寄存器是被修改的，你根本不需要在Clobber/Modify域再声明它们。但除此之外， GCC对剩下的寄存器中哪些会被当前的内联汇编修改一无所知。所以如果你真的在当前内联汇编指令中修改了它们，那么就最好在Clobber/Modify 中声明它们，让GCC针对这些寄存器做相应的处理。否则有可能会造成寄存器的不一致，从而造成程序执行错误。</p><p>如果一个内联汇编语句的Clobber/Modify域存在”memory”，那么GCC会保证在此内联汇编之前，如果某个内存的内容被装入了寄存器，那么在这个内联汇编之后，如果需要使用这个内存处的内容，就会直接到这个内存处重新读取，而不是使用被存放在寄存器中的拷贝。因为这个 时候寄存器中的拷贝已经很可能和内存处的内容不一致了。</p><p>这只是使用”memory”时，GCC会保证做到的一点，但这并不是全部。因为使用”memory”是向GCC声明内存发生了变化，而内存发生变化带来的影响并不止这一点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> __argc, <span class="type">char</span>* __argv[])</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span>* __p = (<span class="type">int</span>*)__argc; </span><br><span class="line">    (*__p) = <span class="number">9999</span>; </span><br><span class="line">    __asm__(<span class="string">&quot;&quot;</span>:::<span class="string">&quot;memory&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span>((*__p) == <span class="number">9999</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>; </span><br><span class="line">    <span class="keyword">return</span> (*__p); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中，如果没有那条内联汇编语句，那个if语句的判断条件就完全是一句废话。GCC在优化时会意识到这一点，而直接只生成return 5的汇编代码，而不会再生成if语句的相关代码，而不会生成return (*__p)的相关代码。但你加上了这条内联汇编语句，它除了声明内存变化之外，什么都没有做。但GCC此时就不能简单的认为它不需要判断都知道 (*__p)一定与9999相等，它只有老老实实生成这条if语句的汇编代码，一起相关的两个return语句相关代码。</p><p>linux内核中内存屏障也是基于它实现，<code>#define barrier() _asm__volatile_(&quot;&quot; : : : &quot;memory&quot;)</code>，主要是保证程序的执行遵循顺序一致性。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux实用工具</title>
      <link href="/2022/02/24/220224-Linux%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
      <url>/2022/02/24/220224-Linux%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-screen工具"><a href="#Linux-screen工具" class="headerlink" title="Linux screen工具"></a>Linux screen工具</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>Linux screen命令用于多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s &lt;shell&gt;][-S &lt;作业名称&gt;]</span><br></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li>-A 　将所有的视窗都调整为目前终端机的大小。</li><li>-d&lt;作业名称&gt; 　将指定的screen作业离线。</li><li>-h&lt;行数&gt; 　指定视窗的缓冲区行数。</li><li>-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。</li><li>-r&lt;作业名称&gt; 　恢复离线的screen作业。</li><li>-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。</li><li>-s<shell> 　指定建立新视窗时，所要执行的shell。</shell></li><li>-S&lt;作业名称&gt; 　指定screen作业的名称。</li><li>-v 　显示版本信息。</li><li>-x 　恢复之前离线的screen作业。</li><li>-ls或–list 　显示目前所有的screen作业。</li><li>-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">screen -ls  # 显示已创建的screen终端</span><br><span class="line">screen -S &lt;screen name&gt;  # 创建新的screen终端</span><br><span class="line">screen -r &lt;screen name&gt;  # 重连screen终端</span><br><span class="line">screen -d &lt;screen name&gt;  # 断开screen终端</span><br><span class="line">screen -S &lt;screen name&gt; -X quit  # 强制停止命令</span><br></pre></td></tr></table></figure><h3 id="screen快捷键"><a href="#screen快捷键" class="headerlink" title="screen快捷键"></a>screen快捷键</h3><ul><li>Ctrl -a c            创建新的视窗</li><li>Ctrl -a d            断开screen终端，任务还在运行</li><li>Ctrl -a k            删除当前视窗</li><li>Ctrl -a 空格      视窗切换</li><li>Ctrl -a ?           快捷键帮助</li><li>Ctrl -a :            命令模式，类似vi</li><li>Ctrl -a [            复制模式，可以移光标上去看上面的打印</li></ul><h3 id="screen配置"><a href="#screen配置" class="headerlink" title="screen配置"></a>screen配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/hao0527/hao0527.github.io/blob/main/others/screencfg -O ~/.screenrc  # 一个好用的screen配置文件</span><br></pre></td></tr></table></figure><p>上面这个配置指令有些问题，wget下载下来的是html，所以就手动复制下内容到~/.screenrc文件吧。</p><h2 id="Linux-vi-vim工具"><a href="#Linux-vi-vim工具" class="headerlink" title="Linux vi/vim工具"></a>Linux vi/vim工具</h2><h3 id="功能介绍-1"><a href="#功能介绍-1" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><h3 id="vi-vim使用"><a href="#vi-vim使用" class="headerlink" title="vi/vim使用"></a>vi/vim使用</h3><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。</p><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p><img src="hthttps://gitee.com/hao0527/hao0527/raw/img/0224-Linux实用工具/220224-Linux实用工具-1.jpg" alt="220224-Linux实用工具-1.jpg"></p><table><thead><tr><th>输入</th><th>作用</th></tr></thead><tbody><tr><td>yy</td><td>复制游标所在的那一行。(常用)</td></tr><tr><td>dd</td><td>剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。</td></tr><tr><td>p/P</td><td>p粘贴在光标行下面，P粘贴在光标行上面。</td></tr><tr><td>u</td><td>复原前一个动作。(常用)</td></tr><tr><td>[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr><tr><td>/word</td><td>向光标之下寻找一个名称为 word 的字符串。 (常用)</td></tr><tr><td>?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td>i, I</td><td>进入输入模式(Insert mode)</td></tr><tr><td>ZZ</td><td>如果修改过，保存当前文件，然后退出！效果等同于保存并退出</td></tr></tbody></table><p>常用的还有替换功能：</p><ul><li><code>:1,$s/word1/word2/g</code> 或 <code>:%s/word1/word2/g</code>，从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</li><li><code>:1,$s/word1/word2/gc</code> 或 <code>:%s/word1/word2/gc</code>，从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ，加了c表示取代前显示提示字符给用户确认 (confirm) 是否需要取代。</li></ul><h4 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h4><p>输入模式比较简单，可以使用键盘上的Home、End等功能键，按Esc退出输入模式到命令模式</p><h4 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h4><table><thead><tr><th>输入</th><th>作用</th></tr></thead><tbody><tr><td>:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td>:q</td><td>离开 vi (常用)</td></tr><tr><td>:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为『强制』离开不储存档案。</td></tr><tr><td>:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td>:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td>:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td>:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td>:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如<br>『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr><tr><td>:set nu/nonu</td><td>显示/取消行号</td></tr></tbody></table><h2 id="Linux-tldr工具"><a href="#Linux-tldr工具" class="headerlink" title="Linux tldr工具"></a>Linux tldr工具</h2><h3 id="功能介绍-2"><a href="#功能介绍-2" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>一个比 –help 和 man 好用的查指令手册的工具，<a href="https://github.com/tldr-pages/tldr">点我跳到tldr(too long don’t read)主页</a>。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>我使用<code>sudo apt install tldr</code>安装，然后<code>mkdir -p ~/.tldr/tldr</code>，再更新字典<code>sudo git clone https://gitclone.com/github.com/tldr-pages/tldr.git ~/.tldr/tldr</code>，国内使用这个镜像快。</p><p>推荐：官网上说可以使用npm或pip3安装。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用方式极其简单，<code>tldr tldr</code>你就可以查到tldr的使用手册。</p><h2 id="Linux-Samba工具"><a href="#Linux-Samba工具" class="headerlink" title="Linux Samba工具"></a>Linux Samba工具</h2><h3 id="功能介绍-3"><a href="#功能介绍-3" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>samba 是基于SMB协议（ServerMessage Block，信息服务块）的开源软件，samba也可以是SMB协议的商标。SMB是一种Linux、UNIX系统上可用于共享文件和打印机等资源的协议，这种协议是基于Client\Server型的协议，Client端可以通过SMB访问到Server（服务器）上的共享资源。当Windows是 Client，Ubuntu是服务器时，通过Samba就可以实现window访问Linux的资源，实现两个系统间的数据交互。samba服务程序已经成为在Linux系统和Windows系统之间共享文件的最佳选择，当然在Linux系统与Linux系统之间的文件共享也选择samba。</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>在Ubuntu中安装<code>sudo apt install samba</code>，会自动安装其依赖组件。</p><p>安装后可用<code>samba -V</code>查看samba版本号，以确认安装完成。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>配置文件目录在/etc/samba/smb.conf，配置以下内容可共享home目录下用户文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Un-comment the following (and tweak the other settings below to suit)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">to <span class="built_in">enable</span> the default home directory shares. This will share each</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">user<span class="string">&#x27;s home directory as \\server\username</span></span></span><br><span class="line">[homes]</span><br><span class="line">   comment = Home Directories</span><br><span class="line">   browseable = no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">By default, the home directories are exported read-only. Change the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">next parameter to &#x27;</span>no<span class="string">&#x27; if you want to be able to write to them.</span></span></span><br><span class="line">   read only = no</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">File creation mask is set to 0700 for security reasons. If you want to</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">create files with group=rw permissions, set next parameter to 0775.</span></span></span><br><span class="line">   create mask = 0775</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Directory creation mask is set to 0700 for security reasons. If you want to</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">create dirs. with group=rw permissions, set next parameter to 0775.</span></span></span><br><span class="line">   directory mask = 0775</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">By default, \\server\username shares can be connected to by anyone</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">with access to the samba server.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Un-comment the following parameter to make sure that only &quot;username&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">can connect to \\server\username</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">This might need tweaking when using external authentication schemes</span></span></span><br><span class="line">   valid users = %S</span><br></pre></td></tr></table></figure><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>以上配置后需要重启samba服务生效，可以注销用户后重新登录。</p><p>通过<code>sudo smbpasswd -a userName</code>添加一个samba用户，不然直接windows远程访问会拒绝访问。</p><p>userName需要是系统已有的用户名，否则会<code>Failed to add entry for user userName</code>。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="/2022/02/20/220220-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/02/20/220220-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="再次了解进程与线程"><a href="#再次了解进程与线程" class="headerlink" title="再次了解进程与线程"></a>再次了解进程与线程</h2><ul><li><a href="/2021/06/11/210611-python%E5%BC%82%E6%AD%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B/">Python异步与线程</a>：这是21年6月时对线程、进程、同步、异步的简单了解，最近在做毕设时又用到了，打算重新回顾一遍。</li></ul><h2 id="多线程与多进程的区别"><a href="#多线程与多进程的区别" class="headerlink" title="多线程与多进程的区别"></a>多线程与多进程的区别</h2><p><strong>多线程 threading：</strong> 一个人有与异性聊天和看剧两件事要做。单线程的她可以看完剧再去聊天，但这样子可能就没人陪她聊天了「哼，发消息不回」。我们把她看成一个CPU核心，为她开起多线程——先看一会剧，偶尔看看新消息，在两件事（线程）间来回切换。多线程：单个CPU核心可以同时做几件事，不至于卡在某一步傻等着。</p><p>用处：爬取网站信息（爬虫），等待多个用户输入</p><p><strong>多进程 processing：</strong> 一个人有很多砖需要搬，他领取手套、推车各种物资（向系统申请了资源）然后开始搬砖。然而他身边有很多人，我们让这些人去帮他！（一核有难，八核围观）。于是他们做了分工，砖很快就搬完了。多进程让多个CPU核心可以一起做事，不至于只有一人干活而其他人傻站着。</p><p>用处：进行高性能计算。只有多进程方案设计合理，才能加速计算。</p><h2 id="Python中应用多进程"><a href="#Python中应用多进程" class="headerlink" title="Python中应用多进程"></a>Python中应用多进程</h2><ul><li>毕设的上位机要接收显示图像，我在udp数据接收解码后，写入IO流，通过管道发给另一个进程，另一个进程做图像的处理与显示，这样就不会因为处理时间过长而阻塞下一次接收解码了。</li><li><a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html">multiprocessing — 基于进程的并行</a>：multiprocessing是Python自带的多进程库，这是Python官方的文档对multiprocessing库的介绍。</li><li>Python的线程是操作系统线程，因此要有Python全局解释器锁。一个python解释器进程内有一条<strong>主线程</strong>，以及多条用户程序的<strong>执行线程</strong>。即使在多核CPU平台上，由于GIL的存在，所以禁止多线程的并行执行。Python 3.6 才让multiprocessing逐渐发展成一个能用的Python内置多进程库，可以进行进程间的通信，以及有限的内存共享。</li></ul><h3 id="两种多进程创建方式"><a href="#两种多进程创建方式" class="headerlink" title="两种多进程创建方式"></a>两种多进程创建方式</h3><p>Python多进程可以选择两种创建进程的方式，spawn与fork，实际使用中可以根据子进程具体做什么来选取用fork还是spawn。</p><ol><li>fork：除了必要的启动资源外，其他变量，包，数据等都继承自父进程，并且是copy-on-write的，也就是共享了父进程的一些内存页，因此启动较快，但是由于大部分都用的父进程数据，所以是不安全的进程</li><li>spawn：从头构建一个子进程，父进程的数据等拷贝到子进程空间内，拥有自己的Python解释器，所以需要重新加载一遍父进程的包，因此启动较慢，由于数据都是自己的，安全性较高</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.set_start_method(<span class="string">&#x27;spawn&#x27;</span>)  <span class="comment"># default on WinOS or MacOS</span></span><br><span class="line">multiprocessing.set_start_method(<span class="string">&#x27;fork&#x27;</span>)   <span class="comment"># default on Linux (UnixOS)</span></span><br></pre></td></tr></table></figure><h3 id="四种进程间通信方式"><a href="#四种进程间通信方式" class="headerlink" title="四种进程间通信方式"></a>四种进程间通信方式</h3><p>Python中进程间通信可以采用进程池Pool、管道Pipe、队列Queue，在新版本Python中多了共享内存Manager的方式。</p><ol><li><a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#module-multiprocessing.pool">进程池Pool</a>：不怎么使用？通常使用另外两个方式通信</li><li><a href="https://docs.python.org/zh-cn/3.7/library/multiprocessing.html#pipes-and-queues">管道和队列</a>：Queue用于多个进程间实现通信，Pipe是两个进程的通信。Queue通过put和get方法插入读取队列，Pipe通过send和recv方法发送和接收信息，用法可以参考这篇文章：<a href="https://www.cnblogs.com/guguobao/p/9398653.html">python进程间通信</a>，如果追求运行更快，那么最好使用管道Pipe而队列Queue，详细查看<a href="https://www.raspberrypi.org/forums/viewtopic.php?t=141576">Python pipes and queues performance</a></li><li><a href="https://docs.python.org/zh-cn/3/library/multiprocessing.html#sharing-state-between-processes">共享内存Manager</a>：Pipe Queue 把需要通信的信息从内存里深拷贝了一份给其他线程使用（需要分发的线程越多，其占用的内存越多）。而共享内存会由解释器负责维护一块共享内存（而不用深拷贝），这块内存每个进程都能读取到，读写的时候遵守管理（因此不要以为用了共享内存就一定变快）</li></ol><h3 id="编程中要注意"><a href="#编程中要注意" class="headerlink" title="编程中要注意"></a>编程中要注意</h3><p>为了避免自己调用自己时重复执行主进程，**多进程的主进程一定要写在程序入口if __name__ == ‘__main__’:，否则可能会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function1</span>(<span class="params"><span class="built_in">id</span></span>):  <span class="comment"># 这里是子进程</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;id <span class="subst">&#123;<span class="built_in">id</span>&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run__process</span>():  <span class="comment"># 这里是主进程</span></span><br><span class="line">    <span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line">    process = [mp.Process(target=function1, args=(<span class="number">1</span>,)),</span><br><span class="line">               mp.Process(target=function1, args=(<span class="number">2</span>,)), ]</span><br><span class="line">    [p.start() <span class="keyword">for</span> p <span class="keyword">in</span> process]  <span class="comment"># 开启了两个进程</span></span><br><span class="line">    [p.join() <span class="keyword">for</span> p <span class="keyword">in</span> process]   <span class="comment"># 等待两个进程依次结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run__process()  # 主线程不建议写在 if外部。由于这里的例子很简单，你强行这么做可能不会报错</span></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    run__process()  <span class="comment"># 正确做法：主线程只能写在 if内部</span></span><br></pre></td></tr></table></figure><p>设计高性能的多进程时，遵守以下规则：</p><ul><li>尽可能少传一点数据</li><li>尽可能减少主线程的负担</li><li>尽可能不让某个进程傻等着</li><li>尽可能减少进程间通信的频率</li></ul><h2 id="网上一些好的文档"><a href="#网上一些好的文档" class="headerlink" title="网上一些好的文档"></a>网上一些好的文档</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/340965963">Python程序入口 <strong>name</strong> == ‘<strong>main</strong>‘ 有重要功能（多线程）而非编程习惯</a>：这篇文章讲述了Python中程序入口的作用，Python用这个简单的方法来判断当前的模块是被直接运行还是被调用，这是很重要的功能。</li><li><a href="https://zhuanlan.zhihu.com/p/340657122">在Python中优雅地用多进程</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大学最后一个假期</title>
      <link href="/2022/01/19/220119-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%AF%92%E5%81%87/"/>
      <url>/2022/01/19/220119-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%AF%92%E5%81%87/</url>
      
        <content type="html"><![CDATA[<h1 id="大学回忆录"><a href="#大学回忆录" class="headerlink" title="大学回忆录"></a>大学回忆录</h1><h2 id="大一上学期"><a href="#大一上学期" class="headerlink" title="大一上学期"></a>大一上学期</h2><p>回忆从开学前几日的寝室生活开始，<strong>室友都非常的好相处</strong>，大家在一起能玩的很嗨。再到大一我参加了两个学生会的部门（学生会办公室&amp;党员之家实践部）和一个社团（单车俱乐部），自己在部门里认识了些不同班级不同专业的朋友，也<strong>交到了一位知心</strong>，大一上学期我天天晚上会和他去健身房，或是去钱塘江边散步，或是在寝室喝酒，元旦跨年我去了他家里，人生中第一次和别人跨年。参与了学生会的活动演出和演讲还有优秀干部的竞选；</p><h2 id="大一寒假"><a href="#大一寒假" class="headerlink" title="大一寒假"></a>大一寒假</h2><p>寒假里我一个人坐飞机去了山东蓬莱，找我高考结束后在华为上班认识的同事，蓬莱待了7天，青岛待了2天。独自旅行，去一个陌生的地方，享受孤独，思考人生，一个人狂欢。旅行结束回家后，我学习了郭天祥的<strong>十天学会51单片机</strong>，但并没有完全学会；</p><h2 id="大一下学期"><a href="#大一下学期" class="headerlink" title="大一下学期"></a>大一下学期</h2><p>大一下学期有我喜欢的课程模电，我通过教同学们解题来学习这门课程，因此也<strong>交到了陪伴我至今的女朋友</strong>。除了模电课我还选了一门电子课程设计也非常喜欢，老师授课讲了51单片机的知识，课程做了51数字钟（我在5月19日晚上写完，拍了个51开发版显示520倒计时的视频），最后的作业是51小车。这学期学生会部门成员积极性变差了，我最后没有选择留任执委，选择了留在电子创新实验室（一待就是三年）；</p><h2 id="大一暑假"><a href="#大一暑假" class="headerlink" title="大一暑假"></a>大一暑假</h2><p>暑假我留在实验室<strong>准备19年的全国大学生电子设计竞赛</strong>，暑假做了历年的题目（声音存储录放、风力摆、旋转倒立摆），那时候的我不知道熬夜会伤身体，每天白天调试，晚上在寝室看文档到凌晨2点。暑假里由于比较专注比赛，忘记关心女朋友，两人有过多次争执，女朋友不回消息，我直接去她家里了，就这样被她家人认识，至今我还常去她家蹭饭。这个暑假差一点点就分手了；</p><h2 id="大二上学期"><a href="#大二上学期" class="headerlink" title="大二上学期"></a>大二上学期</h2><p>大二上学期，一开学和徐高东学长参加了<strong>工程训练大赛</strong>，那次比赛后感觉之前所有学过的东西都能联会贯通了。比赛的时候出现了意外，没有取得好成绩，东哥说了句：比赛不就是这样。随后我参加了<strong>飞思卡尔智能车竞赛</strong>，在校内训练的时候感觉都良好，本来计划我和洪晨益写程序，由于硬件画的板子实在惨不忍睹，就自己动手把硬件做完了，我那写代码的队友也很强，一人能维护好代码，那年寒假前我们俩调车调到学校关门。这学期，我和我的女朋友分手了，但几个星期又复合了，我们相互都很缺时间在一起交流；</p><h2 id="大二寒假"><a href="#大二寒假" class="headerlink" title="大二寒假"></a>大二寒假</h2><p>那年是全世界肺炎流行的一年，寒假在家3个月，当然我也没闲着，趁家里无聊，打开电脑学了些东西，有<strong>python，tensorflow，sklearn，百度飞桨，git</strong>等，有潘利斌陪我一起学。疫情原因只能在家调飞卡，在家里把<strong>Altium Designer</strong>了一遍，画板子是没有问题了。3月在家网课，网课非常适合我，我可以不仅可以回放自己学校老师上课讲的，还能去B站慕课上找名校老师上课的视频；</p><h2 id="大二下学期"><a href="#大二下学期" class="headerlink" title="大二下学期"></a>大二下学期</h2><p>中国疫情控制的很厉害，4月中就能返校了。这学期在学校主要是准备电赛，准备飞卡，飞卡参加的是<strong>AI组别</strong>，通过机器学习，训练后部署到单片机，实现自主规划路线；</p><h2 id="大二暑假"><a href="#大二暑假" class="headerlink" title="大二暑假"></a>大二暑假</h2><p>暑假<strong>培训大一电赛新生</strong>，不过今年比赛延期了，暑假没有比赛。飞卡如期举行，离国赛就差0.02秒，怎么就这么可惜呀。电赛准备了很多模块，把模块间通信学的明明白白的，还有很多PCB上的设计规范也学了一遍，那年我们实验室都在看<strong>长江大学唐老师</strong>的教学视频。</p><h2 id="大三上学期"><a href="#大三上学期" class="headerlink" title="大三上学期"></a>大三上学期</h2><p>大三上学期开始在黄道麒<strong>公司实习</strong>，老板非常厉害，抓住了疫情这个风口，做红外热像仪体温枪这些生意。公司离学校很近，我每天上完课就去公司，那段时间进步非常快，学的东西也非常多非常杂。用了好多品牌的国产mcu，用QT写了上位机，学习了二元光学。十月份<strong>浙江省电子大赛</strong>，作品实物验收满分取得了省二等奖，队友配合的非常棒！这学期上了算法与数据结构和数字逻辑设计、51汇编，非常感兴趣，买了块FPGA开发板练手；</p><h2 id="大三寒假"><a href="#大三寒假" class="headerlink" title="大三寒假"></a>大三寒假</h2><p>寒假里我还在公司上班，老板让我住宾馆可以报销。寒假里我学习了<strong>linux应用开发</strong>，opencv，makefile，cmake，用树莓派做了个红外热像仪的demo。这个寒假我在公司借了很多书看，有linux的，opencv的，无线传感器网络的，感测技术的。在公司里和老板经常聊到很晚，我们谈未来的方向，谈生活时政等等，无所不谈，<strong>是一家有温度的公司</strong>；</p><h2 id="大三下学期"><a href="#大三下学期" class="headerlink" title="大三下学期"></a>大三下学期</h2><p>这学期了解了一些<strong>网络安全，开关电源设计，搭建了blog</strong>，仍然在公司实习。搞的东西太杂了容易忘记自己学过什么，写写博客记录下的话翻到还能有印象。公司里主要是把之前用树莓派跑的demo移到了m4的mcu，另一个项目是用高云fpga做了ov2640的串并转换到mcu处理，练习了fpga。5月份之前飞卡的软件队友提出来要再参加一次，让我做一下硬件，这次我非常熟练，PCB最多就设计了两版就完成了硬件设计；</p><h2 id="大三暑假"><a href="#大三暑假" class="headerlink" title="大三暑假"></a>大三暑假</h2><p>暑假去了一家做半导体芯片的公司实习，是属于系统集成部，公司平均年龄比较大，部门里同事都不怎么说话，公司氛围不太好，领导经常会骂别人很凶，我一看不对劲就溜溜球了。暑假在做wifi图传的项目，尝试用m4自己看数据手册写<strong>WiFi驱动</strong>，不过后来这事没成，换了<strong>esp32用idf</strong>开发。很早开始我就对网络感兴趣，可能未来也会多往这个方向发展；</p><h2 id="大四上学期"><a href="#大四上学期" class="headerlink" title="大四上学期"></a>大四上学期</h2><p>大四第一学期在世界五百强<strong>博世</strong>上班，公司的氛围特别好，领导都很有管理的能力，同事之间办公都非常的舒心，博世是个不加班的外企，但是工作效率挺高的，流程虽多，但处理速度很快。我在博世工作了4个月，学习了高压交流的PCB设计，直流无刷电机，永磁同步电机，把电力这一块学了一遍，也了解了电机的控制算法，最简单的六步换向，还有FOC。可以说这次实习经历相当难忘，每个牛的公司，都有一群好的团队管理者。这学期，还报名考研了，算是把大学的知识复习了一下，没考好，以后也不会再有考研的想法了；</p><h1 id="还有最后一个假期"><a href="#还有最后一个假期" class="headerlink" title="还有最后一个假期"></a>还有最后一个假期</h1><p>最后一个假期也没选择安逸，找了家做安防的公司实习，在这里我学到了<strong>linux驱动开发</strong>的知识，我的主管年龄挺大的技术很好，整个框架是他从头写出来的，我看git log一步步看他怎么写出来，太强了！面试的时候就被他的技术所吸引，这么强的人为人还非常谦虚，值得我去学习！在这里我重学了一年前了解过的<strong>makefile编写，shell脚本编程，C代码规范</strong>等等。看了主管写的几万行脚本代码，我再感叹到太强了！过年在家里自己系统的学了一遍计算机网络，本来还想学计算机组成原理和操作系统的，学操作系统的时候卡住了，看早期的linux源码也非常的费劲，只能推到我2月实习完回学校再学了；</p><h1 id="致青春：如果没有源自内心的冲动，怎么可能登峰造极呢？"><a href="#致青春：如果没有源自内心的冲动，怎么可能登峰造极呢？" class="headerlink" title="致青春：如果没有源自内心的冲动，怎么可能登峰造极呢？"></a>致青春：<strong>如果没有源自内心的冲动，怎么可能登峰造极呢？</strong></h1><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 这算什么 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FPGA之以太网学习</title>
      <link href="/2022/01/13/220113-fpga%E4%B9%8Beth/"/>
      <url>/2022/01/13/220113-fpga%E4%B9%8Beth/</url>
      
        <content type="html"><![CDATA[<h3 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h3><ul><li><a href="https://www.bilibili.com/video/BV194411f7GD?p=80">【正点原子】手把手教你学FPGA系列视频——以太网通信实验</a></li></ul><h3 id="以太网的介绍"><a href="#以太网的介绍" class="headerlink" title="以太网的介绍"></a>以太网的介绍</h3><h4 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h4><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-1.jpg" alt="220113-fpga之eth-1.jpg"></p><ul><li>物理层：在物理层上所传数据的单位是比特。发送方发送1(或0)时，接收方应当收到1(或0)而不是0 (或1)，因此物理层要考虑用多大的电压代表”1”或”0”，以及接收方如何识别出发送方所发送的比特。物理层还要确定连接电缆的插头应当有多少根引脚以及各引脚应如何连接。当然，解释比特代表的意思，就不是物理层的任务。请注意，传递信息所利用的-些物理媒体，如双绞线、同轴电缆、光缆、无线信道等，并不在物理层协议之内而是在物理层协议的下面。</li><li>数据链路层：数据链路层常简称为链路层。我们知道，两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻结点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧(framing)，在两个相邻结点间的链路上传送帧(frame)，每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)。在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结·束。这样，数据链路层在收到一个帧后，就可从中提取出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如发现有差错，数据链路层就简单地丢弃这个出了差错的帧，以免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在数据链路层传输时出现的差错(这就是说，数据链路层不仅要检错，而且要纠错)，那么就要采用可靠传输协议来纠正出现的差错。这种方法会使数据链路层的协议复杂些。</li><li>网络层、运输层、应用层见《计算机网络》书籍；fpga跑eth主要用到了phy层、数据链路mac层、网络层、udp传输层；</li></ul><h4 id="FPGA数据包内容"><a href="#FPGA数据包内容" class="headerlink" title="FPGA数据包内容"></a>FPGA数据包内容</h4><p>下面放出fpga发送的以太网数据包的组层图，图片来自《开拓者FPGA 开发指南V1.3》，相关介绍也可以查看PDF。</p><h5 id="以太网数据包格式"><a href="#以太网数据包格式" class="headerlink" title="以太网数据包格式"></a>以太网数据包格式</h5><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-2.jpg" alt="220113-fpga之eth-2.jpg"></p><h5 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h5><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-3.jpg" alt="220113-fpga之eth-3.jpg"></p><h5 id="IP数据包格式"><a href="#IP数据包格式" class="headerlink" title="IP数据包格式"></a>IP数据包格式</h5><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-4.jpg" alt="220113-fpga之eth-4.jpg"></p><h5 id="UDP数据格式"><a href="#UDP数据格式" class="headerlink" title="UDP数据格式"></a>UDP数据格式</h5><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-5.jpg" alt="220113-fpga之eth-5.jpg"></p><h4 id="千兆以太网物理层"><a href="#千兆以太网物理层" class="headerlink" title="千兆以太网物理层"></a>千兆以太网物理层</h4><ul><li>下面这个是我开发板图和板上的千兆以太网原理图，设计的非常好，板子上的IO基本上都是等长线。  </li></ul><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-6.jpg" alt="220113-fpga之eth-6.jpg"></p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/220113-fpga%E4%B9%8Beth/220113-fpga%E4%B9%8Beth-7.jpg" alt="220113-fpga之eth-7.jpg"></p><ul><li>物理层的设计和学习还有个非常重要的学习资料就是《RTL8211数据手册》，这个手册上竟然写着不对外公布。</li></ul><h3 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h3><h4 id="例程修改"><a href="#例程修改" class="headerlink" title="例程修改"></a>例程修改</h4><ul><li>简易的修改了下例程，让udp每次数据包发送1472个字节数据，其中前4字节是包序列号，用于接收端检测是否掉包，其他的1468个字节数据为0x00-0xFF循环，从而更为精确的模仿正常传输时的内容。再通过每次发完控制idle时间来控制传输速率。</li></ul><h4 id="上位机编写"><a href="#上位机编写" class="headerlink" title="上位机编写"></a>上位机编写</h4><ul><li>上位机才用Python编写，在JupyterNotebook里实现。实现原理主要就是一直读udp，再去比较这次的包序列号是不是上一次+1，如果不是的话打印出来。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">BUFSIZE = <span class="number">1472</span> * <span class="number">100</span></span><br><span class="line">ip_port = (<span class="string">&#x27;192.168.0.3&#x27;</span>, <span class="number">8080</span>)</span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  <span class="comment"># udp协议</span></span><br><span class="line">server.bind(ip_port)</span><br><span class="line">error = <span class="number">0</span></span><br><span class="line">recv_data_a = server.recvfrom(BUFSIZE)[<span class="number">0</span>][:<span class="number">4</span>]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    recv_data_b = server.recvfrom(BUFSIZE)[<span class="number">0</span>][:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>.from_bytes(recv_data_b,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>) != \</span><br><span class="line">       <span class="built_in">int</span>.from_bytes(recv_data_a,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>) + <span class="number">1</span>):</span><br><span class="line">        error += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;error:%u, recv_data_a = %u, recv_data_b = %u&quot;</span> \</span><br><span class="line">              %(error, <span class="built_in">int</span>.from_bytes(recv_data_a,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>), \</span><br><span class="line">                <span class="built_in">int</span>.from_bytes(recv_data_b,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>)))</span><br><span class="line">    recv_data_a = server.recvfrom(BUFSIZE)[<span class="number">0</span>][:<span class="number">4</span>]</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">int</span>.from_bytes(recv_data_a,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>) != \</span><br><span class="line">       <span class="built_in">int</span>.from_bytes(recv_data_b,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>) + <span class="number">1</span>):</span><br><span class="line">        error += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;error:%u, recv_data_b = %u, recv_data_a = %u&quot;</span> \</span><br><span class="line">              %(error, <span class="built_in">int</span>.from_bytes(recv_data_b,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>), \</span><br><span class="line">                <span class="built_in">int</span>.from_bytes(recv_data_a,byteorder=<span class="string">&#x27;big&#x27;</span>,signed=<span class="literal">False</span>)))</span><br><span class="line">server.close()</span><br></pre></td></tr></table></figure><h4 id="掉包处理"><a href="#掉包处理" class="headerlink" title="掉包处理"></a>掉包处理</h4><ul><li>在100Mbps速率传输的时候，每65536帧传输后都会出现2帧的掉包，通过WireShark查看，能找到那2帧包，也就是说数据包被网卡接收但是在上位机处没有接收。通过WireShark查看整个以太网数据包内容后发现规律：只有在IP数据包的首部校验和为0xFFFF的时候才会出现掉包，百度上也有这样的案例，于是修改FPGA代码，让IP包首部标识位不每次+1，这样校验和就不会出现0XFFFF。</li></ul><h4 id="调试结果"><a href="#调试结果" class="headerlink" title="调试结果"></a>调试结果</h4><ul><li>经过简易测试，当传输速率为200Mbps的时候，不掉包；当传输速率为300Mbps的时候，出现掉包。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>本次调试，学习了网络5层模型的物理层和MAC层，通过亲自实践解决出现的问题，对网络的底层实现有了更清楚的认识，对日后学习Linux驱动开发的网络部分会有极大的帮助，以及我的毕设，udp传输图像只是其中的一小部分，如果有时间，我会做个更复杂题目，学习更多的网络知识（大学只学了物联网和网络相关，计网没学）。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动开发学习笔记</title>
      <link href="/2022/01/11/220111-LinuxComm/"/>
      <url>/2022/01/11/220111-LinuxComm/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux-File（文件写入）"><a href="#Linux-File（文件写入）" class="headerlink" title="Linux-File（文件写入）"></a>Linux-File（文件写入）</h3><p>​    对于write函数，我们认为该函数一旦返回，数据便已经写到了文件中。但是这种概念只是宏观上的，一般情况下，对硬盘（或者其他持久存储设备）文件的write操作，更新的只是内存中的页缓存（page cache），而脏页不会立即更新到硬盘中，而是由操作系统统一调度，如flusher内核线程在满足一定条件时（一定时间间隔、内存中的脏页达到一定比例）将脏页面同步到硬盘上（放入设备的IO请求队列）。因为write调用不会等到硬盘IO完成之后才返回，设想如果操作系统在write调用之后、硬盘同步之前崩溃，则数据可能丢失。虽然这样的时间窗口很小，但是对于需要保证事务的持久化（durability）和一致性（consistency）的数据库程序来说，write()所提供的“松散的异步语义”是不够的，通常需要操作系统提供的同步IO（synchronized-IO）原语来保证：</p><p>​    Linux、unix在内核中设有缓冲区、高速缓冲或页面高速缓冲，大多数磁盘I/O都通过缓冲进行，采用延迟写技术。<br>sync：将所有修改过的快缓存区排入写队列，然后返回，并不等待实际写磁盘操作结束；<br>fsync：只对有文件描述符制定的单一文件起作用，并且等待些磁盘操作结束，然后返回；<br>fdatasync：类似fsync，但它只影响文件的数据部分。fsync还会同步更新文件的属性；<br>fflush：标准I/O函数（如：fread，fwrite）会在内存建立缓冲，该函数刷新内存缓冲，将内容写入内核缓冲，要想将其写入磁盘，还需要调用fsync。（先调用fflush后调用fsync，否则不起作用）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pFile = fopen(pFilePath, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == pFile)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> FAILURE;</span><br><span class="line">&#125;</span><br><span class="line">res = fwrite(aValStr, <span class="number">1</span>, <span class="built_in">strlen</span>(aValStr), pFile); </span><br><span class="line"><span class="keyword">if</span>(res != <span class="built_in">strlen</span>(aValStr))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> FAILURE;</span><br><span class="line">&#125;</span><br><span class="line">fflush(pFile);          <span class="comment">//刷新缓冲区，强制缓冲区文件内容写入内核缓冲</span></span><br><span class="line">fsync(fileno(pFile));   <span class="comment">//同步内存中已修改的对应fd的文件数据到设备存储</span></span><br><span class="line">                        <span class="comment">//fileno()用于返回文件流对应的文件描述符fd</span></span><br><span class="line">fclose(pFile);</span><br></pre></td></tr></table></figure><h3 id="Linux-Net（五种IO模型）"><a href="#Linux-Net（五种IO模型）" class="headerlink" title="Linux-Net（五种IO模型）"></a>Linux-Net（五种IO模型）</h3><ul><li>搬运：<a href="https://blog.csdn.net/qq_34638435/article/details/81878301">阻塞IO与非阻塞IO</a>  </li></ul><h4 id="阻塞IO模型"><a href="#阻塞IO模型" class="headerlink" title="阻塞IO模型"></a>阻塞IO模型</h4><ul><li>当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</li></ul><h4 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h4><ul><li>当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。  </li><li>所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU，如果在while循环体中一直去询问内核数据是否就绪，就会导致CPU占用率非常高。</li></ul><h4 id="多路复用IO模型"><a href="#多路复用IO模型" class="headerlink" title="多路复用IO模型"></a>多路复用IO模型</h4><ul><li>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，<strong>只需要使用一个线程就可以管理多个socket</strong>，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且<strong>只有在真正有socket读写事件进行时，才会使用IO资源</strong>，所以它大大减少了资源占用。</li><li>也许有朋友会说，我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。</li><li>不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。<strong>（才用多线程或线程池的方式来轮询和处理时间可解决）</strong></li></ul><h4 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h4><ul><li>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</li></ul><h4 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h4><ul><li> 异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它收到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要知道实际的整个IO操作是如何进行的，只需要先发起一个请求，<strong>当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了</strong>。</li><li>也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。</li><li>前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FPGA之SDRAM学习</title>
      <link href="/2021/12/19/211219-fpga%E4%B9%8Bsdram/"/>
      <url>/2021/12/19/211219-fpga%E4%B9%8Bsdram/</url>
      
        <content type="html"><![CDATA[<h3 id="学习视频"><a href="#学习视频" class="headerlink" title="学习视频"></a>学习视频</h3><ul><li><a href="https://www.bilibili.com/video/BV194411f7GD?p=57">【正点原子】手把手教你学FPGA系列视频——SDRAM</a></li></ul><h3 id="SDRAM介绍"><a href="#SDRAM介绍" class="headerlink" title="SDRAM介绍"></a>SDRAM介绍</h3><ul><li><p><strong>同步动态随机存取内存</strong>（synchronous dynamic random-access memory，简称SDRAM）是有一个<a href="https://baike.baidu.com/item/%E5%90%8C%E6%AD%A5%E6%8E%A5%E5%8F%A3">同步接口</a>的<a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%86%85%E5%AD%98/1681939">动态随机存取内存</a>（<a href="https://baike.baidu.com/item/DRAM">DRAM</a>）。通常DRAM是有一个异步接口的，这样它可以随时响应控制输入的变化。而SDRAM有一个同步接口，在响应控制<a href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5">输入</a>前会等待一个<a href="https://baike.baidu.com/item/%E6%97%B6%E9%92%9F%E4%BF%A1%E5%8F%B7">时钟信号</a>，这样就能和计算机的<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF">系统总线</a>同步。时钟被用来驱动一个<a href="https://baike.baidu.com/item/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/2081914">有限状态机</a>，对进入的指令进行<a href="https://baike.baidu.com/item/%E7%AE%A1%E7%BA%BF">管线</a>(Pipeline)操作。这使得SDRAM与没有同步接口的异步DRAM(asynchronous DRAM)相比，可以有一个更复杂的操作模式。</p></li><li><p>SDRAM从发展到现在已经经历了五代，分别是：第一代SDR SDRAM，第二代DDR SDRAM，第三代DDR2 SDRAM，第四代DDR3 SDRAM，第五代，DDR4 SDRAM。</p></li></ul><h3 id="SDRAM操作时序"><a href="#SDRAM操作时序" class="headerlink" title="SDRAM操作时序"></a>SDRAM操作时序</h3><ul><li>在对 SDRAM进行读写操作之前需要先对芯片进行初始化；SDRAM读写是一个较为复杂的控制流 程，其中包括行激活、列读写、预充电、刷新等一系列操作。</li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li><p>初始化流程如下<br><img src="https://gitee.com/hao0527/hao0527/raw/img/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-1.jpg" alt="211219-fpga之sdram-1.jpg"><br>SDRAM上电后要有200us的输入稳定期，在这个时间内不可以对SDRAM的接口做任何操作； 200us结束以后给所有L-Bank预充电，然后是连续8次刷新操作；最后设置模式寄存器。初始化 最关键的阶段就在于模式寄存器（MR，Mode Register）的设置，简称MRS（MR Set）。</p></li><li><p>模式寄存器如下<br><img src="https://gitee.com/hao0527/hao0527/raw/img/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-2.jpg" alt="211219-fpga之sdram-2.jpg"><br>如上图所示，用于配置模式寄存器的参数由地址线提供，地址线不同的位分别用于表示不 同的参数。SDRAM通过配置模式寄存器来确定芯片的工作方式，包括突发长度（Burst Length）、 潜伏期（CAS Latency）以及操作模式等。<br>需要注意的是，在模式寄存器设置指令发出之后，需要等待一段时间才能够向SDRAM发送 新的指令，这个时间我们称之为模式寄存器设置周期tRSC（Register Set Cycle）。</p></li></ul><h4 id="行激活"><a href="#行激活" class="headerlink" title="行激活"></a>行激活</h4><ul><li>行激活时序图<br><img src="https://gitee.com/hao0527/hao0527/raw/img/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-3.jpg" alt="211219-fpga之sdram-3.jpg"><br>初始化完成后，无论是读操作还是写操作，都要先激活（Active）SDRAM中的一行，使之 处于活动状态（又称行有效）。在此之前还要进行SDRAM芯片的片选和L-Bank的定址，不过它 们与行激活可以同时进行。<br>在片选CS#（#表示低电平有效）、L-Bank定址的同时，RAS（Row Address Strobe，行地址选通脉冲）也处于有效状态。此时An地址线则发送具体的行地址。如图中是A0-A11，共有12个地址线，由于是二进制表示法，所以共有4096个行（2^12=4096），A0-A11的不同数值就确定了具体的行地址。由于行激活的同时也是相应L-Bank有效，所以行激活也可称为L-Bank有效。</li></ul><h4 id="列读写"><a href="#列读写" class="headerlink" title="列读写"></a>列读写</h4><ul><li>列选通与读操作时序图<br><img src="https://gitee.com/hao0527/hao0527/raw/img/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-4.jpg" alt="211219-fpga之sdram-4.jpg"><br>由于在SDRAM中，地址线是行列共用的，因此列寻址时地址线仍然是A0-A11。在寻址时，利用RAS（Row Address Strobe，行地址选通脉冲）与CAS（Column Address Strobe，列地址选通脉冲）来区分行寻址与列寻址。</li><li>在发送列读写命令时必须要与行激活命令有一个时间间隔，这个间隔被定义为tRCD， 即RAS to CAS Delay（RAS至CAS延迟）。这是因为在行激活命令发出之后，芯片存储阵列电子 元件响应需要一定的时间。tRCD是SDRAM的一个重要时序参数，广义的tRCD以时钟周期（tCK， Clock Time）数为单位，比如tRCD=3，就代表RAS至CAS延迟为三个时钟周期，如图 33.1.8所 示。具体到确切的时间，则要根据时钟频率而定。</li></ul><h4 id="数据输出（读）"><a href="#数据输出（读）" class="headerlink" title="数据输出（读）"></a>数据输出（读）</h4><ul><li>在选定列地址后，就已经确定了具体的存储单元，剩下的事情就是数据通过数据I/O通道（DQ）输出到内存总线上了。但是在CAS发出之后，仍要经过一定的时间才能有数据输出，从CAS与读取命令发出到第一笔数据输出的这段时间，被定义为CL（CAS Latency，CAS潜伏期）。CL时间越短，读数据时SDRAM响应就越快。由于CL只在读取时出现，所以CL又被称为读取潜伏期（RL，Read Latency）。CL的单位与tRCD一样，为时钟周期数，具体耗时由时钟频率决定。</li></ul><h4 id="数据输出（写）"><a href="#数据输出（写）" class="headerlink" title="数据输出（写）"></a>数据输出（写）</h4><ul><li>数据写入时序图<br><img src="https://gitee.com/hao0527/hao0527/raw/img/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-5.jpg" alt="211219-fpga之sdram-5.jpg"><br>数据写入的操作也是在tRCD之后进行，但此时没有了CL（记住，CL只出现在读取操作中）， 行寻址与列寻址的时序图和上文一样，只是在列寻址时，WE#为有效状态。<br>数据与写指令同时发送。不过，数据并不是即时地写入存储单元，数据的 真正写入需要一定的周期。为了保证数据的可靠写入，都会留出足够的写入/校正时间（tWR， Write Recovery Time），这个操作也被称作写回（Write Back）。tWR至少占用一个时钟周期 或再多一点（时钟频率越高，tWR占用周期越多）。</li></ul><h4 id="此外"><a href="#此外" class="headerlink" title="此外"></a>此外</h4><ul><li>除上述操作之外，还有突发长度、预充电、刷新、数据掩码常用操作，具体可以查阅《开拓者FPGA开发指南》SDRAM读写测试实验。</li></ul><h3 id="实验仿真"><a href="#实验仿真" class="headerlink" title="实验仿真"></a>实验仿真</h3><p><img src="https://gitee.com/hao0527/hao0527/raw/img/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-6.jpg" alt="211219-fpga之sdram-6.jpg"><br><img src="https://gitee.com/hao0527/hao0527/raw/img/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-7.jpg" alt="211219-fpga之sdram-7.jpg"><br><img src="https://gitee.com/hao0527/hao0527/raw/img/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-8.jpg" alt="211219-fpga之sdram-8.jpg"><br><img src="https://gitee.com/hao0527/hao0527/raw/img/211219-fpga%E4%B9%8Bsdram/211219-fpga%E4%B9%8Bsdram-9.jpg" alt="211219-fpga之sdram-9.jpg"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LTE Cat.1模块和阿里云物联网平台使用</title>
      <link href="/2021/12/17/211217-ltecat1/"/>
      <url>/2021/12/17/211217-ltecat1/</url>
      
        <content type="html"><![CDATA[<h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><ul><li><a href="https://help.aliyun.com/product/30520.html">阿里云物联网平台-产品文档</a></li></ul><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>在博世实习，同事想要远程调试，打印log到终端功能（代替出差去现场调试），于是我就决定用LTE Cat.1模块，配合阿里云物联网平台，使用MQTT传输日志文件。</li></ul><h3 id="阿里云物联网平台使用"><a href="#阿里云物联网平台使用" class="headerlink" title="阿里云物联网平台使用"></a>阿里云物联网平台使用</h3><ol><li><p>打开<a href="https://iot.console.aliyun.com/lk/summary/new">阿里云物联网平台</a>，使用公共实例，<a href="https://help.aliyun.com/document_detail/73728.html">创建产品</a>，数据格式选择<strong>（透传/自定义）</strong>，以便将上行的自定义格式的数据转换为Alink JSON格式，连网方式这里选择<strong>蜂窝（2G/3G/4G/5G）</strong>，所属品类选择<strong>自定义品类</strong>，其它配置默认即可。配置完在产品详情界面图如下：![211217-ltecat1-1.jpg](<a href="https://hao0527.gitee.io/211217-ltecat1/211217-ltecat1-1.https://gitee.com/hao0527/hao0527/raw/img/">https://hao0527.gitee.io/211217-ltecat1/211217-ltecat1-1.https://gitee.com/hao0527/hao0527/raw/img/</a></p></li><li><p><a href="https://help.aliyun.com/document_detail/89271.html">创建设备</a>，创建设备成功后，将自动弹出<strong>添加完成</strong>对话框。您可以查看、复制设备证书信息。设备证书由设备的ProductKey、DeviceName和DeviceSecret组成，是设备与物联网平台进行通信的重要身份认证，建议您妥善保管。配置完在设备详情界面图如下：![211217-ltecat1-2.jpg](<a href="https://hao0527.gitee.io/211217-ltecat1/211217-lthttps://gitee.com/hao0527/hao0527/raw/img/">https://hao0527.gitee.io/211217-ltecat1/211217-lthttps://gitee.com/hao0527/hao0527/raw/img/</a></p></li><li><p>接下来就是在产品详情界面中的功能定义，可以查看<a href="https://help.aliyun.com/document_detail/213906.html">物模型概述</a>，设置MQTT需要上传的变量。我设置了一些调试时用到的变量，如下图：<img src="https://hao0527.gitee.io/211https://gitee.com/hao0527/hao0527/raw/img/1-3.jpg" alt="211217-ltecat1-3.jpg"></p></li><li><p>在产品详情界面中的数据解析可以设置<a href="https://iot.console.aliyun.com/product/productDetail/gecgSxxbl6Q?current=4">物模型数据解析</a>，通过物模型数据解析我们可以将自定义帧结构的数据解析成Alink JSON格式，注意：产品的<strong>数据格式</strong>选择为<strong>透传/自定义</strong>（这个坑我一天，最后找阿里云客服解决）。写完数据解析后，选择模拟类型为<strong>设备上报数据</strong>，执行与提交。</p></li><li><p>接下来就是mcu使用LTE Cat.1模块给阿里云平台发数据了！在设备详情的物模型数据中可以看见，通过物模型数据上报的topic发送来的调试变量。我们也可以通过设备详情中的日志服务看见，阿里云上的数据收发记录和解析记录。</p></li><li><p>阿里云平台上还有很多其他功能，比如说把平台收到的数据再MQTT发给自己服务器做个数据处理与显示等，本次我没有用到，可以查看<a href="https://help.aliyun.com/product/30520.html">阿里云物联网平台-产品文档</a>了解更多功能。</p></li></ol><h3 id="LTE-Cat-1模块介绍"><a href="#LTE-Cat-1模块介绍" class="headerlink" title="LTE Cat.1模块介绍"></a>LTE Cat.1模块介绍</h3><ol><li><p>Luat Air724UG LTE Cat.1 模块，淘宝链接：<a href="https://item.taobao.com/item.htm?spm=a1z0d.6639537.1997196601.315.6b537484HESeeA&id=620804223790">Air724UG DTU透传4G模块Cat.1全网通TTL转LTE FS704UM阿里云MQTT</a></p></li><li><p>模块是串口输入，走4G网发送数据。模块可以一键配置阿里云MQTT服务，然后就能实现透传的功能。MCU也可以使用AT指令控制模块，可以有更丰富的操作。</p></li><li><p>连接阿里云流程可以看模块资料《Air724UG_软件设计手册V1.5》，连阿里云首先HTTP获取MQTT密码，然后连接MQTT，阿里云物联网会比较安全。</p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu使用Clash</title>
      <link href="/2021/10/07/211007-clashForLinux/"/>
      <url>/2021/10/07/211007-clashForLinux/</url>
      
        <content type="html"><![CDATA[<h2 id="安装运行clash"><a href="#安装运行clash" class="headerlink" title="安装运行clash"></a>安装运行clash</h2><ol><li><p>在<a href="https://github.com/Dreamacro/clash/releases">clash发布网站</a>下载对应的版本，我下载的是<strong>clash-linux-amd64-v1.7.1.gz</strong></p></li><li><p>将压缩包里的文件解压至**/opt/clash**，改名为clash，下载订阅链接文件到同个目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O config.yaml [订阅链接]</span><br></pre></td></tr></table></figure></li><li><p>Country.mmdb为全球IP库，可以实现各个国家的IP信息解析和地理定位，没有这个文件clash是无法运行的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo wget -O Country.mmdb https://www.sub-speeder.com/client-download/Country.mmdb</span><br></pre></td></tr></table></figure></li><li><p>把clash权限改为可执行应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x clash</span><br></pre></td></tr></table></figure></li><li><p>执行clash，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./clash -d .</span><br></pre></td></tr></table></figure></li></ol><h2 id="修改系统代理"><a href="#修改系统代理" class="headerlink" title="修改系统代理"></a>修改系统代理</h2><ol><li>我使用的是ubuntu18.4，在设置里面修改。打开系统设置，点击网络代理右边的 ⚙ 按钮，选择手动，填写 HTTP 和 HTTPS 代理为 127.0.0.1:7890，填写 Socks 主机为 127.0.0.1:7891，即可启用系统代理</li></ol><h2 id="配置clash"><a href="#配置clash" class="headerlink" title="配置clash"></a>配置clash</h2><ol><li>在运行了clash后可以打开<a href="http://clash.razord.top/#/proxies">clash配置页面</a>进行配置，基本上就和windows中的clash图形化差不多了</li></ol><h2 id="设置为开机启动"><a href="#设置为开机启动" class="headerlink" title="设置为开机启动"></a>设置为开机启动</h2><ol><li><p>创建service文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch /etc/systemd/system/clash.service</span><br></pre></td></tr></table></figure></li><li><p>编辑service文件，填入以下内容(注意修改clash文件夹路径)</p><blockquote><p>[Unit]<br>Description=clash daemon</p><p>[Service]<br>Type=simple<br>User=root<br>ExecStart=/opt/clash/clash -d /opt/clash/<br>Restart=on-failure</p><p>[Install]<br>WantedBy=multi-user.target</p></blockquote></li><li><p>重新加载systemctl daemon，<strong>systemctl daemon-reload</strong></p></li><li><p>启动Clash，<strong>systemctl start clash.service</strong></p></li><li><p>设置Clash开机自启动，<strong>systemctl enable clash.service</strong></p></li><li><p>systemctl的其他命令参考<a href="https://blog.csdn.net/skh2015java/article/details/94012643">linux中systemctl详细理解及常用命令</a></p></li></ol><h2 id="配置定时更新订阅"><a href="#配置定时更新订阅" class="headerlink" title="配置定时更新订阅"></a>配置定时更新订阅</h2><ol><li>可以设置个定时执行的任务，去下载新的配置文件，并重启clash服务</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电动工具电控设计</title>
      <link href="/2021/09/24/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86/"/>
      <url>/2021/09/24/210924-%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="电机位置反馈"><a href="#电机位置反馈" class="headerlink" title="电机位置反馈"></a>电机位置反馈</h1><h2 id="霍尔传感器"><a href="#霍尔传感器" class="headerlink" title="霍尔传感器"></a>霍尔传感器</h2><ul><li>马达轴上连有磁体，传感器为三个间隔60°的开关霍尔，霍尔会按照【001 - 101 - 100 - 110 - 010 - 011】六个状态变换，根据三相霍尔信号可以检测出电机转子位置所处的扇区，然后控制MOS或IGBT实现六步换向控制。</li><li>三路霍尔信号图<br><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/924-电机控制部分/210924-电机控制部分-1.jpg" alt="210924-电机控制部分-1.JPG"></li><li>120°霍尔换相真值表<br><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/924-电机控制部分/210924-电机控制部分-2.jpg" alt="210924-电机控制部分-2.JPG">  </li></ul><h2 id="无霍尔传感器"><a href="#无霍尔传感器" class="headerlink" title="无霍尔传感器"></a>无霍尔传感器</h2><ul><li>传感器很有用，但会增加成本，增加复杂性（由于需要附加绕组），并降低了可靠性（部分原因是传感器连接更容易受到灰尘和潮湿环境的污染），无传感器控制方式解决了这些不足。</li><li>无传感器利用电机反电动势确定转子角度，下图为三相反电动势波形和霍尔波形比较图<br><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/924-电机控制部分/210924-电机控制部分-3.jpg" alt="210924-电机控制部分-3.JPG"><br>可见，传统BLDC电机中单个霍尔传感器变化输出，与无传感器电机中单个线圈的反电动势零交叉点之间有一个30度的相位差。因此，在检测到零交叉点之后，我们会在无传感器电机电路的固件中内置一个30度相位延迟，然后再激活激励序列中的下一个动作。  </li></ul><h2 id="检测反电动势方法"><a href="#检测反电动势方法" class="headerlink" title="检测反电动势方法"></a>检测反电动势方法</h2><ol><li>最简单的方法就是用比较器将反电动势与一半的直流总线电压比较<br><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/924-电机控制部分/210924-电机控制部分-4.jpg" alt="210924-电机控制部分-4.JPG"><br>在此图中，线圈A正向激励，线圈C反向激励，而线圈B则开路。当实现此相位的激励序列时，反电动势就会上升和下降。这一简单比较器方法主要缺点就是三个绕组可能没有相同的特征，造成实际零交叉点的正负相移。电机仍可能在运转，但可能消耗过多电流。</li><li>上面问题解决方法就是通过使用与电机绕组并接的三个电阻网络来产生一个虚拟中性点，反电动势然后就会与虚拟中性点进行比较。<br><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/924-电机控制部分/210924-电机控制部分-5.jpg" alt="210924-电机控制部分-5.JPG"></li><li>第三种方法是采用模数转换器 (ADC)。为BLDC电机控制提供的许多MCU包括适合作此用途的高速ADC。采用这种方法后，反电动势就会衰减，以便可以直接馈送给MCU。信号被ADC采样后就会同与零点对应的数字值比较。当这两个值匹配时，线圈激励序列就会变址到下一步。这种技术具有一定优势，如允许使用数字滤波器来清除反电动势信号中的高频切换成份。<br><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/924-电机控制部分/210924-电机控制部分-6.jpg" alt="210924-电机控制部分-6.JPG">  </li></ol><h2 id="无感缺点"><a href="#无感缺点" class="headerlink" title="无感缺点"></a>无感缺点</h2><pre><code>无传感器BLDC电机控制有一大不足，就是当电机静止时，不会产生反电动势，这样MCU就无法知道定子和转子位置信息。  解决方法就是通过以预定序列激励线圈来启动处于开环配置的电机。当电机看似运转效率不高时，就会开始循环该序列。最终，速度将足以产生足够的反电动势，供控制系统切换到正常闭环运行状态（有效状态）。  由于反电机势与旋转速度成正比，因此在需要较低速度的应用中，无传感器BLDC电机可能不是一个好的选择。此时带有霍尔效应传感器的BLDC电机可能是更好的选择。  </code></pre><h2 id="示波器测霍尔角"><a href="#示波器测霍尔角" class="headerlink" title="示波器测霍尔角"></a>示波器测霍尔角</h2><p><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/924-电机控制部分/210924-电机控制部分-7.jpg" alt="210924-电机控制部分-7.JPG"></p><h2 id="FOC"><a href="#FOC" class="headerlink" title="FOC"></a>FOC</h2><p>​    <a href="https://zhuanlan.zhihu.com/p/147659820">【自制FOC驱动器】深入浅出讲解FOC算法与SVPWM技术</a></p><h1 id="MCU外围电路设计"><a href="#MCU外围电路设计" class="headerlink" title="MCU外围电路设计"></a>MCU外围电路设计</h1><h2 id="复位电路二极管"><a href="#复位电路二极管" class="headerlink" title="复位电路二极管"></a>复位电路二极管</h2><p>​    <a href="https://blog.csdn.net/cs_ing/article/details/9839661">复位电路为什么要加二极管</a>,断电后瞬间放掉电容的电荷，复位，使断电瞬间RC充分放电。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电动工具驱动部分设计</title>
      <link href="/2021/09/17/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/17/210917-%E9%A9%B1%E5%8A%A8%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h1><h2 id="单相逆变"><a href="#单相逆变" class="headerlink" title="单相逆变"></a>单相逆变</h2><ol><li>需要4个NMOS或者IGBT控制</li><li>正弦脉宽调制SPWM，在输出加电感电容滤波，电感电容值需要足够大（6mH 20uF）</li><li>在mos桥驱动中，用PNP三极管挂在MOS的GS上，作用是用三极管形成放电回路，否则GS电容的电过二极管往驱动芯片内部下管释放<br><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/917-驱动部分设计/210917-驱动部分设计-1.jpg" alt="210917-驱动部分设计-1.JPG"></li><li>在PCB布线时要注意让MOS开关部分的高频回流面积最小；功率地需要单点接地，高频开关环流路径不要铺地，以减小地干扰<br><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/917-驱动部分设计/210917-驱动部分设计-2.jpg" alt="210917-驱动部分设计-2.JPG"></li><li>反馈到单片机的信号需要隔离（电流电压互感器），低通或带通滤波</li><li>先直流升压再逆变的效率比先逆变再工频变压器升压的效率高很多</li></ol><h2 id="三相逆变"><a href="#三相逆变" class="headerlink" title="三相逆变"></a>三相逆变</h2><ol><li>需要6个NMOS或者IGBT控制</li><li>负载有星形负载和三角形负载<br><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/917-驱动部分设计/210917-驱动部分设计-3.jpg" alt="210917-驱动部分设计-3.JPG"></li><li>三相桥式逆变器可控器件导通顺序<br><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/917-驱动部分设计/210917-驱动部分设计-4.jpg" alt="210917-驱动部分设计-4.JPG"></li></ol><h1 id="驱动系统"><a href="#驱动系统" class="headerlink" title="驱动系统"></a>驱动系统</h1><h2 id="高铁"><a href="#高铁" class="headerlink" title="高铁"></a>高铁</h2><ol><li>接触网上传输高压交流电（25kV），通过变压器降压和四象限整流器转换成直流电，在经过逆变器降至六点转换成可调压调频的交流电，输入三相异步、同步牵引电动机，通过传动系统带动车轮运行</li><li>牵引变电所输入220kV三相交流电，通过三相变压器，低侧输出25kV三相交流电，一相往前方接触网，一相往后方接触网，另一项接铁轨</li><li>高铁趋势：整流 -&gt; 图腾柱PFC(无桥PFC)；IPM(IGBT) -&gt; SIC mostet(6个IGBT封装在一起)；三相异步电动机 -&gt; 永磁同步电动机(省电30%)</li><li><a href="https://blog.csdn.net/mahoon411/article/details/116980096">MOS管、IGBT、BJT的区别</a></li></ol><h1 id="PFC功率因数校正"><a href="#PFC功率因数校正" class="headerlink" title="PFC功率因数校正"></a>PFC功率因数校正</h1><h2 id="什么是PFC"><a href="#什么是PFC" class="headerlink" title="什么是PFC"></a>什么是PFC</h2><p>PFC的英文全称为”Power Factor Correction” ，意思是“功率因数校正”，功率因数指的是有效功率与总耗电量(视在功率)之间的关系，也就是有效功率除以总耗电量(视在功率)的比值。基本上功率因数可以衡量电力被有效利用的程度，当功率因数值越大，代表其电力利用率越高。功率因数是用来衡量用电设备用电效率的参数，低功率因数代表低电力效能。为了提高用电设备功率因数的技术就称为功率因数校正。（大于70瓦就必须使用功率因数校正PFC）</p><h2 id="被动式PFC"><a href="#被动式PFC" class="headerlink" title="被动式PFC"></a>被动式PFC</h2><p>被动式PFC一般分“电感补偿式”和“填谷电路式(Valley Fill Circuit)”<br>“电感补偿式”是使交流输入的基波电流与电压之间相位差减小来提高功率因数，“电感补偿式”包括静音式和非静音式。“电感补偿式”的功率因数只能达到0.7～0.8，它一般在高压滤波电容附近。<br>“填谷电路式”属于一种新型无源功率因数校正电路，其特点是利用整流桥后面的填谷电路来大幅度增加整流管的导通角，通过填平谷点，使输入电流从尖峰脉冲变为接近于正弦波的波形，将功率因数提高到0.9左右，显著降低总谐波失真。与传统的电感式无源功率因数校正电路相比，其优点是电路简单，功率因数补偿效果显著，并且在输入电路中不需要使用体积大重量沉的大电感器。</p><h2 id="主动式PFC"><a href="#主动式PFC" class="headerlink" title="主动式PFC"></a>主动式PFC</h2><p>主动式PFC则由电感电容及电子元器件组成，体积小、通过专用IC去调整电流的波形，对电流电压间的相位差进行补偿。主动式PFC可以达到较高的功率因数──通常可达98%以上，但成本也相对较高。此外，主动式PFC还可用作辅助电源，因此在使用主动式PFC电路中，往往不需要待机变压器，而且主动式PFC输出直流电压的纹波很小，这种电源不必采用很大容量的滤波电容。</p><h2 id="Boost-PFC变换器"><a href="#Boost-PFC变换器" class="headerlink" title="Boost PFC变换器"></a>Boost PFC变换器</h2><p><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/917-驱动部分设计/210917-驱动部分设计-5.jpg" alt="210917-驱动部分设计-5.JPG"></p><h2 id="PFC参考"><a href="#PFC参考" class="headerlink" title="PFC参考"></a>PFC参考</h2><ol><li><a href="https://www.sohu.com/a/436812131_100281310">一文搞懂PFC（功率因数校正）</a></li><li><a href="https://www.bilibili.com/video/BV1ko4y1C7km?spm_id_from=333.999.0.0">电赛必备之PFC电路，2006年B题功率因数监测与补偿系统</a></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电动工具电源部分设计</title>
      <link href="/2021/09/13/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/"/>
      <url>/2021/09/13/210913-%E7%94%B5%E6%BA%90%E9%83%A8%E5%88%86%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="电源部分"><a href="#电源部分" class="headerlink" title="电源部分"></a>电源部分</h1><h2 id="AC-DC"><a href="#AC-DC" class="headerlink" title="AC/DC"></a>AC/DC</h2><p><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/913-电源部分设计/210913-电源部分设计-1.jpg" alt="210913-电源部分设计-1.JPG"></p><ol><li><a href="https://zhuanlan.zhihu.com/p/366532046">共模干扰和差模干扰</a></li><li>共模电感上流过共模电流时磁环中的磁通相互叠加，从而具有相当大的电感量，对共模电流起到抑制作用</li><li>X电容滤除差模干扰，利用其在高频时低阻抗的特性，短路掉差模干扰</li><li>压敏电阻是一种限压型保护器件，利用压敏电阻的非线性特性，当过电压出现在压敏电阻的两极间，压敏电阻可以将电压钳位到一个相对固定的电压值，从而实现对后级电路的保护</li><li>聚丙烯膜电容（CBB电容 MKP电容）做直流母线电容效果更好</li></ol><h2 id="Buck"><a href="#Buck" class="headerlink" title="Buck"></a>Buck</h2><p><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/913-电源部分设计/210913-电源部分设计-2.jpg" alt="210913-电源部分设计-2.JPG"></p><ol><li>AC-DC芯片采用MP174，SOURCE引脚是VCC和FB引脚的参考地</li><li>VCC供电电压是哪里来的？根据DataSheet，当Vout&lt;7V的时候，芯片空载功率较小，内部供电足够，当Vout&gt;7V时，需要添加外部辅助电源<br><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/913-电源部分设计/210913-电源部分设计-6.jpg" alt="210913-电源部分设计-6.JPG"></li><li><a href="https://www.bilibili.com/video/BV1ef4y1n7x1?spm_id_from=333.999.0.0">电源大师6——BUCK 降压电路降低EMI与EMC设计，开关电源PCB layout宝典</a></li><li>小信号地连一起（FB分压电阻，comp，ss）然后再与PGND单点相连，或者通过过孔连到背面</li><li>电感两个引脚间距京可能大，非一体成型电感底部不铺铜，让敏感电路（FB）和回路远离电感</li></ol><h2 id="LDO"><a href="#LDO" class="headerlink" title="LDO"></a>LDO</h2><p><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/913-电源部分设计/210913-电源部分设计-3.jpg" alt="210913-电源部分设计-3.JPG"></p><ol><li>LDO输入串阻，限流作用</li><li>LDO输出加TVS保护</li></ol><h1 id="采样部分"><a href="#采样部分" class="headerlink" title="采样部分"></a>采样部分</h1><h2 id="电压采样"><a href="#电压采样" class="headerlink" title="电压采样"></a>电压采样</h2><p><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/913-电源部分设计/210913-电源部分设计-4.jpg" alt="210913-电源部分设计-4.JPG"></p><ol><li>整流桥前和后的采样区别：整流桥前电压更稳定，一般采样用来测各种功率参数；整流桥后面的电压不稳定，会受到马达反冲等影响，整流桥后电压采样应用于过压和欠压保护</li></ol><h2 id="电流采样与过压保护"><a href="#电流采样与过压保护" class="headerlink" title="电流采样与过压保护"></a>电流采样与过压保护</h2><p><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/913-电源部分设计/210913-电源部分设计-5.jpg" alt="210913-电源部分设计-5.JPG"></p><ol><li>差分放大，迟滞比较器，电平反转，三极管自锁</li><li>在差分运放中电容并电阻微分作用，电容串电阻积分作用</li><li>对于电子电路：电阻的两端并联一个电容,为了减小对高频信号的阻抗，相当于微分，这样信号上升速度加快，用于提高响应速度；电容一端接电阻，一端接地，则相反，滤去高频，相当于积分，用于滤波。最典型的应用就是放大电路中的高低音频控制。<br>对于电力电路：不管RC串联还是并联，电容的作用都是一样的，电容的作用就是防止电压突变，吸收尖峰状态的过电压，串联的电阻起阻尼作用，电阻消耗过电压的能量，从而抑制电路的振荡。并联的电阻吸收电容的电能，防止电容的放电电流过大，避免对与之并联的器件（如晶闸管）造成损坏。最典型的应用就是防止操作过电压。</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>esp32开发板传输速率测试</title>
      <link href="/2021/08/31/210831-esp32%E4%BC%A0%E8%BE%93%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/08/31/210831-esp32%E4%BC%A0%E8%BE%93%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="程序框架和环境"><a href="#程序框架和环境" class="headerlink" title="程序框架和环境"></a>程序框架和环境</h3><ul><li>esp32的程序是通过esp-idf框架开发</li><li>esp32做Server，电脑做Client，手机热点AP</li><li>esp32使用外置天线更加稳定，但速率没有明显提升</li></ul><h3 id="TCP-Server"><a href="#TCP-Server" class="headerlink" title="TCP-Server"></a>TCP-Server</h3><ul><li>编译优化-O2，速率可从最高500KB/s提升到800KB/s</li><li>TCP传输错误会重传，有问题的时候速率会下降到100KB/s以下</li><li>应用在640*320分辨率的25帧JPEG图传不稳定</li></ul><h3 id="UDP-Server"><a href="#UDP-Server" class="headerlink" title="UDP-Server"></a>UDP-Server</h3><ul><li><p>速度可以达到1MB/s~2MB/s</p></li><li><p>UDP是个不稳定的传输，会有传输错误</p></li><li><p>不适合应用在JPEG图传</p></li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210831-esp32%E4%BC%A0%E8%BE%93%E6%B5%8B%E8%AF%95/210831-esp32%E4%BC%A0%E8%BE%93%E6%B5%8B%E8%AF%95-1.jpg" alt="210831-esp32传输测试-1.jpg"></p><ul><li><p>由于本人技术原因，无法达到官方测试的速率，大家使用需要亲自测试后才能做结论，可以参考iperf例程后再进行测试</p></li><li><p>参考：<a href="https://docs.espressif.com/projects/esp-idf/zh_CN/latest/esp32/index.html">ESP-IDF编程指南</a></p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> esp32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>在Keil中重定向printf</title>
      <link href="/2021/08/21/210821-%E9%87%8D%E5%AE%9A%E5%90%91printf/"/>
      <url>/2021/08/21/210821-%E9%87%8D%E5%AE%9A%E5%90%91printf/</url>
      
        <content type="html"><![CDATA[<h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p>今天用STM32CubeMX生成了代码，使用printf函数后单片机程序运行异常，查出是STM32CubeMX生成的代码没有printf的重定向，百度查了两个方法后两个都行不通，最后参考正点原子例程解决。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p>错误参考：<a href="https://blog.csdn.net/xukao5671927/article/details/78485537">一知半解学CubeMX——UART：Printf实现</a></p></li><li><p>正确参考：正点原子例程SYSTEM文件夹下的usart.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加入以下代码,支持printf函数,而不需要选择use MicroLIB</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> import(__use_no_semihosting)</span></span><br><span class="line"><span class="comment">//标准库需要的支持函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FILE __stdout;</span><br><span class="line"><span class="comment">//定义_sys_exit()以避免使用半主机模式</span></span><br><span class="line"><span class="type">void</span> _sys_exit(<span class="type">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重定义fputc函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>((USART1-&gt;SR&amp;<span class="number">0X40</span>)==<span class="number">0</span>);<span class="comment">//循环发送,直到发送完毕</span></span><br><span class="line">USART1-&gt;DR = (u8) ch;</span><br><span class="line"><span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>要注意重定向的函数名是<code>int __io_putchar(int ch)</code>还是<code>int fputc(int ch, FILE *f)</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">  <span class="comment">/* With GCC/RAISONANCE, small printf (option LD Linker-&gt;Libraries-&gt;Small printf set to &#x27;Yes&#x27;) calls __io_putchar() */</span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __GNUC__ */</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>CubeMX生成的代码没有勾选Use MicroLib，可能需要勾选，可以看<a href="https://www.cnblogs.com/zyqgold/p/6114637.html">Keil中的USE MicroLib说明</a>，MicroLib不支持操作系统函数。</p></li><li><p>Unix系统里，每行结尾只有“&lt;换行&gt;”，即”\n”；</p><p>Windows系统里面，每行结尾是“&lt;回车&gt;&lt;换行&gt;”，即“\r\n”；</p><p>Mac系统里，每行结尾是“&lt;回车&gt;”，即”\r”；</p><p>参考：<a href="https://blog.csdn.net/liewen_/article/details/89673402">\r,\n,\r\n的区别：回车与换行</a></p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《信号完整性与电源完整性分析》</title>
      <link href="/2021/08/09/210809-%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E4%B8%8E%E7%94%B5%E6%BA%90%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/"/>
      <url>/2021/08/09/210809-%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7%E4%B8%8E%E7%94%B5%E6%BA%90%E5%AE%8C%E6%95%B4%E6%80%A7%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="书籍介绍"><a href="#书籍介绍" class="headerlink" title="书籍介绍"></a>书籍介绍</h3><p>作者: [美] Eric Bogatin<br>出版社: 电子工业出版社<br>原作名: Signal and Power Integrity：Simplified， Third Edition<br>译者: <a href="https://book.douban.com/search/%E6%9D%8E%E7%8E%89%E5%B1%B1">李玉山</a> / <a href="https://book.douban.com/search/%E5%88%98%E6%B4%8B">刘洋</a> / <a href="https://book.douban.com/search/%E5%88%9D%E7%A7%80%E7%90%B4">初秀琴</a> / <a href="https://book.douban.com/search/%E8%B7%AF%E5%BB%BA%E6%B0%91">路建民</a></p><h3 id="第一版前言"><a href="#第一版前言" class="headerlink" title="第一版前言"></a>第一版前言</h3><p>“一切都应该尽可能简单，而不只是简单一点。”        ——阿尔伯特·爱因斯坦</p><h3 id="信号完整性问题的10个基本原则"><a href="#信号完整性问题的10个基本原则" class="headerlink" title="信号完整性问题的10个基本原则"></a>信号完整性问题的10个基本原则</h3><ol><li><p>提高高速产品设计的关键是：充分利用分析工具实现准确的性能预估，使用测量手段验证设计过程，降低风险并提高所采用设计工具的可信度。</p></li><li><p>将问题的实质与表面现象剥离开的唯一可行途径是：采用经验法则，解析近似，数值仿真工具或测量工具获得数据，这是工程实践的本质要素。</p></li><li><p>任何一段互联，无论线长和形状，也无论信号的上升边如何，都是一个由信号路径和返回路径构成的传输线。一个信号在沿着互联前进的每一步，都会感受到一个瞬时阻抗。如果<strong>阻抗恒定</strong>为常数，比如具有均匀横截面传输线的情况，那么其信号质量将会获得奇迹般的改善。</p></li><li><p><strong>把“接地”这个术语忘掉</strong>，由于它所造成的问题比用它解决问题还要多。每一路都有返回路径。抓住“返回路径”，像对待信号路径一样去寻找并处理返回路径，这样有助于培养解决问题的直觉能力。</p></li><li><p>当电压变化时，电容器上就有电流流动。对于快速变化的前沿，即<strong>使印制电路板边沿和悬空导线之间的空气间隙形成的边缘线电容</strong>，都有可能拥有较低的阻抗。</p></li><li><p>电感与阻扰电流周围的磁力线匝数有本质的联系。只要电流与磁力线的匝数发生改变，在导线的两端就会产生电压。这一电压是导致反射噪声，串扰，开关噪声，地弹，轨道塌陷及电磁干扰的根源之一。</p></li><li><p>当流经地回路电感上的电流发生变化时，在接地回路导线上产生的电压称为是地弹。它是造成开关噪声和电磁干扰的内在机理。</p></li><li><p>以同频率的方法作为参照，信号带宽是指的有效正弦波分量的最高频率值。互联模型的带宽是指在这个最高的正弦频率上，模型仍然准确的预估互联的实际性能。在使用模型进行分析时，一定不要让信号的带宽超过模型的带宽。</p></li><li><p>除了少数情况之外，信号完整性公式中给出的是定义或者近似。在特别需要准确的场合就不使用近似。</p></li><li><p>有损传输线引起的问题是上升边退化。由于集肤深度和介质损耗，损耗随着频率的升高而增加。如果损耗随着频率的升高而保持不变，上升边就不会发生变化，这时的有损线只是增添了一些不便而已。</p></li></ol><h3 id="100条使信号完整性问题最小化的通用设计规则"><a href="#100条使信号完整性问题最小化的通用设计规则" class="headerlink" title="100条使信号完整性问题最小化的通用设计规则"></a>100条使信号完整性问题最小化的通用设计规则</h3><ul><li><a href="https://blog.csdn.net/qwertyuj/article/details/8460438">100条使信号完整性问题最小化的通用设计原则</a></li></ul><h3 id="100条估计信号完整性效应的经验法则"><a href="#100条估计信号完整性效应的经验法则" class="headerlink" title="100条估计信号完整性效应的经验法则"></a>100条估计信号完整性效应的经验法则</h3><ul><li><a href="https://blog.csdn.net/qwertyuj/article/details/8460440">100条估计信号完整性效应的经验法则</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>fpga频率计设计</title>
      <link href="/2021/08/05/210805-fpga%E9%A2%91%E7%8E%87%E8%AE%A1/"/>
      <url>/2021/08/05/210805-fpga%E9%A2%91%E7%8E%87%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>开发板：<a href="https://item.taobao.com/item.htm?spm=a1z10.1-c.w4004-1816603213.25.3acf849bUh4GaW&id=592735846549">勤谋电子 Intel Altera Cyclone IV FPGA 开发板 EP4CE15 开发板</a></li><li>IDE：Quartus (Quartus Prime 18.0) Standard Edition</li><li>下载器：<a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.16.4d1e5dd8starCH&id=616077647019&ns=1&abbucket=9&skuId=4393547028324">USB Blaster下载器 ALTERA CPLD/FPGA下载线</a></li></ul><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><ul><li>实时频率测量</li><li>测量范围1Hz-50Mhz</li><li>测量误差0.0005%@20MHz</li><li>uart串口打印</li></ul><h3 id="不足思考"><a href="#不足思考" class="headerlink" title="不足思考"></a>不足思考</h3><ul><li>可以使用PLL提高sys_clk，使测量范围增到100MHz</li><li>程序逻辑复杂，还需简化</li><li>自适应闸门时间，在高频的时候提高实时测量的频率，低频的时候又可以准确测量，可使测量范围下限更小</li></ul><h3 id="Github发布"><a href="#Github发布" class="headerlink" title="Github发布"></a>Github发布</h3><ul><li><a href="https://github.com/hao0527/fpga-freq_measure_uart">https://github.com/hao0527/fpga-freq_measure_uart</a></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《FreeRTOS源码详解与应用开发——基于STM32》</title>
      <link href="/2021/07/29/210729-FreeRTOS%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
      <url>/2021/07/29/210729-FreeRTOS%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h3 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h3><ul><li><a href="https://www.bilibili.com/video/BV1a4411Q7X1">正点原子FreeRTOS手把手教学-基于STM32</a></li></ul><h3 id="思考与心得"><a href="#思考与心得" class="headerlink" title="思考与心得"></a>思考与心得</h3><ol><li><p>本书结构为：编码风格、<strong>系统移植</strong>、<strong>系统配置</strong>、任务函数、中断配置、临界区保护、多任务、列表结构、<strong>系统任务调度器</strong>、任务切换、时间管理、队列结构、信号量、<strong>软件定时器</strong>、事件标志组、任务通知、<strong>Tickless模式</strong>、空闲任务、<strong>内存管理</strong>。</p></li><li><p>跟今年2月份学的rtThread差不多，rtThread是参考<a href="https://www.rt-thread.org/document/site/#/rt-thread-version/rt-thread-standard/programming-manual/basic/basic">官方文档</a>学习的，学习了内核的一部分，和本次学习《FreeRTOS源码详解与应用开发》的内容差不多，也是借本书回忆一下之前学的实时系统。比较关心对接口的使用，本书的源码详解有一部分没有细看，日后需要的时候再啃源码，也可以自己手写一个实时系统来理解内核中核心的部分。</p></li><li><p>有些公司可能不想用实时系统，理由是影响速度，那么问题来了，<a href="https://www.zhihu.com/question/342441430">什么情况下需要采用嵌入式操作系统呢？</a>看过这个知乎的回答就知道，大型项目中裸奔会造成资源的浪费，特别是处理GUI、lwip、fatfs等，里面有大量的delay。在需要并行这些就需要用到rtos，使用os还可以实现应用层与底层硬件的隔离，可以方便分块开发、移植等。另外在资源数较少的mcu上不很适合使用rtos。</p></li><li><p>光看书没有用，我欠缺rtos的实践，最好是拿个项目练练手。</p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 嵌入式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我画的第一块四层板</title>
      <link href="/2021/07/10/210710-%E7%AC%AC%E4%B8%80%E5%9D%97%E5%9B%9B%E5%B1%82%E6%9D%BF/"/>
      <url>/2021/07/10/210710-%E7%AC%AC%E4%B8%80%E5%9D%97%E5%9B%9B%E5%B1%82%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p><img src="htthttps://gitee.com/hao0527/hao0527/raw/img/710-第一块四层板/210710-第一块四层板-1.jpg" alt="210710-第一块四层板-1.jpg"></p><ul><li><p>第一次画四层板，嘉立创打板的时候出了点问题，嘉立创PCB解析和AD21.3.1版本的不兼容，导致内层存在空气间距</p></li><li><p>我还测试了下这个TVS和PTC防反接啥的，效果都蛮不错的</p></li><li><p>总体来说，感觉这块板子设计的蛮不错，目前没啥别的问题</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电路设计中各种GND之间的连接</title>
      <link href="/2021/06/28/210628-GND%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5/"/>
      <url>/2021/06/28/210628-GND%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/qlexcel/article/details/92728245">PCB的地与机壳（连接大地）为什么用阻容连接？</a></li><li><a href="https://www.bilibili.com/read/cv8008391/">电路设计中有几种地？各类GND的含义详解</a></li></ul><h3 id="GND可以分为几种"><a href="#GND可以分为几种" class="headerlink" title="GND可以分为几种"></a>GND可以分为几种</h3><ol><li><p>模拟地线AGND<br> 模拟信号是微弱信号，容易受到其他电路大电流的影响，大电流会在模拟电路中产生大的压降，会使得模拟信号失真。</p></li><li><p>数字地线DGND<br> 有按键检测电路、USB通信电路、单片机电路，在由0跳变到1的过程，电压产生了变化，根据麦克斯韦电磁理论，变化的电流周围会产生磁场，也就会形成EMC辐射，使用单独的DGND与其他电路隔离，防止辐射扩散。</p></li><li><p>功率地线PGND<br> 大电流会造成不同功能电路之间的地偏移现象。</p></li><li><p>电源地线GND<br> 是所有电路的0V电压参考点，是电源的地线GND。</p></li><li><p>交流地线CGND<br> 在AC-DC电源电路中，一个是交流地线，一个是直流地线，交流地线作为交流电路部分的0V参考点，直流地线作为直流电路部分的0V参考点。通常为了在电路中统一一个地线GND，工程师会将交流地线通过一个耦合电容或者电感与直流地线连接在一起。</p></li><li><p>大地地线EGND<br> 地线是在电系统或电子设备中，接大地、接外壳或接参考电位为零的导线。为了增强电路的安全系数，工程师一般在高压大电流的项目中使用大地的地线EGND，例如在家用电器电风扇、电冰箱、电视机等电路中。</p></li></ol><h3 id="不细分GND会导致的问题"><a href="#不细分GND会导致的问题" class="headerlink" title="不细分GND会导致的问题"></a>不细分GND会导致的问题</h3><ol><li><p>信号串扰<br> 假如将不同功能的地线GND直接连接在一起，大功率电路通过地线GND，会影响小功率电路的0V参考点GND，这样就产生了不同电路信号之间的串扰。</p></li><li><p>信号精度<br> 交流电源的地线CGND由于是正弦波，是周期性的上下波动变化，它的电压也是上下波动，不是像直流地线GND一样始终维持在一个0V上不变。将不同电路的地线GND连接在一起，周期性变化的交流地线CGND会带动模拟电路的地线AGND变化，这样就影响了模拟信号的电压精度值了。</p></li><li><p>EMC实验<br> 信号越弱，对外的电磁辐射EMC也就越弱；信号越强，对外的电磁辐射EMC也就越强。假如将不同电路的地线GND连接在一起，信号强电路的地线GND，直接干扰了信号弱电路的地线GND。</p></li><li><p>电路可靠性<br> 电路系统之间，信号连接的部分越少，电路独立运行的能力越强；信号连接的部分越多，电路独立运行的能力就越弱。</p></li></ol><h3 id="GND和机壳的连接"><a href="#GND和机壳的连接" class="headerlink" title="GND和机壳的连接"></a>GND和机壳的连接</h3><p>​    PCB板卡置于金属机壳中，机壳一般接大地，PCB的GND与机壳之间经常使用一个电容（1nF/1KV）并联一个电阻（1M）连接。</p><ol><li><p>电容是干啥用的<br>从EMS（电磁抗扰度）角度说，这个电容是在假设PE良好连接大地的前提下，降低可能存在的，以大地电平为参考的高频干扰型号对电路的影响，是为了抑制电路和干扰源之间瞬态共模压差的。其实GND直连PE是最好的，但是，直连可能不可操作或者不安全，例如，220V交流电过整流桥之后产生的GND是不可以连接PE的，所以就弄个低频过不去，高频能过去的路径。从EMI（电磁干扰）角度说，如果有与PE相连的金属外壳，有这个高频路径，也能够避免高频信号辐射出来。</p></li><li><p>一般在1nF左右比较合适<br>如果答主在变频器、伺服驱动器这样8~16kHz开关频率的工业设备上用这么大的电容值，那么，用户摸外壳会有触电的风险的。一般选到这么大，都是电路其他地方设计不合格，为了对付EMC测试，只好把这个电容加大的。<strong>最好是安规电容，GND和PE间选用Y电容</strong>。</p></li><li><p>1M电阻是干啥用的<br>这是对付ESD（静电放电）测试用的。因为这种用电容连接PE和GND的系统（浮地系统），在做ESD测试的时候，打入被测电路的电荷无处释放，会逐渐累积，抬升或降低GND相对与PE的电平，累积到一定程度，超过了PE和电路之间的绝缘最薄弱处所能耐受的电压范围，GND和PE之间就会放电，几个纳秒间，在PCB上的产生数十到数百安培的电流，这足以让任何电路因EMP（电磁脉冲）宕机，或者是让PE与电路之间绝缘最薄弱处所在信号连接的器件损坏。但是刚才说了，有时候又不能直接连接PE和GND，那么就用一个1-2M的电阻去慢慢释放这个电荷，以消除二者间的压差。当然1-2M这个数值是根据ESD测试标准选择的，因为IEC61000里面规定最高的重复次数只有10次/秒，如果你搞个1000次/秒的非标ESD放电，那么1~2M的电阻我觉得是不能释放掉累积的电荷的。1M电阻的高阻接地方式，往往是为了在<strong>提供EMC保护</strong>的同时或者说不影响防护效果的同时<strong>限制故障电流</strong>，印象中1M是根据人体模型得到的结果。比如内部挂了，GND连到高压上的故障，有这个1M，通过的电流不会伤害人体。</p></li><li><p>PE不可靠！因为很多国内的客户根本不会给你接上有效的PE，也就是说，你根本无法依靠PE来提升EMS或降低EMI的指标。其实这也不能全怪客户，是因为他们的车间、厂房、办公室根本就没按照电工标准来修，压根就是没有接地线的！所以，我明白PE不可靠以后，就使用一些技巧让电路能够硬抗过EMS测试。</p></li><li><p>PE（机壳）和GND直连是不行的。多见的系统是浮地，机壳连PE，PCBA不连PE，这样机壳就是个很好的法拉第笼，有效屏蔽外界。</p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FPGA驱动OV2640用SPI转发JPEG数据</title>
      <link href="/2021/06/23/210623-fpgaOV/"/>
      <url>/2021/06/23/210623-fpgaOV/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>FPGA采用的是<a href="http://www.gowinsemi.com.cn/prod_view.aspx?TypeId=10&FId=t3:10:3&Id=168">高云小蜜蜂家族</a>的GW1N-LV4QN88C6/I5</li><li>摄像头使用OV2640，可以配置数据为JPEG压缩后输出</li><li>采用DC-DC降压到3.6V再LDO降至3.3V与2.8V，OV内核和FPGA内核采用DC-DC降到1.2V使用</li></ul><h2 id="FPGA部分"><a href="#FPGA部分" class="headerlink" title="FPGA部分"></a>FPGA部分</h2><h3 id="编程流程图"><a href="#编程流程图" class="headerlink" title="编程流程图"></a>编程流程图</h3><ol><li>I2C驱动</li><li>FIFO配置</li><li>通过I2C配置OV2640寄存器</li><li>获取DCMI接口数据</li><li>JPEG找出帧头帧尾</li><li>把有效数据存入FIFO</li><li>SPI读FIFO数据输出</li></ol><h3 id="I2C驱动"><a href="#I2C驱动" class="headerlink" title="I2C驱动"></a>I2C驱动</h3><p>参考：正点原子OV5640驱动程序</p><h3 id="FIFO配置"><a href="#FIFO配置" class="headerlink" title="FIFO配置"></a>FIFO配置</h3><p>通过FIFO SC HS IP核向导生成（SC是同步的意思），在使用的时候需要查看IP核用户指南，重点要看时序部分</p><h3 id="SPI驱动"><a href="#SPI驱动" class="headerlink" title="SPI驱动"></a>SPI驱动</h3><p>参考：<a href="https://www.cnblogs.com/liujinggang/p/9609739.html">SPI总线的原理与Verilog实现</a></p><h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><p>本次FPGA实现读取OV2640并SPI发出来的小功能，解决了低端MCU没有DCMI外设，遇到了IP核不会使用的问题，要多看手册里的时序部分。还有就是有些数据处理的时候要缓冲，加延时，否则会造成信号的错位。后面我要加强流水线结构的设计，多用并行的思想发挥FPGA的优势。</p><h2 id="项目GitHub链接"><a href="#项目GitHub链接" class="headerlink" title="项目GitHub链接"></a>项目GitHub链接</h2><p><a href="https://github.com/hao0527/fpga-ov2640_fifo_spi">https://github.com/hao0527/fpga-ov2640_fifo_spi</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SRAM与DRAM</title>
      <link href="/2021/06/12/210612-RAM/"/>
      <url>/2021/06/12/210612-RAM/</url>
      
        <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/qq_21435127/article/details/79617714">浅谈关于SRAM与DRAM的区别</a></li></ul><h3 id="SRAM与DRAM的区别"><a href="#SRAM与DRAM的区别" class="headerlink" title="SRAM与DRAM的区别"></a>SRAM与DRAM的区别</h3><p>​        SRAM(Static RAM)与DRAM(Dynamic RAM)，从名字上看，SRAM与DRAM的区别只在于一个是静态一个是动态。由于SRAM不需要刷新电路就能够保存数据，所以具有静止存取数据的作用。而DRAM则需要不停地刷新电路，否则内部的数据将会消失。而且不停刷新电路的功耗是很高的，在我们的PC待机时消耗的电量有很大一部分都来自于对内存的刷新。那么为什么我们不用SRAM来作为内存呢？</p><p><strong>SRAM的基本单元结构图</strong> 和 <strong>DRAM的基本单元结构图</strong></p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210612-RAM/210612-RAM-1.jpg" alt="210612-RAM-1.jpg"></p><p>​        SRAM存储一位需要花6个晶体管，而DRAM只需要花一个电容和一个晶体管。cache（高速缓冲存储器）追求的是速度所以选择SRAM，而内存则追求容量所以选择能够在相同空间中存放更多内容并且造价相对低廉的DRAM。</p><p>​        我们姑且不去讨论关于SRAM是如何静态存储数据（触发器）的。为什么DRAM需要不断刷新呢？</p><p>​        DRAM的数据实际上是存在电容里的。而电容放久了，内部的电荷就会越来越少，对外就形成不了电位的变化。而且当对DRAM进行读操作的时候需要将电容与外界形成回路，通过检查是否有电荷流进或流出来判断该bit是1还是0。所以无论怎样，在读操作中我们都破坏了原来的数据。所以在读操作结束后需要将数据写回DRAM中。在整个读或者写操作的周期中，计算机都会进行DRAM的刷新，通常是刷新的周期是4ms-64ms。</p><p>​        关于SRAM和DRAM的寻址方式也有所不同。虽然通常我们都认为内存像一个长长的数组呈一维排列，但实际上内存是以一个二维数组的形式排列的，每个单元都有其行地址和列地址，当然cache也一样。而这两者的不同在于对于容量较小的SRAM，我们可以将行地址和列地址一次性传入到SRAM中，而如果我们对DRAM也这样做的话，则需要很多很多根地址线（容量越大，地址越长，地址位数越多）。所以我们选择分别传送行地址和列地址到DRAM中。先选中一整行，然后将整行数据存到一个锁存器中，等待列地址的传送然后选中所需要的数据。这也是为什么SRAM比DRAM快的原因之一。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python异步与线程</title>
      <link href="/2021/06/11/210611-python%E5%BC%82%E6%AD%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/06/11/210611-python%E5%BC%82%E6%AD%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h3><p>所谓多线程，就是系统可以同时运行多个任务，在操作系统中，每个任务就是一个线程。</p><p>Python 多线程可以成倍提高程序的运行速度。</p><p>进程是资源分配的最小单位，线程是程序执行的最小单位。</p><h3 id="python3多线程"><a href="#python3多线程" class="headerlink" title="python3多线程"></a>python3多线程</h3><p>参考：<a href="https://www.runoob.com/python3/python3-multithreading.html">Python3 多线程</a></p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h3><p><strong>同步</strong>是指完成事务的逻辑，先执行第一个事务，如果阻塞了，会一直等待，直到这个事务完成，再执行第二个事务，顺序执行。</p><p><strong>异步</strong>是和同步相对的，异步是指在处理调用这个事务的之后，不会等待这个事务的处理结果，直接处理第二个事务去了，通过状态、通知、回调来通知调用者处理结果。</p><h3 id="python3异步"><a href="#python3异步" class="headerlink" title="python3异步"></a>python3异步</h3><p>参考：<a href="https://docs.python.org/zh-cn/3/library/asyncio.html?highlight=asyncio#module-asyncio">asyncio — 异步 I/O</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛客网每日一练</title>
      <link href="/2021/06/07/210607-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83/"/>
      <url>/2021/06/07/210607-%E6%AF%8F%E6%97%A5%E4%B8%80%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<ol><li><p>（判断题）指针就是地址，因此一个变量的指针就是该变量的地址。<br>答案：错误；解释：指针是个变量，指针的值是个地址，地址是个常量。</p></li><li><p>char* s=”AAA”;<br>s[0]=’B’;    //错误，初始化指针时所创建的字符串常量被定义为只读，修改违法</p></li><li><p><code>char ch;int i;float f;double d;</code><br>表达式：<code>ch/i+(f*d-i)</code>的结果类型为<u>double</u></p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">MAX</span>(++a, b);</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">MAX</span>(++a, b + <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, a, b, c, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output： 8 0 7 10<br>解释：注意define，第一次调用MAX时，++a先执行了一次，此时a为6，由于满足宏定义中(a)&gt;(b)的条件，所以执行a，这个a就对应++a，所以a又自增了一次，变为7，由此得出c为7。 第二个MAX时a又自增了一次，此时为8，由于不满足条件，所以执行的是宏定义中的b，没有执行++a，所以a最终为8</p></li><li><p>关于fseek()    参考：<a href="https://www.runoob.com/cprogramming/c-function-fseek.html">C库函数 - fseek()</a></p></li><li><p>转义字符分三种，一般转义字符，八进制转义字符和十六进制转义字符 </p><p> <strong>一般转义字符</strong>，如‘\b’，由两个字符表示，其实代表一个字符，这个代表退格字符 </p><p> <strong>八进制转义字符</strong>，如‘\007’,三位数字是八进制的，ASCII码为7的表示响铃 </p><p> <strong>十六进制转义字符</strong>，如’\xfe’，同样后面数字是所表示意思的Ascii码的十六进制表示，注意一定要有x，大小写都行</p></li><li><p>在C程序中逗号运算符的优先级最低，赋值运算符其次；j++是属于赋值语句；sizeof()属于一元运算符；</p></li><li><p>C中&amp;&amp;（逻辑与）和&amp;（按位与）</p><ul><li>按位与运用二进制进行计算，逻辑与比较符号两边的真假输出逻辑值。</li><li>按位与对所有的表达式都要判断，逻辑与运算符第一个表达式不成立的话，后面的表达式不运算，直接返回。</li><li>按位与&amp;输出运算结果为不同的数值，逻辑与 &amp;&amp; 输出逻辑值true或者 false。</li></ul></li><li><p>两个指针变量不可以相加，因为指针变量相加没有意义。</p></li><li><p>scanf函数不能指定输入精度，可以指定长度，比如%m.nf是不允许的，但是可以%mf(m为整数)。<code>scanf(&quot;%7.2f&quot;,&amp;a);</code>不合法</p></li><li><p>多态类中的虚函数表建立在编译阶段。对类的编译，内存分布不太了解。</p></li><li><p><code>const int* p</code>是常量指针，<strong>p可以改变，*p不能改变</strong>；<code>int* const p = &amp;a</code>是指针常量，<strong>p不可以改变，*p能改变</strong>；记忆方法：const后面是p，p不能改变，const后面是*p，*p不能改变；还有一种<code>const int* const p = &amp;a</code>，p和*p都不能改变。</p></li><li><p>C++程序执行时，内存划分4个区域。不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程。代码区和全局区是在程序运行前划分，堆栈是在程序运行后划分。</p><ul><li>代码区：存放函数体和二进制代码，由操作系统负责管理（共享、只读）</li><li>全局区：存放全局变量和静态变量以及字符串，全局常量（程序结束后，由系统自动回收）</li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量，局部常量等</li><li>堆区：由程序员分配释放，若程序员不释放，程序结束时，由系统自动回收</li></ul></li><li><p>C++用new关键字请求内存，用delete释放内存，参考：<a href="https://www.runoob.com/cplusplus/cpp-dynamic-memory.html">C++ 动态内存</a></p></li><li><p>C没有引用，C++引用变量是一个别名，参考：<a href="https://www.runoob.com/cplusplus/cpp-references.htmlv">C++引用</a>；使用<a href="https://www.runoob.com/cplusplus/passing-parameters-by-references.html">引用传参</a>；使用<a href="https://www.runoob.com/cplusplus/returning-values-by-reference.html">引用作为函数返回值</a>；<a href="https://www.bilibili.com/video/BV1et411b73Z?p=93&spm_id_from=pageDriver">引用的本质</a>是指针常量；</p></li><li><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。<strong>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝析构时重复释放堆带来的问题</strong>。</p></li><li><p>类成员中有其他类对象，构造时先构造成员中的类对象，再构造自身；析构时相反。</p></li><li><p>静态成员变量：所有对象共享同一份数据；在编译阶段分配内存；类内声明，类外初始化；静态成员函数：所有对象共享同一个函数；静态成员函数只能访问静态成员变量；</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Class &amp;c)</span><br><span class="line">&#123;<span class="comment">// c++重载&lt;&lt;运算符</span></span><br><span class="line">    cout &lt;&lt; c.m_A;<span class="comment">// 打印成员变量</span></span><br><span class="line">    <span class="keyword">return</span> cout;<span class="comment">// 链式编程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电容的选型</title>
      <link href="/2021/05/23/210523-%E7%94%B5%E5%AE%B9%E9%80%89%E5%9E%8B/"/>
      <url>/2021/05/23/210523-%E7%94%B5%E5%AE%B9%E9%80%89%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="https://blog.csdn.net/yingxuexuan/article/details/6117023">LDO 输出电容</a></p></li><li><p><a href="https://blog.csdn.net/AirCity123/article/details/104186046">LDO输出端电容对其稳定性的影响</a></p></li></ul><h3 id="各种电容特性"><a href="#各种电容特性" class="headerlink" title="各种电容特性"></a>各种电容特性</h3><p><strong>多层陶瓷电容</strong></p><p>多层陶瓷电容(MLCC)不仅尺寸小，而且将低ESR、低ESL和宽工作温度范围特性融于一体，可以说是旁路电容的首选。不过，这类电容也并非完美无缺。根据电介质材料不同，电容值会随着温度、直流偏置和交流信号电压动态变化。另外，电介质材料的压电特性可将振动或机械冲击转换为交流噪声电压。大多数情况下，此类噪声往往以微伏计，但在极端情况下，机械力可以产生毫伏级噪声。</p><p>电压控制振荡器(VCO)、锁相环(PLL)、RF功率放大器(PA)和其它模拟电路都对供电轨上的噪声非常敏感。在VCO和PLL中，此类噪声表现为相位噪声；在RF PA中，表现为幅度调制；而在超声、CT扫描以及处理低电平模拟信号的其它应用中，则表现为显示伪像。尽管陶瓷电容存在上述缺陷，但由于尺寸小且成本低，因此几乎在每种电子器件中都会用到。不过，当调节器用在对噪声敏感的应用中时，设计人员必须仔细评估这些副作用。</p><p><strong>固态钽电解电容</strong></p><p>与陶瓷电容相比，固态钽电容对温度、偏置和振动效应的敏感度相对较低。新兴一种固态钽电容采用导电聚合物电解质，而非常见的二氧化锰电解质，其浪涌电流能力有所提高，而且无需电流限制电阻。此项技术的另一好处是ESR更低。固态钽电容的电容值可以相对于温度和偏置电压保持稳定，因此选择标准仅包括容差、工作温度范围内的降压情况以及最大ESR。</p><p>导电聚合物钽电容具有低ESR特性，成本高于陶瓷电容而且体积也略大，但对于不能忍受压电效应噪声的应用而言可能是唯一选择。不过，钽电容的漏电流要远远大于等值陶瓷电容，因此不适合一些低电流应用。</p><p>固态聚合物电解质技术的缺点是此类钽电容对无铅焊接过程中的高温更为敏感，因此制造商通常会规定电容在焊接时不得超过三个焊接周期。组装过程中若忽视此项要求，则可能导致长期稳定性问题。</p><p><strong>铝电解电容</strong></p><p>传统的铝电解电容往往体积较大、ESR和ESL较高、漏电流相对较高且使用寿命有限（以数千小时计）。而OS-CON电容则采用有机半导体电解质和铝箔阴极，以实现较低的ESR。这类电容虽然与固态聚合物钽电容相关，但实际上要比钽电容早10年或更久。由于不存在液态电解质逐渐变干的问题，OS-CON型电容的使用寿命要比传统的铝电解电容长。大多数电容的工作温度上限为105°C，但现在OS-CON型电容可以在最高125°C的温度范围内工作。</p><p>虽然OS-CON型电容的性能要优于传统的铝电解电容，但是与陶瓷电容或固态聚合物钽电容相比，往往体积更大且ESR更高。与固态聚合物钽电容一样，这类电容不受压电效应影响，因此适合低噪声应用。</p><p><strong>固态电容</strong></p><p>固态电容器的全名为固态铝质电解电容器，是目前电容器产品中最高阶的产品，固态电容的介电材料则为功能性导电高分子，能大幅提升产品的稳定度与安全性，它与液态铝质电解电容最大差别，在于所使用的介电材料，过去铝质电解电容所使用的介电材料是电解液，而固态电容则是导电性高分子材料，也因此导致成本相对较高。固态电容特点固态电容具备环保、低阻抗、高低温稳定、耐高纹波及高信赖度等优越特性，是目前电解电容产品中最高阶的产品。由于固态电容特性远优于液态铝电容，固态电容耐温达摄氏260度，且导电性、频率特性及寿命均佳，适用于低电压、高电流的应用。</p><h3 id="LDO负载电容"><a href="#LDO负载电容" class="headerlink" title="LDO负载电容"></a>LDO负载电容</h3><p>影响LDO稳定工作的外在因素是负载电容容值CL和ESR，以及LDO的输出电流，他们的关系是：</p><ol><li><p>容值小的CL，ESR往往较大，容值大的CL，ESR往往较小。无论哪种电容，都要保证ESR在合理的范围内，规格书往往会提供这个范围。</p></li><li><p>当LDO输出电流是额定电流的20%~50%时，容易发生不稳定状况。</p></li><li><p>低温时，CL的ESR会升高，并且容值也会发生变化。选型时要注意！</p></li><li><p>在ESR很低，LDO输出电流很小（≤1mA）时，容易发生不稳定状况。</p></li><li><p>同一温度下，LDO输出电流越小，保证LDO稳定性的ESR值越高。</p></li><li><p>同一输出电流下，温度越高，保证LDO稳定性的ESR越大。</p></li><li><p>在低输出电流时，LDO输出波形变成三角波，说明ESR过低；在中等输出电流时，如果LDO波形是正弦波，说明ESR过高。</p></li></ol><table><thead><tr><th><strong>电容技术</strong></th><th><strong>等效串联电阻</strong></th><th><strong>等效串联电感</strong></th><th><strong>电压稳定性</strong></th><th><strong>温度稳定性</strong></th><th><strong>振动敏感度</strong></th><th><strong>电容值/单位体积</strong></th></tr></thead><tbody><tr><td><strong>铝电解电容</strong></td><td>最高</td><td>最高</td><td>好</td><td>最低</td><td>低</td><td>低</td></tr><tr><td><strong>固态钽电容</strong></td><td>中等</td><td>中等</td><td>最佳</td><td>好</td><td>低</td><td>高</td></tr><tr><td><strong>聚合物固态铝电容</strong></td><td>低</td><td>低</td><td>最佳</td><td>好</td><td>低</td><td>高</td></tr><tr><td><strong>多层陶瓷电容</strong></td><td>最低</td><td>最低</td><td>差</td><td>好</td><td>高</td><td>中等</td></tr></tbody></table><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 智能车 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>十六届智能车基础四轮方案</title>
      <link href="/2021/05/17/210517-%E9%A3%9E%E5%8D%A1/"/>
      <url>/2021/05/17/210517-%E9%A3%9E%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>不会吧，不会吧，我又参加飞卡了？</p><h3 id="基础四轮组规则"><a href="#基础四轮组规则" class="headerlink" title="基础四轮组规则"></a>基础四轮组规则</h3><ul><li><p>车模：B车模，车模宽度不超过25厘米，高度不超过20厘米，长度没有限制，如果安装摄像头传感器，摄像头镜片中心的高度距离地面不超过10厘米</p></li><li><p>MCU：指定使用 Infineon系列单片机，允许使用各类电磁、红外光电、摄像头、激光、超声传感器</p></li><li><p>赛道元素：进出库、三岔路口（进出口120°，路口间直线距离&lt;3m）、环岛（R&lt;0.5m）、坡道（坡度&lt;=20°）、十字路口（需直行）、弯道（曲率半径&lt;0.5m）</p></li></ul><h3 id="电机驱动"><a href="#电机驱动" class="headerlink" title="电机驱动"></a>电机驱动</h3><p>IR2184老方案，B车电机比较猛，可能有11.7A，试一下加RDC释放电路来提高刹车性能</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-1.jpg" alt="210517-飞卡-1.jpg"></p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-2.jpg" alt="210517-飞卡-2.jpg"></p><ul><li><input checked disabled type="checkbox"> 电机驱动加上ina240测电机电流(21.6.11前)</li></ul><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-7.jpg" alt="210517-飞卡-7.jpg"></p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-8.jpg" alt="210517-飞卡-8.jpg"></p><p>（21.6.11）程序员通过电机反转来刹车，未加驱动死区时间，导致锂电池保护板保护。</p><h3 id="电磁运放"><a href="#电磁运放" class="headerlink" title="电磁运放"></a>电磁运放</h3><p>采用逐飞方案，opa4377，单端放大，检波，二极管使用了压降小的肖特基二极管</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-3.jpg" alt="210517-飞卡-3.jpg"></p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-4.jpg" alt="210517-飞卡-4.jpg"></p><h3 id="tc377主控"><a href="#tc377主控" class="headerlink" title="tc377主控"></a>tc377主控</h3><p>考虑到DC-DC负载响应速率不如LDO，继续使用LM1084-ADJ给舵机供6.3v电<br><img src="https://gitee.com/hao0527/hao0527/raw/img/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-5.jpg" alt="210517-飞卡-5.jpg"><br><img src="https://gitee.com/hao0527/hao0527/raw/img/210517-%E9%A3%9E%E5%8D%A1/210517-%E9%A3%9E%E5%8D%A1-6.jpg" alt="210517-飞卡-6.jpg"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 智能车 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态顺序栈（C++）</title>
      <link href="/2021/05/14/210514-stack/"/>
      <url>/2021/05/14/210514-stack/</url>
      
        <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><p><a href="http://c.biancheng.net/view/279.html">cin.getline()：C++读入一行字符串（整行数据）</a></p></li><li><p><a href="https://blog.csdn.net/dove1202ly/article/details/78542574">动态顺序栈的简单实现</a></p></li><li><p><a href="https://www.cnblogs.com/wkfvawl/p/10846851.html">C++ delete 和 delete []的区别</a></p></li><li><p><a href="https://www.cnblogs.com/lst601z815/p/5034576.html">c++数组自动扩容（动态数组）</a></p></li><li><p><a href="https://blog.csdn.net/manchengpiaoxue/article/details/83145476">c++动态数组</a></p></li><li><p><a href="https://codingdict.com/article/6233">C++ 类构造函数 &amp; 析构函数</a></p></li><li><p><a href="http://c.biancheng.net/view/2318.html">C++类模板5分钟入门教程</a></p></li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Stack</span>():_pData(<span class="keyword">new</span> T[<span class="number">1</span>]), _capacity(<span class="number">1</span>), _size(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;creat stack successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Stack</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> [] _pData;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete stack successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">CheckCapacity</span>();</span><br><span class="line">_pData[_size++] = t;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;push &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">T&amp; <span class="title">Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T&amp; t = _pData[_size<span class="number">-1</span>];</span><br><span class="line">_size--;</span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;pop return &quot; &lt;&lt; t &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">Capacity</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CheckCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">Size</span>();</span><br><span class="line"><span class="type">size_t</span> capacity = <span class="built_in">Capacity</span>();</span><br><span class="line"><span class="type">size_t</span> newcapacity = <span class="number">2</span> * capacity;</span><br><span class="line"><span class="keyword">if</span> (size &gt;= capacity)</span><br><span class="line">&#123;</span><br><span class="line">_capacity = newcapacity;</span><br><span class="line">T* tmp = <span class="keyword">new</span> T[newcapacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp[i] = _pData[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] _pData;</span><br><span class="line">_pData = tmp;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;capacity add to &quot;</span> &lt;&lt; newcapacity &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _pData;</span><br><span class="line"><span class="type">size_t</span> _capacity;</span><br><span class="line"><span class="type">size_t</span> _size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Stack&lt;<span class="type">char</span>&gt; s;</span><br><span class="line"><span class="type">char</span> strInput[<span class="number">100</span>]=<span class="string">&quot;test\0&quot;</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;input:&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(!cin.<span class="built_in">getline</span>(strInput,<span class="number">100</span>))</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;error, input too long&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span>(strInput[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">Push</span>(strInput[i]);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;output:&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(strInput[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">Pop</span>();</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">creat stack successful</span><br><span class="line">input:i love tzy</span><br><span class="line">push i successful</span><br><span class="line">capacity add to 2</span><br><span class="line">push   successful</span><br><span class="line">capacity add to 4</span><br><span class="line">push l successful</span><br><span class="line">push o successful</span><br><span class="line">capacity add to 8</span><br><span class="line">push v successful</span><br><span class="line">push e successful</span><br><span class="line">push   successful</span><br><span class="line">push t successful</span><br><span class="line">capacity add to 16</span><br><span class="line">push z successful</span><br><span class="line">push y successful</span><br><span class="line">output:yzt evol i</span><br></pre></td></tr></table></figure><h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><ol><li>Sublime里运行程序不能输入数据，只能输出数据（卡在cin）</li><li>参考：<strong>动态顺序栈的简单实现</strong> 中，数组扩容未改变_capacity</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>esp-idf开发esp32</title>
      <link href="/2021/05/11/210511-espidf/"/>
      <url>/2021/05/11/210511-espidf/</url>
      
        <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li>安装Visual Studio Code（下面简称vscode）</li><li>安装python3.7.8（添加环境变量）、Git工具、CMake</li><li>vscode安装ESP-IDF Explorer插件，一键安装idf工具（国内速度慢）</li><li>通过这个插件安装esp-idf可能会失败，我当初用手机流量+梯子装的很快</li></ol><h2 id="使用idf"><a href="#使用idf" class="headerlink" title="使用idf"></a>使用idf</h2><p>Windows开发建议在vscode中使用esp-idf explorer插件</p><p>vscode还支持macOS和Linxu，未试过在其他操作系统使用该插件</p><h3 id="直接使用esp-idf"><a href="#直接使用esp-idf" class="headerlink" title="直接使用esp-idf"></a>直接使用esp-idf</h3><ol><li><p><code>%USERPROFILE%\esp\esp-idf</code>目录下examples文件夹内有例程</p></li><li><p>每次用idf工具，需要执行<code>%USERPROFILE%\esp\esp-idf</code>目录下的export添加环境变量，我是Windows，需要执行export.ps1，<strong>使用export.bat无效</strong>，ps1是Windows Power Shell脚本，需要电脑开启运行脚本权限，在管理员模式下Shell输入<code>set-executionpolicy remotesigned</code>开启权限，然后就可以运行export.ps1</p></li><li><p>在工程文件夹内使用<code>idf.py menuconfig</code>来配置工程</p></li><li><p>使用<code>idf.py build</code>来编译程序（首次编译或更改SDK后的速度慢）</p></li><li><p><code>idf.py -p PORT flash monitor</code>来下载程序</p></li></ol><h3 id="使用esp-idf-explorer插件"><a href="#使用esp-idf-explorer插件" class="headerlink" title="使用esp-idf explorer插件"></a>使用esp-idf explorer插件</h3><ul><li><p>这个工具非常好用，有GUI配SDK，在vscode用插件指令可以编译下载等</p></li><li><p>参考：<a href="https://www.bilibili.com/video/BV17p4y167uN?p=1">ESP-IDF VS Code 插件快速操作指南</a></p></li><li><p>vscode cmd <code>&gt;ESP-IDF:Show Examples Projects</code>基于例程新建工程</p></li><li><p>编译，下载，调试，设置sdk等功能点点左下角图标就可以</p></li></ul><h2 id="我的esp项目"><a href="#我的esp项目" class="headerlink" title="我的esp项目"></a>我的esp项目</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>通过esp32把红外热像Demo板的温度信号用TCP发到电脑上</p><h3 id="ESP和Demo板Uart通信"><a href="#ESP和Demo板Uart通信" class="headerlink" title="ESP和Demo板Uart通信"></a>ESP和Demo板Uart通信</h3><ul><li>参考esp例程：uart_events</li></ul><h3 id="ESP和电脑TCP通信"><a href="#ESP和电脑TCP通信" class="headerlink" title="ESP和电脑TCP通信"></a>ESP和电脑TCP通信</h3><ul><li>参考esp例程：tcp_client</li></ul><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ol><li>uart通信波特率设成921600时，接收会hw fifo overflow，esp没有DMA例程，通过降波特率解决</li><li>socket通信电脑端接收的时候不断更改<code>recv(new_fd, buff, BUFSIZ, 0)</code>buff指针会程序中断，未查出原因，通过把每次接收到的数据包写入文件解决</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> esp32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>卡片机项目进度</title>
      <link href="/2021/05/07/210507-%E5%8D%A1%E7%89%87%E6%9C%BA/"/>
      <url>/2021/05/07/210507-%E5%8D%A1%E7%89%87%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="室内-双光-配电柜卡片机"><a href="#室内-双光-配电柜卡片机" class="headerlink" title="室内 双光 配电柜卡片机"></a>室内 双光 配电柜卡片机</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ol><li>80*62 分辨率  预留160*120的空间和接口</li><li>200W 1920*1080  可见光分辨率</li><li>白光 LED 拍照照明</li><li>DC6-8.4V外部供电</li><li>低功耗</li><li>6-8pin航插，DC5V，uart 和SWD接口</li><li>无线图传电台：开阔地300米</li></ol><h3 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h3><ol><li><p>红外：80*62 的 3.3v spi接口上拉  160*120  fpc的 8Mbps UART ，DC5.0V降压 </p></li><li><p>可见光：OV2640 200W 24pin  考虑fpga作为DVP-spi接口 fpga时钟</p></li><li><p> 白光LED： DC3.4V 100-500mA</p></li><li><p>无线模块：24L01 2.4-2.52GHZ 250Kbps 500mW 27DB发射功率</p></li><li><p>电源：DC6V-8.4V 输入，加单向TVS和PTC保护  1uA低功耗LDO 接MCU ,带有EN使能脚的BUCK输出3.3V/5V</p></li><li><p>光敏  光电二极管加lmv321 放大 ADC</p></li><li><p>输出接口：SMA 无线  8pin 航插  RST，Vin ，rx/tx , SWD (ESD保护)</p></li><li><p>MCU：带RTC 32.768</p></li></ol><h3 id="调试阶段进度"><a href="#调试阶段进度" class="headerlink" title="调试阶段进度"></a>调试阶段进度</h3><h4 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h4><ul><li><input checked disabled type="checkbox"> 绘制原理图</li><li><input checked disabled type="checkbox"> 绘制PCB（调试板）</li><li><input checked disabled type="checkbox"> 制板焊接（调试板）</li><li><input checked disabled type="checkbox"> 绘制产品的PCB</li></ul><h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><ul><li><input checked disabled type="checkbox"> 调试80*60红外模块</li><li><input checked disabled type="checkbox"> 调试160*120红外模块</li><li><input checked disabled type="checkbox"> 调试FPGA-OV2640部分</li><li><input checked disabled type="checkbox"> 调试FPGA-MCU部分</li><li><input checked disabled type="checkbox"> 调试24L01模块</li><li><input checked disabled type="checkbox"> 调试电源管理部分</li><li><input disabled type="checkbox"> 调试其他功能</li></ul><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ul><li><input checked disabled type="checkbox"> 红外模块板外形</li><li><input disabled type="checkbox"> ……</li></ul><h2 id="无线集抄器部分"><a href="#无线集抄器部分" class="headerlink" title="无线集抄器部分"></a>无线集抄器部分</h2><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><ol><li>可以支持500个从站</li><li>服务器端配置网络和从站设备</li><li>网口或者CAT1上传服务器</li><li>户外型  安装部署方便</li><li>DC12V 持续供电</li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 工作日志 </category>
          
          <category> 卡片机 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BJT和FET相关知识总结</title>
      <link href="/2021/05/06/210506-bjt%E5%92%8Cfet/"/>
      <url>/2021/05/06/210506-bjt%E5%92%8Cfet/</url>
      
        <content type="html"><![CDATA[<h2 id="晶体三极管（BJT）"><a href="#晶体三极管（BJT）" class="headerlink" title="晶体三极管（BJT）"></a>晶体三极管（BJT）</h2><p>《模拟电子技术基础》（第五版）P24</p><h2 id="场效应管（FET）"><a href="#场效应管（FET）" class="headerlink" title="场效应管（FET）"></a>场效应管（FET）</h2><h3 id="结型场效应管（JFET）"><a href="#结型场效应管（JFET）" class="headerlink" title="结型场效应管（JFET）"></a>结型场效应管（JFET）</h3><p>《模拟电子技术基础》（第五版）P33</p><h3 id="绝缘栅型场效应管（IGFET）"><a href="#绝缘栅型场效应管（IGFET）" class="headerlink" title="绝缘栅型场效应管（IGFET）"></a>绝缘栅型场效应管（IGFET）</h3><ol><li>绝缘栅型场效应管的栅极与源极、漏极之间都采用SiO<sub>2</sub>绝缘层隔离，栅极为金属铝，又称MOS管</li><li>IGFET的G-S间内阻比JFET大得多，可达10<sup>10</sup>Ω以上</li><li>MOS分N沟道和P沟道两类，每一类分<strong>增强型</strong>和<strong>耗尽型</strong>两种，U<sub>GS</sub>=0时，I<sub>d</sub>=0为增强型，I<sub>d</sub>≠0为耗尽型</li><li>NMOS的U<sub>GS</sub> 越大，反型层越厚，导电沟道电阻越小</li><li>与JFET一样，MOS管有三个工作区：可变电阻区、恒流区、夹断区，当U<sub>DS</sub>增大到U<sub>GS(th)</sub>（即U<sub>DS</sub>=U<sub>GS</sub>-U<sub>GS(th)</sub>）时，沟道在漏极一侧出现加断点，进入恒流区，U<sub>DS</sub>增大的部分几乎全部用于克服预夹断区对漏极电流的阻力</li><li>U<sub>DS</sub>&gt;U<sub>GS</sub>-U<sub>GS(th)</sub>时，对应每一个U<sub>GS</sub>就有一个确定的I<sub>d</sub>，可将I<sub>d</sub>视为电压U<sub>GS</sub>控制的电流源</li></ol><h3 id="FET符号及特性"><a href="#FET符号及特性" class="headerlink" title="FET符号及特性"></a>FET符号及特性</h3><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210506-bjt%E5%92%8Cfet/210506-bjt%E5%92%8Cfet-1.jpg" alt="210506-bjt和fet-1.jpg"><img src="https://gitee.com/hao0527/hao0527/raw/img/210506-bjt%E5%92%8Cfet/210506-bjt%E5%92%8Cfet-2.jpg" alt="210506-bjt和fet-2.jpg"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 硬件 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>喜提域名ihcode.cn（爱皓码）</title>
      <link href="/2021/05/04/210504-%E5%9F%9F%E5%90%8D/"/>
      <url>/2021/05/04/210504-%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h3><ol><li>在<a href="https://www.ename.cn/">易名官网</a>注册网站账号，实名认证（审核了半天）</li><li>选择好域名加入购物车，支付就可以，我的域名价格为35元一年</li></ol><h3 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h3><ol><li><p>注册完域名后进入后台-域名管理-我的域名</p></li><li><p>DNS使用的是<strong>易名DNS</strong>（免费版），网上听说易名DNS很烂，以后我再换一个DNS，易名DNS服务器是海外的，国内的DNS服务器需要备案，我的空间和服务器在本地，备案比较麻烦，就没备案</p></li><li><p>易名云解析中解析记录的一些配置如下</p><ul><li><p>主机记录就是域名前缀，常见用法有：</p><p>www：解析后的域名为 <code>www.ihcode.cn</code></p><p>@：直接解析主域名ihcode.cn</p><p>*：泛解析，匹配其他所有域名 *.ihcode.cn</p></li><li><p>要指向空间商提供的 IP 地址，选择「类型 A」，要指向一个域名，选择「类型 CNAME」</p></li><li><p>各类型的记录值一般是这样的：</p><p>A记录：填写您服务器 IP，如果您不知道，请咨询您的空间商</p><p>CNAME记录：填写空间商给您提供的域名</p></li><li><p>TTL(Time To Live)，缓存的生存时间。指地方dns缓存您域名记录信息的时间，缓存失效后会再次到获取记录值。</p><p>600（10分钟）：建议正常情况下使用600。</p><p>60（1分钟）：如果您经常修改IP，修改记录一分钟即可生效。长期使用60，解析速度会略受影响。</p><p>3600（1小时）：如果您IP极少变动（一年几次），建议选择3600，解析速度快。</p></li></ul></li><li><p>易名云解析中URL转发的一些配置如下</p><ul><li><p>域名，可以是 *.ihcode.cn 或者 <code>www.ihcode.cn</code></p></li><li><p>类型：显性或隐性</p><p>设置显性URL转发后，当用户访问域名会自动转向访问指定值，址栏显示指定值</p><p>设置隐性URL转发后，当用户访问域名会自动转向访问指定值，址栏仍旧显示之前域名</p></li><li><p>转发值：就是要跳转的域名链接http://，可以带端口号</p></li></ul></li></ol><h3 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h3><ol><li><p>解析记录的记录值只能是IP地址或者是指向的该IP的DDNS域名，不能加端口号</p><p>使用url转发可以带端口号，但是隐性类型转发后无法获取网页logo和名称，UI不正确等问题，使用显性类型转发可以</p></li><li><p>修改完解析记录后需要至少10分钟才能正常使用</p><p>清空DNS缓存即可，Windows管理员CMD输入<code>ipconfig /flushdns</code></p></li><li><p>Hexo 4000端口微信访问的时候会报非标准端口警告</p><p>考虑以后使用树莓派开一个web服务器，使用80端口映射到公网IP</p></li></ol><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OV2640初步调试记录</title>
      <link href="/2021/05/03/210503-ov2640/"/>
      <url>/2021/05/03/210503-ov2640/</url>
      
        <content type="html"><![CDATA[<h2 id="OV2640硬件"><a href="#OV2640硬件" class="headerlink" title="OV2640硬件"></a>OV2640硬件</h2><h3 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h3><p>参考：OV2640硬件开发手册</p><p>设计：Hao</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210503-ov2640/210503-ov2640-1.jpg" alt="210503-ov2640-1.jpg"></p><h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><p>layout：小张</p><h2 id="OV2640软件"><a href="#OV2640软件" class="headerlink" title="OV2640软件"></a>OV2640软件</h2><h3 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h3><ul><li>jpeg读取，24l01发送</li><li>光线暗打开闪光（未完成），通过读取曝光时间来判断光线强弱，决定是否打开闪光灯</li></ul><h3 id="程序开发"><a href="#程序开发" class="headerlink" title="程序开发"></a>程序开发</h3><ul><li><p>参考：<a href="https://www.bilibili.com/video/BV1Rx411R75t?p=79">正点原子ov2640实验视频</a>、OV2640数据手册、OV2640软件开发手册</p></li><li><p>接口：SCCB（类I2C）、DCMI（8bit并口）</p></li><li><p>传感器、传感器窗口、图像尺寸、图像窗口之间的关系如下图：<img src="https://gitee.com/hao0527/hao0527/raw/img/210503-ov2640/210503-ov2640-3.jpg" alt="210503-ov2640-3.jpg"></p></li><li><p>程序开发按照正点原子给的库很容易进行，但部分功能库里没有需要查阅软件开发手册和数据手册，对寄存器进行读写。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>DOVDD是IO的电平，给了3.3V，因为和它通讯的单片机使用的电压也是3.3V，如果这里用2.8V可以也是可以，会产生电流倒灌，增加了产品不稳定的因素</p></li><li><p>ov2640模组在上电的时候比较烫手，温度有55℃上下，不使用的时候将PWDN拉高，停止给电</p></li><li><p>为了节约成本，24Mhz时钟可以由单片机输出，代替有源晶振</p></li><li><p>如果单片机没有DCMI接口，软件模拟速度跟不上，需要使用带FIFO的摄像头（ov7550），才可以由软件模拟读取并口数据，模拟的还没有尝试过，可以参考原子哥M3例程，F103使用0V7550</p></li><li><p>由于大多数低成本国产单片机不带DCMI接口，可以由高云FPGA驱动ov2640，通过SPI发送给单片机，这是本人五一节后要做的事情</p></li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 工作日志 </category>
          
          <category> 卡片机 </category>
          
          <category> OV2640 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>80*62红外热像Demo板调试记录</title>
      <link href="/2021/04/30/210430-at32/"/>
      <url>/2021/04/30/210430-at32/</url>
      
        <content type="html"><![CDATA[<h2 id="AT32（SPI）"><a href="#AT32（SPI）" class="headerlink" title="AT32（SPI）"></a>AT32（SPI）</h2><ul><li>暂时没有用DMA搬运，SPI3用于读取MI0801模组数据，SPI2用于驱LCD</li></ul><h3 id="SPI配置参数"><a href="#SPI配置参数" class="headerlink" title="SPI配置参数"></a>SPI配置参数</h3><ul><li><p>SPI配置需要注意的参数：极性CPOL和相位CPHA，<a href="https://www.cnblogs.com/shangdawei/p/4752476.html">详解SPI中的极性CPOL和相位CPHA</a></p></li><li><p>如何判断CPOL：SCLK的空闲时候的电压，是0还是1，决定了CPOL是0还是1</p></li><li><p>如何判断CPHA：数据采样时刻对应着的SCLK的电平，是第一个边沿还是第二个边沿，对应着CPHA为0还是1</p><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210430-at32/210430-at32-1.jpg" alt="210430-at32-1.jpg"></p></li></ul><h3 id="驱动LCD问题"><a href="#驱动LCD问题" class="headerlink" title="驱动LCD问题"></a>驱动LCD问题</h3><ul><li>LCD用到了SPI和另外几个IO，写入命令过程中，要将DC拉低，0X2A、0X2B、0X2C是命令，但是DC拉低没有对上，通过程序加delay解决，当SPI速率上升后，可以不用delay就能使用LCD</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LCD_WR_REG</span><span class="params">(<span class="type">uint8_t</span> dat)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//  Delay_us(5);</span></span><br><span class="line">  <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TE) == RESET);</span><br><span class="line">  LCD_DC_Clr();<span class="comment">//写命令</span></span><br><span class="line">  LCD_Writ_Bus(dat);</span><br><span class="line">  <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TE) == RESET);</span><br><span class="line"><span class="comment">//  Delay_us(5);</span></span><br><span class="line">  LCD_DC_Set();<span class="comment">//写数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>AT32在读写SPI前要等待上一次读写操作完成，否则会出现发送数据缺少，接收卡死</li></ul><h3 id="SPI-NSS上拉问题"><a href="#SPI-NSS上拉问题" class="headerlink" title="SPI NSS上拉问题"></a>SPI NSS上拉问题</h3><ul><li>at32单片机无法配置输出上拉或者下拉，SPI一开始调试的时候需要接着逻辑分析仪才可以，不接spi就接收不到数据，通过外加2k上拉电阻解决</li></ul><h2 id="AT32-SRAM"><a href="#AT32-SRAM" class="headerlink" title="AT32(SRAM)"></a>AT32(SRAM)</h2><h3 id="配置使用224KB-SRAM"><a href="#配置使用224KB-SRAM" class="headerlink" title="配置使用224KB SRAM"></a>配置使用224KB SRAM</h3><ul><li><p>要打开224KB SRAM《AT32F403A &amp; AT32F407入门使用指南》给了四种方法</p><p>1.2.3 AT32F403A_407零等待/非零等待Flash和内置SRAM大小选择配置大小选择配置说明</p><ul><li>使用 ICP/ISP 方式</li><li>使用脱机烧录器方式</li><li>客户也可以使用在 Bootloader program（IAP）内修改 SRAM 的大小，并调用它</li><li>启动文件中修改 AT32F403A_407 SRAM 为 224KB</li></ul></li><li><p>我用的是第三种方法，直接下一遍SRAM例程就开启了224KB SRAM</p></li></ul><h2 id="KEIL编译优化"><a href="#KEIL编译优化" class="headerlink" title="KEIL编译优化"></a>KEIL编译优化</h2><ul><li><strong>Keil编译优化等级从0提升到3，使图像帧率从2.5fps提升到了3.5fps</strong></li></ul><h3 id="不同编译优化等级区别"><a href="#不同编译优化等级区别" class="headerlink" title="不同编译优化等级区别"></a>不同编译优化等级区别</h3><ul><li><p>Level0：近乎不优化，用于调试代码。出现代码行不能设置断点可如此设置试试</p></li><li><p>Level1：部分优化。移除未调用的内联函数和静态函数，关闭debug窗口优化，此状态也能用于调试</p></li><li><p>Level2：默认优化等级。如果处于debug状态，<strong>部分代码行将不能被调试</strong>，具体做了什么优化好像没说</p></li><li><p>Level3：可能更牛的优化等级。会增加编译时间，可能会快，可能生成的文件大小会小，可能会暴毙</p></li><li><p>相关文档：<a href="https://blog.csdn.net/jiangchao3392/article/details/80267198">KEIL编译器【C语言编译选项优化等级说明】</a></p></li></ul><h2 id="实物"><a href="#实物" class="headerlink" title="实物"></a>实物</h2><h3 id="实物展示图"><a href="#实物展示图" class="headerlink" title="实物展示图"></a>实物展示图</h3><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210430-at32/210430-at32-2.jpg" alt="210430-at32-2.jpg"></p><h3 id="四种图像显示模式"><a href="#四种图像显示模式" class="headerlink" title="四种图像显示模式"></a>四种图像显示模式</h3><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210430-at32/210430-at32-3.jpg" alt="210430-at32-3.jpg"></p><h3 id="红外显示示范"><a href="#红外显示示范" class="headerlink" title="红外显示示范"></a>红外显示示范</h3><p><img src="https://gitee.com/hao0527/hao0527/raw/img/210430-at32/210430-at32-4.jpg" alt="210430-at32-4.jpg"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 工作日志 </category>
          
          <category> 卡片机 </category>
          
          <category> AT32 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客框架在使用中遇到的问题</title>
      <link href="/2021/04/25/210425-hexo/"/>
      <url>/2021/04/25/210425-hexo/</url>
      
        <content type="html"><![CDATA[<h2 id="如何用Hexo搭建博客？"><a href="#如何用Hexo搭建博客？" class="headerlink" title="如何用Hexo搭建博客？"></a>如何用Hexo搭建博客？</h2><h3 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h3><ul><li><a href="https://www.bilibili.com/video/BV1Yb411a7ty">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></li></ul><h3 id="文档教程"><a href="#文档教程" class="headerlink" title="文档教程"></a>文档教程</h3><ul><li><a href="https://hexo.io/zh-cn/docs/">Hexo文档</a></li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="md插入图片网页上不显示"><a href="#md插入图片网页上不显示" class="headerlink" title="md插入图片网页上不显示"></a>md插入图片网页上不显示</h3><p>参考：<a href="https://blog.csdn.net/xjm850552586/article/details/84101345">hexo引用本地图片无法显示</a>、<a href="https://www.jianshu.com/p/3db6a61d3782">hexo使用markdown图片无法显示问题</a></p><ol><li>安装 <strong>hexo-asset-image</strong>插件</li><li>修改插件 <strong>_config.yml</strong>内容</li><li>图片放在 <strong>/source/_posts/xxx</strong>文件夹内，xxx与xxx.md同名</li><li>使用<code>![xxx](xxx/xxx.png)</code>直接插入图片（注意不能有差别，多个”/“都不行）</li></ol><h3 id="Markdown上下标"><a href="#Markdown上下标" class="headerlink" title="Markdown上下标"></a>Markdown上下标</h3><p>参考：<a href="https://www.jianshu.com/p/13b3366f0260">在markdown中如何加入上标、下标？</a></p><ul><li>SiO<sub>2</sub>写法为：<code>SiO&lt;sub&gt;2&lt;/sub&gt;</code></li><li>2<sup>10</sup>Ω写法为：<code>2&lt;sup&gt;10&lt;/sup&gt;Ω</code></li></ul><h3 id="Hexo-Github部署"><a href="#Hexo-Github部署" class="headerlink" title="Hexo Github部署"></a>Hexo Github部署</h3><ol><li>安装hexo-deployer-git插件 ‘cnpm install –save hexo-deployer-git’</li><li>git添加SSHKey</li><li>blog文件夹中_config.yml配置hexo-deployer-git插件<br> type: git<br> repo: <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#109;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#x68;&#117;&#x62;&#x2e;&#x63;&#111;&#109;</a>:hao0527/hao0527.github.io.git<br> branch: main</li><li>hexo g 编译<br> hexo d 发布到Github</li><li>每次发布会GithubPages的Custom domain都会被删除，在本地source文件夹中添加CNAME文件，内容写自定义域名就行</li></ol><h3 id="Hexo-增加搜索功能"><a href="#Hexo-增加搜索功能" class="headerlink" title="Hexo 增加搜索功能"></a>Hexo 增加搜索功能</h3><p>参考：<a href="https://blog.csdn.net/xinyflove/article/details/108791970">Hexo博客添加搜索功能</a></p><p>参考：<a href="https://blog.csdn.net/Best_xiaogao/article/details/126471145">npm WARN config global –global, –local are deprecated. Use –location 的解决方法</a></p><hr><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
